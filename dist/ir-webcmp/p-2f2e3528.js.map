{"version":3,"names":["ClickOutside","proto","methodName","descriptor","originalConnected","connectedCallback","originalDisconnected","disconnectedCallback","originalDidUnload","componentDidUnload","args","host","getClickOutsideHost","this","callback","bind","registerClickOutside","apply","unregisterClickOutside","component","element","isDomAvailable","__irClickOutsideCleanup__","handler","event","isEventInsideHost","call","window","addEventListener","removeEventListener","instance","getElement","path","composedPath","Array","isArray","includes","target","contains","shadowRoot","document","SlotManager","hostElement","slotNames","onStateChange","slotState","Map","slotObserver","isInitialized","constructor","initialize","updateSlotState","setupListeners","console","warn","handleSlotChange","MutationObserver","observe","childList","subtree","attributes","attributeFilter","destroy","disconnect","clear","hasSlot","name","get","getSlotState","getActiveSlots","from","entries","filter","_","hasContent","map","refresh","newState","forEach","set","checkSlotHasContent","children","some","child","getAttribute","createSlotManager","manager"],"sources":["src/decorators/ClickOutside.ts","src/utils/slot.ts"],"sourcesContent":["import { getElement, ComponentInterface } from '@stencil/core';\nimport { HTMLStencilElement } from '@stencil/core/internal';\n\n/**\n * Call this function as soon as the click outside of annotated method's host is done.\n * @example\n```\n@ClickOutside()\ncallback() {\n  // this will run when click outside of element (host component) is done.\n}\n```\n */\nexport function ClickOutside() {\n  return (proto: ComponentInterface, methodName: string, descriptor: PropertyDescriptor) => {\n    const originalConnected = proto.connectedCallback;\n    const originalDisconnected = proto.disconnectedCallback;\n    const originalDidUnload = proto.componentDidUnload;\n\n    proto.connectedCallback = function (...args: any[]) {\n      const host = getClickOutsideHost(this);\n      if (host) {\n        const callback = (this as any)[methodName]?.bind(this);\n        if (callback) {\n          registerClickOutside(this, host, callback);\n        }\n      }\n\n      return originalConnected?.apply(this, args);\n    };\n\n    proto.disconnectedCallback = function (...args: any[]) {\n      const host = getClickOutsideHost(this);\n      if (host) {\n        unregisterClickOutside(host);\n      }\n\n      return originalDisconnected?.apply(this, args);\n    };\n\n    proto.componentDidUnload = function (...args: any[]) {\n      const host = getClickOutsideHost(this);\n      if (host) {\n        unregisterClickOutside(host);\n      }\n\n      return originalDidUnload?.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Register callback function for HTMLElement to be executed when user clicks outside of element.\n * @example\n```\n<span \n    ref={spanEl => registerClickOutside(this, spanEl, () => this.test())}>\n      Hello, World!\n</span>;\n```\n */\nexport function registerClickOutside(component: ComponentInterface, element: HTMLClickOutsideElement, callback: (event: Event) => void): void {\n  if (!element || !isDomAvailable()) return;\n  if (element.__irClickOutsideCleanup__) return;\n\n  const handler = (event: Event) => {\n    if (isEventInsideHost(element as any, event)) {\n      return;\n    }\n\n    callback.call(component, event);\n  };\n\n  window.addEventListener('click', handler, true);\n\n  element.__irClickOutsideCleanup__ = () => {\n    window.removeEventListener('click', handler, true);\n  };\n}\n\nexport function unregisterClickOutside(element: HTMLClickOutsideElement | null | undefined): void {\n  if (!element || !isDomAvailable()) return;\n  element.__irClickOutsideCleanup__?.();\n  delete element.__irClickOutsideCleanup__;\n}\n\nexport interface HTMLClickOutsideElement extends HTMLStencilElement {\n  __irClickOutsideCleanup__?: () => void;\n}\n\nfunction getClickOutsideHost(instance: any): HTMLClickOutsideElement | null {\n  if (!isDomAvailable()) return null;\n\n  try {\n    return getElement(instance) as HTMLClickOutsideElement;\n  } catch {\n    return null;\n  }\n}\n\nfunction isEventInsideHost(host: HTMLElement, event: Event): boolean {\n  if (!event) return false;\n\n  const path = typeof event.composedPath === 'function' ? event.composedPath() : [];\n  if (Array.isArray(path) && path.includes(host)) {\n    return true;\n  }\n\n  const target = event.target as Node | null;\n  if (!target) return false;\n\n  if (host === target) return true;\n  if (typeof (host as any).contains === 'function' && host.contains(target)) return true;\n\n  return !!host.shadowRoot?.contains(target);\n}\n\nfunction isDomAvailable(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n","/**\n * SlotManager - A reusable service for managing slot state in Stencil components\n *\n * Usage:\n * 1. Create an instance in your component\n * 2. Initialize in componentWillLoad()\n * 3. Setup observers in componentDidLoad()\n * 4. Cleanup in disconnectedCallback()\n * 5. Check slot state using hasSlot()\n */\nexport class SlotManager {\n  private slotState = new Map<string, boolean>();\n  private slotObserver: MutationObserver | null = null;\n  private isInitialized = false;\n\n  constructor(private readonly hostElement: HTMLElement, private readonly slotNames: readonly string[], private readonly onStateChange?: () => void) {}\n\n  /**\n   * Initialize the slot state. Call this in componentWillLoad()\n   */\n  initialize(): void {\n    this.updateSlotState();\n    this.isInitialized = true;\n  }\n\n  /**\n   * Setup slot listeners and observers. Call this in componentDidLoad()\n   */\n  setupListeners(): void {\n    if (!this.isInitialized) {\n      console.warn('SlotManager: initialize() must be called before setupListeners()');\n      return;\n    }\n\n    // Listen to slotchange events\n    this.hostElement.addEventListener('slotchange', this.handleSlotChange);\n\n    // Use MutationObserver as a fallback for browsers that don't fire slotchange reliably\n    this.slotObserver = new MutationObserver(this.handleSlotChange);\n    this.slotObserver.observe(this.hostElement, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['slot'],\n    });\n  }\n\n  /**\n   * Remove all listeners and cleanup. Call this in disconnectedCallback()\n   */\n  destroy(): void {\n    this.hostElement.removeEventListener('slotchange', this.handleSlotChange);\n    this.slotObserver?.disconnect();\n    this.slotObserver = null;\n    this.slotState.clear();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Check if a specific slot has content\n   */\n  hasSlot(name: string): boolean {\n    return this.slotState.get(name) ?? false;\n  }\n\n  /**\n   * Get all slot states as a Map\n   */\n  getSlotState(): ReadonlyMap<string, boolean> {\n    return this.slotState;\n  }\n\n  /**\n   * Get all slot names that have content\n   */\n  getActiveSlots(): string[] {\n    return Array.from(this.slotState.entries())\n      .filter(([_, hasContent]) => hasContent)\n      .map(([name]) => name);\n  }\n\n  /**\n   * Manually trigger a slot state update\n   */\n  refresh(): void {\n    this.updateSlotState();\n  }\n\n  private handleSlotChange = (): void => {\n    this.updateSlotState();\n    this.onStateChange?.();\n  };\n\n  private updateSlotState(): void {\n    const newState = new Map<string, boolean>();\n\n    this.slotNames.forEach(name => {\n      newState.set(name, this.checkSlotHasContent(name));\n    });\n\n    this.slotState = newState;\n  }\n\n  private checkSlotHasContent(name: string): boolean {\n    return Array.from(this.hostElement.children).some(child => child.getAttribute('slot') === name);\n  }\n}\n\n/**\n * Convenience function to create a SlotManager with automatic lifecycle management\n * Returns helper methods that can be called directly in lifecycle hooks\n */\nexport function createSlotManager(hostElement: HTMLElement, slotNames: readonly string[], onStateChange?: () => void) {\n  const manager = new SlotManager(hostElement, slotNames, onStateChange);\n\n  return {\n    manager,\n    // Lifecycle hooks\n    initialize: () => manager.initialize(),\n    setupListeners: () => manager.setupListeners(),\n    destroy: () => manager.destroy(),\n    // Query methods\n    hasSlot: (name: string) => manager.hasSlot(name),\n    getSlotState: () => manager.getSlotState(),\n    getActiveSlots: () => manager.getActiveSlots(),\n    refresh: () => manager.refresh(),\n  };\n}\n"],"mappings":"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","ignoreList":[]}
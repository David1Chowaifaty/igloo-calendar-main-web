{"version":3,"names":["SlotManager","hostElement","slotNames","onStateChange","slotState","Map","slotObserver","isInitialized","constructor","this","initialize","updateSlotState","setupListeners","console","warn","addEventListener","handleSlotChange","MutationObserver","observe","childList","subtree","attributes","attributeFilter","destroy","removeEventListener","disconnect","clear","hasSlot","name","get","getSlotState","getActiveSlots","Array","from","entries","filter","_","hasContent","map","refresh","newState","forEach","set","checkSlotHasContent","children","some","child","getAttribute","createSlotManager","manager"],"sources":["src/utils/slot.ts"],"sourcesContent":["/**\n * SlotManager - A reusable service for managing slot state in Stencil components\n *\n * Usage:\n * 1. Create an instance in your component\n * 2. Initialize in componentWillLoad()\n * 3. Setup observers in componentDidLoad()\n * 4. Cleanup in disconnectedCallback()\n * 5. Check slot state using hasSlot()\n */\nexport class SlotManager {\n  private slotState = new Map<string, boolean>();\n  private slotObserver: MutationObserver | null = null;\n  private isInitialized = false;\n\n  constructor(private readonly hostElement: HTMLElement, private readonly slotNames: readonly string[], private readonly onStateChange?: () => void) {}\n\n  /**\n   * Initialize the slot state. Call this in componentWillLoad()\n   */\n  initialize(): void {\n    this.updateSlotState();\n    this.isInitialized = true;\n  }\n\n  /**\n   * Setup slot listeners and observers. Call this in componentDidLoad()\n   */\n  setupListeners(): void {\n    if (!this.isInitialized) {\n      console.warn('SlotManager: initialize() must be called before setupListeners()');\n      return;\n    }\n\n    // Listen to slotchange events\n    this.hostElement.addEventListener('slotchange', this.handleSlotChange);\n\n    // Use MutationObserver as a fallback for browsers that don't fire slotchange reliably\n    this.slotObserver = new MutationObserver(this.handleSlotChange);\n    this.slotObserver.observe(this.hostElement, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['slot'],\n    });\n  }\n\n  /**\n   * Remove all listeners and cleanup. Call this in disconnectedCallback()\n   */\n  destroy(): void {\n    this.hostElement.removeEventListener('slotchange', this.handleSlotChange);\n    this.slotObserver?.disconnect();\n    this.slotObserver = null;\n    this.slotState.clear();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Check if a specific slot has content\n   */\n  hasSlot(name: string): boolean {\n    return this.slotState.get(name) ?? false;\n  }\n\n  /**\n   * Get all slot states as a Map\n   */\n  getSlotState(): ReadonlyMap<string, boolean> {\n    return this.slotState;\n  }\n\n  /**\n   * Get all slot names that have content\n   */\n  getActiveSlots(): string[] {\n    return Array.from(this.slotState.entries())\n      .filter(([_, hasContent]) => hasContent)\n      .map(([name]) => name);\n  }\n\n  /**\n   * Manually trigger a slot state update\n   */\n  refresh(): void {\n    this.updateSlotState();\n  }\n\n  private handleSlotChange = (): void => {\n    this.updateSlotState();\n    this.onStateChange?.();\n  };\n\n  private updateSlotState(): void {\n    const newState = new Map<string, boolean>();\n\n    this.slotNames.forEach(name => {\n      newState.set(name, this.checkSlotHasContent(name));\n    });\n\n    this.slotState = newState;\n  }\n\n  private checkSlotHasContent(name: string): boolean {\n    return Array.from(this.hostElement.children).some(child => child.getAttribute('slot') === name);\n  }\n}\n\n/**\n * Convenience function to create a SlotManager with automatic lifecycle management\n * Returns helper methods that can be called directly in lifecycle hooks\n */\nexport function createSlotManager(hostElement: HTMLElement, slotNames: readonly string[], onStateChange?: () => void) {\n  const manager = new SlotManager(hostElement, slotNames, onStateChange);\n\n  return {\n    manager,\n    // Lifecycle hooks\n    initialize: () => manager.initialize(),\n    setupListeners: () => manager.setupListeners(),\n    destroy: () => manager.destroy(),\n    // Query methods\n    hasSlot: (name: string) => manager.hasSlot(name),\n    getSlotState: () => manager.getSlotState(),\n    getActiveSlots: () => manager.getActiveSlots(),\n    refresh: () => manager.refresh(),\n  };\n}\n"],"mappings":"MAUaA,EAKkBC,YAA2CC,UAA+CC,cAJ/GC,UAAY,IAAIC,IAChBC,aAAwC,KACxCC,cAAgB,MAExB,WAAAC,CAA6BP,EAA2CC,EAA+CC,GAA1FM,KAAAR,cAA2CQ,KAAAP,YAA+CO,KAAAN,e,CAKvH,UAAAO,GACED,KAAKE,kBACLF,KAAKF,cAAgB,I,CAMvB,cAAAK,GACE,IAAKH,KAAKF,cAAe,CACvBM,QAAQC,KAAK,oEACb,M,CAIFL,KAAKR,YAAYc,iBAAiB,aAAcN,KAAKO,kBAGrDP,KAAKH,aAAe,IAAIW,iBAAiBR,KAAKO,kBAC9CP,KAAKH,aAAaY,QAAQT,KAAKR,YAAa,CAC1CkB,UAAW,KACXC,QAAS,KACTC,WAAY,KACZC,gBAAiB,CAAC,S,CAOtB,OAAAC,GACEd,KAAKR,YAAYuB,oBAAoB,aAAcf,KAAKO,kBACxDP,KAAKH,cAAcmB,aACnBhB,KAAKH,aAAe,KACpBG,KAAKL,UAAUsB,QACfjB,KAAKF,cAAgB,K,CAMvB,OAAAoB,CAAQC,GACN,OAAOnB,KAAKL,UAAUyB,IAAID,IAAS,K,CAMrC,YAAAE,GACE,OAAOrB,KAAKL,S,CAMd,cAAA2B,GACE,OAAOC,MAAMC,KAAKxB,KAAKL,UAAU8B,WAC9BC,QAAO,EAAEC,EAAGC,KAAgBA,IAC5BC,KAAI,EAAEV,KAAUA,G,CAMrB,OAAAW,GACE9B,KAAKE,iB,CAGCK,iBAAmB,KACzBP,KAAKE,kBACLF,KAAKN,iBAAiB,EAGhB,eAAAQ,GACN,MAAM6B,EAAW,IAAInC,IAErBI,KAAKP,UAAUuC,SAAQb,IACrBY,EAASE,IAAId,EAAMnB,KAAKkC,oBAAoBf,GAAM,IAGpDnB,KAAKL,UAAYoC,C,CAGX,mBAAAG,CAAoBf,GAC1B,OAAOI,MAAMC,KAAKxB,KAAKR,YAAY2C,UAAUC,MAAKC,GAASA,EAAMC,aAAa,UAAYnB,G,WAQ9EoB,EAAkB/C,EAA0BC,EAA8BC,GACxF,MAAM8C,EAAU,IAAIjD,EAAYC,EAAaC,EAAWC,GAExD,MAAO,CACL8C,UAEAvC,WAAY,IAAMuC,EAAQvC,aAC1BE,eAAgB,IAAMqC,EAAQrC,iBAC9BW,QAAS,IAAM0B,EAAQ1B,UAEvBI,QAAUC,GAAiBqB,EAAQtB,QAAQC,GAC3CE,aAAc,IAAMmB,EAAQnB,eAC5BC,eAAgB,IAAMkB,EAAQlB,iBAC9BQ,QAAS,IAAMU,EAAQV,UAE3B,Q","ignoreList":[]}
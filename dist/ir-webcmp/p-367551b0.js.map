{"version":3,"names":["Debounce","wait","options","_","__","descriptor","originalMethod","value","leading","trailing","timeoutMap","WeakMap","lastCallMap","args","context","this","now","Date","existingTimeout","get","lastCall","clearTimeout","apply","set","timeout","setTimeout","delete"],"sources":["src/decorators/debounce.ts"],"sourcesContent":["/**\n * Debounce decorator that delays method execution until after wait milliseconds\n * have elapsed since the last time it was invoked.\n *\n * @param wait - The number of milliseconds to delay\n * @param options - Configuration options\n * @param options.leading - Execute on the leading edge (default: false)\n * @param options.trailing - Execute on the trailing edge (default: true)\n */\nexport function Debounce(wait: number, options: { leading?: boolean; trailing?: boolean } = {}) {\n  return function (_, __, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    const { leading = false, trailing = true } = options;\n\n    // Store timeout IDs per instance\n    const timeoutMap = new WeakMap<any, NodeJS.Timeout>();\n    const lastCallMap = new WeakMap<any, number>();\n\n    descriptor.value = function (this: any, ...args: any[]) {\n      const context = this;\n      const now = Date.now();\n\n      const existingTimeout = timeoutMap.get(context);\n      const lastCall = lastCallMap.get(context);\n\n      // Clear existing timeout\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n      }\n\n      // Execute on leading edge if enabled and it's the first call\n      if (leading && !existingTimeout) {\n        originalMethod.apply(context, args);\n        lastCallMap.set(context, now);\n      }\n\n      // Set up trailing execution\n      if (trailing) {\n        const timeout = setTimeout(() => {\n          if (!leading || (leading && lastCall && now - lastCall >= wait)) {\n            originalMethod.apply(context, args);\n          }\n          timeoutMap.delete(context);\n          lastCallMap.delete(context);\n        }, wait);\n\n        timeoutMap.set(context, timeout);\n      }\n    };\n\n    return descriptor;\n  };\n}\n"],"mappings":"SASgBA,EAASC,EAAcC,EAAqD,IAC1F,OAAO,SAAUC,EAAGC,EAAIC,GACtB,MAAMC,EAAiBD,EAAWE,MAClC,MAAMC,QAAEA,EAAU,MAAKC,SAAEA,EAAW,MAASP,EAG7C,MAAMQ,EAAa,IAAIC,QACvB,MAAMC,EAAc,IAAID,QAExBN,EAAWE,MAAQ,YAAwBM,GACzC,MAAMC,EAAUC,KAChB,MAAMC,EAAMC,KAAKD,MAEjB,MAAME,EAAkBR,EAAWS,IAAIL,GACvC,MAAMM,EAAWR,EAAYO,IAAIL,GAGjC,GAAII,EAAiB,CACnBG,aAAaH,E,CAIf,GAAIV,IAAYU,EAAiB,CAC/BZ,EAAegB,MAAMR,EAASD,GAC9BD,EAAYW,IAAIT,EAASE,E,CAI3B,GAAIP,EAAU,CACZ,MAAMe,EAAUC,YAAW,KACzB,IAAKjB,GAAYA,GAAWY,GAAYJ,EAAMI,GAAYnB,EAAO,CAC/DK,EAAegB,MAAMR,EAASD,E,CAEhCH,EAAWgB,OAAOZ,GAClBF,EAAYc,OAAOZ,EAAQ,GAC1Bb,GAEHS,EAAWa,IAAIT,EAASU,E,GAI5B,OAAOnB,C,CAEX,Q","ignoreList":[]}
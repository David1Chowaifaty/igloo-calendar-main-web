{"version":3,"names":["OverflowAdd","tag","_proto","_methodName","descriptor","original","value","args","host","getOverflowHost","this","addOverflowForHost","apply","OverflowRelease","removeOverflowForHost","TAG_REGISTRY","Map","BODY_ATTR","STYLE_ID_PREFIX","ensureStyleForTag","isDomAvailable","styleId","document","getElementById","hasOverflow","documentElement","scrollHeight","window","innerHeight","scrollbarWidth","innerWidth","clientWidth","css","trim","style","createElement","id","textContent","head","appendChild","addBodyTag","body","current","getAttribute","tokens","Set","split","has","add","setAttribute","Array","from","join","removeBodyTag","delete","next","removeAttribute","__overflowTags__","counts","previous","get","set","entry","hosts","count","attachDisconnectCleanup","size","Math","max","MutationObserver","__overflowObserver__","obs","isConnected","tagEntries","entries","forEach","i","disconnect","observe","childList","subtree","instance","getElement"],"sources":["src/decorators/OverflowLock.ts"],"sourcesContent":["import { getElement, ComponentInterface } from '@stencil/core';\nimport { HTMLStencilElement } from '@stencil/core/internal';\n\n/**\n * Decorator: call on a method that *acquires* an overflow lock for the host under a specific tag.\n * Example:\n *   @OverflowAdd('modal')\n *   openModal() { ... }\n */\nexport function OverflowAdd(tag: string = 'data-ir-overflow') {\n  return (_proto: ComponentInterface, _methodName: string, descriptor: PropertyDescriptor) => {\n    const original = descriptor?.value;\n\n    descriptor.value = function (...args: any[]) {\n      const host = getOverflowHost(this);\n      if (host) {\n        addOverflowForHost(host, tag);\n      }\n\n      return original?.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Decorator: call on a method that *releases* an overflow lock for the host under a specific tag.\n * Example:\n *   @OverflowRelease('modal')\n *   closeModal() { ... }\n */\nexport function OverflowRelease(tag: string = 'data-ir-overflow') {\n  return (_proto: ComponentInterface, _methodName: string, descriptor: PropertyDescriptor) => {\n    const original = descriptor?.value;\n\n    descriptor.value = function (...args: any[]) {\n      const host = getOverflowHost(this);\n      if (host) {\n        removeOverflowForHost(host, tag);\n      }\n\n      return original?.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n\n/** Host augmentation so we can track how many locks this host has per tag. */\nexport interface HTMLOverflowHostElement extends HTMLStencilElement {\n  __overflowTags__?: Map<string, number>;\n}\n\ninterface TagRegistryEntry {\n  hosts: Set<HTMLElement>;\n  count: number;\n}\n\n/* ---------------------- Core registry & body lock logic --------------------- */\n\nconst TAG_REGISTRY: Map<string, TagRegistryEntry> = new Map();\n// Attribute on <body> that holds a space-separated list of active tags\nconst BODY_ATTR = 'data-overflow-locks';\n// Style element id prefix for per-tag CSS\nconst STYLE_ID_PREFIX = 'overflow-style-';\n\n/** Ensure a <style> for this tag exists (once) and targets the body attr token. */\nfunction ensureStyleForTag(tag: string) {\n  if (!isDomAvailable()) return;\n\n  const styleId = STYLE_ID_PREFIX + tag;\n  if (document.getElementById(styleId)) return;\n\n  // Determine if page has vertical overflow\n  const hasOverflow = document.documentElement.scrollHeight > window.innerHeight;\n\n  // Calculate scrollbar width (0 if no overflow)\n  const scrollbarWidth = hasOverflow ? window.innerWidth - document.documentElement.clientWidth : 0;\n\n  const css = `\n    /* Auto-inserted overflow lock for \"${tag}\" */\n    body[${BODY_ATTR}~=\"${tag}\"] {\n      overflow: hidden !important;\n      /* margin-inline-end respects LTR/RTL direction */\n      margin-inline-end: ${scrollbarWidth}px !important;\n    }\n  `.trim();\n\n  const style = document.createElement('style');\n  style.id = styleId;\n  style.textContent = css;\n  document.head.appendChild(style);\n}\n\n/** Add the tag token to body’s data-overflow-locks (space-separated tokens). */\nfunction addBodyTag(tag: string) {\n  if (!isDomAvailable()) return;\n\n  ensureStyleForTag(tag);\n\n  const body = document.body;\n  const current = (body.getAttribute(BODY_ATTR) || '').trim();\n  const tokens = new Set(current ? current.split(/\\s+/) : []);\n  if (!tokens.has(tag)) {\n    tokens.add(tag);\n    body.setAttribute(BODY_ATTR, Array.from(tokens).join(' '));\n  }\n}\n\n/** Remove the tag token from body’s data-overflow-locks. */\nfunction removeBodyTag(tag: string) {\n  if (!isDomAvailable()) return;\n\n  const body = document.body;\n  const current = (body.getAttribute(BODY_ATTR) || '').trim();\n  if (!current) return;\n\n  const tokens = new Set(current.split(/\\s+/));\n  if (tokens.delete(tag)) {\n    const next = Array.from(tokens).join(' ');\n    if (next) body.setAttribute(BODY_ATTR, next);\n    else body.removeAttribute(BODY_ATTR);\n  }\n}\n\n/** Register a host under a tag, and lock the body for that tag if it’s the first. */\nfunction addOverflowForHost(host: HTMLOverflowHostElement, tag: string) {\n  if (!host || !isDomAvailable()) return;\n\n  // Track on host\n  host.__overflowTags__ ||= new Map<string, number>();\n  const counts = host.__overflowTags__;\n  const previous = counts.get(tag) ?? 0;\n  counts.set(tag, previous + 1);\n\n  // Track globally\n  let entry = TAG_REGISTRY.get(tag);\n  if (!entry) {\n    entry = { hosts: new Set<HTMLElement>(), count: 0 };\n    TAG_REGISTRY.set(tag, entry);\n  }\n\n  if (previous === 0) {\n    entry.hosts.add(host as any);\n  }\n\n  entry.count += 1;\n\n  // If this is the first active lock for this tag, lock the body for this tag\n  if (entry.count === 1) {\n    addBodyTag(tag);\n  }\n\n  // Safety: auto-clean on detach\n  attachDisconnectCleanup(host);\n}\n\n/** Unregister a host from a tag, and possibly unlock the body for that tag. */\nfunction removeOverflowForHost(host: HTMLOverflowHostElement, tag: string) {\n  if (!host || !isDomAvailable()) return;\n\n  // Update host\n  const counts = host.__overflowTags__;\n  if (!counts) return;\n\n  const current = counts.get(tag);\n  if (!current) return;\n\n  if (current > 1) {\n    counts.set(tag, current - 1);\n  } else {\n    counts.delete(tag);\n    if (counts.size === 0) {\n      delete host.__overflowTags__;\n    }\n  }\n\n  // Update global registry\n  const entry = TAG_REGISTRY.get(tag);\n  if (!entry) return;\n\n  entry.count = Math.max(0, entry.count - 1);\n\n  if (current === 1) {\n    entry.hosts.delete(host as any);\n  }\n\n  if (entry.count === 0) {\n    TAG_REGISTRY.delete(tag);\n    removeBodyTag(tag);\n    // Optional: also remove the injected style node if you prefer cleanup:\n    // const style = document.getElementById(STYLE_ID_PREFIX + tag);\n    // style?.remove();\n  }\n}\n\n/** If a host is removed from the DOM without calling release, auto-clean its tags. */\nfunction attachDisconnectCleanup(host: HTMLOverflowHostElement) {\n  if (!host || !isDomAvailable() || typeof MutationObserver === 'undefined') return;\n  // Don’t attach multiple observers to the same host\n  if ((host as any).__overflowObserver__) return;\n\n  const obs = new MutationObserver(() => {\n    // If host is no longer connected, clear all tags it owned\n    if (!host.isConnected) {\n      const tagEntries = host.__overflowTags__ ? Array.from(host.__overflowTags__.entries()) : [];\n      tagEntries.forEach(([tag, count]) => {\n        for (let i = 0; i < count; i += 1) {\n          removeOverflowForHost(host, tag);\n        }\n      });\n      obs.disconnect();\n      delete (host as any).__overflowObserver__;\n    }\n  });\n\n  obs.observe(document.documentElement, { childList: true, subtree: true });\n  (host as any).__overflowObserver__ = obs;\n}\n\nfunction getOverflowHost(instance: any): HTMLOverflowHostElement | null {\n  if (!isDomAvailable()) return null;\n\n  try {\n    return getElement(instance) as HTMLOverflowHostElement;\n  } catch {\n    return null;\n  }\n}\n\nfunction isDomAvailable(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n"],"mappings":"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","ignoreList":[]}
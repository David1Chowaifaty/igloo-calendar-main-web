{"file":"debounce.js","mappings":"AAAA;;;;;;;;;SASgB,QAAQ,CAAC,IAAY,EAAE,UAAqD,EAAE;IAC5F,OAAO,UAAU,CAAC,EAAE,EAAE,EAAE,UAA8B;QACpD,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;QACxC,MAAM,EAAE,OAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;;QAGrD,MAAM,UAAU,GAAG,IAAI,OAAO,EAAuB,CAAC;QACtD,MAAM,WAAW,GAAG,IAAI,OAAO,EAAe,CAAC;QAE/C,UAAU,CAAC,KAAK,GAAG,UAAqB,GAAG,IAAW;YACpD,MAAM,OAAO,GAAG,IAAI,CAAC;YACrB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAEvB,MAAM,eAAe,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;;YAG1C,IAAI,eAAe,EAAE;gBACnB,YAAY,CAAC,eAAe,CAAC,CAAC;aAC/B;;YAGD,IAAI,OAAO,IAAI,CAAC,eAAe,EAAE;gBAC/B,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBACpC,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;aAC/B;;YAGD,IAAI,QAAQ,EAAE;gBACZ,MAAM,OAAO,GAAG,UAAU,CAAC;oBACzB,IAAI,CAAC,OAAO,KAAK,OAAO,IAAI,QAAQ,IAAI,GAAG,GAAG,QAAQ,IAAI,IAAI,CAAC,EAAE;wBAC/D,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;qBACrC;oBACD,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;oBAC3B,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;iBAC7B,EAAE,IAAI,CAAC,CAAC;gBAET,UAAU,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;aAClC;SACF,CAAC;QAEF,OAAO,UAAU,CAAC;KACnB,CAAC;AACJ;;;;","names":[],"sources":["src/decorators/debounce.ts"],"sourcesContent":["/**\n * Debounce decorator that delays method execution until after wait milliseconds\n * have elapsed since the last time it was invoked.\n *\n * @param wait - The number of milliseconds to delay\n * @param options - Configuration options\n * @param options.leading - Execute on the leading edge (default: false)\n * @param options.trailing - Execute on the trailing edge (default: true)\n */\nexport function Debounce(wait: number, options: { leading?: boolean; trailing?: boolean } = {}) {\n  return function (_, __, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    const { leading = false, trailing = true } = options;\n\n    // Store timeout IDs per instance\n    const timeoutMap = new WeakMap<any, NodeJS.Timeout>();\n    const lastCallMap = new WeakMap<any, number>();\n\n    descriptor.value = function (this: any, ...args: any[]) {\n      const context = this;\n      const now = Date.now();\n\n      const existingTimeout = timeoutMap.get(context);\n      const lastCall = lastCallMap.get(context);\n\n      // Clear existing timeout\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n      }\n\n      // Execute on leading edge if enabled and it's the first call\n      if (leading && !existingTimeout) {\n        originalMethod.apply(context, args);\n        lastCallMap.set(context, now);\n      }\n\n      // Set up trailing execution\n      if (trailing) {\n        const timeout = setTimeout(() => {\n          if (!leading || (leading && lastCall && now - lastCall >= wait)) {\n            originalMethod.apply(context, args);\n          }\n          timeoutMap.delete(context);\n          lastCallMap.delete(context);\n        }, wait);\n\n        timeoutMap.set(context, timeout);\n      }\n    };\n\n    return descriptor;\n  };\n}\n"],"version":3}
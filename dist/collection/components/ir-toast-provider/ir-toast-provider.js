import { h } from "@stencil/core";
export class IrToastProvider {
    el;
    position = 'top-end';
    rtl = false;
    duration = 5000;
    toasts = [];
    popoverRef;
    toastTimers = new Map();
    componentDidLoad() {
        // Ensure popover API is supported
        if (this.popoverRef && typeof this.popoverRef.showPopover === 'function') {
            // Initially hide the popover
            try {
                this.popoverRef.hidePopover?.();
            }
            catch (e) {
                // Popover might not be shown yet
            }
        }
    }
    disconnectedCallback() {
        this.toastTimers.forEach(timer => {
            if (timer.timeoutId) {
                clearTimeout(timer.timeoutId);
            }
        });
        this.toastTimers.clear();
    }
    handleToast(event) {
        const detail = event?.detail || {};
        const payload = {
            ...detail,
            title: detail.title ?? 'Notification',
        };
        this.addToast(payload);
    }
    async addToast(toast) {
        const id = toast.id ?? this.generateToastId();
        const newToast = {
            id,
            type: toast.type ?? 'info',
            duration: toast.duration ?? this.duration,
            dismissible: toast.dismissible ?? true,
            leaving: false,
            ...toast,
        };
        this.toasts = [...this.toasts, newToast];
        this.announceToast(newToast);
        // Show popover when first toast is added
        if (this.toasts.length === 1) {
            this.showPopover();
        }
        if (newToast.duration && newToast.duration > 0) {
            this.startTimer(newToast.id, newToast.duration);
        }
        return id;
    }
    async removeToast(id) {
        // Mark toast as leaving for exit animation
        this.toasts = this.toasts.map(toast => (toast.id === id ? { ...toast, leaving: true } : toast));
        // Wait for animation to complete, then remove
        setTimeout(() => {
            this.clearTimer(id);
            this.toasts = this.toasts.filter(toast => toast.id !== id);
            // Hide popover when last toast is removed
            if (this.toasts.length === 0) {
                this.hidePopover();
            }
        }, 200); // Match the exit animation duration
    }
    async clearAllToasts() {
        this.toastTimers.forEach(timer => {
            if (timer.timeoutId) {
                clearTimeout(timer.timeoutId);
            }
        });
        this.toastTimers.clear();
        this.toasts = [];
        this.hidePopover();
    }
    showPopover() {
        if (this.popoverRef && typeof this.popoverRef.showPopover === 'function') {
            try {
                this.popoverRef.showPopover();
            }
            catch (e) {
                // Popover might already be shown
            }
        }
    }
    hidePopover() {
        if (this.popoverRef && typeof this.popoverRef.hidePopover === 'function') {
            try {
                this.popoverRef.hidePopover();
            }
            catch (e) {
                // Popover might already be hidden
            }
        }
    }
    generateToastId() {
        return `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    startTimer(id, duration) {
        if (typeof window === 'undefined') {
            return;
        }
        this.clearTimer(id);
        const timeoutId = window.setTimeout(() => this.removeToast(id), duration);
        this.toastTimers.set(id, { timeoutId, remaining: duration, startedAt: Date.now() });
    }
    pauseTimer(id) {
        const timer = this.toastTimers.get(id);
        if (!timer || timer.timeoutId === undefined || timer.startedAt === undefined) {
            return;
        }
        clearTimeout(timer.timeoutId);
        const elapsed = Date.now() - timer.startedAt;
        const remaining = Math.max(timer.remaining - elapsed, 0);
        this.toastTimers.set(id, { remaining });
    }
    resumeTimer(id) {
        const timer = this.toastTimers.get(id);
        if (!timer || timer.timeoutId !== undefined) {
            return;
        }
        if (timer.remaining <= 0) {
            this.removeToast(id);
            return;
        }
        if (typeof window === 'undefined') {
            return;
        }
        const timeoutId = window.setTimeout(() => this.removeToast(id), timer.remaining);
        this.toastTimers.set(id, { timeoutId, remaining: timer.remaining, startedAt: Date.now() });
    }
    clearTimer(id) {
        const timer = this.toastTimers.get(id);
        if (timer?.timeoutId) {
            clearTimeout(timer.timeoutId);
        }
        this.toastTimers.delete(id);
    }
    announceToast(toast) {
        if (typeof document === 'undefined' || !this.el?.shadowRoot) {
            return;
        }
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', toast.type === 'error' || toast.type === 'danger' ? 'assertive' : 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.className = 'sr-only';
        announcement.textContent = `${toast.type}: ${toast.title}${toast.description ? '. ' + toast.description : ''}`;
        this.el.shadowRoot.appendChild(announcement);
        setTimeout(() => {
            announcement.remove();
        }, 1000);
    }
    getPositionClass() {
        const [vertical, horizontal] = this.position.split('-');
        return `toast-container--${vertical} toast-container--${horizontal}`;
    }
    getAlertPosition() {
        const [vertical = 'top', horizontal = 'end'] = this.position.split('-');
        const horizontalMap = {
            start: this.rtl ? 'right' : 'left',
            end: this.rtl ? 'left' : 'right',
        };
        const resolvedHorizontal = horizontalMap[horizontal] ?? 'right';
        const resolvedVertical = vertical === 'bottom' ? 'bottom' : 'top';
        return `${resolvedVertical}-${resolvedHorizontal}`;
    }
    mapVariant(type) {
        switch (type) {
            case 'success':
                return 'success';
            case 'warning':
                return 'warning';
            case 'error':
            case 'danger':
                return 'danger';
            default:
                return 'info';
        }
    }
    handleToastDismiss = (event) => {
        event.stopPropagation();
        this.removeToast(event.detail.id);
    };
    handleInteractionChange = (event) => {
        event.stopPropagation();
        if (event.detail.interacting) {
            this.pauseTimer(event.detail.id);
        }
        else {
            this.resumeTimer(event.detail.id);
        }
    };
    handlePopoverToggle = (event) => {
        // Prevent popover from being closed by user interaction or light dismiss
        if (this.toasts.length > 0) {
            event.preventDefault();
            this.showPopover();
        }
    };
    render() {
        return (h("div", { key: '9f1ed8ca4bd15b7e6bdf8f853c1160fda565b1e6', ref: el => (this.popoverRef = el), popover: "manual", class: "toast-popover", onToggle: this.handlePopoverToggle }, h("div", { key: '9c3da1d3cd35189e04e6cc22c52f73eb1cdcf266', class: `toast-container ${this.getPositionClass()} ${this.rtl ? 'rtl' : ''}`, role: "region", "aria-label": "Notifications", "aria-live": "polite", dir: this.rtl ? 'rtl' : 'ltr' }, this.toasts.map(toast => (h("div", { class: "toast-item", key: toast.id }, h("ir-toast-alert", { toastId: toast.id, label: toast.title, description: toast.description, dismissible: toast.dismissible, actionLabel: toast.actionLabel, position: this.getAlertPosition(), variant: this.mapVariant(toast.type), leaving: toast.leaving, onIrToastDismiss: this.handleToastDismiss, onIrToastInteractionChange: this.handleInteractionChange })))))));
    }
    static get is() { return "ir-toast-provider"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["ir-toast-provider.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["ir-toast-provider.css"]
        };
    }
    static get properties() {
        return {
            "position": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'top-start' | 'top-center' | 'top-end' | 'bottom-start' | 'bottom-center' | 'bottom-end'",
                    "resolved": "\"bottom-center\" | \"bottom-end\" | \"bottom-start\" | \"top-center\" | \"top-end\" | \"top-start\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "attribute": "position",
                "reflect": false,
                "defaultValue": "'top-end'"
            },
            "rtl": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "attribute": "rtl",
                "reflect": false,
                "defaultValue": "false"
            },
            "duration": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "attribute": "duration",
                "reflect": false,
                "defaultValue": "5000"
            }
        };
    }
    static get states() {
        return {
            "toasts": {}
        };
    }
    static get methods() {
        return {
            "addToast": {
                "complexType": {
                    "signature": "(toast: Toast) => Promise<string>",
                    "parameters": [{
                            "name": "toast",
                            "type": "Toast",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Toast": {
                            "location": "local",
                            "path": "/Users/davidchowaifaty/code/igloorooms/modified-ir-webcmp/src/components/ir-toast-provider/ir-toast-provider.tsx",
                            "id": "src/components/ir-toast-provider/ir-toast-provider.tsx::Toast"
                        },
                        "ManagedToast": {
                            "location": "global",
                            "id": "global::ManagedToast"
                        }
                    },
                    "return": "Promise<string>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "removeToast": {
                "complexType": {
                    "signature": "(id: string) => Promise<void>",
                    "parameters": [{
                            "name": "id",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "clearAllToasts": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get listeners() {
        return [{
                "name": "toast",
                "method": "handleToast",
                "target": "body",
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=ir-toast-provider.js.map

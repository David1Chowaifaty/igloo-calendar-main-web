{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/services/booking-service/utils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAY,aAAa,EAAE,MAAM,uBAAuB,CAAC;AAChE;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,iBAAiB,CAAC,cAA8B;IAC9D,IAAI,CAAC;QACH,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,CAAC;aACxB,MAAM,CAAC;YACN,KAAK,EAAE,aAAa,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YACnC,MAAM,EAAE,aAAa,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YACpC,OAAO,EAAE,aAAa,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;SACtC,CAAC;aACD,KAAK,CAAC,cAAc,CAAC,CAAC;QACzB,MAAM,KAAK,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC;QAEzB,MAAM,OAAO,GAAG,CAAC,KAAe,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvI,MAAM,iBAAiB,GAAG,CAAC,IAAY,EAAE,EAAE;YACzC,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,SAAS,KAAK,IAAI,CAAC,CAAC;YAC9D,OAAO,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACnE,CAAC,CAAC;QACF,IAAI,GAAG,GAA+B,EAAE,CAAC;QACzC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACrB,wCAAwC;YACxC,mDAAmD;YACnD,gBAAgB;YAChB,wDAAwD;YACxD,uBAAuB;YACvB,6CAA6C;YAC7C,mDAAmD;YACnD,gBAAgB;YAChB,uDAAuD;YACvD,uBAAuB;YACvB,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACb,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACnB,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC","sourcesContent":["import { PaymentEntries } from '@/components/ir-booking-details/types';\nimport { z } from 'zod';\nimport { IEntries, ZIEntrySchema } from '../../models/IBooking';\n/**\n * Builds a grouped payment types record from raw entries and groups.\n *\n * @param paymentEntries - The flat list of all available payment  entries.\n * @returns A record where each key is a group CODE_NAME and the value is the\n *          ordered array of payment type entries belonging to that group.\n *\n * @example\n * const result = buildPaymentTypes(paymentEntries);\n * // {\n * //   PAYMENTS: [ { CODE_NAME: \"001\", CODE_VALUE_EN: \"Cash\", ... }, ... ],\n * //   ADJUSTMENTS: [ ... ],\n * //   ...\n * // }\n */\nexport function buildPaymentTypes(paymentEntries: PaymentEntries): Record<string, IEntries[]> {\n  try {\n    const { groups, types } = z\n      .object({\n        types: ZIEntrySchema.array().min(1),\n        groups: ZIEntrySchema.array().min(1),\n        methods: ZIEntrySchema.array().min(1),\n      })\n      .parse(paymentEntries);\n    const items = [...types];\n\n    const byCodes = (codes: string[]) => codes.map(code => items.find(i => i.CODE_NAME === code)).filter((x): x is IEntries => Boolean(x));\n\n    const extractGroupCodes = (code: string) => {\n      const paymentGroup = groups.find(pt => pt.CODE_NAME === code);\n      return paymentGroup ? paymentGroup.CODE_VALUE_EN.split(',') : [];\n    };\n    let rec: Record<string, IEntries[]> = {};\n    groups.forEach(group => {\n      // if (group.CODE_NAME === 'PAYMENTS') {\n      //   rec[group.CODE_NAME] = methods.map(entry => ({\n      //     ...entry,\n      //     CODE_VALUE_EN: `Payment: ${entry.CODE_VALUE_EN}`,\n      //   })) as IEntries[];\n      // } else if (group.CODE_NAME === 'REFUND') {\n      //   rec[group.CODE_NAME] = methods.map(entry => ({\n      //     ...entry,\n      //     CODE_VALUE_EN: `Refund: ${entry.CODE_VALUE_EN}`,\n      //   })) as IEntries[];\n      rec[group.CODE_NAME] = byCodes(extractGroupCodes(group.CODE_NAME));\n    });\n    return rec;\n  } catch (error) {\n    console.log(error);\n    return {};\n  }\n}\n"]}
{"version":3,"file":"debounce.js","sourceRoot":"","sources":["../../src/decorators/debounce.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG;AACH,MAAM,UAAU,QAAQ,CAAC,IAAY,EAAE,UAAqD,EAAE;IAC5F,OAAO,UAAU,CAAC,EAAE,EAAE,EAAE,UAA8B;QACpD,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;QACxC,MAAM,EAAE,OAAO,GAAG,KAAK,EAAE,QAAQ,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;QAErD,iCAAiC;QACjC,MAAM,UAAU,GAAG,IAAI,OAAO,EAAuB,CAAC;QACtD,MAAM,WAAW,GAAG,IAAI,OAAO,EAAe,CAAC;QAE/C,UAAU,CAAC,KAAK,GAAG,UAAqB,GAAG,IAAW;YACpD,MAAM,OAAO,GAAG,IAAI,CAAC;YACrB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAEvB,MAAM,eAAe,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAE1C,yBAAyB;YACzB,IAAI,eAAe,EAAE,CAAC;gBACpB,YAAY,CAAC,eAAe,CAAC,CAAC;YAChC,CAAC;YAED,6DAA6D;YAC7D,IAAI,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC;gBAChC,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;gBACpC,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YAChC,CAAC;YAED,4BAA4B;YAC5B,IAAI,QAAQ,EAAE,CAAC;gBACb,MAAM,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;oBAC9B,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,IAAI,QAAQ,IAAI,GAAG,GAAG,QAAQ,IAAI,IAAI,CAAC,EAAE,CAAC;wBAChE,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;oBACtC,CAAC;oBACD,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;oBAC3B,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBAC9B,CAAC,EAAE,IAAI,CAAC,CAAC;gBAET,UAAU,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YACnC,CAAC;QACH,CAAC,CAAC;QAEF,OAAO,UAAU,CAAC;IACpB,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * Debounce decorator that delays method execution until after wait milliseconds\n * have elapsed since the last time it was invoked.\n *\n * @param wait - The number of milliseconds to delay\n * @param options - Configuration options\n * @param options.leading - Execute on the leading edge (default: false)\n * @param options.trailing - Execute on the trailing edge (default: true)\n */\nexport function Debounce(wait: number, options: { leading?: boolean; trailing?: boolean } = {}) {\n  return function (_, __, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    const { leading = false, trailing = true } = options;\n\n    // Store timeout IDs per instance\n    const timeoutMap = new WeakMap<any, NodeJS.Timeout>();\n    const lastCallMap = new WeakMap<any, number>();\n\n    descriptor.value = function (this: any, ...args: any[]) {\n      const context = this;\n      const now = Date.now();\n\n      const existingTimeout = timeoutMap.get(context);\n      const lastCall = lastCallMap.get(context);\n\n      // Clear existing timeout\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n      }\n\n      // Execute on leading edge if enabled and it's the first call\n      if (leading && !existingTimeout) {\n        originalMethod.apply(context, args);\n        lastCallMap.set(context, now);\n      }\n\n      // Set up trailing execution\n      if (trailing) {\n        const timeout = setTimeout(() => {\n          if (!leading || (leading && lastCall && now - lastCall >= wait)) {\n            originalMethod.apply(context, args);\n          }\n          timeoutMap.delete(context);\n          lastCallMap.delete(context);\n        }, wait);\n\n        timeoutMap.set(context, timeout);\n      }\n    };\n\n    return descriptor;\n  };\n}\n"]}
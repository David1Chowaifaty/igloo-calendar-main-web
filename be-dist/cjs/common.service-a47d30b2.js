'use strict';

const index = require('./index-08156e03.js');
const axios = require('./axios-bc0bd15c.js');

class Token {
    getToken() {
        return this.token;
    }
    setToken(token) {
        this.token = token;
    }
}
class MissingTokenError extends Error {
    constructor(message = 'Missing token!!') {
        super(message);
        this.name = 'MissingTokenError';
    }
}

var locale = {};

var af = {};

var formatDistance$2H = {};

formatDistance$2H.formatDistance = void 0;

const formatDistanceLocale$1j = {
  lessThanXSeconds: {
    one: "minder as 'n sekonde",
    other: "minder as {{count}} sekondes",
  },

  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekondes",
  },

  halfAMinute: "'n halwe minuut",

  lessThanXMinutes: {
    one: "minder as 'n minuut",
    other: "minder as {{count}} minute",
  },

  xMinutes: {
    one: "'n minuut",
    other: "{{count}} minute",
  },

  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} ure",
  },

  xHours: {
    one: "1 uur",
    other: "{{count}} ure",
  },

  xDays: {
    one: "1 dag",
    other: "{{count}} dae",
  },

  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weke",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weke",
  },

  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maande",
  },

  xMonths: {
    one: "1 maand",
    other: "{{count}} maande",
  },

  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar",
  },

  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar",
  },

  overXYears: {
    one: "meer as 1 jaar",
    other: "meer as {{count}} jaar",
  },

  almostXYears: {
    one: "byna 1 jaar",
    other: "byna {{count}} jaar",
  },
};

const formatDistance$2G = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$1j[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "oor " + result;
    } else {
      return result + " gelede";
    }
  }

  return result;
};
formatDistance$2H.formatDistance = formatDistance$2G;

var formatLong$1s = {};

var buildFormatLongFn$1 = {};

buildFormatLongFn$1.buildFormatLongFn = buildFormatLongFn;

function buildFormatLongFn(args) {
  return (options = {}) => {
    // TODO: Remove String()
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

formatLong$1s.formatLong = void 0;
var _index$9H = buildFormatLongFn$1;

const dateFormats$1s = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "yyyy/MM/dd",
};

const timeFormats$1s = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1s = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1s.formatLong = {
  date: (0, _index$9H.buildFormatLongFn)({
    formats: dateFormats$1s,
    defaultWidth: "full",
  }),

  time: (0, _index$9H.buildFormatLongFn)({
    formats: timeFormats$1s,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9H.buildFormatLongFn)({
    formats: dateTimeFormats$1s,
    defaultWidth: "full",
  }),
});

var formatRelative$2H = {};

formatRelative$2H.formatRelative = void 0;

const formatRelativeLocale$1k = {
  lastWeek: "'verlede' eeee 'om' p",
  yesterday: "'gister om' p",
  today: "'vandag om' p",
  tomorrow: "'mÃ´re om' p",
  nextWeek: "eeee 'om' p",
  other: "P",
};

const formatRelative$2G = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$1k[token];
formatRelative$2H.formatRelative = formatRelative$2G;

var localize$1k = {};

var buildLocalizeFn$1 = {};

buildLocalizeFn$1.buildLocalizeFn = buildLocalizeFn; /* eslint-disable no-unused-vars */

/**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */

/**
 * The map of localized values for each width.
 */

/**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */

/**
 * Converts the unit value to the tuple of values.
 */

/**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */

/**
 * The tuple of localized quarter values. The first element represents Q1.
 */

/**
 * The tuple of localized day values. The first element represents Sunday.
 */

/**
 * The tuple of localized month values. The first element represents January.
 */

function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";

    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;

      valuesArray =
        args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;

    // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}

localize$1k.localize = void 0;
var _index$9G = buildLocalizeFn$1;

const eraValues$1k = {
  narrow: ["vC", "nC"],
  abbreviated: ["vC", "nC"],
  wide: ["voor Christus", "na Christus"],
};

const quarterValues$1k = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ste kwartaal", "2de kwartaal", "3de kwartaal", "4de kwartaal"],
};

const monthValues$1k = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mrt",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Des",
  ],

  wide: [
    "Januarie",
    "Februarie",
    "Maart",
    "April",
    "Mei",
    "Junie",
    "Julie",
    "Augustus",
    "September",
    "Oktober",
    "November",
    "Desember",
  ],
};

const dayValues$1k = {
  narrow: ["S", "M", "D", "W", "D", "V", "S"],
  short: ["So", "Ma", "Di", "Wo", "Do", "Vr", "Sa"],
  abbreviated: ["Son", "Maa", "Din", "Woe", "Don", "Vry", "Sat"],
  wide: [
    "Sondag",
    "Maandag",
    "Dinsdag",
    "Woensdag",
    "Donderdag",
    "Vrydag",
    "Saterdag",
  ],
};

const dayPeriodValues$1k = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand",
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand",
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand",
  },
};
const formattingDayPeriodValues$14 = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand",
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand",
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand",
  },
};

const ordinalNumber$1k = (dirtyNumber) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 < 20) {
    switch (rem100) {
      case 1:
      case 8:
        return number + "ste";
      default:
        return number + "de";
    }
  }
  return number + "ste";
};

(localize$1k.localize = {
  ordinalNumber: ordinalNumber$1k,

  era: (0, _index$9G.buildLocalizeFn)({
    values: eraValues$1k,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9G.buildLocalizeFn)({
    values: quarterValues$1k,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9G.buildLocalizeFn)({
    values: monthValues$1k,
    defaultWidth: "wide",
  }),

  day: (0, _index$9G.buildLocalizeFn)({
    values: dayValues$1k,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9G.buildLocalizeFn)({
    values: dayPeriodValues$1k,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$14,
    defaultFormattingWidth: "wide",
  }),
});

var match$1j = {};

var buildMatchFn$1 = {};

buildMatchFn$1.buildMatchFn = buildMatchFn;

function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;

    const matchPattern =
      (width && args.matchPatterns[width]) ||
      args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];

    const parsePatterns =
      (width && args.parsePatterns[width]) ||
      args.parsePatterns[args.defaultParseWidth];

    const key = Array.isArray(parsePatterns)
      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
      : // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString));

    let value;

    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback
      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        options.valueCallback(value)
      : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

function findKey(object, predicate) {
  for (const key in object) {
    if (
      Object.prototype.hasOwnProperty.call(object, key) &&
      predicate(object[key])
    ) {
      return key;
    }
  }
  return undefined;
}

function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

var buildMatchPatternFn$1 = {};

buildMatchPatternFn$1.buildMatchPatternFn = buildMatchPatternFn;

function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];

    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback
      ? args.valueCallback(parseResult[0])
      : parseResult[0];

    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
    value = options.valueCallback ? options.valueCallback(value) : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

match$1j.match = void 0;

var _index$9F = buildMatchFn$1;
var _index2$4p = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1j = /^(\d+)(ste|de)?/i;
const parseOrdinalNumberPattern$1j = /\d+/i;

const matchEraPatterns$1j = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?C\.?)/,
  wide: /^((voor|na) Christus)/,
};
const parseEraPatterns$1j = {
  any: [/^v/, /^n/],
};

const matchQuarterPatterns$1j = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](st|d)e kwartaal/i,
};
const parseQuarterPatterns$1j = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1j = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(Jan|Feb|Mrt|Apr|Mei|Jun|Jul|Aug|Sep|Okt|Nov|Dec)\.?/i,
  wide: /^(Januarie|Februarie|Maart|April|Mei|Junie|Julie|Augustus|September|Oktober|November|Desember)/i,
};
const parseMonthPatterns$1j = {
  narrow: [
    /^J/i,
    /^F/i,
    /^M/i,
    /^A/i,
    /^M/i,
    /^J/i,
    /^J/i,
    /^A/i,
    /^S/i,
    /^O/i,
    /^N/i,
    /^D/i,
  ],

  any: [
    /^Jan/i,
    /^Feb/i,
    /^Mrt/i,
    /^Apr/i,
    /^Mei/i,
    /^Jun/i,
    /^Jul/i,
    /^Aug/i,
    /^Sep/i,
    /^Okt/i,
    /^Nov/i,
    /^Dec/i,
  ],
};

const matchDayPatterns$1j = {
  narrow: /^[smdwv]/i,
  short: /^(So|Ma|Di|Wo|Do|Vr|Sa)/i,
  abbreviated: /^(Son|Maa|Din|Woe|Don|Vry|Sat)/i,
  wide: /^(Sondag|Maandag|Dinsdag|Woensdag|Donderdag|Vrydag|Saterdag)/i,
};
const parseDayPatterns$1j = {
  narrow: [/^S/i, /^M/i, /^D/i, /^W/i, /^D/i, /^V/i, /^S/i],
  any: [/^So/i, /^Ma/i, /^Di/i, /^Wo/i, /^Do/i, /^Vr/i, /^Sa/i],
};

const matchDayPeriodPatterns$1j = {
  any: /^(vm|nm|middernag|(?:uur )?die (oggend|middag|aand))/i,
};
const parseDayPeriodPatterns$1j = {
  any: {
    am: /^vm/i,
    pm: /^nm/i,
    midnight: /^middernag/i,
    noon: /^middaguur/i,
    morning: /oggend/i,
    afternoon: /middag/i,
    evening: /laat middag/i,
    night: /aand/i,
  },
};

(match$1j.match = {
  ordinalNumber: (0, _index2$4p.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1j,
    parsePattern: parseOrdinalNumberPattern$1j,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$9F.buildMatchFn)({
    matchPatterns: matchEraPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1j,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$9F.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1j,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$9F.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1j,
    defaultParseWidth: "any",
  }),

  day: (0, _index$9F.buildMatchFn)({
    matchPatterns: matchDayPatterns$1j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1j,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$9F.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1j,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1j,
    defaultParseWidth: "any",
  }),
});

af.af = void 0;
var _index$9E = formatDistance$2H;
var _index2$4o = formatLong$1s;
var _index3$2h = formatRelative$2H;
var _index4$1M = localize$1k;
var _index5$1D = match$1j;

/**
 * @category Locales
 * @summary Afrikaans locale.
 * @language Afrikaans
 * @iso-639-2 afr
 * @author Marnus Weststrate [@marnusw](https://github.com/marnusw)
 */
(af.af = {
  code: "af",
  formatDistance: _index$9E.formatDistance,
  formatLong: _index2$4o.formatLong,
  formatRelative: _index3$2h.formatRelative,
  localize: _index4$1M.localize,
  match: _index5$1D.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var ar = {};

var formatDistance$2F = {};

formatDistance$2F.formatDistance = void 0;

const formatDistanceLocale$1i = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø«Ø§ÙÙØªØ§Ù",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµÙ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§Ø¦Ù",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø¯ÙÙÙØªØ§Ù",
    threeToTen: "{{count}} Ø¯ÙØ§Ø¦Ù",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø© ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø³Ø§Ø¹ØªÙÙ ØªÙØ±ÙØ¨Ø§",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨Ø§Ù",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©",
    two: "Ø³Ø§Ø¹ØªØ§Ù",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙÙ ÙØ§Ø­Ø¯",
    two: "ÙÙÙØ§Ù",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ ØªÙØ±ÙØ¨Ø§",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹Ø§ ØªÙØ±ÙØ¨Ø§",
  },

  xWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯",
    two: "Ø£Ø³Ø¨ÙØ¹Ø§Ù",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹Ø§",
  },

  aboutXMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø´ÙØ±ÙÙ ØªÙØ±ÙØ¨Ø§",
    threeToTen: "{{count}} Ø£Ø´ÙØ± ØªÙØ±ÙØ¨Ø§",
    other: "{{count}} Ø´ÙØ±Ø§ ØªÙØ±ÙØ¨Ø§Ù",
  },

  xMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯",
    two: "Ø´ÙØ±Ø§Ù",
    threeToTen: "{{count}} Ø£Ø´ÙØ±",
    other: "{{count}} Ø´ÙØ±Ø§",
  },

  aboutXYears: {
    one: "Ø³ÙØ© ÙØ§Ø­Ø¯Ø© ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø³ÙØªÙÙ ØªÙØ±ÙØ¨Ø§",
    threeToTen: "{{count}} Ø³ÙÙØ§Øª ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø³ÙØ© ØªÙØ±ÙØ¨Ø§Ù",
  },

  xYears: {
    one: "Ø³ÙØ© ÙØ§Ø­Ø¯",
    two: "Ø³ÙØªØ§Ù",
    threeToTen: "{{count}} Ø³ÙÙØ§Øª",
    other: "{{count}} Ø³ÙØ©",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø³ÙØ©",
    two: "Ø£ÙØ«Ø± ÙÙ Ø³ÙØªÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø³ÙÙØ§Øª",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø³ÙØ©",
  },

  almostXYears: {
    one: "ÙØ§ ÙÙØ§Ø±Ø¨ Ø³ÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "ÙØ§ ÙÙØ§Ø±Ø¨ Ø³ÙØªÙÙ",
    threeToTen: "ÙØ§ ÙÙØ§Ø±Ø¨ {{count}} Ø³ÙÙØ§Øª",
    other: "ÙØ§ ÙÙØ§Ø±Ø¨ {{count}} Ø³ÙØ©",
  },
};

const formatDistance$2E = (token, count, options) => {
  const usageGroup = formatDistanceLocale$1i[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ø®ÙØ§Ù " + result;
    } else {
      return "ÙÙØ° " + result;
    }
  }

  return result;
};
formatDistance$2F.formatDistance = formatDistance$2E;

var formatLong$1r = {};

formatLong$1r.formatLong = void 0;
var _index$9D = buildFormatLongFn$1;

const dateFormats$1r = {
  full: "EEEEØ do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy",
};

const timeFormats$1r = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1r = {
  full: "{{date}} 'Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' {{time}}",
  long: "{{date}} 'Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1r.formatLong = {
  date: (0, _index$9D.buildFormatLongFn)({
    formats: dateFormats$1r,
    defaultWidth: "full",
  }),

  time: (0, _index$9D.buildFormatLongFn)({
    formats: timeFormats$1r,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9D.buildFormatLongFn)({
    formats: dateTimeFormats$1r,
    defaultWidth: "full",
  }),
});

var formatRelative$2F = {};

formatRelative$2F.formatRelative = void 0;

const formatRelativeLocale$1j = {
  lastWeek: "eeee 'Ø§ÙÙØ§Ø¶Ù Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' p",
  yesterday: "'Ø§ÙØ£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' p",
  today: "'Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' p",
  tomorrow: "'ØºØ¯Ø§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' p",
  nextWeek: "eeee 'Ø§ÙÙØ§Ø¯Ù Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©' p",
  other: "P",
};

const formatRelative$2E = (token) => formatRelativeLocale$1j[token];
formatRelative$2F.formatRelative = formatRelative$2E;

var localize$1j = {};

localize$1j.localize = void 0;
var _index$9C = buildLocalizeFn$1;

const eraValues$1j = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1j = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1j = {
  narrow: ["Ù", "Ù", "Ù", "Ø£", "Ù", "Ù", "Ù", "Ø£", "Ø³", "Ø£", "Ù", "Ø¯"],
  abbreviated: [
    "ÙÙØ§ÙØ±",
    "ÙØ¨Ø±Ø§ÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙÙ",
    "ÙÙÙÙÙ",
    "Ø£ØºØ³Ø·Ø³",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],

  wide: [
    "ÙÙØ§ÙØ±",
    "ÙØ¨Ø±Ø§ÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙÙ",
    "ÙÙÙÙÙ",
    "Ø£ØºØ³Ø·Ø³",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],
};

const dayValues$1j = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],

  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ§Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1j = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "Ø§ÙÙØ³Ø§Ø¡",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "Ø§ÙÙØ³Ø§Ø¡",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "Ø§ÙÙØ³Ø§Ø¡",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
};

const formattingDayPeriodValues$13 = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙØ¸ÙØ±",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙÙØªØµÙ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1j = (num) => String(num);

(localize$1j.localize = {
  ordinalNumber: ordinalNumber$1j,

  era: (0, _index$9C.buildLocalizeFn)({
    values: eraValues$1j,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9C.buildLocalizeFn)({
    values: quarterValues$1j,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9C.buildLocalizeFn)({
    values: monthValues$1j,
    defaultWidth: "wide",
  }),

  day: (0, _index$9C.buildLocalizeFn)({
    values: dayValues$1j,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9C.buildLocalizeFn)({
    values: dayPeriodValues$1j,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$13,
    defaultFormattingWidth: "wide",
  }),
});

var match$1i = {};

match$1i.match = void 0;
var _index$9B = buildMatchPatternFn$1;
var _index2$4n = buildMatchFn$1;

const matchOrdinalNumberPattern$1i = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1i = /\d+/i;

const matchEraPatterns$1i = {
  narrow: /[ÙØ¨]/,
  abbreviated: /[ÙØ¨]\.Ù\./,
  wide: /(ÙØ¨Ù|Ø¨Ø¹Ø¯) Ø§ÙÙÙÙØ§Ø¯/,
};
const parseEraPatterns$1i = {
  any: [/ÙØ¨Ù/, /Ø¨Ø¹Ø¯/],
};

const matchQuarterPatterns$1i = {
  narrow: /^[1234]/i,
  abbreviated: /Ø±[1234]/,
  wide: /Ø§ÙØ±Ø¨Ø¹ (Ø§ÙØ£ÙÙ|Ø§ÙØ«Ø§ÙÙ|Ø§ÙØ«Ø§ÙØ«|Ø§ÙØ±Ø§Ø¨Ø¹)/,
};
const parseQuarterPatterns$1i = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1i = {
  narrow: /^[Ø£ÙÙÙØ³ÙØ¯]/,
  abbreviated:
    /^(ÙÙØ§ÙØ±|ÙØ¨Ø±Ø§ÙØ±|ÙØ§Ø±Ø³|Ø£Ø¨Ø±ÙÙ|ÙØ§ÙÙ|ÙÙÙÙÙ|ÙÙÙÙÙ|Ø£ØºØ³Ø·Ø³|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/,
  wide: /^(ÙÙØ§ÙØ±|ÙØ¨Ø±Ø§ÙØ±|ÙØ§Ø±Ø³|Ø£Ø¨Ø±ÙÙ|ÙØ§ÙÙ|ÙÙÙÙÙ|ÙÙÙÙÙ|Ø£ØºØ³Ø·Ø³|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/,
};
const parseMonthPatterns$1i = {
  narrow: [
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ø³/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^ÙÙØ§ÙØ±/i,
    /^ÙØ¨Ø±Ø§ÙØ±/i,
    /^ÙØ§Ø±Ø³/i,
    /^Ø£Ø¨Ø±ÙÙ/i,
    /^ÙØ§ÙÙ/i,
    /^ÙÙÙÙÙ/i,
    /^ÙÙÙÙÙ/i,
    /^Ø£ØºØ³Ø·Ø³/i,
    /^Ø³Ø¨ØªÙØ¨Ø±/i,
    /^Ø£ÙØªÙØ¨Ø±/i,
    /^ÙÙÙÙØ¨Ø±/i,
    /^Ø¯ÙØ³ÙØ¨Ø±/i,
  ],
};

const matchDayPatterns$1i = {
  narrow: /^[Ø­ÙØ«Ø±Ø®Ø¬Ø³]/i,
  short: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  abbreviated: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ§Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/i,
};
const parseDayPatterns$1i = {
  narrow: [/^Ø­/i, /^Ù/i, /^Ø«/i, /^Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
  wide: [
    /^Ø§ÙØ£Ø­Ø¯/i,
    /^Ø§ÙØ§Ø«ÙÙÙ/i,
    /^Ø§ÙØ«ÙØ§Ø«Ø§Ø¡/i,
    /^Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡/i,
    /^Ø§ÙØ®ÙÙØ³/i,
    /^Ø§ÙØ¬ÙØ¹Ø©/i,
    /^Ø§ÙØ³Ø¨Øª/i,
  ],

  any: [/^Ø£Ø­/i, /^Ø§Ø«/i, /^Ø«/i, /^Ø£Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
};

const matchDayPeriodPatterns$1i = {
  narrow: /^(Øµ|Ù|ÙÙØªØµÙ Ø§ÙÙÙÙ|Ø§ÙØ¸ÙØ±|Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±|ÙÙ Ø§ÙØµØ¨Ø§Ø­|ÙÙ Ø§ÙÙØ³Ø§Ø¡|ÙÙ Ø§ÙÙÙÙ)/,
  any: /^(Øµ|Ù|ÙÙØªØµÙ Ø§ÙÙÙÙ|Ø§ÙØ¸ÙØ±|Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±|ÙÙ Ø§ÙØµØ¨Ø§Ø­|ÙÙ Ø§ÙÙØ³Ø§Ø¡|ÙÙ Ø§ÙÙÙÙ)/,
};
const parseDayPeriodPatterns$1i = {
  any: {
    am: /^Øµ/,
    pm: /^Ù/,
    midnight: /ÙÙØªØµÙ Ø§ÙÙÙÙ/,
    noon: /Ø§ÙØ¸ÙØ±/,
    afternoon: /Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±/,
    morning: /ÙÙ Ø§ÙØµØ¨Ø§Ø­/,
    evening: /ÙÙ Ø§ÙÙØ³Ø§Ø¡/,
    night: /ÙÙ Ø§ÙÙÙÙ/,
  },
};

(match$1i.match = {
  ordinalNumber: (0, _index$9B.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1i,
    parsePattern: parseOrdinalNumberPattern$1i,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index2$4n.buildMatchFn)({
    matchPatterns: matchEraPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1i,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$4n.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1i,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index2$4n.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1i,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$4n.buildMatchFn)({
    matchPatterns: matchDayPatterns$1i,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1i,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$4n.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1i,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1i,
    defaultParseWidth: "any",
  }),
});

ar.ar = void 0;
var _index$9A = formatDistance$2F;
var _index2$4m = formatLong$1r;
var _index3$2g = formatRelative$2F;
var _index4$1L = localize$1j;
var _index5$1C = match$1i;

/**
 * @category Locales
 * @summary Arabic locale (Modern Standard Arabic - Al-fussha).
 * @language Modern Standard Arabic
 * @iso-639-2 ara
 * @author Abdallah Hassan [@AbdallahAHO](https://github.com/AbdallahAHO)
 * @author Koussay Haj Kacem [@essana3](https://github.com/essana3)
 */
(ar.ar = {
  code: "ar",
  formatDistance: _index$9A.formatDistance,
  formatLong: _index2$4m.formatLong,
  formatRelative: _index3$2g.formatRelative,
  localize: _index4$1L.localize,
  match: _index5$1C.match,
  options: {
    weekStartsOn: 6 /* Saturday */,
    firstWeekContainsDate: 1,
  },
});

var arDZ = {};

var formatDistance$2D = {};

formatDistance$2D.formatDistance = void 0;

const formatDistanceLocale$1h = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø£ÙÙ ÙÙ Ø«Ø§ÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø«Ø§ÙØªÙÙ",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµÙ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§Ø¦Ù",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø¯ÙÙÙØªÙÙ",
    threeToTen: "{{count}} Ø¯ÙØ§Ø¦Ù",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø© ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø³Ø§Ø¹ØªÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨Ø§Ù",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©",
    two: "Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙÙ ÙØ§Ø­Ø¯",
    two: "ÙÙÙÙÙ",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
  },

  xWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹",
  },

  aboutXMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø´ÙØ±ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
  },

  xMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯",
    two: "Ø´ÙØ±ÙÙ",
    threeToTen: "{{count}} Ø£Ø´ÙØ±",
    other: "{{count}} Ø´ÙØ±",
  },

  aboutXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },

  xYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯",
    two: "Ø¹Ø§ÙÙÙ",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù",
    other: "{{count}} Ø¹Ø§Ù",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§Ù",
    two: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§ÙÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø£Ø¹ÙØ§Ù",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø¹Ø§Ù",
  },

  almostXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },
};

const formatDistance$2C = (token, count, options) => {
  options = options || {};

  const usageGroup = formatDistanceLocale$1h[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÙÙ Ø®ÙØ§Ù " + result;
    } else {
      return "ÙÙØ° " + result;
    }
  }

  return result;
};
formatDistance$2D.formatDistance = formatDistance$2C;

var formatLong$1q = {};

formatLong$1q.formatLong = void 0;
var _index$9z = buildFormatLongFn$1;

const dateFormats$1q = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$1q = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1q = {
  full: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  long: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1q.formatLong = {
  date: (0, _index$9z.buildFormatLongFn)({
    formats: dateFormats$1q,
    defaultWidth: "full",
  }),

  time: (0, _index$9z.buildFormatLongFn)({
    formats: timeFormats$1q,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9z.buildFormatLongFn)({
    formats: dateTimeFormats$1q,
    defaultWidth: "full",
  }),
});

var formatRelative$2D = {};

formatRelative$2D.formatRelative = void 0;

const formatRelativeLocale$1i = {
  lastWeek: "'Ø£Ø®Ø±' eeee 'Ø¹ÙØ¯' p",
  yesterday: "'Ø£ÙØ³ Ø¹ÙØ¯' p",
  today: "'Ø§ÙÙÙÙ Ø¹ÙØ¯' p",
  tomorrow: "'ØºØ¯Ø§Ù Ø¹ÙØ¯' p",
  nextWeek: "eeee 'Ø¹ÙØ¯' p",
  other: "P",
};

const formatRelative$2C = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$1i[token];
};
formatRelative$2D.formatRelative = formatRelative$2C;

var localize$1i = {};

localize$1i.localize = void 0;
var _index$9y = buildLocalizeFn$1;

const eraValues$1i = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1i = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1i = {
  narrow: ["Ø¬", "Ù", "Ù", "Ø£", "Ù", "Ø¬", "Ø¬", "Ø£", "Ø³", "Ø£", "Ù", "Ø¯"],
  abbreviated: [
    "Ø¬Ø§ÙÙ",
    "ÙÙÙÙ",
    "ÙØ§Ø±Ø³",
    "Ø£ÙØ±ÙÙ",
    "ÙØ§ÙÙ",
    "Ø¬ÙØ§ÙÙ",
    "Ø¬ÙÙÙ",
    "Ø£ÙØª",
    "Ø³Ø¨ØªÙ",
    "Ø£ÙØªÙ",
    "ÙÙÙÙ",
    "Ø¯ÙØ³Ù",
  ],

  wide: [
    "Ø¬Ø§ÙÙÙ",
    "ÙÙÙØ±Ù",
    "ÙØ§Ø±Ø³",
    "Ø£ÙØ±ÙÙ",
    "ÙØ§Ù",
    "Ø¬ÙØ§Ù",
    "Ø¬ÙÙÙÙØ©",
    "Ø£ÙØª",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],
};

const dayValues$1i = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙ", "Ø«ÙØ§", "Ø£Ø±Ø¨Ù", "Ø®ÙÙÙ", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ§Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1i = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
};
const formattingDayPeriodValues$12 = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1i = (dirtyNumber) => {
  return String(dirtyNumber);
};

(localize$1i.localize = {
  ordinalNumber: ordinalNumber$1i,

  era: (0, _index$9y.buildLocalizeFn)({
    values: eraValues$1i,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9y.buildLocalizeFn)({
    values: quarterValues$1i,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$9y.buildLocalizeFn)({
    values: monthValues$1i,
    defaultWidth: "wide",
  }),

  day: (0, _index$9y.buildLocalizeFn)({
    values: dayValues$1i,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9y.buildLocalizeFn)({
    values: dayPeriodValues$1i,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$12,
    defaultFormattingWidth: "wide",
  }),
});

var match$1h = {};

match$1h.match = void 0;
var _index$9x = buildMatchPatternFn$1;
var _index2$4l = buildMatchFn$1;

const matchOrdinalNumberPattern$1h = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1h = /\d+/i;

const matchEraPatterns$1h = {
  narrow: /^(Ù|Ø¨)/i,
  abbreviated: /^(Ù\.?\s?Ù\.?|Ù\.?\s?Ù\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯)/i,
};
const parseEraPatterns$1h = {
  any: [/^ÙØ¨Ù/i, /^Ø¨Ø¹Ø¯/i],
};

const matchQuarterPatterns$1h = {
  narrow: /^[1234]/i,
  abbreviated: /^Ø±[1234]/i,
  wide: /^Ø§ÙØ±Ø¨Ø¹ [1234]/i,
};
const parseQuarterPatterns$1h = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1h = {
  narrow: /^[Ø¬ÙÙØ£Ø³ÙØ¯]/i,
  abbreviated: /^(Ø¬Ø§Ù|ÙÙÙ|ÙØ§Ø±|Ø£ÙØ±|ÙØ§Ù|Ø¬ÙØ§|Ø¬ÙÙ|Ø£ÙØª|Ø³Ø¨Øª|Ø£ÙØª|ÙÙÙ|Ø¯ÙØ³)/i,
  wide: /^(Ø¬Ø§ÙÙÙ|ÙÙÙØ±Ù|ÙØ§Ø±Ø³|Ø£ÙØ±ÙÙ|ÙØ§Ù|Ø¬ÙØ§Ù|Ø¬ÙÙÙÙØ©|Ø£ÙØª|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/i,
};

const parseMonthPatterns$1h = {
  narrow: [
    /^Ø¬/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¬/i,
    /^Ø¬/i,
    /^Ø£/i,
    /^Ø³/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^Ø¬Ø§Ù/i,
    /^ÙÙÙ/i,
    /^ÙØ§Ø±/i,
    /^Ø£ÙØ±/i,
    /^ÙØ§Ù/i,
    /^Ø¬ÙØ§/i,
    /^Ø¬ÙÙ/i,
    /^Ø£ÙØª/i,
    /^Ø³Ø¨Øª/i,
    /^Ø£ÙØª/i,
    /^ÙÙÙ/i,
    /^Ø¯ÙØ³/i,
  ],
};

const matchDayPatterns$1h = {
  narrow: /^[Ø­ÙØ«Ø±Ø®Ø¬Ø³]/i,
  short: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  abbreviated: /^(Ø£Ø­Ø¯|Ø§Ø«Ù|Ø«ÙØ§|Ø£Ø±Ø¨|Ø®ÙÙ|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ§Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/i,
};
const parseDayPatterns$1h = {
  narrow: [/^Ø­/i, /^Ù/i, /^Ø«/i, /^Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
  wide: [
    /^Ø§ÙØ£Ø­Ø¯/i,
    /^Ø§ÙØ§Ø«ÙÙÙ/i,
    /^Ø§ÙØ«ÙØ§Ø«Ø§Ø¡/i,
    /^Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡/i,
    /^Ø§ÙØ®ÙÙØ³/i,
    /^Ø§ÙØ¬ÙØ¹Ø©/i,
    /^Ø§ÙØ³Ø¨Øª/i,
  ],

  any: [/^Ø£Ø­/i, /^Ø§Ø«/i, /^Ø«/i, /^Ø£Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
};

const matchDayPeriodPatterns$1h = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns$1h = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

(match$1h.match = {
  ordinalNumber: (0, _index$9x.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1h,
    parsePattern: parseOrdinalNumberPattern$1h,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index2$4l.buildMatchFn)({
    matchPatterns: matchEraPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1h,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$4l.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1h,
    defaultParseWidth: "any",
    valueCallback: (index) => Number(index) + 1,
  }),

  month: (0, _index2$4l.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1h,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$4l.buildMatchFn)({
    matchPatterns: matchDayPatterns$1h,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1h,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$4l.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1h,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1h,
    defaultParseWidth: "any",
  }),
});

arDZ.arDZ = void 0;
var _index$9w = formatDistance$2D;
var _index2$4k = formatLong$1q;
var _index3$2f = formatRelative$2D;
var _index4$1K = localize$1i;
var _index5$1B = match$1h;

/**
 * @category Locales
 * @summary Arabic locale (Algerian Arabic).
 * @language Algerian Arabic
 * @iso-639-2 ara
 * @author Badreddine Boumaza [@badre429](https://github.com/badre429)
 * @author Ahmed ElShahat [@elshahat](https://github.com/elshahat)
 */
(arDZ.arDZ = {
  code: "ar-DZ",
  formatDistance: _index$9w.formatDistance,
  formatLong: _index2$4k.formatLong,
  formatRelative: _index3$2f.formatRelative,
  localize: _index4$1K.localize,
  match: _index5$1B.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var arEG = {};

var formatDistance$2B = {};

formatDistance$2B.formatDistance = void 0;

const formatDistanceLocale$1g = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ©",
    two: "Ø«Ø§ÙÙØªÙÙ",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ©",
    two: "Ø¯ÙÙÙØªÙÙ",
    threeToTen: "{{count}} Ø¯ÙØ§ÙÙ",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø­ÙØ§ÙÙ Ø³Ø§Ø¹Ø©",
    two: "Ø­ÙØ§ÙÙ Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "Ø­ÙØ§ÙÙ {{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "Ø­ÙØ§ÙÙ {{count}} Ø³Ø§Ø¹Ø©",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø©",
    two: "Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙÙ",
    two: "ÙÙÙÙÙ",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø­ÙØ§ÙÙ Ø£Ø³Ø¨ÙØ¹",
    two: "Ø­ÙØ§ÙÙ Ø£Ø³Ø¨ÙØ¹ÙÙ",
    threeToTen: "Ø­ÙØ§ÙÙ {{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "Ø­ÙØ§ÙÙ {{count}} Ø£Ø³Ø¨ÙØ¹",
  },

  xWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹",
  },

  aboutXMonths: {
    one: "Ø­ÙØ§ÙÙ Ø´ÙØ±",
    two: "Ø­ÙØ§ÙÙ Ø´ÙØ±ÙÙ",
    threeToTen: "Ø­ÙØ§ÙÙ {{count}} Ø£Ø´ÙØ±",
    other: "Ø­ÙØ§ÙÙ {{count}} Ø´ÙØ±",
  },

  xMonths: {
    one: "Ø´ÙØ±",
    two: "Ø´ÙØ±ÙÙ",
    threeToTen: "{{count}} Ø£Ø´ÙØ±",
    other: "{{count}} Ø´ÙØ±",
  },

  aboutXYears: {
    one: "Ø­ÙØ§ÙÙ Ø³ÙØ©",
    two: "Ø­ÙØ§ÙÙ Ø³ÙØªÙÙ",
    threeToTen: "Ø­ÙØ§ÙÙ {{count}} Ø³ÙÙÙ",
    other: "Ø­ÙØ§ÙÙ {{count}} Ø³ÙØ©",
  },

  xYears: {
    one: "Ø¹Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù",
    other: "{{count}} Ø¹Ø§Ù",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø³ÙØ©",
    two: "Ø£ÙØ«Ø± ÙÙ Ø³ÙØªÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø³ÙÙÙ",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø³ÙØ©",
  },

  almostXYears: {
    one: "Ø¹Ø§Ù ØªÙØ±ÙØ¨ÙØ§",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨ÙØ§",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨ÙØ§",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨ÙØ§",
  },
};

const formatDistance$2A = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$1g[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return `ÙÙ Ø®ÙØ§Ù ${result}`;
    } else {
      return `ÙÙØ° ${result}`;
    }
  }

  return result;
};
formatDistance$2B.formatDistance = formatDistance$2A;

var formatLong$1p = {};

formatLong$1p.formatLong = void 0;
var _index$9v = buildFormatLongFn$1;

const dateFormats$1p = {
  full: "EEEEØ do MMMM y",
  long: "do MMMM y",
  medium: "dd/MMM/y",
  short: "d/MM/y",
};

const timeFormats$1p = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1p = {
  full: "{{date}} 'Ø§ÙØ³Ø§Ø¹Ø©' {{time}}",
  long: "{{date}} 'Ø§ÙØ³Ø§Ø¹Ø©' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1p.formatLong = {
  date: (0, _index$9v.buildFormatLongFn)({
    formats: dateFormats$1p,
    defaultWidth: "full",
  }),

  time: (0, _index$9v.buildFormatLongFn)({
    formats: timeFormats$1p,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9v.buildFormatLongFn)({
    formats: dateTimeFormats$1p,
    defaultWidth: "full",
  }),
});

var formatRelative$2B = {};

formatRelative$2B.formatRelative = void 0;

const formatRelativeLocale$1h = {
  lastWeek: "eeee 'Ø§ÙÙÙ Ø¬Ø§Ù Ø§ÙØ³Ø§Ø¹Ø©' p",
  yesterday: "'Ø¥ÙØ¨Ø§Ø±Ø­ Ø§ÙØ³Ø§Ø¹Ø©' p",
  today: "'Ø§ÙÙÙØ§Ø±Ø¯Ø© Ø§ÙØ³Ø§Ø¹Ø©' p",
  tomorrow: "'Ø¨ÙØ±Ø© Ø§ÙØ³Ø§Ø¹Ø©' p",
  nextWeek: "eeee 'Ø§ÙØ³Ø§Ø¹Ø©' p",
  other: "P",
};

const formatRelative$2A = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$1h[token];
formatRelative$2B.formatRelative = formatRelative$2A;

var localize$1h = {};

localize$1h.localize = void 0;
var _index$9u = buildLocalizeFn$1;

const eraValues$1h = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù", "Ø¨.Ù"],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1h = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1h = {
  narrow: ["Ù", "Ù", "Ù", "Ø£", "Ù", "Ù", "Ù", "Ø£", "Ø³", "Ø£", "Ù", "Ø¯"],
  abbreviated: [
    "ÙÙØ§",
    "ÙØ¨Ø±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙ",
    "ÙÙÙÙ",
    "Ø£ØºØ³Ù",
    "Ø³Ø¨ØªÙ",
    "Ø£ÙØªÙ",
    "ÙÙÙÙ",
    "Ø¯ÙØ³Ù",
  ],

  wide: [
    "ÙÙØ§ÙØ±",
    "ÙØ¨Ø±Ø§ÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙÙ",
    "ÙÙÙÙÙ",
    "Ø£ØºØ³Ø·Ø³",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],
};

const dayValues$1h = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],

  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ§Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1h = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ù",
    night: "ÙÙÙØ§Ù",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±Ø§Ù",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ù",
    night: "ÙÙÙØ§Ù",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±Ø§Ù",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ù",
    night: "ÙÙÙØ§Ù",
  },
};

const formattingDayPeriodValues$11 = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±Ø§Ù",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø¸ÙØ±Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1h = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$1h.localize = {
  ordinalNumber: ordinalNumber$1h,

  era: (0, _index$9u.buildLocalizeFn)({
    values: eraValues$1h,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9u.buildLocalizeFn)({
    values: quarterValues$1h,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9u.buildLocalizeFn)({
    values: monthValues$1h,
    defaultWidth: "wide",
  }),

  day: (0, _index$9u.buildLocalizeFn)({
    values: dayValues$1h,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9u.buildLocalizeFn)({
    values: dayPeriodValues$1h,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$11,
    defaultFormattingWidth: "wide",
  }),
});

var match$1g = {};

match$1g.match = void 0;

var _index$9t = buildMatchFn$1;
var _index2$4j = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1g = /^(\d+)/;
const parseOrdinalNumberPattern$1g = /\d+/i;

const matchEraPatterns$1g = {
  narrow: /^(Ù|Ø¨)/g,
  abbreviated: /^(Ù.Ù|Ø¨.Ù)/g,
  wide: /^(ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯)/g,
};
const parseEraPatterns$1g = {
  any: [/^Ù/g, /^Ø¨/g],
};
const matchQuarterPatterns$1g = {
  narrow: /^[1234]/,
  abbreviated: /^Ø±[1234]/,
  wide: /^Ø§ÙØ±Ø¨Ø¹ (Ø§ÙØ£ÙÙ|Ø§ÙØ«Ø§ÙÙ|Ø§ÙØ«Ø§ÙØ«|Ø§ÙØ±Ø§Ø¨Ø¹)/,
};
const parseQuarterPatterns$1g = {
  wide: [/Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ/, /Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ/, /Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«/, /Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹/],

  any: [/1/, /2/, /3/, /4/],
};

const matchMonthPatterns$1g = {
  narrow: /^(Ù|Ù|Ù|Ø£|Ø³|Ù|Ø¯)/,
  abbreviated: /^(ÙÙØ§|ÙØ¨Ø±|ÙØ§Ø±Ø³|Ø£Ø¨Ø±ÙÙ|ÙØ§ÙÙ|ÙÙÙÙ|ÙÙÙÙ|Ø£ØºØ³Ù|Ø³Ø¨ØªÙ|Ø£ÙØªÙ|ÙÙÙÙ|Ø¯ÙØ³Ù)/,
  wide: /^(ÙÙØ§ÙØ±|ÙØ¨Ø±Ø§ÙØ±|ÙØ§Ø±Ø³|Ø£Ø¨Ø±ÙÙ|ÙØ§ÙÙ|ÙÙÙÙÙ|ÙÙÙÙÙ|Ø£ØºØ³Ø·Ø³|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/,
};
const parseMonthPatterns$1g = {
  narrow: [
    /^Ù/,
    /^Ù/,
    /^Ù/,
    /^Ø£/,
    /^Ù/,
    /^Ù/,
    /^Ù/,
    /^Ø£/,
    /^Ø³/,
    /^Ø£/,
    /^Ù/,
    /^Ø¯/,
  ],

  any: [
    /^ÙÙØ§/,
    /^ÙØ¨Ø±/,
    /^ÙØ§Ø±Ø³/,
    /^Ø£Ø¨Ø±ÙÙ/,
    /^ÙØ§ÙÙ/,
    /^ÙÙÙ/,
    /^ÙÙÙ/,
    /^Ø£ØºØ³/,
    /^Ø³Ø¨Øª/,
    /^Ø£ÙØª/,
    /^ÙÙÙ/,
    /^Ø¯ÙØ³/,
  ],
};

const matchDayPatterns$1g = {
  narrow: /^(Ø­|Ù|Ø«|Ø±|Ø®|Ø¬|Ø³)/,
  short: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/,
  abbreviated: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ§Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/,
};
const parseDayPatterns$1g = {
  narrow: [/^Ø­/, /^Ù/, /^Ø«/, /^Ø±/, /^Ø®/, /^Ø¬/, /^Ø³/],
  any: [/Ø£Ø­Ø¯/, /Ø§Ø«ÙÙÙ/, /Ø«ÙØ§Ø«Ø§Ø¡/, /Ø£Ø±Ø¨Ø¹Ø§Ø¡/, /Ø®ÙÙØ³/, /Ø¬ÙØ¹Ø©/, /Ø³Ø¨Øª/],
};

const matchDayPeriodPatterns$1g = {
  narrow: /^(Øµ|Ù|Ù|Ø¸|ÙÙ Ø§ÙØµØ¨Ø§Ø­|Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±|ÙÙ Ø§ÙÙØ³Ø§Ø¡|ÙÙ Ø§ÙÙÙÙ)/,
  abbreviated: /^(Øµ|Ù|ÙØµÙ Ø§ÙÙÙÙ|Ø¸ÙØ±Ø§Ù|ÙÙ Ø§ÙØµØ¨Ø§Ø­|Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±|ÙÙ Ø§ÙÙØ³Ø§Ø¡|ÙÙ Ø§ÙÙÙÙ)/,
  wide: /^(Øµ|Ù|ÙØµÙ Ø§ÙÙÙÙ|ÙÙ Ø§ÙØµØ¨Ø§Ø­|Ø¸ÙØ±Ø§Ù|Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±|ÙÙ Ø§ÙÙØ³Ø§Ø¡|ÙÙ Ø§ÙÙÙÙ)/,
  any: /^(Øµ|Ù|ØµØ¨Ø§Ø­|Ø¸ÙØ±|ÙØ³Ø§Ø¡|ÙÙÙ)/,
};
const parseDayPeriodPatterns$1g = {
  any: {
    am: /^Øµ/,
    pm: /^Ù/,
    midnight: /^Ù/,
    noon: /^Ø¸/,
    morning: /^Øµ/,
    afternoon: /^Ø¨Ø¹Ø¯/,
    evening: /^Ù/,
    night: /^Ù/,
  },
};

(match$1g.match = {
  ordinalNumber: (0, _index2$4j.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1g,
    parsePattern: parseOrdinalNumberPattern$1g,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index$9t.buildMatchFn)({
    matchPatterns: matchEraPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1g,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$9t.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1g,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$9t.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1g,
    defaultParseWidth: "any",
  }),

  day: (0, _index$9t.buildMatchFn)({
    matchPatterns: matchDayPatterns$1g,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1g,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$9t.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1g,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1g,
    defaultParseWidth: "any",
  }),
});

arEG.arEG = void 0;
var _index$9s = formatDistance$2B;
var _index2$4i = formatLong$1p;
var _index3$2e = formatRelative$2B;
var _index4$1J = localize$1h;
var _index5$1A = match$1g;

/**
 * @category Locales
 * @summary Arabic locale (Egypt).
 * @language Arabic
 * @iso-639-2 ara
 * @author AbdAllah AbdElFattah [@AbdAllahAbdElFattah13](https://github.com/AbdAllahAbdElFattah13)
 */
(arEG.arEG = {
  code: "ar-EG",
  formatDistance: _index$9s.formatDistance,
  formatLong: _index2$4i.formatLong,
  formatRelative: _index3$2e.formatRelative,
  localize: _index4$1J.localize,
  match: _index5$1A.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var arMA = {};

var formatDistance$2z = {};

formatDistance$2z.formatDistance = void 0;

const formatDistanceLocale$1f = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø£ÙÙ ÙÙ Ø«Ø§ÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø«Ø§ÙØªÙÙ",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµÙ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§Ø¦Ù",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø¯ÙÙÙØªÙÙ",
    threeToTen: "{{count}} Ø¯ÙØ§Ø¦Ù",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø© ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø³Ø§Ø¹ØªÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨Ø§Ù",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©",
    two: "Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙÙ ÙØ§Ø­Ø¯",
    two: "ÙÙÙÙÙ",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
  },

  xWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹",
  },

  aboutXMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø´ÙØ±ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
  },

  xMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯",
    two: "Ø´ÙØ±ÙÙ",
    threeToTen: "{{count}} Ø£Ø´ÙØ±",
    other: "{{count}} Ø´ÙØ±",
  },

  aboutXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },

  xYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯",
    two: "Ø¹Ø§ÙÙÙ",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù",
    other: "{{count}} Ø¹Ø§Ù",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§Ù",
    two: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§ÙÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø£Ø¹ÙØ§Ù",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø¹Ø§Ù",
  },

  almostXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },
};

const formatDistance$2y = (token, count, options) => {
  options = options || {};

  const usageGroup = formatDistanceLocale$1f[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÙÙ Ø®ÙØ§Ù " + result;
    } else {
      return "ÙÙØ° " + result;
    }
  }

  return result;
};
formatDistance$2z.formatDistance = formatDistance$2y;

var formatLong$1o = {};

formatLong$1o.formatLong = void 0;
var _index$9r = buildFormatLongFn$1;

const dateFormats$1o = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$1o = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1o = {
  full: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  long: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1o.formatLong = {
  date: (0, _index$9r.buildFormatLongFn)({
    formats: dateFormats$1o,
    defaultWidth: "full",
  }),

  time: (0, _index$9r.buildFormatLongFn)({
    formats: timeFormats$1o,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9r.buildFormatLongFn)({
    formats: dateTimeFormats$1o,
    defaultWidth: "full",
  }),
});

var formatRelative$2z = {};

formatRelative$2z.formatRelative = void 0;

const formatRelativeLocale$1g = {
  lastWeek: "'Ø£Ø®Ø±' eeee 'Ø¹ÙØ¯' p",
  yesterday: "'Ø£ÙØ³ Ø¹ÙØ¯' p",
  today: "'Ø§ÙÙÙÙ Ø¹ÙØ¯' p",
  tomorrow: "'ØºØ¯Ø§Ù Ø¹ÙØ¯' p",
  nextWeek: "eeee 'Ø¹ÙØ¯' p",
  other: "P",
};

const formatRelative$2y = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$1g[token];
};
formatRelative$2z.formatRelative = formatRelative$2y;

var localize$1g = {};

localize$1g.localize = void 0;
var _index$9q = buildLocalizeFn$1;

const eraValues$1g = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1g = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1g = {
  narrow: ["Ù", "Ù", "Ù", "Ø£", "Ù", "Ù", "Ù", "Øº", "Ø´", "Ø£", "Ù", "Ø¯"],
  abbreviated: [
    "ÙÙØ§",
    "ÙØ¨Ø±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§Ù",
    "ÙÙÙÙ",
    "ÙÙÙÙ",
    "ØºØ´Øª",
    "Ø´ØªÙÙ",
    "Ø£ÙØªÙ",
    "ÙÙÙÙ",
    "Ø¯Ø¬ÙÙ",
  ],

  wide: [
    "ÙÙØ§ÙØ±",
    "ÙØ¨Ø±Ø§ÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§Ù",
    "ÙÙÙÙÙ",
    "ÙÙÙÙÙØ²",
    "ØºØ´Øª",
    "Ø´ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙØ¨Ø±",
    "Ø¯Ø¬ÙØ¨Ø±",
  ],
};

const dayValues$1g = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙ", "Ø«ÙØ§", "Ø£Ø±Ø¨Ù", "Ø®ÙÙÙ", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ¥Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1g = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
};
const formattingDayPeriodValues$10 = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1g = (dirtyNumber) => {
  return String(dirtyNumber);
};

(localize$1g.localize = {
  ordinalNumber: ordinalNumber$1g,

  era: (0, _index$9q.buildLocalizeFn)({
    values: eraValues$1g,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9q.buildLocalizeFn)({
    values: quarterValues$1g,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$9q.buildLocalizeFn)({
    values: monthValues$1g,
    defaultWidth: "wide",
  }),

  day: (0, _index$9q.buildLocalizeFn)({
    values: dayValues$1g,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9q.buildLocalizeFn)({
    values: dayPeriodValues$1g,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$10,
    defaultFormattingWidth: "wide",
  }),
});

var match$1f = {};

match$1f.match = void 0;
var _index$9p = buildMatchPatternFn$1;
var _index2$4h = buildMatchFn$1;

const matchOrdinalNumberPattern$1f = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1f = /\d+/i;

const matchEraPatterns$1f = {
  narrow: /^(Ù|Ø¨)/i,
  abbreviated: /^(Ù\.?\s?Ù\.?|Ù\.?\s?Ù\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯)/i,
};
const parseEraPatterns$1f = {
  any: [/^ÙØ¨Ù/i, /^Ø¨Ø¹Ø¯/i],
};

const matchQuarterPatterns$1f = {
  narrow: /^[1234]/i,
  abbreviated: /^Ø±[1234]/i,
  wide: /^Ø§ÙØ±Ø¨Ø¹ [1234]/i,
};
const parseQuarterPatterns$1f = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1f = {
  narrow: /^[ÙÙÙØ£ÙØ³ÙØ¯]/i,
  abbreviated: /^(ÙÙ|Ù|ÙØ§Ø±|Ø£Ø¨|ÙØ§Ù|ÙÙÙ|ÙÙÙ|ØºØ´|Ø´Øª|Ø£Ù|Ù|Ø¯)/i,
  wide: /^(ÙÙ|Ù|ÙØ§Ø±|Ø£Ø¨|ÙØ§Ù|ÙÙÙ|ÙÙÙ|ØºØ´|Ø´Øª|Ø£Ù|Ù|Ø¯)/i,
};
const parseMonthPatterns$1f = {
  narrow: [
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Øº/i,
    /^Ø´/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^ÙÙ/i,
    /^ÙØ¨/i,
    /^ÙØ§Ø±/i,
    /^Ø£Ø¨/i,
    /^ÙØ§Ù/i,
    /^ÙÙÙ/i,
    /^ÙÙÙ/i,
    /^ØºØ´Øª/i,
    /^Ø´/i,
    /^Ø£Ù/i,
    /^Ù/i,
    /^Ø¯/i,
  ],
};

const matchDayPatterns$1f = {
  narrow: /^[Ø­ÙØ«Ø±Ø®Ø¬Ø³]/i,
  short: /^(Ø£Ø­Ø¯|Ø¥Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  abbreviated: /^(Ø£Ø­Ø¯|Ø¥Ø«Ù|Ø«ÙØ§|Ø£Ø±Ø¨|Ø®ÙÙ|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ¥Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/i,
};
const parseDayPatterns$1f = {
  narrow: [/^Ø­/i, /^Ù/i, /^Ø«/i, /^Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
  wide: [
    /^Ø§ÙØ£Ø­Ø¯/i,
    /^Ø§ÙØ¥Ø«ÙÙÙ/i,
    /^Ø§ÙØ«ÙØ§Ø«Ø§Ø¡/i,
    /^Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡/i,
    /^Ø§ÙØ®ÙÙØ³/i,
    /^Ø§ÙØ¬ÙØ¹Ø©/i,
    /^Ø§ÙØ³Ø¨Øª/i,
  ],

  any: [/^Ø£Ø­/i, /^Ø¥Ø«/i, /^Ø«/i, /^Ø£Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
};

const matchDayPeriodPatterns$1f = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns$1f = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

(match$1f.match = {
  ordinalNumber: (0, _index$9p.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1f,
    parsePattern: parseOrdinalNumberPattern$1f,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index2$4h.buildMatchFn)({
    matchPatterns: matchEraPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1f,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$4h.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1f,
    defaultParseWidth: "any",
    valueCallback: (index) => Number(index) + 1,
  }),

  month: (0, _index2$4h.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1f,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$4h.buildMatchFn)({
    matchPatterns: matchDayPatterns$1f,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1f,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$4h.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1f,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1f,
    defaultParseWidth: "any",
  }),
});

arMA.arMA = void 0;
var _index$9o = formatDistance$2z;
var _index2$4g = formatLong$1o;
var _index3$2d = formatRelative$2z;
var _index4$1I = localize$1g;
var _index5$1z = match$1f;

/**
 * @category Locales
 * @summary Arabic locale (Moroccan Arabic).
 * @language Moroccan Arabic
 * @iso-639-2 ara
 * @author Achraf Rrami [@rramiachraf](https://github.com/rramiachraf)
 */
(arMA.arMA = {
  code: "ar-MA",
  formatDistance: _index$9o.formatDistance,
  formatLong: _index2$4g.formatLong,
  formatRelative: _index3$2d.formatRelative,
  localize: _index4$1I.localize,
  match: _index5$1z.match,
  options: {
    // Monday is 1
    weekStartsOn: 1,
    firstWeekContainsDate: 1,
  },
});

var arSA = {};

var formatDistance$2x = {};

formatDistance$2x.formatDistance = void 0;

const formatDistanceLocale$1e = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø£ÙÙ ÙÙ Ø«Ø§ÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø«Ø§ÙØªÙÙ",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµÙ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§Ø¦Ù",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©",
    two: "Ø¯ÙÙÙØªÙÙ",
    threeToTen: "{{count}} Ø¯ÙØ§Ø¦Ù",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø© ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø³Ø§Ø¹ØªÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨Ø§Ù",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©",
    two: "Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "{{count}} Ø³Ø§Ø¹Ø§Øª",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙÙ ÙØ§Ø­Ø¯",
    two: "ÙÙÙÙÙ",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹ ØªÙØ±ÙØ¨Ø§Ù",
  },

  xWeeks: {
    one: "Ø£Ø³Ø¨ÙØ¹ ÙØ§Ø­Ø¯",
    two: "Ø£Ø³Ø¨ÙØ¹ÙÙ",
    threeToTen: "{{count}} Ø£Ø³Ø§Ø¨ÙØ¹",
    other: "{{count}} Ø£Ø³Ø¨ÙØ¹",
  },

  aboutXMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø´ÙØ±ÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø´ÙØ± ØªÙØ±ÙØ¨Ø§Ù",
  },

  xMonths: {
    one: "Ø´ÙØ± ÙØ§Ø­Ø¯",
    two: "Ø´ÙØ±ÙÙ",
    threeToTen: "{{count}} Ø£Ø´ÙØ±",
    other: "{{count}} Ø´ÙØ±",
  },

  aboutXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },

  xYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯",
    two: "Ø¹Ø§ÙÙÙ",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù",
    other: "{{count}} Ø¹Ø§Ù",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§Ù",
    two: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§ÙÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø£Ø¹ÙØ§Ù",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø¹Ø§Ù",
  },

  almostXYears: {
    one: "Ø¹Ø§Ù ÙØ§Ø­Ø¯ ØªÙØ±ÙØ¨Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨Ø§Ù",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨Ø§Ù",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨Ø§Ù",
  },
};

const formatDistance$2w = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$1e[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÙÙ Ø®ÙØ§Ù " + result;
    } else {
      return "ÙÙØ° " + result;
    }
  }

  return result;
};
formatDistance$2x.formatDistance = formatDistance$2w;

var formatLong$1n = {};

formatLong$1n.formatLong = void 0;
var _index$9n = buildFormatLongFn$1;

const dateFormats$1n = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$1n = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1n = {
  full: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  long: "{{date}} 'Ø¹ÙØ¯' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1n.formatLong = {
  date: (0, _index$9n.buildFormatLongFn)({
    formats: dateFormats$1n,
    defaultWidth: "full",
  }),

  time: (0, _index$9n.buildFormatLongFn)({
    formats: timeFormats$1n,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9n.buildFormatLongFn)({
    formats: dateTimeFormats$1n,
    defaultWidth: "full",
  }),
});

var formatRelative$2x = {};

formatRelative$2x.formatRelative = void 0;

const formatRelativeLocale$1f = {
  lastWeek: "'Ø£Ø®Ø±' eeee 'Ø¹ÙØ¯' p",
  yesterday: "'Ø£ÙØ³ Ø¹ÙØ¯' p",
  today: "'Ø§ÙÙÙÙ Ø¹ÙØ¯' p",
  tomorrow: "'ØºØ¯Ø§Ù Ø¹ÙØ¯' p",
  nextWeek: "eeee 'Ø¹ÙØ¯' p",
  other: "P",
};

const formatRelative$2w = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$1f[token];
formatRelative$2x.formatRelative = formatRelative$2w;

var localize$1f = {};

localize$1f.localize = void 0;
var _index$9m = buildLocalizeFn$1;

const eraValues$1f = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1f = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1f = {
  narrow: ["Ù", "Ù", "Ù", "Ø£", "Ù", "Ù", "Ù", "Ø£", "Ø³", "Ø£", "Ù", "Ø¯"],
  abbreviated: [
    "ÙÙØ§",
    "ÙØ¨Ø±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙ",
    "ÙÙÙÙ",
    "Ø£ØºØ³Ù",
    "Ø³Ø¨ØªÙ",
    "Ø£ÙØªÙ",
    "ÙÙÙÙ",
    "Ø¯ÙØ³Ù",
  ],

  wide: [
    "ÙÙØ§ÙØ±",
    "ÙØ¨Ø±Ø§ÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø£Ø¨Ø±ÙÙ",
    "ÙØ§ÙÙ",
    "ÙÙÙÙÙ",
    "ÙÙÙÙÙ",
    "Ø£ØºØ³Ø·Ø³",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],
};

const dayValues$1f = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙ", "Ø«ÙØ§", "Ø£Ø±Ø¨Ù", "Ø®ÙÙÙ", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ§Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1f = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙØ³Ø§Ø¡Ø§Ù",
    night: "ÙÙÙØ§Ù",
  },
};
const formattingDayPeriodValues$$ = {
  narrow: {
    am: "Øµ",
    pm: "Ù",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ù",
    midnight: "ÙØµÙ Ø§ÙÙÙÙ",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø§Ø­Ø§Ù",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙØ¸ÙÙØ±",
    evening: "ÙÙ Ø§ÙÙØ³Ø§Ø¡",
    night: "ÙÙ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1f = (dirtyNumber) => {
  return String(dirtyNumber);
};

(localize$1f.localize = {
  ordinalNumber: ordinalNumber$1f,

  era: (0, _index$9m.buildLocalizeFn)({
    values: eraValues$1f,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9m.buildLocalizeFn)({
    values: quarterValues$1f,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9m.buildLocalizeFn)({
    values: monthValues$1f,
    defaultWidth: "wide",
  }),

  day: (0, _index$9m.buildLocalizeFn)({
    values: dayValues$1f,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9m.buildLocalizeFn)({
    values: dayPeriodValues$1f,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$$,
    defaultFormattingWidth: "wide",
  }),
});

var match$1e = {};

match$1e.match = void 0;

var _index$9l = buildMatchFn$1;
var _index2$4f = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1e = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1e = /\d+/i;

const matchEraPatterns$1e = {
  narrow: /^(Ù|Ø¨)/i,
  abbreviated: /^(Ù\.?\s?Ù\.?|Ù\.?\s?Ù\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯|Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯)/i,
};
const parseEraPatterns$1e = {
  any: [/^ÙØ¨Ù/i, /^Ø¨Ø¹Ø¯/i],
};

const matchQuarterPatterns$1e = {
  narrow: /^[1234]/i,
  abbreviated: /^Ø±[1234]/i,
  wide: /^Ø§ÙØ±Ø¨Ø¹ [1234]/i,
};
const parseQuarterPatterns$1e = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1e = {
  narrow: /^[ÙÙÙØ£ÙØ³ÙØ¯]/i,
  abbreviated: /^(ÙÙ|Ù|ÙØ§Ø±|Ø£Ø¨|ÙØ§Ù|ÙÙÙ|ÙÙÙ|Ø£Øº|Ø³|Ø£Ù|Ù|Ø¯)/i,
  wide: /^(ÙÙ|Ù|ÙØ§Ø±|Ø£Ø¨|ÙØ§Ù|ÙÙÙ|ÙÙÙ|Ø£Øº|Ø³|Ø£Ù|Ù|Ø¯)/i,
};
const parseMonthPatterns$1e = {
  narrow: [
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ø³/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^ÙÙ/i,
    /^Ù/i,
    /^ÙØ§Ø±/i,
    /^Ø£Ø¨/i,
    /^ÙØ§Ù/i,
    /^ÙÙÙ/i,
    /^ÙÙÙ/i,
    /^Ø£Øº/i,
    /^Ø³/i,
    /^Ø£Ù/i,
    /^Ù/i,
    /^Ø¯/i,
  ],
};

const matchDayPatterns$1e = {
  narrow: /^[Ø­ÙØ«Ø±Ø®Ø¬Ø³]/i,
  short: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  abbreviated: /^(Ø£Ø­Ø¯|Ø§Ø«Ù|Ø«ÙØ§|Ø£Ø±Ø¨|Ø®ÙÙ|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ§Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/i,
};
const parseDayPatterns$1e = {
  narrow: [/^Ø­/i, /^Ù/i, /^Ø«/i, /^Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
  wide: [
    /^Ø§ÙØ£Ø­Ø¯/i,
    /^Ø§ÙØ§Ø«ÙÙÙ/i,
    /^Ø§ÙØ«ÙØ§Ø«Ø§Ø¡/i,
    /^Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡/i,
    /^Ø§ÙØ®ÙÙØ³/i,
    /^Ø§ÙØ¬ÙØ¹Ø©/i,
    /^Ø§ÙØ³Ø¨Øª/i,
  ],

  any: [/^Ø£Ø­/i, /^Ø§Ø«/i, /^Ø«/i, /^Ø£Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
};

const matchDayPeriodPatterns$1e = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns$1e = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

(match$1e.match = {
  ordinalNumber: (0, _index2$4f.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1e,
    parsePattern: parseOrdinalNumberPattern$1e,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$9l.buildMatchFn)({
    matchPatterns: matchEraPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1e,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$9l.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1e,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$9l.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1e,
    defaultParseWidth: "any",
  }),

  day: (0, _index$9l.buildMatchFn)({
    matchPatterns: matchDayPatterns$1e,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1e,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$9l.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1e,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1e,
    defaultParseWidth: "any",
  }),
});

arSA.arSA = void 0;
var _index$9k = formatDistance$2x;
var _index2$4e = formatLong$1n;
var _index3$2c = formatRelative$2x;
var _index4$1H = localize$1f;
var _index5$1y = match$1e;

/**
 * @category Locales
 * @summary Arabic locale (Sauid Arabic).
 * @language Arabic
 * @iso-639-2 ara
 * @author Dhaifallah Alwadani [@dalwadani](https://github.com/dalwadani)
 */
(arSA.arSA = {
  code: "ar-SA",
  formatDistance: _index$9k.formatDistance,
  formatLong: _index2$4e.formatLong,
  formatRelative: _index3$2c.formatRelative,
  localize: _index4$1H.localize,
  match: _index5$1y.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var arTN = {};

var formatDistance$2v = {};

formatDistance$2v.formatDistance = void 0;

const formatDistanceLocale$1d = {
  lessThanXSeconds: {
    one: "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø²ÙØ² Ø«ÙØ§ÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø«ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø«Ø§ÙÙØ©",
  },

  xSeconds: {
    one: "Ø«Ø§ÙÙØ©",
    two: "Ø²ÙØ² Ø«ÙØ§ÙÙ",
    threeToTen: "{{count}} Ø«ÙØ§ÙÙ",
    other: "{{count}} Ø«Ø§ÙÙØ©",
  },

  halfAMinute: "ÙØµ Ø¯ÙÙÙØ©",

  lessThanXMinutes: {
    one: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©",
    two: "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØªÙÙ",
    threeToTen: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙØ§ÙÙ",
    other: "Ø£ÙÙ ÙÙ {{count}} Ø¯ÙÙÙØ©",
  },

  xMinutes: {
    one: "Ø¯ÙÙÙØ©",
    two: "Ø¯ÙÙÙØªÙÙ",
    threeToTen: "{{count}} Ø¯ÙØ§ÙÙ",
    other: "{{count}} Ø¯ÙÙÙØ©",
  },

  aboutXHours: {
    one: "Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨",
    two: "Ø³Ø§Ø¹ØªÙÙ ØªÙØ±ÙØ¨",
    threeToTen: "{{count}} Ø³ÙØ§ÙØ¹ ØªÙØ±ÙØ¨",
    other: "{{count}} Ø³Ø§Ø¹Ø© ØªÙØ±ÙØ¨",
  },

  xHours: {
    one: "Ø³Ø§Ø¹Ø©",
    two: "Ø³Ø§Ø¹ØªÙÙ",
    threeToTen: "{{count}} Ø³ÙØ§ÙØ¹",
    other: "{{count}} Ø³Ø§Ø¹Ø©",
  },

  xDays: {
    one: "ÙÙØ§Ø±",
    two: "ÙÙØ§Ø±ÙÙ",
    threeToTen: "{{count}} Ø£ÙØ§Ù",
    other: "{{count}} ÙÙÙ",
  },

  aboutXWeeks: {
    one: "Ø¬ÙØ¹Ø© ØªÙØ±ÙØ¨",
    two: "Ø¬ÙØ¹ØªÙÙ ØªÙØ±ÙØ¨",
    threeToTen: "{{count}} Ø¬ÙØ§Ø¹ ØªÙØ±ÙØ¨",
    other: "{{count}} Ø¬ÙØ¹Ø© ØªÙØ±ÙØ¨",
  },

  xWeeks: {
    one: "Ø¬ÙØ¹Ø©",
    two: "Ø¬ÙØ¹ØªÙÙ",
    threeToTen: "{{count}} Ø¬ÙØ§Ø¹",
    other: "{{count}} Ø¬ÙØ¹Ø©",
  },

  aboutXMonths: {
    one: "Ø´ÙØ± ØªÙØ±ÙØ¨",
    two: "Ø´ÙØ±ÙÙ ØªÙØ±ÙØ¨",
    threeToTen: "{{count}} Ø£Ø´ÙØ±Ø© ØªÙØ±ÙØ¨",
    other: "{{count}} Ø´ÙØ± ØªÙØ±ÙØ¨",
  },

  xMonths: {
    one: "Ø´ÙØ±",
    two: "Ø´ÙØ±ÙÙ",
    threeToTen: "{{count}} Ø£Ø´ÙØ±Ø©",
    other: "{{count}} Ø´ÙØ±",
  },

  aboutXYears: {
    one: "Ø¹Ø§Ù ØªÙØ±ÙØ¨",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨",
  },

  xYears: {
    one: "Ø¹Ø§Ù",
    two: "Ø¹Ø§ÙÙÙ",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù",
    other: "{{count}} Ø¹Ø§Ù",
  },

  overXYears: {
    one: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§Ù",
    two: "Ø£ÙØ«Ø± ÙÙ Ø¹Ø§ÙÙÙ",
    threeToTen: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø£Ø¹ÙØ§Ù",
    other: "Ø£ÙØ«Ø± ÙÙ {{count}} Ø¹Ø§Ù",
  },

  almostXYears: {
    one: "Ø¹Ø§Ù ØªÙØ±ÙØ¨",
    two: "Ø¹Ø§ÙÙÙ ØªÙØ±ÙØ¨",
    threeToTen: "{{count}} Ø£Ø¹ÙØ§Ù ØªÙØ±ÙØ¨",
    other: "{{count}} Ø¹Ø§Ù ØªÙØ±ÙØ¨",
  },
};

const formatDistance$2u = (token, count, options) => {
  const usageGroup = formatDistanceLocale$1d[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÙÙ " + result;
    } else {
      return "Ø¹ÙØ¯Ù " + result;
    }
  }

  return result;
};
formatDistance$2v.formatDistance = formatDistance$2u;

var formatLong$1m = {};

formatLong$1m.formatLong = void 0;
var _index$9j = buildFormatLongFn$1;

const dateFormats$1m = {
  full: "EEEEØ do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy",
};

const timeFormats$1m = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1m = {
  full: "{{date}} 'ÙØ¹' {{time}}",
  long: "{{date}} 'ÙØ¹' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1m.formatLong = {
  date: (0, _index$9j.buildFormatLongFn)({
    formats: dateFormats$1m,
    defaultWidth: "full",
  }),

  time: (0, _index$9j.buildFormatLongFn)({
    formats: timeFormats$1m,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9j.buildFormatLongFn)({
    formats: dateTimeFormats$1m,
    defaultWidth: "full",
  }),
});

var formatRelative$2v = {};

formatRelative$2v.formatRelative = void 0;

const formatRelativeLocale$1e = {
  lastWeek: "eeee 'Ø¥ÙÙ ÙØ§Øª ÙØ¹' p",
  yesterday: "'Ø§ÙØ¨Ø§Ø±Ø­ ÙØ¹' p",
  today: "'Ø§ÙÙÙÙ ÙØ¹' p",
  tomorrow: "'ØºØ¯ÙØ© ÙØ¹' p",
  nextWeek: "eeee 'Ø§ÙØ¬ÙØ¹Ø© Ø§ÙØ¬Ø§ÙØ© ÙØ¹' p 'ÙÙØ§Ø±'",
  other: "P",
};

const formatRelative$2u = (token) => formatRelativeLocale$1e[token];
formatRelative$2v.formatRelative = formatRelative$2u;

var localize$1e = {};

localize$1e.localize = void 0;
var _index$9i = buildLocalizeFn$1;

const eraValues$1e = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§ÙÙÙÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§ÙÙÙÙØ§Ø¯"],
};

const quarterValues$1e = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø±1", "Ø±2", "Ø±3", "Ø±4"],
  wide: ["Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ£ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙÙ", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ«Ø§ÙØ«", "Ø§ÙØ±Ø¨Ø¹ Ø§ÙØ±Ø§Ø¨Ø¹"],
};

const monthValues$1e = {
  narrow: ["Ø¯", "Ù", "Ø£", "Ø³", "Ø£", "Ø¬", "Ø¬", "Ù", "Ø£", "Ù", "Ù", "Ø¬"],
  abbreviated: [
    "Ø¬Ø§ÙÙÙ",
    "ÙÙÙØ±Ù",
    "ÙØ§Ø±Ø³",
    "Ø£ÙØ±ÙÙ",
    "ÙØ§Ù",
    "Ø¬ÙØ§Ù",
    "Ø¬ÙÙÙÙØ©",
    "Ø£ÙØª",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],

  wide: [
    "Ø¬Ø§ÙÙÙ",
    "ÙÙÙØ±Ù",
    "ÙØ§Ø±Ø³",
    "Ø£ÙØ±ÙÙ",
    "ÙØ§Ù",
    "Ø¬ÙØ§Ù",
    "Ø¬ÙÙÙÙØ©",
    "Ø£ÙØª",
    "Ø³Ø¨ØªÙØ¨Ø±",
    "Ø£ÙØªÙØ¨Ø±",
    "ÙÙÙÙØ¨Ø±",
    "Ø¯ÙØ³ÙØ¨Ø±",
  ],
};

const dayValues$1e = {
  narrow: ["Ø­", "Ù", "Ø«", "Ø±", "Ø®", "Ø¬", "Ø³"],
  short: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],
  abbreviated: ["Ø£Ø­Ø¯", "Ø§Ø«ÙÙÙ", "Ø«ÙØ§Ø«Ø§Ø¡", "Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø®ÙÙØ³", "Ø¬ÙØ¹Ø©", "Ø³Ø¨Øª"],

  wide: [
    "Ø§ÙØ£Ø­Ø¯",
    "Ø§ÙØ§Ø«ÙÙÙ",
    "Ø§ÙØ«ÙØ§Ø«Ø§Ø¡",
    "Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡",
    "Ø§ÙØ®ÙÙØ³",
    "Ø§ÙØ¬ÙØ¹Ø©",
    "Ø§ÙØ³Ø¨Øª",
  ],
};

const dayPeriodValues$1e = {
  narrow: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "Ø§ÙØ¹Ø´ÙØ©",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "Ø§ÙØ¹Ø´ÙØ©",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "Ø§ÙØµØ¨Ø§Ø­",
    noon: "Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "Ø§ÙØ¹Ø´ÙØ©",
    night: "Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
};

const formattingDayPeriodValues$_ = {
  narrow: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "ÙÙ Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "ÙÙ Ø§ÙØ¹Ø´ÙØ©",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
  abbreviated: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "ÙÙ Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "ÙÙ Ø§ÙØ¹Ø´ÙØ©",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
  wide: {
    am: "Øµ",
    pm: "Ø¹",
    morning: "ÙÙ Ø§ÙØµØ¨Ø§Ø­",
    noon: "ÙÙ Ø§ÙÙØ§ÙÙØ©",
    afternoon: "Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©",
    evening: "ÙÙ Ø§ÙØ¹Ø´ÙØ©",
    night: "ÙÙ Ø§ÙÙÙÙ",
    midnight: "ÙØµ Ø§ÙÙÙÙ",
  },
};

const ordinalNumber$1e = (num) => String(num);

(localize$1e.localize = {
  ordinalNumber: ordinalNumber$1e,

  era: (0, _index$9i.buildLocalizeFn)({
    values: eraValues$1e,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9i.buildLocalizeFn)({
    values: quarterValues$1e,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9i.buildLocalizeFn)({
    values: monthValues$1e,
    defaultWidth: "wide",
  }),

  day: (0, _index$9i.buildLocalizeFn)({
    values: dayValues$1e,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9i.buildLocalizeFn)({
    values: dayPeriodValues$1e,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$_,
    defaultFormattingWidth: "wide",
  }),
});

var match$1d = {};

match$1d.match = void 0;
var _index$9h = buildMatchPatternFn$1;
var _index2$4d = buildMatchFn$1;

const matchOrdinalNumberPattern$1d = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$1d = /\d+/i;

const matchEraPatterns$1d = {
  narrow: /[ÙØ¨]/,
  abbreviated: /[ÙØ¨]\.Ù\./,
  wide: /(ÙØ¨Ù|Ø¨Ø¹Ø¯) Ø§ÙÙÙÙØ§Ø¯/,
};
const parseEraPatterns$1d = {
  any: [/ÙØ¨Ù/, /Ø¨Ø¹Ø¯/],
};

const matchQuarterPatterns$1d = {
  narrow: /^[1234]/i,
  abbreviated: /Ø±[1234]/,
  wide: /Ø§ÙØ±Ø¨Ø¹ (Ø§ÙØ£ÙÙ|Ø§ÙØ«Ø§ÙÙ|Ø§ÙØ«Ø§ÙØ«|Ø§ÙØ±Ø§Ø¨Ø¹)/,
};
const parseQuarterPatterns$1d = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1d = {
  narrow: /^[Ø¬ÙÙØ£Ø³ÙØ¯]/,
  abbreviated:
    /^(Ø¬Ø§ÙÙÙ|ÙÙÙØ±Ù|ÙØ§Ø±Ø³|Ø£ÙØ±ÙÙ|ÙØ§Ù|Ø¬ÙØ§Ù|Ø¬ÙÙÙÙØ©|Ø£ÙØª|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/,
  wide: /^(Ø¬Ø§ÙÙÙ|ÙÙÙØ±Ù|ÙØ§Ø±Ø³|Ø£ÙØ±ÙÙ|ÙØ§Ù|Ø¬ÙØ§Ù|Ø¬ÙÙÙÙØ©|Ø£ÙØª|Ø³Ø¨ØªÙØ¨Ø±|Ø£ÙØªÙØ¨Ø±|ÙÙÙÙØ¨Ø±|Ø¯ÙØ³ÙØ¨Ø±)/,
};
const parseMonthPatterns$1d = {
  narrow: [
    /^Ø¬/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¬/i,
    /^Ø¬/i,
    /^Ø£/i,
    /^Ø³/i,
    /^Ø£/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^Ø¬Ø§ÙÙÙ/i,
    /^ÙÙÙØ±Ù/i,
    /^ÙØ§Ø±Ø³/i,
    /^Ø£ÙØ±ÙÙ/i,
    /^ÙØ§Ù/i,
    /^Ø¬ÙØ§Ù/i,
    /^Ø¬ÙÙÙÙØ©/i,
    /^Ø£ÙØª/i,
    /^Ø³Ø¨ØªÙØ¨Ø±/i,
    /^Ø£ÙØªÙØ¨Ø±/i,
    /^ÙÙÙÙØ¨Ø±/i,
    /^Ø¯ÙØ³ÙØ¨Ø±/i,
  ],
};

const matchDayPatterns$1d = {
  narrow: /^[Ø­ÙØ«Ø±Ø®Ø¬Ø³]/i,
  short: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  abbreviated: /^(Ø£Ø­Ø¯|Ø§Ø«ÙÙÙ|Ø«ÙØ§Ø«Ø§Ø¡|Ø£Ø±Ø¨Ø¹Ø§Ø¡|Ø®ÙÙØ³|Ø¬ÙØ¹Ø©|Ø³Ø¨Øª)/i,
  wide: /^(Ø§ÙØ£Ø­Ø¯|Ø§ÙØ§Ø«ÙÙÙ|Ø§ÙØ«ÙØ§Ø«Ø§Ø¡|Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡|Ø§ÙØ®ÙÙØ³|Ø§ÙØ¬ÙØ¹Ø©|Ø§ÙØ³Ø¨Øª)/i,
};
const parseDayPatterns$1d = {
  narrow: [/^Ø­/i, /^Ù/i, /^Ø«/i, /^Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
  wide: [
    /^Ø§ÙØ£Ø­Ø¯/i,
    /^Ø§ÙØ§Ø«ÙÙÙ/i,
    /^Ø§ÙØ«ÙØ§Ø«Ø§Ø¡/i,
    /^Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡/i,
    /^Ø§ÙØ®ÙÙØ³/i,
    /^Ø§ÙØ¬ÙØ¹Ø©/i,
    /^Ø§ÙØ³Ø¨Øª/i,
  ],

  any: [/^Ø£Ø­/i, /^Ø§Ø«/i, /^Ø«/i, /^Ø£Ø±/i, /^Ø®/i, /^Ø¬/i, /^Ø³/i],
};

const matchDayPeriodPatterns$1d = {
  narrow: /^(Øµ|Ø¹|Ù Ù|Ù|(ÙÙ|ÙØ¹) (ØµØ¨Ø§Ø­|ÙØ§ÙÙØ©|Ø¹Ø´ÙØ©|ÙÙÙ))/,
  any: /^([ØµØ¹]|ÙØµ Ø§ÙÙÙÙ|ÙØ§ÙÙØ©|(ÙÙ|ÙØ¹) (ØµØ¨Ø§Ø­|ÙØ§ÙÙØ©|Ø¹Ø´ÙØ©|ÙÙÙ))/,
};
const parseDayPeriodPatterns$1d = {
  any: {
    am: /^Øµ/,
    pm: /^Ø¹/,
    midnight: /ÙØµ Ø§ÙÙÙÙ/,
    noon: /ÙØ§ÙÙØ©/,
    afternoon: /Ø¨Ø¹Ø¯ Ø§ÙÙØ§ÙÙØ©/,
    morning: /ØµØ¨Ø§Ø­/,
    evening: /Ø¹Ø´ÙØ©/,
    night: /ÙÙÙ/,
  },
};

(match$1d.match = {
  ordinalNumber: (0, _index$9h.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1d,
    parsePattern: parseOrdinalNumberPattern$1d,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index2$4d.buildMatchFn)({
    matchPatterns: matchEraPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1d,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$4d.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1d,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index2$4d.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1d,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$4d.buildMatchFn)({
    matchPatterns: matchDayPatterns$1d,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1d,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$4d.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1d,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1d,
    defaultParseWidth: "any",
  }),
});

arTN.arTN = void 0;
var _index$9g = formatDistance$2v;
var _index2$4c = formatLong$1m;
var _index3$2b = formatRelative$2v;
var _index4$1G = localize$1e;
var _index5$1x = match$1d;

/**
 * @category Locales
 * @summary Arabic locale (Tunisian Arabic).
 * @language Arabic
 * @iso-639-2 ara
 * @author Koussay Haj Kacem [@essana3](https://github.com/essana3)
 */
(arTN.arTN = {
  code: "ar-TN",
  formatDistance: _index$9g.formatDistance,
  formatLong: _index2$4c.formatLong,
  formatRelative: _index3$2b.formatRelative,
  localize: _index4$1G.localize,
  match: _index5$1x.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var az = {};

var formatDistance$2t = {};

formatDistance$2t.formatDistance = void 0;

const formatDistanceLocale$1c = {
  lessThanXSeconds: {
    one: "bir saniyÉdÉn az",
    other: "{{count}} bir saniyÉdÉn az",
  },

  xSeconds: {
    one: "1 saniyÉ",
    other: "{{count}} saniyÉ",
  },

  halfAMinute: "yarÄ±m dÉqiqÉ",

  lessThanXMinutes: {
    one: "bir dÉqiqÉdÉn az",
    other: "{{count}} bir dÉqiqÉdÉn az",
  },

  xMinutes: {
    one: "bir dÉqiqÉ",
    other: "{{count}} dÉqiqÉ",
  },

  aboutXHours: {
    one: "tÉxminÉn 1 saat",
    other: "tÉxminÉn {{count}} saat",
  },

  xHours: {
    one: "1 saat",
    other: "{{count}} saat",
  },

  xDays: {
    one: "1 gÃ¼n",
    other: "{{count}} gÃ¼n",
  },

  aboutXWeeks: {
    one: "tÉxminÉn 1 hÉftÉ",
    other: "tÉxminÉn {{count}} hÉftÉ",
  },

  xWeeks: {
    one: "1 hÉftÉ",
    other: "{{count}} hÉftÉ",
  },

  aboutXMonths: {
    one: "tÉxminÉn 1 ay",
    other: "tÉxminÉn {{count}} ay",
  },

  xMonths: {
    one: "1 ay",
    other: "{{count}} ay",
  },

  aboutXYears: {
    one: "tÉxminÉn 1 il",
    other: "tÉxminÉn {{count}} il",
  },

  xYears: {
    one: "1 il",
    other: "{{count}} il",
  },

  overXYears: {
    one: "1 ildÉn Ã§ox",
    other: "{{count}} ildÉn Ã§ox",
  },

  almostXYears: {
    one: "demÉk olar ki 1 il",
    other: "demÉk olar ki {{count}} il",
  },
};

const formatDistance$2s = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$1c[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " ÉvvÉl";
    }
  }

  return result;
};
formatDistance$2t.formatDistance = formatDistance$2s;

var formatLong$1l = {};

formatLong$1l.formatLong = void 0;
var _index$9f = buildFormatLongFn$1;

const dateFormats$1l = {
  full: "EEEE, do MMMM y 'il'",
  long: "do MMMM y 'il'",
  medium: "d MMM y 'il'",
  short: "dd.MM.yyyy",
};

const timeFormats$1l = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$1l = {
  full: "{{date}} {{time}} - 'dÉ'",
  long: "{{date}} {{time}} - 'dÉ'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1l.formatLong = {
  date: (0, _index$9f.buildFormatLongFn)({
    formats: dateFormats$1l,
    defaultWidth: "full",
  }),

  time: (0, _index$9f.buildFormatLongFn)({
    formats: timeFormats$1l,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9f.buildFormatLongFn)({
    formats: dateTimeFormats$1l,
    defaultWidth: "full",
  }),
});

var formatRelative$2t = {};

formatRelative$2t.formatRelative = void 0;

const formatRelativeLocale$1d = {
  lastWeek: "'sonuncu' eeee p -'dÉ'",
  yesterday: "'dÃ¼nÉn' p -'dÉ'",
  today: "'bugÃ¼n' p -'dÉ'",
  tomorrow: "'sabah' p -'dÉ'",
  nextWeek: "eeee p -'dÉ'",
  other: "P",
};

const formatRelative$2s = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$1d[token];
formatRelative$2t.formatRelative = formatRelative$2s;

var localize$1d = {};

localize$1d.localize = void 0;
var _index$9e = buildLocalizeFn$1;

const eraValues$1d = {
  narrow: ["e.É", "b.e"],
  abbreviated: ["e.É", "b.e"],
  wide: ["eramÄ±zdan ÉvvÉl", "bizim era"],
};

const quarterValues$1d = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ci kvartal", "2ci kvartal", "3cÃ¼ kvartal", "4cÃ¼ kvartal"],
};
const monthValues$1d = {
  narrow: ["Y", "F", "M", "A", "M", "Ä°", "Ä°", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "Ä°yun",
    "Ä°yul",
    "Avq",
    "Sen",
    "Okt",
    "Noy",
    "Dek",
  ],

  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "Ä°yun",
    "Ä°yul",
    "Avqust",
    "Sentyabr",
    "Oktyabr",
    "Noyabr",
    "Dekabr",
  ],
};

const dayValues$1d = {
  narrow: ["B.", "B.e", "Ã.a", "Ã.", "C.a", "C.", "Å."],
  short: ["B.", "B.e", "Ã.a", "Ã.", "C.a", "C.", "Å."],
  abbreviated: ["Baz", "Baz.e", "ÃÉr.a", "ÃÉr", "CÃ¼m.a", "CÃ¼m", "ÅÉ"],
  wide: [
    "Bazar",
    "Bazar ertÉsi",
    "ÃÉrÅÉnbÉ axÅamÄ±",
    "ÃÉrÅÉnbÉ",
    "CÃ¼mÉ axÅamÄ±",
    "CÃ¼mÉ",
    "ÅÉnbÉ",
  ],
};

const dayPeriodValues$1d = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
};

const formattingDayPeriodValues$Z = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecÉyarÄ±",
    noon: "gÃ¼n",
    morning: "sÉhÉr",
    afternoon: "gÃ¼ndÃ¼z",
    evening: "axÅam",
    night: "gecÉ",
  },
};

const suffixes$1 = {
  1: "-inci",
  5: "-inci",
  8: "-inci",
  70: "-inci",
  80: "-inci",
  2: "-nci",
  7: "-nci",
  20: "-nci",
  50: "-nci",
  3: "-Ã¼ncÃ¼",
  4: "-Ã¼ncÃ¼",
  100: "-Ã¼ncÃ¼",
  6: "-ncÄ±",
  9: "-uncu",
  10: "-uncu",
  30: "-uncu",
  60: "-Ä±ncÄ±",
  90: "-Ä±ncÄ±",
};

const getSuffix = (number) => {
  if (number === 0) {
    // special case for zero
    return number + "-Ä±ncÄ±";
  }

  const a = number % 10;
  const b = (number % 100) - a;
  const c = number >= 100 ? 100 : null;

  if (suffixes$1[a]) {
    return suffixes$1[a];
  } else if (suffixes$1[b]) {
    return suffixes$1[b];
  } else if (c !== null) {
    return suffixes$1[c];
  }
  return "";
};

const ordinalNumber$1d = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const suffix = getSuffix(number);

  return number + suffix;
};

(localize$1d.localize = {
  ordinalNumber: ordinalNumber$1d,

  era: (0, _index$9e.buildLocalizeFn)({
    values: eraValues$1d,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$9e.buildLocalizeFn)({
    values: quarterValues$1d,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$9e.buildLocalizeFn)({
    values: monthValues$1d,
    defaultWidth: "wide",
  }),

  day: (0, _index$9e.buildLocalizeFn)({
    values: dayValues$1d,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$9e.buildLocalizeFn)({
    values: dayPeriodValues$1d,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$Z,
    defaultFormattingWidth: "wide",
  }),
});

var match$1c = {};

match$1c.match = void 0;

var _index$9d = buildMatchFn$1;
var _index2$4b = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1c = /^(\d+)(-?(ci|inci|nci|uncu|Ã¼ncÃ¼|ncÄ±))?/i;
const parseOrdinalNumberPattern$1c = /\d+/i;

const matchEraPatterns$1c = {
  narrow: /^(b|a)$/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)$/i,
  wide: /^(bizim eradan ÉvvÉl|bizim era)$/i,
};
const parseEraPatterns$1c = {
  any: [/^b$/i, /^(a|c)$/i],
};

const matchQuarterPatterns$1c = {
  narrow: /^[1234]$/i,
  abbreviated: /^K[1234]$/i,
  wide: /^[1234](ci)? kvartal$/i,
};
const parseQuarterPatterns$1c = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1c = {
  narrow: /^[(?-i)yfmaisond]$/i,
  abbreviated: /^(Yan|Fev|Mar|Apr|May|Ä°yun|Ä°yul|Avq|Sen|Okt|Noy|Dek)$/i,
  wide: /^(Yanvar|Fevral|Mart|Aprel|May|Ä°yun|Ä°yul|Avgust|Sentyabr|Oktyabr|Noyabr|Dekabr)$/i,
};
const parseMonthPatterns$1c = {
  narrow: [
    /^[(?-i)y]$/i,
    /^[(?-i)f]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)s]$/i,
    /^[(?-i)o]$/i,
    /^[(?-i)n]$/i,
    /^[(?-i)d]$/i,
  ],

  abbreviated: [
    /^Yan$/i,
    /^Fev$/i,
    /^Mar$/i,
    /^Apr$/i,
    /^May$/i,
    /^Ä°yun$/i,
    /^Ä°yul$/i,
    /^Avg$/i,
    /^Sen$/i,
    /^Okt$/i,
    /^Noy$/i,
    /^Dek$/i,
  ],

  wide: [
    /^Yanvar$/i,
    /^Fevral$/i,
    /^Mart$/i,
    /^Aprel$/i,
    /^May$/i,
    /^Ä°yun$/i,
    /^Ä°yul$/i,
    /^Avgust$/i,
    /^Sentyabr$/i,
    /^Oktyabr$/i,
    /^Noyabr$/i,
    /^Dekabr$/i,
  ],
};

const matchDayPatterns$1c = {
  narrow: /^(B\.|B\.e|Ã\.a|Ã\.|C\.a|C\.|Å\.)$/i,
  short: /^(B\.|B\.e|Ã\.a|Ã\.|C\.a|C\.|Å\.)$/i,
  abbreviated: /^(Baz\.e|ÃÉr|ÃÉr\.a|CÃ¼m|CÃ¼m\.a|ÅÉ)$/i,
  wide: /^(Bazar|Bazar ertÉsi|ÃÉrÅÉnbÉ axÅamÄ±|ÃÉrÅÉnbÉ|CÃ¼mÉ axÅamÄ±|CÃ¼mÉ|ÅÉnbÉ)$/i,
};
const parseDayPatterns$1c = {
  narrow: [
    /^B\.$/i,
    /^B\.e$/i,
    /^Ã\.a$/i,
    /^Ã\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^Å\.$/i,
  ],

  abbreviated: [
    /^Baz$/i,
    /^Baz\.e$/i,
    /^ÃÉr\.a$/i,
    /^ÃÉr$/i,
    /^CÃ¼m\.a$/i,
    /^CÃ¼m$/i,
    /^ÅÉ$/i,
  ],

  wide: [
    /^Bazar$/i,
    /^Bazar ertÉsi$/i,
    /^ÃÉrÅÉnbÉ axÅamÄ±$/i,
    /^ÃÉrÅÉnbÉ$/i,
    /^CÃ¼mÉ axÅamÄ±$/i,
    /^CÃ¼mÉ$/i,
    /^ÅÉnbÉ$/i,
  ],

  any: [
    /^B\.$/i,
    /^B\.e$/i,
    /^Ã\.a$/i,
    /^Ã\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^Å\.$/i,
  ],
};

const matchDayPeriodPatterns$1c = {
  narrow: /^(a|p|gecÉyarÄ±|gÃ¼n|sÉhÉr|gÃ¼ndÃ¼z|axÅam|gecÉ)$/i,
  any: /^(am|pm|a\.m\.|p\.m\.|AM|PM|gecÉyarÄ±|gÃ¼n|sÉhÉr|gÃ¼ndÃ¼z|axÅam|gecÉ)$/i,
};
const parseDayPeriodPatterns$1c = {
  any: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /^gecÉyarÄ±$/i,
    noon: /^gÃ¼n$/i,
    morning: /sÉhÉr$/i,
    afternoon: /gÃ¼ndÃ¼z$/i,
    evening: /axÅam$/i,
    night: /gecÉ$/i,
  },
};

(match$1c.match = {
  ordinalNumber: (0, _index2$4b.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1c,
    parsePattern: parseOrdinalNumberPattern$1c,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$9d.buildMatchFn)({
    matchPatterns: matchEraPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1c,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$9d.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1c,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$9d.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1c,
    defaultParseWidth: "narrow",
  }),

  day: (0, _index$9d.buildMatchFn)({
    matchPatterns: matchDayPatterns$1c,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1c,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$9d.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1c,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1c,
    defaultParseWidth: "any",
  }),
});

az.az = void 0;
var _index$9c = formatDistance$2t;
var _index2$4a = formatLong$1l;
var _index3$2a = formatRelative$2t;
var _index4$1F = localize$1d;
var _index5$1w = match$1c;

/**
 * @category Locales
 * @summary Azerbaijani locale.
 * @language Azerbaijani
 * @iso-639-2 aze
 */

(az.az = {
  code: "az",
  formatDistance: _index$9c.formatDistance,
  formatLong: _index2$4a.formatLong,
  formatRelative: _index3$2a.formatRelative,
  localize: _index4$1F.localize,
  match: _index5$1w.match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1,
  },
});

var be = {};

var formatDistance$2r = {};

formatDistance$2r.formatDistance = void 0;

function declension$6(scheme, count) {
  // scheme for count=1 exists
  if (scheme.one !== undefined && count === 1) {
    return scheme.one;
  }

  const rem10 = count % 10;
  const rem100 = count % 100;

  // 1, 21, 31, ...
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count));

    // 2, 3, 4, 22, 23, 24, 32 ...
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count));

    // 5, 6, 7, 8, 9, 10, 11, ...
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count));
  }
}

function buildLocalizeTokenFn$4(scheme) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension$6(scheme.future, count);
        } else {
          return "Ð¿ÑÐ°Ð· " + declension$6(scheme.regular, count);
        }
      } else {
        if (scheme.past) {
          return declension$6(scheme.past, count);
        } else {
          return declension$6(scheme.regular, count) + " ÑÐ°Ð¼Ñ";
        }
      }
    } else {
      return declension$6(scheme.regular, count);
    }
  };
}

const halfAMinute$1 = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ð¿ÑÐ°Ð· Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ";
    } else {
      return "Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ";
    }
  }

  return "Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ";
};

const formatDistanceLocale$1b = {
  lessThanXSeconds: buildLocalizeTokenFn$4({
    regular: {
      one: "Ð¼ÐµÐ½Ñ Ð·Ð° ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´",
    },
    future: {
      one: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  xSeconds: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ð°",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
    },
    past: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  halfAMinute: halfAMinute$1,

  lessThanXMinutes: buildLocalizeTokenFn$4({
    regular: {
      one: "Ð¼ÐµÐ½Ñ Ð·Ð° ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
    future: {
      one: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
  }),

  xMinutes: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ð°",
      singularGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
    past: {
      singularNominative: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
  }),

  aboutXHours: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
  }),

  xHours: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ð°",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
    past: {
      singularNominative: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
  }),

  xDays: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} Ð´Ð·ÐµÐ½Ñ",
      singularGenitive: "{{count}} Ð´Ð½Ñ",
      pluralGenitive: "{{count}} Ð´Ð·ÑÐ½",
    },
  }),

  aboutXWeeks: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½Ñ",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½ÑÑ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½ÑÑ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð·ÐµÐ½Ñ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð½Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð½ÑÑ",
    },
  }),

  xWeeks: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} ÑÑÐ´Ð·ÐµÐ½Ñ",
      singularGenitive: "{{count}} ÑÑÐ´Ð½Ñ",
      pluralGenitive: "{{count}} ÑÑÐ´Ð½ÑÑ",
    },
  }),

  aboutXMonths: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑÑ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
  }),

  xMonths: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "{{count}} Ð¼ÐµÑÑÑÑ",
      pluralGenitive: "{{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
  }),

  aboutXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð¾Ð´Ð°",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  xYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "{{count}} Ð³Ð¾Ð´",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  overXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  almostXYears: buildLocalizeTokenFn$4({
    regular: {
      singularNominative: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),
};

const formatDistance$2q = (token, count, options) => {
  options = options || {};
  return formatDistanceLocale$1b[token](count, options);
};
formatDistance$2r.formatDistance = formatDistance$2q;

var formatLong$1k = {};

formatLong$1k.formatLong = void 0;
var _index$9b = buildFormatLongFn$1;

const dateFormats$1k = {
  full: "EEEE, d MMMM y 'Ð³.'",
  long: "d MMMM y 'Ð³.'",
  medium: "d MMM y 'Ð³.'",
  short: "dd.MM.y",
};

const timeFormats$1k = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$1k = {
  any: "{{date}}, {{time}}",
};

(formatLong$1k.formatLong = {
  date: (0, _index$9b.buildFormatLongFn)({
    formats: dateFormats$1k,
    defaultWidth: "full",
  }),

  time: (0, _index$9b.buildFormatLongFn)({
    formats: timeFormats$1k,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$9b.buildFormatLongFn)({
    formats: dateTimeFormats$1k,
    defaultWidth: "any",
  }),
});

var formatRelative$2r = {};

var isSameWeek$1 = {};

var startOfWeek$1 = {};

var toDate$1 = {};

toDate$1.toDate = toDate;

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (
    argument instanceof Date ||
    (typeof argument === "object" && argStr === "[object Date]")
  ) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new argument.constructor(+argument);
  } else if (
    typeof argument === "number" ||
    argStr === "[object Number]" ||
    typeof argument === "string" ||
    argStr === "[object String]"
  ) {
    // TODO: Can we get rid of as?
    return new Date(argument);
  } else {
    // TODO: Can we get rid of as?
    return new Date(NaN);
  }
}

var defaultOptions$1 = {};

defaultOptions$1.getDefaultOptions = getDefaultOptions$2;
defaultOptions$1.setDefaultOptions = setDefaultOptions$2;

let defaultOptions = {};

function getDefaultOptions$2() {
  return defaultOptions;
}

function setDefaultOptions$2(newOptions) {
  defaultOptions = newOptions;
}

startOfWeek$1.startOfWeek = startOfWeek;
var _index$9a = toDate$1;

var _index2$49 = defaultOptions$1;

/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(date, options) {
  const defaultOptions = (0, _index2$49.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index$9a.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

isSameWeek$1.isSameWeek = isSameWeek;
var _index$99 = startOfWeek$1;

/**
 * The {@link isSameWeek} function options.
 */

/**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 * @param options - An object with options
 *
 * @returns The dates are in the same week (and month and year)
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameWeek(dateLeft, dateRight, options) {
  const dateLeftStartOfWeek = (0, _index$99.startOfWeek)(dateLeft, options);
  const dateRightStartOfWeek = (0, _index$99.startOfWeek)(dateRight, options);

  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}

formatRelative$2r.formatRelative = void 0;
var _index$98 = isSameWeek$1;
var _index2$48 = toDate$1;

const accusativeWeekdays$7 = [
  "Ð½ÑÐ´Ð·ÐµÐ»Ñ",
  "Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº",
  "Ð°ÑÑÐ¾ÑÐ°Ðº",
  "ÑÐµÑÐ°Ð´Ñ",
  "ÑÐ°ÑÐ²ÐµÑ",
  "Ð¿ÑÑÐ½ÑÑÑ",
  "ÑÑÐ±Ð¾ÑÑ",
];

function lastWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð¼ÑÐ½ÑÐ»ÑÑ " + weekday + " Ð°' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð¼ÑÐ½ÑÐ»Ñ " + weekday + " Ð°' p";
  }
}

function thisWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];

  return "'Ñ " + weekday + " Ð°' p";
}

function nextWeek$8(day) {
  const weekday = accusativeWeekdays$7[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½ÑÑ " + weekday + " Ð°' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ñ " + weekday + " Ð°' p";
  }
}

const lastWeekFormat$2 = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$48.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$98.isSameWeek)(date, baseDate, options)) {
    return thisWeek$8(day);
  } else {
    return lastWeek$8(day);
  }
};

const nextWeekFormat$2 = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$48.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$98.isSameWeek)(date, baseDate, options)) {
    return thisWeek$8(day);
  } else {
    return nextWeek$8(day);
  }
};

const formatRelativeLocale$1c = {
  lastWeek: lastWeekFormat$2,
  yesterday: "'ÑÑÐ¾ÑÐ° Ð°' p",
  today: "'ÑÑÐ½Ð½Ñ Ð°' p",
  tomorrow: "'Ð·Ð°ÑÑÑÐ° Ð°' p",
  nextWeek: nextWeekFormat$2,
  other: "P",
};

const formatRelative$2q = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$1c[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$2r.formatRelative = formatRelative$2q;

var localize$1c = {};

localize$1c.localize = void 0;

var _index$97 = buildLocalizeFn$1;

const eraValues$1c = {
  narrow: ["Ð´Ð° Ð½.Ñ.", "Ð½.Ñ."],
  abbreviated: ["Ð´Ð° Ð½. Ñ.", "Ð½. Ñ."],
  wide: ["Ð´Ð° Ð½Ð°ÑÐ°Ð¹ ÑÑÑ", "Ð½Ð°ÑÐ°Ð¹ ÑÑÑ"],
};

const quarterValues$1c = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ñ ÐºÐ².", "2-Ñ ÐºÐ².", "3-Ñ ÐºÐ².", "4-Ñ ÐºÐ²."],
  wide: ["1-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "2-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "3-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "4-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$1c = {
  narrow: ["Ð¡", "Ð", "Ð¡", "Ð", "Ð", "Ð§", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡"],
  abbreviated: [
    "ÑÑÑÐ´Ð·.",
    "Ð»ÑÑ.",
    "ÑÐ°Ðº.",
    "ÐºÑÐ°Ñ.",
    "Ð¼Ð°Ð¹",
    "ÑÑÑÐ².",
    "Ð»ÑÐ¿.",
    "Ð¶Ð½.",
    "Ð²ÐµÑ.",
    "ÐºÐ°ÑÑÑ.",
    "Ð»ÑÑÑ.",
    "ÑÐ½ÐµÐ¶.",
  ],

  wide: [
    "ÑÑÑÐ´Ð·ÐµÐ½Ñ",
    "Ð»ÑÑÑ",
    "ÑÐ°ÐºÐ°Ð²ÑÐº",
    "ÐºÑÐ°ÑÐ°Ð²ÑÐº",
    "Ð¼Ð°Ð¹",
    "ÑÑÑÐ²ÐµÐ½Ñ",
    "Ð»ÑÐ¿ÐµÐ½Ñ",
    "Ð¶Ð½ÑÐ²ÐµÐ½Ñ",
    "Ð²ÐµÑÐ°ÑÐµÐ½Ñ",
    "ÐºÐ°ÑÑÑÑÑÐ½ÑÐº",
    "Ð»ÑÑÑÐ°Ð¿Ð°Ð´",
    "ÑÐ½ÐµÐ¶Ð°Ð½Ñ",
  ],
};
const formattingMonthValues$i = {
  narrow: ["Ð¡", "Ð", "Ð¡", "Ð", "Ð", "Ð§", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡"],
  abbreviated: [
    "ÑÑÑÐ´Ð·.",
    "Ð»ÑÑ.",
    "ÑÐ°Ðº.",
    "ÐºÑÐ°Ñ.",
    "Ð¼Ð°Ñ",
    "ÑÑÑÐ².",
    "Ð»ÑÐ¿.",
    "Ð¶Ð½.",
    "Ð²ÐµÑ.",
    "ÐºÐ°ÑÑÑ.",
    "Ð»ÑÑÑ.",
    "ÑÐ½ÐµÐ¶.",
  ],

  wide: [
    "ÑÑÑÐ´Ð·ÐµÐ½Ñ",
    "Ð»ÑÑÐ°Ð³Ð°",
    "ÑÐ°ÐºÐ°Ð²ÑÐºÐ°",
    "ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°",
    "Ð¼Ð°Ñ",
    "ÑÑÑÐ²ÐµÐ½Ñ",
    "Ð»ÑÐ¿ÐµÐ½Ñ",
    "Ð¶Ð½ÑÑÐ½Ñ",
    "Ð²ÐµÑÐ°ÑÐ½Ñ",
    "ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°",
    "Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°",
    "ÑÐ½ÐµÐ¶Ð½Ñ",
  ],
};

const dayValues$1c = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½Ð´", "Ð¿Ð½", "Ð°Ñ", "ÑÑ", "ÑÑ", "Ð¿Ñ", "ÑÐ±"],
  abbreviated: ["Ð½ÑÐ´Ð·", "Ð¿Ð°Ð½", "Ð°ÑÑ", "ÑÐµÑ", "ÑÐ°Ñ", "Ð¿ÑÑ", "ÑÑÐ±"],
  wide: [
    "Ð½ÑÐ´Ð·ÐµÐ»Ñ",
    "Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº",
    "Ð°ÑÑÐ¾ÑÐ°Ðº",
    "ÑÐµÑÐ°Ð´Ð°",
    "ÑÐ°ÑÐ²ÐµÑ",
    "Ð¿ÑÑÐ½ÑÑÐ°",
    "ÑÑÐ±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$1c = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾Ñ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾Ñ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½Ð°Ñ",
    noon: "Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½ÑÑÐ°",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑÐ°Ñ",
    night: "Ð½Ð¾Ñ",
  },
};
const formattingDayPeriodValues$Y = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½Ð°Ñ",
    noon: "Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½ÑÑÑ",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑÐ°ÑÐ°",
    night: "Ð½Ð¾ÑÑ",
  },
};

const ordinalNumber$1c = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number = Number(dirtyNumber);
  let suffix;

  /** Though it's an incorrect ordinal form of a date we use it here for consistency with other similar locales (ru, uk)
   *  For date-month combinations should be used `d` formatter.
   *  Correct:   `d MMMM` (4 Ð²ÐµÑÐ°ÑÐ½Ñ)
   *  Incorrect: `do MMMM` (4-Ð³Ð° Ð²ÐµÑÐ°ÑÐ½Ñ)
   *
   *  But following the consistency leads to mistakes for literal uses of `do` formatter (ordinal day of month).
   *  So for phrase "5th day of month" (`do Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`)
   *  library will produce:            `5-Ð³Ð° Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`
   *  but correct spelling should be:  `5-Ñ Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`
   *
   *  So I guess there should be a stand-alone and a formatting version of "day of month" formatters
   */
  if (unit === "date") {
    suffix = "-Ð³Ð°";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix = "-Ñ";
  } else {
    suffix =
      (number % 10 === 2 || number % 10 === 3) &&
      number % 100 !== 12 &&
      number % 100 !== 13
        ? "-Ñ"
        : "-Ñ";
  }

  return number + suffix;
};

(localize$1c.localize = {
  ordinalNumber: ordinalNumber$1c,

  era: (0, _index$97.buildLocalizeFn)({
    values: eraValues$1c,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$97.buildLocalizeFn)({
    values: quarterValues$1c,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$97.buildLocalizeFn)({
    values: monthValues$1c,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$i,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$97.buildLocalizeFn)({
    values: dayValues$1c,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$97.buildLocalizeFn)({
    values: dayPeriodValues$1c,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$Y,
    defaultFormattingWidth: "wide",
  }),
});

var match$1b = {};

match$1b.match = void 0;

var _index$96 = buildMatchFn$1;
var _index2$47 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1b =
  /^(\d+)(-?(Ðµ|Ñ|Ð³Ð°|Ñ|Ñ|Ð°Ðµ|Ð°Ñ|ÑÑ|ÑÑ|Ð³Ñ|ÑÑ|ÑÑ|Ð¼Ñ))?/i;
const parseOrdinalNumberPattern$1b = /\d+/i;

const matchEraPatterns$1b = {
  narrow: /^((Ð´Ð° )?Ð½\.?\s?Ñ\.?)/i,
  abbreviated: /^((Ð´Ð° )?Ð½\.?\s?Ñ\.?)/i,
  wide: /^(Ð´Ð° Ð½Ð°ÑÐ°Ð¹ ÑÑÑ|Ð½Ð°ÑÐ°Ð¹ ÑÑÑ|Ð½Ð°ÑÐ° ÑÑÐ°)/i,
};
const parseEraPatterns$1b = {
  any: [/^Ð´/i, /^Ð½/i],
};

const matchQuarterPatterns$1b = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ÑÑ]?)? ÐºÐ².?/i,
  wide: /^[1234](-?[ÑÑ]?)? ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};
const parseQuarterPatterns$1b = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1b = {
  narrow: /^[ÑÐ»ÐºÐ¼ÑÐ¶Ð²]/i,
  abbreviated:
    /^(ÑÑÑÐ´Ð·|Ð»ÑÑ|ÑÐ°Ðº|ÐºÑÐ°Ñ|Ð¼Ð°[Ð¹Ñ]|ÑÑÑÐ²|Ð»ÑÐ¿|Ð¶Ð½|Ð²ÐµÑ|ÐºÐ°ÑÑÑ|Ð»ÑÑÑ|ÑÐ½ÐµÐ¶)\.?/i,
  wide: /^(ÑÑÑÐ´Ð·ÐµÐ½[ÑÑ]|Ð»ÑÑ(Ñ|Ð°Ð³Ð°)|ÑÐ°ÐºÐ°Ð²ÑÐºÐ°?|ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°?|Ð¼Ð°[Ð¹Ñ]|ÑÑÑÐ²ÐµÐ½[ÑÑ]|Ð»ÑÐ¿ÐµÐ½[ÑÑ]|Ð¶Ð½Ñ(Ð²ÐµÐ½Ñ|ÑÐ½Ñ)|Ð²ÐµÑÐ°Ñ(ÐµÐ½Ñ|Ð½Ñ)|ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°?|Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°?|ÑÐ½ÐµÐ¶(Ð°Ð½Ñ|Ð½Ñ))/i,
};
const parseMonthPatterns$1b = {
  narrow: [
    /^Ñ/i,
    /^Ð»/i,
    /^Ñ/i,
    /^Ðº/i,
    /^Ð¼/i,
    /^Ñ/i,
    /^Ð»/i,
    /^Ð¶/i,
    /^Ð²/i,
    /^Ðº/i,
    /^Ð»/i,
    /^Ñ/i,
  ],

  any: [
    /^ÑÑ/i,
    /^Ð»Ñ/i,
    /^ÑÐ°/i,
    /^ÐºÑ/i,
    /^Ð¼Ð°/i,
    /^Ñ/i,
    /^Ð»ÑÐ¿/i,
    /^Ð¶/i,
    /^Ð²/i,
    /^ÐºÐ°/i,
    /^Ð»ÑÑ/i,
    /^ÑÐ½/i,
  ],
};

const matchDayPatterns$1b = {
  narrow: /^[Ð½Ð¿Ð°ÑÑ]/i,
  short: /^(Ð½Ð´|Ð½Ñ|Ð¿Ð½|Ð¿Ð°|Ð°Ñ|Ð°Ñ|ÑÑ|ÑÐµ|ÑÑ|ÑÐ°|Ð¿Ñ|Ð¿Ñ|ÑÐ±|ÑÑ)\.?/i,
  abbreviated: /^(Ð½ÑÐ´Ð·?|Ð½Ð´Ð·|Ð¿Ð½Ð´|Ð¿Ð°Ð½|Ð°ÑÑ|ÑÑÐ´|ÑÐµÑ|ÑÑÐ²|ÑÐ°Ñ|Ð¿ÑÐ½|Ð¿ÑÑ|ÑÑÐ±).?/i,
  wide: /^(Ð½ÑÐ´Ð·ÐµÐ»[ÑÑ]|Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»(Ð°Ðº|ÐºÐ°)|Ð°ÑÑÐ¾Ñ(Ð°Ðº|ÐºÐ°)|ÑÐµÑÐ°Ð´[Ð°Ñ]|ÑÐ°ÑÐ²(ÐµÑ|ÑÑÐ³Ð°)|Ð¿ÑÑÐ½ÑÑ[Ð°Ñ]|ÑÑÐ±Ð¾Ñ[Ð°Ñ])/i,
};
const parseDayPatterns$1b = {
  narrow: [/^Ð½/i, /^Ð¿/i, /^Ð°/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð½/i, /^Ð¿[Ð°Ð½]/i, /^Ð°/i, /^Ñ[ÐµÑ]/i, /^Ñ/i, /^Ð¿[ÑÑ]/i, /^Ñ[ÑÐ±]/i],
};

const matchDayPeriodPatterns$1b = {
  narrow: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½\.?|Ð¿Ð¾ÑÐ´\.?|ÑÐ°Ð½\.?|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾ÑÑ?)/i,
  abbreviated: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½\.?|Ð¿Ð¾ÑÐ´\.?|ÑÐ°Ð½\.?|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾ÑÑ?)/i,
  wide: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½Ð°Ñ|Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ|ÑÐ°Ð½ÑÑ[Ð°Ñ]|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°?|Ð½Ð¾ÑÑ?)/i,
};
const parseDayPeriodPatterns$1b = {
  any: {
    am: /^Ð´Ð¿/i,
    pm: /^Ð¿Ð¿/i,
    midnight: /^Ð¿Ð¾ÑÐ½/i,
    noon: /^Ð¿Ð¾ÑÐ´/i,
    morning: /^Ñ/i,
    afternoon: /^Ð´[Ð·Ð½]/i,
    evening: /^Ð²/i,
    night: /^Ð½/i,
  },
};

(match$1b.match = {
  ordinalNumber: (0, _index2$47.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1b,
    parsePattern: parseOrdinalNumberPattern$1b,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$96.buildMatchFn)({
    matchPatterns: matchEraPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1b,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$96.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1b,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$96.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1b,
    defaultParseWidth: "any",
  }),

  day: (0, _index$96.buildMatchFn)({
    matchPatterns: matchDayPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1b,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$96.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1b,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$1b,
    defaultParseWidth: "any",
  }),
});

be.be = void 0;
var _index$95 = formatDistance$2r;
var _index2$46 = formatLong$1k;
var _index3$29 = formatRelative$2r;
var _index4$1E = localize$1c;
var _index5$1v = match$1b;

/**
 * @category Locales
 * @summary Belarusian locale.
 * @language Belarusian
 * @iso-639-2 bel
 * @author Kiryl Anokhin [@alyrik](https://github.com/alyrik)
 * @author Martin Wind [@arvigeus](https://github.com/mawi12345)
 */
(be.be = {
  code: "be",
  formatDistance: _index$95.formatDistance,
  formatLong: _index2$46.formatLong,
  formatRelative: _index3$29.formatRelative,
  localize: _index4$1E.localize,
  match: _index5$1v.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var beTarask = {};

var formatDistance$2p = {};

formatDistance$2p.formatDistance = void 0;

function declension$5(scheme, count) {
  // scheme for count=1 exists
  if (scheme.one !== undefined && count === 1) {
    return scheme.one;
  }

  const rem10 = count % 10;
  const rem100 = count % 100;

  // 1, 21, 31, ...
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count));

    // 2, 3, 4, 22, 23, 24, 32 ...
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count));

    // 5, 6, 7, 8, 9, 10, 11, ...
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count));
  }
}

function buildLocalizeTokenFn$3(scheme) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension$5(scheme.future, count);
        } else {
          return "Ð¿ÑÐ°Ð· " + declension$5(scheme.regular, count);
        }
      } else {
        if (scheme.past) {
          return declension$5(scheme.past, count);
        } else {
          return declension$5(scheme.regular, count) + " ÑÐ°Ð¼Ñ";
        }
      }
    } else {
      return declension$5(scheme.regular, count);
    }
  };
}

const halfAMinute = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ð¿ÑÐ°Ð· Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ";
    } else {
      return "Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ";
    }
  }

  return "Ð¿Ð°ÑÑÐ²ÑÐ»ÑÐ½Ñ";
};

const formatDistanceLocale$1a = {
  lessThanXSeconds: buildLocalizeTokenFn$3({
    regular: {
      one: "Ð¼ÐµÐ½Ñ Ð·Ð° ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´",
    },
    future: {
      one: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  xSeconds: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ð°",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
    },
    past: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  halfAMinute: halfAMinute,

  lessThanXMinutes: buildLocalizeTokenFn$3({
    regular: {
      one: "Ð¼ÐµÐ½Ñ Ð·Ð° ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ Ð·Ð° {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
    future: {
      one: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularNominative: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¼ÐµÐ½Ñ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
  }),

  xMinutes: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ð°",
      singularGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
    past: {
      singularNominative: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐ²ÑÐ»ÑÐ½ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} ÑÐ²ÑÐ»ÑÐ½",
    },
  }),

  aboutXHours: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
  }),

  xHours: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ð°",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
    past: {
      singularNominative: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ ÑÐ°Ð¼Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð·ÑÐ½ ÑÐ°Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      singularGenitive: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½Ñ",
      pluralGenitive: "Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð·ÑÐ½",
    },
  }),

  xDays: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} Ð´Ð·ÐµÐ½Ñ",
      singularGenitive: "{{count}} Ð´Ð½Ñ",
      pluralGenitive: "{{count}} Ð´Ð·ÑÐ½",
    },
  }),

  aboutXWeeks: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½Ñ",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½ÑÑ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} ÑÑÐ´Ð½ÑÑ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð·ÐµÐ½Ñ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð½Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} ÑÑÐ´Ð½ÑÑ",
    },
  }),

  xWeeks: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} ÑÑÐ´Ð·ÐµÐ½Ñ",
      singularGenitive: "{{count}} ÑÑÐ´Ð½Ñ",
      pluralGenitive: "{{count}} ÑÑÐ´Ð½ÑÑ",
    },
  }),

  aboutXMonths: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑÑ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
  }),

  xMonths: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "{{count}} Ð¼ÐµÑÑÑÑ",
      pluralGenitive: "{{count}} Ð¼ÐµÑÑÑÐ°Ñ",
    },
  }),

  aboutXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð¾Ð´Ð°",
      singularGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
      pluralGenitive: "ÐºÐ°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð¿ÑÑÐ±Ð»ÑÐ·Ð½Ð° Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  xYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "{{count}} Ð³Ð¾Ð´",
      singularGenitive: "{{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "{{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  overXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑ Ð·Ð° {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑ, ÑÑÐ¼ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),

  almostXYears: buildLocalizeTokenFn$3({
    regular: {
      singularNominative: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð°Ð¼Ð°Ð»Ñ {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
    future: {
      singularNominative: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ñ",
      pluralGenitive: "Ð°Ð¼Ð°Ð»Ñ Ð¿ÑÐ°Ð· {{count}} Ð³Ð°Ð´Ð¾Ñ",
    },
  }),
};

const formatDistance$2o = (token, count, options) => {
  options = options || {};
  return formatDistanceLocale$1a[token](count, options);
};
formatDistance$2p.formatDistance = formatDistance$2o;

var formatLong$1j = {};

formatLong$1j.formatLong = void 0;
var _index$94 = buildFormatLongFn$1;

const dateFormats$1j = {
  full: "EEEE, d MMMM y 'Ð³.'",
  long: "d MMMM y 'Ð³.'",
  medium: "d MMM y 'Ð³.'",
  short: "dd.MM.y",
};

const timeFormats$1j = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$1j = {
  any: "{{date}}, {{time}}",
};

(formatLong$1j.formatLong = {
  date: (0, _index$94.buildFormatLongFn)({
    formats: dateFormats$1j,
    defaultWidth: "full",
  }),

  time: (0, _index$94.buildFormatLongFn)({
    formats: timeFormats$1j,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$94.buildFormatLongFn)({
    formats: dateTimeFormats$1j,
    defaultWidth: "any",
  }),
});

var formatRelative$2p = {};

formatRelative$2p.formatRelative = void 0;
var _index$93 = isSameWeek$1;
var _index2$45 = toDate$1;

const accusativeWeekdays$6 = [
  "Ð½ÑÐ´Ð·ÐµÐ»Ñ",
  "Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº",
  "Ð°ÑÑÐ¾ÑÐ°Ðº",
  "ÑÐµÑÐ°Ð´Ñ",
  "ÑÐ°ÑÑÐ²ÐµÑ",
  "Ð¿ÑÑÐ½ÑÑÑ",
  "ÑÑÐ±Ð¾ÑÑ",
];

function lastWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð¼ÑÐ½ÑÐ»ÑÑ " + weekday + " Ð°' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð¼ÑÐ½ÑÐ»Ñ " + weekday + " Ð°' p";
  }
}

function thisWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];

  return "'Ñ " + weekday + " Ð°' p";
}

function nextWeek$7(day) {
  const weekday = accusativeWeekdays$6[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½ÑÑ " + weekday + " Ð°' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ñ " + weekday + " Ð°' p";
  }
}

const lastWeekFormat$1 = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$45.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$93.isSameWeek)(date, baseDate, options)) {
    return thisWeek$7(day);
  } else {
    return lastWeek$7(day);
  }
};

const nextWeekFormat$1 = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$45.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$93.isSameWeek)(date, baseDate, options)) {
    return thisWeek$7(day);
  } else {
    return nextWeek$7(day);
  }
};

const formatRelativeLocale$1b = {
  lastWeek: lastWeekFormat$1,
  yesterday: "'ÑÑÐ¾ÑÐ° Ð°' p",
  today: "'ÑÑÐ½ÑÐ½Ñ Ð°' p",
  tomorrow: "'Ð·Ð°ÑÑÑÐ° Ð°' p",
  nextWeek: nextWeekFormat$1,
  other: "P",
};

const formatRelative$2o = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$1b[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$2p.formatRelative = formatRelative$2o;

var localize$1b = {};

localize$1b.localize = void 0;

var _index$92 = buildLocalizeFn$1;

const eraValues$1b = {
  narrow: ["Ð´Ð° Ð½.Ñ.", "Ð½.Ñ."],
  abbreviated: ["Ð´Ð° Ð½. Ñ.", "Ð½. Ñ."],
  wide: ["Ð´Ð° Ð½Ð°ÑÐ°Ð¹ ÑÑÑ", "Ð½Ð°ÑÐ°Ð¹ ÑÑÑ"],
};

const quarterValues$1b = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ñ ÐºÐ².", "2-Ñ ÐºÐ².", "3-Ñ ÐºÐ².", "4-Ñ ÐºÐ²."],
  wide: ["1-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "2-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "3-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»", "4-Ñ ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$1b = {
  narrow: ["Ð¡", "Ð", "Ð¡", "Ð", "Ð¢", "Ð§", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡"],
  abbreviated: [
    "ÑÑÑÐ´Ð·.",
    "Ð»ÑÑ.",
    "ÑÐ°Ðº.",
    "ÐºÑÐ°Ñ.",
    "ÑÑÐ°Ð².",
    "ÑÑÑÐ².",
    "Ð»ÑÐ¿.",
    "Ð¶Ð½.",
    "Ð²ÐµÑ.",
    "ÐºÐ°ÑÑÑ.",
    "Ð»ÑÑÑ.",
    "ÑÑÐ½ÐµÐ¶.",
  ],

  wide: [
    "ÑÑÑÐ´Ð·ÐµÐ½Ñ",
    "Ð»ÑÑÑ",
    "ÑÐ°ÐºÐ°Ð²ÑÐº",
    "ÐºÑÐ°ÑÐ°Ð²ÑÐº",
    "ÑÑÐ°Ð²ÐµÐ½Ñ",
    "ÑÑÑÐ²ÐµÐ½Ñ",
    "Ð»ÑÐ¿ÐµÐ½Ñ",
    "Ð¶Ð½ÑÐ²ÐµÐ½Ñ",
    "Ð²ÐµÑÐ°ÑÐµÐ½Ñ",
    "ÐºÐ°ÑÑÑÑÑÐ½ÑÐº",
    "Ð»ÑÑÑÐ°Ð¿Ð°Ð´",
    "ÑÑÐ½ÐµÐ¶Ð°Ð½Ñ",
  ],
};
const formattingMonthValues$h = {
  narrow: ["Ð¡", "Ð", "Ð¡", "Ð", "Ð¢", "Ð§", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡"],
  abbreviated: [
    "ÑÑÑÐ´Ð·.",
    "Ð»ÑÑ.",
    "ÑÐ°Ðº.",
    "ÐºÑÐ°Ñ.",
    "ÑÑÐ°Ð².",
    "ÑÑÑÐ².",
    "Ð»ÑÐ¿.",
    "Ð¶Ð½.",
    "Ð²ÐµÑ.",
    "ÐºÐ°ÑÑÑ.",
    "Ð»ÑÑÑ.",
    "ÑÑÐ½ÐµÐ¶.",
  ],

  wide: [
    "ÑÑÑÐ´Ð·ÐµÐ½Ñ",
    "Ð»ÑÑÐ°Ð³Ð°",
    "ÑÐ°ÐºÐ°Ð²ÑÐºÐ°",
    "ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°",
    "ÑÑÐ°ÑÐ½Ñ",
    "ÑÑÑÐ²ÐµÐ½Ñ",
    "Ð»ÑÐ¿ÐµÐ½Ñ",
    "Ð¶Ð½ÑÑÐ½Ñ",
    "Ð²ÐµÑÐ°ÑÐ½Ñ",
    "ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°",
    "Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°",
    "ÑÑÐ½ÐµÐ¶Ð½Ñ",
  ],
};

const dayValues$1b = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½Ð´", "Ð¿Ð½", "Ð°Ñ", "ÑÑ", "ÑÑ", "Ð¿Ñ", "ÑÐ±"],
  abbreviated: ["Ð½ÑÐ´Ð·", "Ð¿Ð°Ð½", "Ð°ÑÑ", "ÑÐµÑ", "ÑÐ°ÑÑ", "Ð¿ÑÑ", "ÑÑÐ±"],
  wide: [
    "Ð½ÑÐ´Ð·ÐµÐ»Ñ",
    "Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº",
    "Ð°ÑÑÐ¾ÑÐ°Ðº",
    "ÑÐµÑÐ°Ð´Ð°",
    "ÑÐ°ÑÑÐ²ÐµÑ",
    "Ð¿ÑÑÐ½ÑÑÐ°",
    "ÑÑÐ±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$1b = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾Ñ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾Ñ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½Ð°Ñ",
    noon: "Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½ÑÑÐ°",
    afternoon: "Ð´Ð·ÐµÐ½Ñ",
    evening: "Ð²ÐµÑÐ°Ñ",
    night: "Ð½Ð¾Ñ",
  },
};
const formattingDayPeriodValues$X = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½.",
    noon: "Ð¿Ð¾ÑÐ´.",
    morning: "ÑÐ°Ð½.",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾ÑÐ½Ð°Ñ",
    noon: "Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½ÑÑÑ",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑÐ°ÑÐ°",
    night: "Ð½Ð¾ÑÑ",
  },
};

const ordinalNumber$1b = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number = Number(dirtyNumber);
  let suffix;

  /** Though it's an incorrect ordinal form of a date we use it here for consistency with other similar locales (ru, uk)
   *  For date-month combinations should be used `d` formatter.
   *  Correct:   `d MMMM` (4 Ð²ÐµÑÐ°ÑÐ½Ñ)
   *  Incorrect: `do MMMM` (4-Ð³Ð° Ð²ÐµÑÐ°ÑÐ½Ñ)
   *
   *  But following the consistency leads to mistakes for literal uses of `do` formatter (ordinal day of month).
   *  So for phrase "5th day of month" (`do Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`)
   *  library will produce:            `5-Ð³Ð° Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`
   *  but correct spelling should be:  `5-Ñ Ð´Ð·ÐµÐ½Ñ Ð¼ÐµÑÑÑÐ°`
   *
   *  So I guess there should be a stand-alone and a formatting version of "day of month" formatters
   */
  if (unit === "date") {
    suffix = "-Ð³Ð°";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix = "-Ñ";
  } else {
    suffix =
      (number % 10 === 2 || number % 10 === 3) &&
      number % 100 !== 12 &&
      number % 100 !== 13
        ? "-Ñ"
        : "-Ñ";
  }

  return number + suffix;
};

(localize$1b.localize = {
  ordinalNumber: ordinalNumber$1b,

  era: (0, _index$92.buildLocalizeFn)({
    values: eraValues$1b,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$92.buildLocalizeFn)({
    values: quarterValues$1b,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$92.buildLocalizeFn)({
    values: monthValues$1b,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$h,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$92.buildLocalizeFn)({
    values: dayValues$1b,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$92.buildLocalizeFn)({
    values: dayPeriodValues$1b,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$X,
    defaultFormattingWidth: "wide",
  }),
});

var match$1a = {};

match$1a.match = void 0;

var _index$91 = buildMatchFn$1;
var _index2$44 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1a =
  /^(\d+)(-?(Ðµ|Ñ|Ð³Ð°|Ñ|Ñ|Ð°Ðµ|Ð°Ñ|ÑÑ|ÑÑ|Ð³Ñ|ÑÑ|ÑÑ|Ð¼Ñ))?/i;
const parseOrdinalNumberPattern$1a = /\d+/i;

const matchEraPatterns$1a = {
  narrow: /^((Ð´Ð° )?Ð½\.?\s?Ñ\.?)/i,
  abbreviated: /^((Ð´Ð° )?Ð½\.?\s?Ñ\.?)/i,
  wide: /^(Ð´Ð° Ð½Ð°ÑÐ°Ð¹ ÑÑÑ|Ð½Ð°ÑÐ°Ð¹ ÑÑÑ|Ð½Ð°ÑÐ° ÑÑÐ°)/i,
};
const parseEraPatterns$1a = {
  any: [/^Ð´/i, /^Ð½/i],
};

const matchQuarterPatterns$1a = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ÑÑ]?)? ÐºÐ².?/i,
  wide: /^[1234](-?[ÑÑ]?)? ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};
const parseQuarterPatterns$1a = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$1a = {
  narrow: /^[ÑÐ»ÐºÐ¼ÑÐ¶Ð²]/i,
  abbreviated:
    /^(ÑÑÑÐ´Ð·|Ð»ÑÑ|ÑÐ°Ðº|ÐºÑÐ°Ñ|ÑÑ(Ð°Ð²)?|ÑÑÑÐ²|Ð»ÑÐ¿|Ð¶Ð½|Ð²ÐµÑ|ÐºÐ°ÑÑÑ|Ð»ÑÑÑ|ÑÑÐ½ÐµÐ¶)\.?/i,
  wide: /^(ÑÑÑÐ´Ð·ÐµÐ½[ÑÑ]|Ð»ÑÑ(Ñ|Ð°Ð³Ð°)|ÑÐ°ÐºÐ°Ð²ÑÐºÐ°?|ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°?|ÑÑÐ°(Ð²ÐµÐ½Ñ|ÑÐ½Ñ)|ÑÑÑÐ²ÐµÐ½[ÑÑ]|Ð»ÑÐ¿ÐµÐ½[ÑÑ]|Ð¶Ð½Ñ(Ð²ÐµÐ½Ñ|ÑÐ½Ñ)|Ð²ÐµÑÐ°Ñ(ÐµÐ½Ñ|Ð½Ñ)|ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°?|Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°?|ÑÑÐ½ÐµÐ¶(Ð°Ð½Ñ|Ð½Ñ))/i,
};
const parseMonthPatterns$1a = {
  narrow: [
    /^Ñ/i,
    /^Ð»/i,
    /^Ñ/i,
    /^Ðº/i,
    /^Ñ/i,
    /^Ñ/i,
    /^Ð»/i,
    /^Ð¶/i,
    /^Ð²/i,
    /^Ðº/i,
    /^Ð»/i,
    /^Ñ/i,
  ],

  any: [
    /^ÑÑ/i,
    /^Ð»Ñ/i,
    /^ÑÐ°/i,
    /^ÐºÑ/i,
    /^ÑÑ/i,
    /^Ñ/i,
    /^Ð»ÑÐ¿/i,
    /^Ð¶/i,
    /^Ð²/i,
    /^ÐºÐ°/i,
    /^Ð»ÑÑ/i,
    /^ÑÐ½/i,
  ],
};

const matchDayPatterns$1a = {
  narrow: /^[Ð½Ð¿Ð°ÑÑ]/i,
  short: /^(Ð½Ð´|Ð½Ñ|Ð¿Ð½|Ð¿Ð°|Ð°Ñ|Ð°Ñ|ÑÑ|ÑÐµ|ÑÑ|ÑÐ°|Ð¿Ñ|Ð¿Ñ|ÑÐ±|ÑÑ)\.?/i,
  abbreviated: /^(Ð½ÑÐ´Ð·?|Ð½Ð´Ð·|Ð¿Ð½Ð´|Ð¿Ð°Ð½|Ð°ÑÑ|ÑÑÐ´|ÑÐµÑ|ÑÑÑÐ²|ÑÐ°ÑÑ|Ð¿ÑÐ½|Ð¿ÑÑ|ÑÑÐ±).?/i,
  wide: /^(Ð½ÑÐ´Ð·ÐµÐ»[ÑÑ]|Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»(Ð°Ðº|ÐºÐ°)|Ð°ÑÑÐ¾Ñ(Ð°Ðº|ÐºÐ°)|ÑÐµÑÐ°Ð´[Ð°Ñ]|ÑÐ°ÑÑÐ²(ÐµÑ|ÑÑÐ³Ð°)|Ð¿ÑÑÐ½ÑÑ[Ð°Ñ]|ÑÑÐ±Ð¾Ñ[Ð°Ñ])/i,
};
const parseDayPatterns$1a = {
  narrow: [/^Ð½/i, /^Ð¿/i, /^Ð°/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð½/i, /^Ð¿[Ð°Ð½]/i, /^Ð°/i, /^Ñ[ÐµÑ]/i, /^Ñ/i, /^Ð¿[ÑÑ]/i, /^Ñ[ÑÐ±]/i],
};

const matchDayPeriodPatterns$1a = {
  narrow: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½\.?|Ð¿Ð¾ÑÐ´\.?|ÑÐ°Ð½\.?|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾ÑÑ?)/i,
  abbreviated: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½\.?|Ð¿Ð¾ÑÐ´\.?|ÑÐ°Ð½\.?|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾ÑÑ?)/i,
  wide: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾ÑÐ½Ð°Ñ|Ð¿Ð¾ÑÐ´Ð·ÐµÐ½Ñ|ÑÐ°Ð½ÑÑ[Ð°Ñ]|Ð´Ð·ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°?|Ð½Ð¾ÑÑ?)/i,
};
const parseDayPeriodPatterns$1a = {
  any: {
    am: /^Ð´Ð¿/i,
    pm: /^Ð¿Ð¿/i,
    midnight: /^Ð¿Ð¾ÑÐ½/i,
    noon: /^Ð¿Ð¾ÑÐ´/i,
    morning: /^Ñ/i,
    afternoon: /^Ð´[Ð·Ð½]/i,
    evening: /^Ð²/i,
    night: /^Ð½/i,
  },
};

(match$1a.match = {
  ordinalNumber: (0, _index2$44.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1a,
    parsePattern: parseOrdinalNumberPattern$1a,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$91.buildMatchFn)({
    matchPatterns: matchEraPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1a,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$91.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1a,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$91.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1a,
    defaultParseWidth: "any",
  }),

  day: (0, _index$91.buildMatchFn)({
    matchPatterns: matchDayPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1a,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$91.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$1a,
    defaultParseWidth: "any",
  }),
});

beTarask.beTarask = void 0;
var _index$90 = formatDistance$2p;
var _index2$43 = formatLong$1j;
var _index3$28 = formatRelative$2p;
var _index4$1D = localize$1b;
var _index5$1u = match$1a;

/**
 * @category Locales
 * @summary Belarusian Classic locale.
 * @language Belarusian Classic
 * @iso-639-2 bel
 * @author Ryhor Nopears [@nopears](https://github.com/nopears)
 */
(beTarask.beTarask = {
  code: "be-tarask",
  formatDistance: _index$90.formatDistance,
  formatLong: _index2$43.formatLong,
  formatRelative: _index3$28.formatRelative,
  localize: _index4$1D.localize,
  match: _index5$1u.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var bg = {};

var formatDistance$2n = {};

formatDistance$2n.formatDistance = void 0;

const formatDistanceLocale$19 = {
  lessThanXSeconds: {
    one: "Ð¿Ð¾-Ð¼Ð°Ð»ÐºÐ¾ Ð¾Ñ ÑÐµÐºÑÐ½Ð´Ð°",
    other: "Ð¿Ð¾-Ð¼Ð°Ð»ÐºÐ¾ Ð¾Ñ {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  xSeconds: {
    one: "1 ÑÐµÐºÑÐ½Ð´Ð°",
    other: "{{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  halfAMinute: "Ð¿Ð¾Ð»Ð¾Ð²Ð¸Ð½ Ð¼Ð¸Ð½ÑÑÐ°",

  lessThanXMinutes: {
    one: "Ð¿Ð¾-Ð¼Ð°Ð»ÐºÐ¾ Ð¾Ñ Ð¼Ð¸Ð½ÑÑÐ°",
    other: "Ð¿Ð¾-Ð¼Ð°Ð»ÐºÐ¾ Ð¾Ñ {{count}} Ð¼Ð¸Ð½ÑÑÐ¸",
  },

  xMinutes: {
    one: "1 Ð¼Ð¸Ð½ÑÑÐ°",
    other: "{{count}} Ð¼Ð¸Ð½ÑÑÐ¸",
  },

  aboutXHours: {
    one: "Ð¾ÐºÐ¾Ð»Ð¾ ÑÐ°Ñ",
    other: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} ÑÐ°ÑÐ°",
  },

  xHours: {
    one: "1 ÑÐ°Ñ",
    other: "{{count}} ÑÐ°ÑÐ°",
  },

  xDays: {
    one: "1 Ð´ÐµÐ½",
    other: "{{count}} Ð´Ð½Ð¸",
  },

  aboutXWeeks: {
    one: "Ð¾ÐºÐ¾Ð»Ð¾ ÑÐµÐ´Ð¼Ð¸ÑÐ°",
    other: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} ÑÐµÐ´Ð¼Ð¸ÑÐ¸",
  },

  xWeeks: {
    one: "1 ÑÐµÐ´Ð¼Ð¸ÑÐ°",
    other: "{{count}} ÑÐµÐ´Ð¼Ð¸ÑÐ¸",
  },

  aboutXMonths: {
    one: "Ð¾ÐºÐ¾Ð»Ð¾ Ð¼ÐµÑÐµÑ",
    other: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð¼ÐµÑÐµÑÐ°",
  },

  xMonths: {
    one: "1 Ð¼ÐµÑÐµÑ",
    other: "{{count}} Ð¼ÐµÑÐµÑÐ°",
  },

  aboutXYears: {
    one: "Ð¾ÐºÐ¾Ð»Ð¾ Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  xYears: {
    one: "1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  overXYears: {
    one: "Ð½Ð°Ð´ Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð½Ð°Ð´ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  almostXYears: {
    one: "Ð¿Ð¾ÑÑÐ¸ Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð¿Ð¾ÑÑÐ¸ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },
};

const formatDistance$2m = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$19[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÑÐ»ÐµÐ´ " + result;
    } else {
      return "Ð¿ÑÐµÐ´Ð¸ " + result;
    }
  }

  return result;
};
formatDistance$2n.formatDistance = formatDistance$2m;

var formatLong$1i = {};

formatLong$1i.formatLong = void 0;
var _index$8$ = buildFormatLongFn$1;

const dateFormats$1i = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$1i = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$1i = {
  any: "{{date}} {{time}}",
};

(formatLong$1i.formatLong = {
  date: (0, _index$8$.buildFormatLongFn)({
    formats: dateFormats$1i,
    defaultWidth: "full",
  }),

  time: (0, _index$8$.buildFormatLongFn)({
    formats: timeFormats$1i,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8$.buildFormatLongFn)({
    formats: dateTimeFormats$1i,
    defaultWidth: "any",
  }),
});

var formatRelative$2n = {};

formatRelative$2n.formatRelative = void 0;
var _index$8_ = isSameWeek$1;
var _index2$42 = toDate$1;

// Adapted from the `ru` translation

const weekdays$3 = [
  "Ð½ÐµÐ´ÐµÐ»Ñ",
  "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº",
  "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
  "ÑÑÑÐ´Ð°",
  "ÑÐµÑÐ²ÑÑÑÑÐº",
  "Ð¿ÐµÑÑÐº",
  "ÑÑÐ±Ð¾ÑÐ°",
];

function lastWeek$6(day) {
  const weekday = weekdays$3[day];

  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'Ð¼Ð¸Ð½Ð°Ð»Ð°ÑÐ° " + weekday + " Ð²' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'Ð¼Ð¸Ð½Ð°Ð»Ð¸Ñ " + weekday + " Ð²' p";
  }
}

function thisWeek$6(day) {
  const weekday = weekdays$3[day];

  if (day === 2 /* Tue */) {
    return "'Ð²ÑÐ² " + weekday + " Ð²' p";
  } else {
    return "'Ð² " + weekday + " Ð²' p";
  }
}

function nextWeek$6(day) {
  const weekday = weekdays$3[day];

  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'ÑÐ»ÐµÐ´Ð²Ð°ÑÐ°ÑÐ° " + weekday + " Ð²' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'ÑÐ»ÐµÐ´Ð²Ð°ÑÐ¸Ñ " + weekday + " Ð²' p";
  }
}

const lastWeekFormatToken = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$42.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$8_.isSameWeek)(date, baseDate, options)) {
    return thisWeek$6(day);
  } else {
    return lastWeek$6(day);
  }
};

const nextWeekFormatToken = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$42.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$8_.isSameWeek)(date, baseDate, options)) {
    return thisWeek$6(day);
  } else {
    return nextWeek$6(day);
  }
};

const formatRelativeLocale$1a = {
  lastWeek: lastWeekFormatToken,
  yesterday: "'Ð²ÑÐµÑÐ° Ð²' p",
  today: "'Ð´Ð½ÐµÑ Ð²' p",
  tomorrow: "'ÑÑÑÐµ Ð²' p",
  nextWeek: nextWeekFormatToken,
  other: "P",
};

const formatRelative$2m = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$1a[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$2n.formatRelative = formatRelative$2m;

var localize$1a = {};

localize$1a.localize = void 0;
var _index$8Z = buildLocalizeFn$1;

const eraValues$1a = {
  narrow: ["Ð¿Ñ.Ð½.Ðµ.", "Ð½.Ðµ."],
  abbreviated: ["Ð¿ÑÐµÐ´Ð¸ Ð½. Ðµ.", "Ð½. Ðµ."],
  wide: ["Ð¿ÑÐµÐ´Ð¸ Ð½Ð¾Ð²Ð°ÑÐ° ÐµÑÐ°", "Ð½Ð¾Ð²Ð°ÑÐ° ÐµÑÐ°"],
};

const quarterValues$1a = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ð²Ð¾ ÑÑÐ¸Ð¼ÐµÑ.", "2-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑ.", "3-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑ.", "4-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑ."],

  wide: [
    "1-Ð²Ð¾ ÑÑÐ¸Ð¼ÐµÑÐµÑÐ¸Ðµ",
    "2-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑÐµÑÐ¸Ðµ",
    "3-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑÐµÑÐ¸Ðµ",
    "4-ÑÐ¾ ÑÑÐ¸Ð¼ÐµÑÐµÑÐ¸Ðµ",
  ],
};

const monthValues$1a = {
  abbreviated: [
    "ÑÐ½Ñ",
    "ÑÐµÐ²",
    "Ð¼Ð°Ñ",
    "Ð°Ð¿Ñ",
    "Ð¼Ð°Ð¹",
    "ÑÐ½Ð¸",
    "ÑÐ»Ð¸",
    "Ð°Ð²Ð³",
    "ÑÐµÐ¿",
    "Ð¾ÐºÑ",
    "Ð½Ð¾Ðµ",
    "Ð´ÐµÐº",
  ],

  wide: [
    "ÑÐ½ÑÐ°ÑÐ¸",
    "ÑÐµÐ²ÑÑÐ°ÑÐ¸",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐ¸Ð»",
    "Ð¼Ð°Ð¹",
    "ÑÐ½Ð¸",
    "ÑÐ»Ð¸",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸",
    "Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸",
    "Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸",
    "Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸",
  ],
};

const dayValues$1a = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½Ð´", "Ð¿Ð½", "Ð²Ñ", "ÑÑ", "ÑÑ", "Ð¿Ñ", "ÑÐ±"],
  abbreviated: ["Ð½ÐµÐ´", "Ð¿Ð¾Ð½", "Ð²ÑÐ¾", "ÑÑÑ", "ÑÐµÑ", "Ð¿ÐµÑ", "ÑÑÐ±"],
  wide: [
    "Ð½ÐµÐ´ÐµÐ»Ñ",
    "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº",
    "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
    "ÑÑÑÐ´Ð°",
    "ÑÐµÑÐ²ÑÑÑÑÐº",
    "Ð¿ÐµÑÑÐº",
    "ÑÑÐ±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$1a = {
  wide: {
    am: "Ð¿ÑÐµÐ´Ð¸ Ð¾Ð±ÑÐ´",
    pm: "ÑÐ»ÐµÐ´ Ð¾Ð±ÑÐ´",
    midnight: "Ð² Ð¿Ð¾Ð»ÑÐ½Ð¾Ñ",
    noon: "Ð½Ð° Ð¾Ð±ÑÐ´",
    morning: "ÑÑÑÑÐ¸Ð½ÑÐ°",
    afternoon: "ÑÐ»ÐµÐ´Ð¾Ð±ÐµÐ´",
    evening: "Ð²ÐµÑÐµÑÑÐ°",
    night: "Ð¿ÑÐµÐ· Ð½Ð¾ÑÑÐ°",
  },
};

function isFeminine(unit) {
  return (
    unit === "year" || unit === "week" || unit === "minute" || unit === "second"
  );
}

function isNeuter(unit) {
  return unit === "quarter";
}

function numberWithSuffix(number, unit, masculine, feminine, neuter) {
  const suffix = isNeuter(unit)
    ? neuter
    : isFeminine(unit)
      ? feminine
      : masculine;
  return number + "-" + suffix;
}

const ordinalNumber$1a = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;

  if (number === 0) {
    return numberWithSuffix(0, unit, "ÐµÐ²", "ÐµÐ²Ð°", "ÐµÐ²Ð¾");
  } else if (number % 1000 === 0) {
    return numberWithSuffix(number, unit, "ÐµÐ½", "Ð½Ð°", "Ð½Ð¾");
  } else if (number % 100 === 0) {
    return numberWithSuffix(number, unit, "ÑÐµÐ½", "ÑÐ½Ð°", "ÑÐ½Ð¾");
  }

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return numberWithSuffix(number, unit, "Ð²Ð¸", "Ð²Ð°", "Ð²Ð¾");
      case 2:
        return numberWithSuffix(number, unit, "ÑÐ¸", "ÑÐ°", "ÑÐ¾");
      case 7:
      case 8:
        return numberWithSuffix(number, unit, "Ð¼Ð¸", "Ð¼Ð°", "Ð¼Ð¾");
    }
  }

  return numberWithSuffix(number, unit, "ÑÐ¸", "ÑÐ°", "ÑÐ¾");
};

(localize$1a.localize = {
  ordinalNumber: ordinalNumber$1a,

  era: (0, _index$8Z.buildLocalizeFn)({
    values: eraValues$1a,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8Z.buildLocalizeFn)({
    values: quarterValues$1a,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8Z.buildLocalizeFn)({
    values: monthValues$1a,
    defaultWidth: "wide",
  }),

  day: (0, _index$8Z.buildLocalizeFn)({
    values: dayValues$1a,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8Z.buildLocalizeFn)({
    values: dayPeriodValues$1a,
    defaultWidth: "wide",
  }),
});

var match$19 = {};

match$19.match = void 0;

var _index$8Y = buildMatchFn$1;
var _index2$41 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$19 =
  /^(\d+)(-?[Ð²ÑÐ¼Ñ][Ð°Ð¸]|-?Ñ?(ÐµÐ½|Ð½Ð°)|-?(ÐµÐ²|ÐµÐ²Ð°))?/i;
const parseOrdinalNumberPattern$19 = /\d+/i;

const matchEraPatterns$19 = {
  narrow: /^((Ð¿Ñ)?Ð½\.?\s?Ðµ\.?)/i,
  abbreviated: /^((Ð¿Ñ)?Ð½\.?\s?Ðµ\.?)/i,
  wide: /^(Ð¿ÑÐµÐ´Ð¸ Ð½Ð¾Ð²Ð°ÑÐ° ÐµÑÐ°|Ð½Ð¾Ð²Ð°ÑÐ° ÐµÑÐ°|Ð½Ð¾Ð²Ð° ÐµÑÐ°)/i,
};
const parseEraPatterns$19 = {
  any: [/^Ð¿/i, /^Ð½/i],
};

const matchQuarterPatterns$19 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[Ð²ÑÑ]?o?)? ÑÑÐ¸Ð¼ÐµÑ.?/i,
  wide: /^[1234](-?[Ð²ÑÑ]?Ð¾?)? ÑÑÐ¸Ð¼ÐµÑÐµÑÐ¸Ðµ/i,
};
const parseQuarterPatterns$19 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchDayPatterns$19 = {
  narrow: /^[Ð½Ð¿Ð²ÑÑ]/i,
  short: /^(Ð½Ð´|Ð¿Ð½|Ð²Ñ|ÑÑ|ÑÑ|Ð¿Ñ|ÑÐ±)/i,
  abbreviated: /^(Ð½ÐµÐ´|Ð¿Ð¾Ð½|Ð²ÑÐ¾|ÑÑÑ|ÑÐµÑ|Ð¿ÐµÑ|ÑÑÐ±)/i,
  wide: /^(Ð½ÐµÐ´ÐµÐ»Ñ|Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº|Ð²ÑÐ¾ÑÐ½Ð¸Ðº|ÑÑÑÐ´Ð°|ÑÐµÑÐ²ÑÑÑÑÐº|Ð¿ÐµÑÑÐº|ÑÑÐ±Ð¾ÑÐ°)/i,
};

const parseDayPatterns$19 = {
  narrow: [/^Ð½/i, /^Ð¿/i, /^Ð²/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð½[ÐµÐ´]/i, /^Ð¿[Ð¾Ð½]/i, /^Ð²Ñ/i, /^ÑÑ/i, /^Ñ[ÐµÑ]/i, /^Ð¿[ÐµÑ]/i, /^Ñ[ÑÐ±]/i],
};

const matchMonthPatterns$19 = {
  abbreviated: /^(ÑÐ½Ñ|ÑÐµÐ²|Ð¼Ð°Ñ|Ð°Ð¿Ñ|Ð¼Ð°Ð¹|ÑÐ½Ð¸|ÑÐ»Ð¸|Ð°Ð²Ð³|ÑÐµÐ¿|Ð¾ÐºÑ|Ð½Ð¾Ðµ|Ð´ÐµÐº)/i,
  wide: /^(ÑÐ½ÑÐ°ÑÐ¸|ÑÐµÐ²ÑÑÐ°ÑÐ¸|Ð¼Ð°ÑÑ|Ð°Ð¿ÑÐ¸Ð»|Ð¼Ð°Ð¹|ÑÐ½Ð¸|ÑÐ»Ð¸|Ð°Ð²Ð³ÑÑÑ|ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸|Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸|Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸|Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸)/i,
};

const parseMonthPatterns$19 = {
  any: [
    /^Ñ/i,
    /^Ñ/i,
    /^Ð¼Ð°Ñ/i,
    /^Ð°Ð¿/i,
    /^Ð¼Ð°Ð¹/i,
    /^ÑÐ½/i,
    /^ÑÐ»/i,
    /^Ð°Ð²/i,
    /^ÑÐµ/i,
    /^Ð¾ÐºÑ/i,
    /^Ð½Ð¾/i,
    /^Ð´Ðµ/i,
  ],
};

const matchDayPeriodPatterns$19 = {
  any: /^(Ð¿ÑÐµÐ´Ð¸ Ð¾|ÑÐ»ÐµÐ´ Ð¾|Ð² Ð¿Ð¾|Ð½Ð° Ð¾|Ð¿ÑÐµÐ·|Ð²ÐµÑ|ÑÑÑ|ÑÐ»ÐµÐ´Ð¾)/i,
};
const parseDayPeriodPatterns$19 = {
  any: {
    am: /^Ð¿ÑÐµÐ´Ð¸ Ð¾/i,
    pm: /^ÑÐ»ÐµÐ´ Ð¾/i,
    midnight: /^Ð² Ð¿Ð¾Ð»/i,
    noon: /^Ð½Ð° Ð¾Ð±/i,
    morning: /^ÑÑÑ/i,
    afternoon: /^ÑÐ»ÐµÐ´Ð¾/i,
    evening: /^Ð²ÐµÑ/i,
    night: /^Ð¿ÑÐµÐ· Ð½/i,
  },
};

(match$19.match = {
  ordinalNumber: (0, _index2$41.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$19,
    parsePattern: parseOrdinalNumberPattern$19,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8Y.buildMatchFn)({
    matchPatterns: matchEraPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$19,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8Y.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$19,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8Y.buildMatchFn)({
    matchPatterns: matchMonthPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$19,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8Y.buildMatchFn)({
    matchPatterns: matchDayPatterns$19,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$19,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8Y.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$19,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$19,
    defaultParseWidth: "any",
  }),
});

bg.bg = void 0;
var _index$8X = formatDistance$2n;
var _index2$40 = formatLong$1i;
var _index3$27 = formatRelative$2n;
var _index4$1C = localize$1a;
var _index5$1t = match$19;

/**
 * @category Locales
 * @summary Bulgarian locale.
 * @language Bulgarian
 * @iso-639-2 bul
 * @author Nikolay Stoynov [@arvigeus](https://github.com/arvigeus)
 * @author Tsvetan Ovedenski [@fintara](https://github.com/fintara)
 */
(bg.bg = {
  code: "bg",
  formatDistance: _index$8X.formatDistance,
  formatLong: _index2$40.formatLong,
  formatRelative: _index3$27.formatRelative,
  localize: _index4$1C.localize,
  match: _index5$1t.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var bn = {};

var formatDistance$2l = {};

var localize$19 = {};

localize$19.localize = void 0;
localize$19.numberToLocale = numberToLocale$1;
var _index$8W = buildLocalizeFn$1;

const numberValues$1 = {
  locale: {
    1: "à§§",
    2: "à§¨",
    3: "à§©",
    4: "à§ª",
    5: "à§«",
    6: "à§¬",
    7: "à§­",
    8: "à§®",
    9: "à§¯",
    0: "à§¦",
  },
  number: {
    "à§§": "1",
    "à§¨": "2",
    "à§©": "3",
    "à§ª": "4",
    "à§«": "5",
    "à§¬": "6",
    "à§­": "7",
    "à§®": "8",
    "à§¯": "9",
    "à§¦": "0",
  },
};

const eraValues$19 = {
  narrow: ["à¦à§à¦°à¦¿à¦à¦ªà§à¦", "à¦à§à¦°à¦¿à¦"],
  abbreviated: ["à¦à§à¦°à¦¿à¦à¦ªà§à¦°à§à¦¬", "à¦à§à¦°à¦¿à¦"],
  wide: ["à¦à§à¦°à¦¿à¦¸à§à¦à¦ªà§à¦°à§à¦¬", "à¦à§à¦°à¦¿à¦¸à§à¦à¦¾à¦¬à§à¦¦"],
};

const quarterValues$19 = {
  narrow: ["à§§", "à§¨", "à§©", "à§ª"],
  abbreviated: ["à§§à¦¤à§à¦°à§", "à§¨à¦¤à§à¦°à§", "à§©à¦¤à§à¦°à§", "à§ªà¦¤à§à¦°à§"],
  wide: ["à§§à¦® à¦¤à§à¦°à§à¦®à¦¾à¦¸à¦¿à¦", "à§¨à§ à¦¤à§à¦°à§à¦®à¦¾à¦¸à¦¿à¦", "à§©à§ à¦¤à§à¦°à§à¦®à¦¾à¦¸à¦¿à¦", "à§ªà¦°à§à¦¥ à¦¤à§à¦°à§à¦®à¦¾à¦¸à¦¿à¦"],
};

const monthValues$19 = {
  narrow: [
    "à¦à¦¾à¦¨à§",
    "à¦«à§à¦¬à§à¦°à§",
    "à¦®à¦¾à¦°à§à¦",
    "à¦à¦ªà§à¦°à¦¿à¦²",
    "à¦®à§",
    "à¦à§à¦¨",
    "à¦à§à¦²à¦¾à¦",
    "à¦à¦à¦¸à§à¦",
    "à¦¸à§à¦ªà§à¦",
    "à¦à¦à§à¦à§",
    "à¦¨à¦­à§",
    "à¦¡à¦¿à¦¸à§",
  ],

  abbreviated: [
    "à¦à¦¾à¦¨à§",
    "à¦«à§à¦¬à§à¦°à§",
    "à¦®à¦¾à¦°à§à¦",
    "à¦à¦ªà§à¦°à¦¿à¦²",
    "à¦®à§",
    "à¦à§à¦¨",
    "à¦à§à¦²à¦¾à¦",
    "à¦à¦à¦¸à§à¦",
    "à¦¸à§à¦ªà§à¦",
    "à¦à¦à§à¦à§",
    "à¦¨à¦­à§",
    "à¦¡à¦¿à¦¸à§",
  ],

  wide: [
    "à¦à¦¾à¦¨à§à§à¦¾à¦°à¦¿",
    "à¦«à§à¦¬à§à¦°à§à§à¦¾à¦°à¦¿",
    "à¦®à¦¾à¦°à§à¦",
    "à¦à¦ªà§à¦°à¦¿à¦²",
    "à¦®à§",
    "à¦à§à¦¨",
    "à¦à§à¦²à¦¾à¦",
    "à¦à¦à¦¸à§à¦",
    "à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦°",
    "à¦à¦à§à¦à§à¦¬à¦°",
    "à¦¨à¦­à§à¦®à§à¦¬à¦°",
    "à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦°",
  ],
};

const dayValues$19 = {
  narrow: ["à¦°", "à¦¸à§", "à¦®", "à¦¬à§", "à¦¬à§", "à¦¶à§", "à¦¶"],
  short: ["à¦°à¦¬à¦¿", "à¦¸à§à¦®", "à¦®à¦à§à¦à¦²", "à¦¬à§à¦§", "à¦¬à§à¦¹", "à¦¶à§à¦à§à¦°", "à¦¶à¦¨à¦¿"],
  abbreviated: ["à¦°à¦¬à¦¿", "à¦¸à§à¦®", "à¦®à¦à§à¦à¦²", "à¦¬à§à¦§", "à¦¬à§à¦¹", "à¦¶à§à¦à§à¦°", "à¦¶à¦¨à¦¿"],
  wide: [
    "à¦°à¦¬à¦¿à¦¬à¦¾à¦°",
    "à¦¸à§à¦®à¦¬à¦¾à¦°",
    "à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°",
    "à¦¬à§à¦§à¦¬à¦¾à¦°",
    "à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦° ",
    "à¦¶à§à¦à§à¦°à¦¬à¦¾à¦°",
    "à¦¶à¦¨à¦¿à¦¬à¦¾à¦°",
  ],
};

const dayPeriodValues$19 = {
  narrow: {
    am: "à¦ªà§",
    pm: "à¦à¦ª",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
  abbreviated: {
    am: "à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨",
    pm: "à¦à¦ªà¦°à¦¾à¦¹à§à¦¨",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
  wide: {
    am: "à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨",
    pm: "à¦à¦ªà¦°à¦¾à¦¹à§à¦¨",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
};

const formattingDayPeriodValues$W = {
  narrow: {
    am: "à¦ªà§",
    pm: "à¦à¦ª",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
  abbreviated: {
    am: "à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨",
    pm: "à¦à¦ªà¦°à¦¾à¦¹à§à¦¨",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
  wide: {
    am: "à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨",
    pm: "à¦à¦ªà¦°à¦¾à¦¹à§à¦¨",
    midnight: "à¦®à¦§à§à¦¯à¦°à¦¾à¦¤",
    noon: "à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨",
    morning: "à¦¸à¦à¦¾à¦²",
    afternoon: "à¦¬à¦¿à¦à¦¾à¦²",
    evening: "à¦¸à¦¨à§à¦§à§à¦¯à¦¾",
    night: "à¦°à¦¾à¦¤",
  },
};

function dateOrdinalNumber(number, localeNumber) {
  if (number > 18 && number <= 31) {
    return localeNumber + "à¦¶à§";
  } else {
    switch (number) {
      case 1:
        return localeNumber + "à¦²à¦¾";
      case 2:
      case 3:
        return localeNumber + "à¦°à¦¾";
      case 4:
        return localeNumber + "à¦ à¦¾";
      default:
        return localeNumber + "à¦";
    }
  }
}

const ordinalNumber$19 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const localeNumber = numberToLocale$1(number);
  const unit = options?.unit;

  if (unit === "date") {
    return dateOrdinalNumber(number, localeNumber);
  }
  if (number > 10 || number === 0) return localeNumber + "à¦¤à¦®";

  const rem10 = number % 10;
  switch (rem10) {
    case 2:
    case 3:
      return localeNumber + "à§";
    case 4:
      return localeNumber + "à¦°à§à¦¥";
    case 6:
      return localeNumber + "à¦·à§à¦ ";
    default:
      return localeNumber + "à¦®";
  }
};

// function localeToNumber(locale: string): number {
//   const enNumber = locale.toString().replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function (match) {
//     return numberValues.number[match as keyof typeof numberValues.number]
//   })
//   return Number(enNumber)
// }

function numberToLocale$1(enNumber) {
  return enNumber.toString().replace(/\d/g, function (match) {
    return numberValues$1.locale[match];
  });
}

(localize$19.localize = {
  ordinalNumber: ordinalNumber$19,

  era: (0, _index$8W.buildLocalizeFn)({
    values: eraValues$19,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8W.buildLocalizeFn)({
    values: quarterValues$19,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8W.buildLocalizeFn)({
    values: monthValues$19,
    defaultWidth: "wide",
  }),

  day: (0, _index$8W.buildLocalizeFn)({
    values: dayValues$19,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8W.buildLocalizeFn)({
    values: dayPeriodValues$19,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$W,
    defaultFormattingWidth: "wide",
  }),
});

formatDistance$2l.formatDistance = void 0;
var _index$8V = localize$19;

const formatDistanceLocale$18 = {
  lessThanXSeconds: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦¸à§à¦à§à¦¨à§à¦¡",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦¸à§à¦à§à¦¨à§à¦¡",
  },

  xSeconds: {
    one: "à§§ à¦¸à§à¦à§à¦¨à§à¦¡",
    other: "{{count}} à¦¸à§à¦à§à¦¨à§à¦¡",
  },

  halfAMinute: "à¦à¦§ à¦®à¦¿à¦¨à¦¿à¦",

  lessThanXMinutes: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦®à¦¿à¦¨à¦¿à¦",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦®à¦¿à¦¨à¦¿à¦",
  },

  xMinutes: {
    one: "à§§ à¦®à¦¿à¦¨à¦¿à¦",
    other: "{{count}} à¦®à¦¿à¦¨à¦¿à¦",
  },

  aboutXHours: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦à¦¨à§à¦à¦¾",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦à¦¨à§à¦à¦¾",
  },

  xHours: {
    one: "à§§ à¦à¦¨à§à¦à¦¾",
    other: "{{count}} à¦à¦¨à§à¦à¦¾",
  },

  xDays: {
    one: "à§§ à¦¦à¦¿à¦¨",
    other: "{{count}} à¦¦à¦¿à¦¨",
  },

  aboutXWeeks: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦¸à¦ªà§à¦¤à¦¾à¦¹",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦¸à¦ªà§à¦¤à¦¾à¦¹",
  },

  xWeeks: {
    one: "à§§ à¦¸à¦ªà§à¦¤à¦¾à¦¹",
    other: "{{count}} à¦¸à¦ªà§à¦¤à¦¾à¦¹",
  },

  aboutXMonths: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦®à¦¾à¦¸",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦®à¦¾à¦¸",
  },

  xMonths: {
    one: "à§§ à¦®à¦¾à¦¸",
    other: "{{count}} à¦®à¦¾à¦¸",
  },

  aboutXYears: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦¬à¦à¦°",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦¬à¦à¦°",
  },

  xYears: {
    one: "à§§ à¦¬à¦à¦°",
    other: "{{count}} à¦¬à¦à¦°",
  },

  overXYears: {
    one: "à§§ à¦¬à¦à¦°à§à¦° à¦¬à§à¦¶à¦¿",
    other: "{{count}} à¦¬à¦à¦°à§à¦° à¦¬à§à¦¶à¦¿",
  },

  almostXYears: {
    one: "à¦ªà§à¦°à¦¾à§ à§§ à¦¬à¦à¦°",
    other: "à¦ªà§à¦°à¦¾à§ {{count}} à¦¬à¦à¦°",
  },
};

const formatDistance$2k = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$18[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      (0, _index$8V.numberToLocale)(count),
    );
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " à¦à¦° à¦®à¦§à§à¦¯à§";
    } else {
      return result + " à¦à¦à§";
    }
  }

  return result;
};
formatDistance$2l.formatDistance = formatDistance$2k;

var formatLong$1h = {};

formatLong$1h.formatLong = void 0;
var _index$8U = buildFormatLongFn$1;

const dateFormats$1h = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$1h = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1h = {
  full: "{{date}} {{time}} 'à¦¸à¦®à§'",
  long: "{{date}} {{time}} 'à¦¸à¦®à§'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1h.formatLong = {
  date: (0, _index$8U.buildFormatLongFn)({
    formats: dateFormats$1h,
    defaultWidth: "full",
  }),

  time: (0, _index$8U.buildFormatLongFn)({
    formats: timeFormats$1h,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8U.buildFormatLongFn)({
    formats: dateTimeFormats$1h,
    defaultWidth: "full",
  }),
});

var formatRelative$2l = {};

formatRelative$2l.formatRelative = void 0;

const formatRelativeLocale$19 = {
  lastWeek: "'à¦à¦¤' eeee 'à¦¸à¦®à§' p",
  yesterday: "'à¦à¦¤à¦à¦¾à¦²' 'à¦¸à¦®à§' p",
  today: "'à¦à¦' 'à¦¸à¦®à§' p",
  tomorrow: "'à¦à¦à¦¾à¦®à§à¦à¦¾à¦²' 'à¦¸à¦®à§' p",
  nextWeek: "eeee 'à¦¸à¦®à§' p",
  other: "P",
};

const formatRelative$2k = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$19[token];
formatRelative$2l.formatRelative = formatRelative$2k;

var match$18 = {};

match$18.match = void 0;

var _index$8T = buildMatchFn$1;
var _index2$3$ = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$18 = /^(\d+)(à¦®|à§|à¦°à§à¦¥|à¦·à§à¦ |à¦¶à§|à¦|à¦¤à¦®)?/i;
const parseOrdinalNumberPattern$18 = /\d+/i;

const matchEraPatterns$18 = {
  narrow: /^(à¦à§à¦°à¦¿à¦à¦ªà§à¦|à¦à§à¦°à¦¿à¦)/i,
  abbreviated: /^(à¦à§à¦°à¦¿à¦à¦ªà§à¦°à§à¦¬|à¦à§à¦°à¦¿à¦)/i,
  wide: /^(à¦à§à¦°à¦¿à¦¸à§à¦à¦ªà§à¦°à§à¦¬|à¦à§à¦°à¦¿à¦¸à§à¦à¦¾à¦¬à§à¦¦)/i,
};
const parseEraPatterns$18 = {
  narrow: [/^à¦à§à¦°à¦¿à¦à¦ªà§à¦/i, /^à¦à§à¦°à¦¿à¦/i],
  abbreviated: [/^à¦à§à¦°à¦¿à¦à¦ªà§à¦°à§à¦¬/i, /^à¦à§à¦°à¦¿à¦/i],
  wide: [/^à¦à§à¦°à¦¿à¦¸à§à¦à¦ªà§à¦°à§à¦¬/i, /^à¦à§à¦°à¦¿à¦¸à§à¦à¦¾à¦¬à§à¦¦/i],
};

const matchQuarterPatterns$18 = {
  narrow: /^[à§§à§¨à§©à§ª]/i,
  abbreviated: /^[à§§à§¨à§©à§ª]à¦¤à§à¦°à§/i,
  wide: /^[à§§à§¨à§©à§ª](à¦®|à§|à¦°à§à¦¥)? à¦¤à§à¦°à§à¦®à¦¾à¦¸à¦¿à¦/i,
};
const parseQuarterPatterns$18 = {
  any: [/à§§/i, /à§¨/i, /à§©/i, /à§ª/i],
};

const matchMonthPatterns$18 = {
  narrow:
    /^(à¦à¦¾à¦¨à§|à¦«à§à¦¬à§à¦°à§|à¦®à¦¾à¦°à§à¦|à¦à¦ªà§à¦°à¦¿à¦²|à¦®à§|à¦à§à¦¨|à¦à§à¦²à¦¾à¦|à¦à¦à¦¸à§à¦|à¦¸à§à¦ªà§à¦|à¦à¦à§à¦à§|à¦¨à¦­à§|à¦¡à¦¿à¦¸à§)/i,
  abbreviated:
    /^(à¦à¦¾à¦¨à§|à¦«à§à¦¬à§à¦°à§|à¦®à¦¾à¦°à§à¦|à¦à¦ªà§à¦°à¦¿à¦²|à¦®à§|à¦à§à¦¨|à¦à§à¦²à¦¾à¦|à¦à¦à¦¸à§à¦|à¦¸à§à¦ªà§à¦|à¦à¦à§à¦à§|à¦¨à¦­à§|à¦¡à¦¿à¦¸à§)/i,
  wide: /^(à¦à¦¾à¦¨à§à§à¦¾à¦°à¦¿|à¦«à§à¦¬à§à¦°à§à§à¦¾à¦°à¦¿|à¦®à¦¾à¦°à§à¦|à¦à¦ªà§à¦°à¦¿à¦²|à¦®à§|à¦à§à¦¨|à¦à§à¦²à¦¾à¦|à¦à¦à¦¸à§à¦|à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦°|à¦à¦à§à¦à§à¦¬à¦°|à¦¨à¦­à§à¦®à§à¦¬à¦°|à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦°)/i,
};
const parseMonthPatterns$18 = {
  any: [
    /^à¦à¦¾à¦¨à§/i,
    /^à¦«à§à¦¬à§à¦°à§/i,
    /^à¦®à¦¾à¦°à§à¦/i,
    /^à¦à¦ªà§à¦°à¦¿à¦²/i,
    /^à¦®à§/i,
    /^à¦à§à¦¨/i,
    /^à¦à§à¦²à¦¾à¦/i,
    /^à¦à¦à¦¸à§à¦/i,
    /^à¦¸à§à¦ªà§à¦/i,
    /^à¦à¦à§à¦à§/i,
    /^à¦¨à¦­à§/i,
    /^à¦¡à¦¿à¦¸à§/i,
  ],
};

const matchDayPatterns$18 = {
  narrow: /^(à¦°|à¦¸à§|à¦®|à¦¬à§|à¦¬à§|à¦¶à§|à¦¶)+/i,
  short: /^(à¦°à¦¬à¦¿|à¦¸à§à¦®|à¦®à¦à§à¦à¦²|à¦¬à§à¦§|à¦¬à§à¦¹|à¦¶à§à¦à§à¦°|à¦¶à¦¨à¦¿)+/i,
  abbreviated: /^(à¦°à¦¬à¦¿|à¦¸à§à¦®|à¦®à¦à§à¦à¦²|à¦¬à§à¦§|à¦¬à§à¦¹|à¦¶à§à¦à§à¦°|à¦¶à¦¨à¦¿)+/i,
  wide: /^(à¦°à¦¬à¦¿à¦¬à¦¾à¦°|à¦¸à§à¦®à¦¬à¦¾à¦°|à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°|à¦¬à§à¦§à¦¬à¦¾à¦°|à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦° |à¦¶à§à¦à§à¦°à¦¬à¦¾à¦°|à¦¶à¦¨à¦¿à¦¬à¦¾à¦°)+/i,
};
const parseDayPatterns$18 = {
  narrow: [/^à¦°/i, /^à¦¸à§/i, /^à¦®/i, /^à¦¬à§/i, /^à¦¬à§/i, /^à¦¶à§/i, /^à¦¶/i],
  short: [/^à¦°à¦¬à¦¿/i, /^à¦¸à§à¦®/i, /^à¦®à¦à§à¦à¦²/i, /^à¦¬à§à¦§/i, /^à¦¬à§à¦¹/i, /^à¦¶à§à¦à§à¦°/i, /^à¦¶à¦¨à¦¿/i],

  abbreviated: [
    /^à¦°à¦¬à¦¿/i,
    /^à¦¸à§à¦®/i,
    /^à¦®à¦à§à¦à¦²/i,
    /^à¦¬à§à¦§/i,
    /^à¦¬à§à¦¹/i,
    /^à¦¶à§à¦à§à¦°/i,
    /^à¦¶à¦¨à¦¿/i,
  ],

  wide: [
    /^à¦°à¦¬à¦¿à¦¬à¦¾à¦°/i,
    /^à¦¸à§à¦®à¦¬à¦¾à¦°/i,
    /^à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°/i,
    /^à¦¬à§à¦§à¦¬à¦¾à¦°/i,
    /^à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à¦¿à¦¬à¦¾à¦° /i,
    /^à¦¶à§à¦à§à¦°à¦¬à¦¾à¦°/i,
    /^à¦¶à¦¨à¦¿à¦¬à¦¾à¦°/i,
  ],
};

const matchDayPeriodPatterns$18 = {
  narrow: /^(à¦ªà§|à¦à¦ª|à¦®à¦§à§à¦¯à¦°à¦¾à¦¤|à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨|à¦¸à¦à¦¾à¦²|à¦¬à¦¿à¦à¦¾à¦²|à¦¸à¦¨à§à¦§à§à¦¯à¦¾|à¦°à¦¾à¦¤)/i,
  abbreviated: /^(à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨|à¦à¦ªà¦°à¦¾à¦¹à§à¦¨|à¦®à¦§à§à¦¯à¦°à¦¾à¦¤|à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨|à¦¸à¦à¦¾à¦²|à¦¬à¦¿à¦à¦¾à¦²|à¦¸à¦¨à§à¦§à§à¦¯à¦¾|à¦°à¦¾à¦¤)/i,
  wide: /^(à¦ªà§à¦°à§à¦¬à¦¾à¦¹à§à¦¨|à¦à¦ªà¦°à¦¾à¦¹à§à¦¨|à¦®à¦§à§à¦¯à¦°à¦¾à¦¤|à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨|à¦¸à¦à¦¾à¦²|à¦¬à¦¿à¦à¦¾à¦²|à¦¸à¦¨à§à¦§à§à¦¯à¦¾|à¦°à¦¾à¦¤)/i,
};
const parseDayPeriodPatterns$18 = {
  any: {
    am: /^à¦ªà§/i,
    pm: /^à¦à¦ª/i,
    midnight: /^à¦®à¦§à§à¦¯à¦°à¦¾à¦¤/i,
    noon: /^à¦®à¦§à§à¦¯à¦¾à¦¹à§à¦¨/i,
    morning: /à¦¸à¦à¦¾à¦²/i,
    afternoon: /à¦¬à¦¿à¦à¦¾à¦²/i,
    evening: /à¦¸à¦¨à§à¦§à§à¦¯à¦¾/i,
    night: /à¦°à¦¾à¦¤/i,
  },
};

(match$18.match = {
  ordinalNumber: (0, _index2$3$.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$18,
    parsePattern: parseOrdinalNumberPattern$18,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8T.buildMatchFn)({
    matchPatterns: matchEraPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$18,
    defaultParseWidth: "wide",
  }),

  quarter: (0, _index$8T.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$18,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8T.buildMatchFn)({
    matchPatterns: matchMonthPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$18,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8T.buildMatchFn)({
    matchPatterns: matchDayPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$18,
    defaultParseWidth: "wide",
  }),

  dayPeriod: (0, _index$8T.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$18,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$18,
    defaultParseWidth: "any",
  }),
});

bn.bn = void 0;
var _index$8S = formatDistance$2l;
var _index2$3_ = formatLong$1h;
var _index3$26 = formatRelative$2l;
var _index4$1B = localize$19;
var _index5$1s = match$18;

/**
 * @category Locales
 * @summary Bengali locale.
 * @language Bengali
 * @iso-639-2 ben
 * @author Touhidur Rahman [@touhidrahman](https://github.com/touhidrahman)
 * @author Farhad Yasir [@nutboltu](https://github.com/nutboltu)
 */
(bn.bn = {
  code: "bn",
  formatDistance: _index$8S.formatDistance,
  formatLong: _index2$3_.formatLong,
  formatRelative: _index3$26.formatRelative,
  localize: _index4$1B.localize,
  match: _index5$1s.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var bs = {};

var formatDistance$2j = {};

formatDistance$2j.formatDistance = void 0;

const formatDistanceLocale$17 = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu",
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi",
  },

  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu",
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi",
  },

  halfAMinute: "pola minute",

  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu",
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta",
  },

  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu",
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta",
  },

  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat",
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati",
  },

  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat",
    },
    dual: "{{count}} sata",
    other: "{{count}} sati",
  },

  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan",
    },
    dual: "{{count}} dana",
    other: "{{count}} dana",
  },

  aboutXWeeks: {
    one: {
      standalone: "oko 1 sedmicu",
      withPrepositionAgo: "oko 1 sedmicu",
      withPrepositionIn: "oko 1 sedmicu",
    },
    dual: "oko {{count}} sedmice",
    other: "oko {{count}} sedmice",
  },

  xWeeks: {
    one: {
      standalone: "1 sedmicu",
      withPrepositionAgo: "1 sedmicu",
      withPrepositionIn: "1 sedmicu",
    },
    dual: "{{count}} sedmice",
    other: "{{count}} sedmice",
  },

  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec",
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci",
  },

  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec",
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci",
  },

  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu",
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina",
  },

  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu",
    },
    dual: "{{count}} godine",
    other: "{{count}} godina",
  },

  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu",
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina",
  },

  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu",
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina",
  },
};

const formatDistance$2i = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$17[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (
    count % 10 > 1 &&
    count % 10 < 5 && // if last digit is between 2 and 4
    String(count).substr(-2, 1) !== "1" // unless the 2nd to last digit is "1"
  ) {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }

  return result;
};
formatDistance$2j.formatDistance = formatDistance$2i;

var formatLong$1g = {};

formatLong$1g.formatLong = void 0;
var _index$8R = buildFormatLongFn$1;

const dateFormats$1g = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy.",
};

const timeFormats$1g = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1g = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$1g.formatLong = {
  date: (0, _index$8R.buildFormatLongFn)({
    formats: dateFormats$1g,
    defaultWidth: "full",
  }),

  time: (0, _index$8R.buildFormatLongFn)({
    formats: timeFormats$1g,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8R.buildFormatLongFn)({
    formats: dateTimeFormats$1g,
    defaultWidth: "full",
  }),
});

var formatRelative$2j = {};

formatRelative$2j.formatRelative = void 0;

const formatRelativeLocale$18 = {
  lastWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'proÅ¡le nedjelje u' p";
      case 3:
        return "'proÅ¡le srijede u' p";
      case 6:
        return "'proÅ¡le subote u' p";
      default:
        return "'proÅ¡li' EEEE 'u' p";
    }
  },
  yesterday: "'juÄe u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'sljedeÄe nedjelje u' p";
      case 3:
        return "'sljedeÄu srijedu u' p";
      case 6:
        return "'sljedeÄu subotu u' p";
      default:
        return "'sljedeÄi' EEEE 'u' p";
    }
  },
  other: "P",
};

const formatRelative$2i = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$18[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$2j.formatRelative = formatRelative$2i;

var localize$18 = {};

localize$18.localize = void 0;
var _index$8Q = buildLocalizeFn$1;

const eraValues$18 = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Prije Hrista", "Poslije Hrista"],
};

const quarterValues$18 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$18 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar",
  ],
};

const formattingMonthValues$g = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar",
  ],
};

const dayValues$18 = {
  narrow: ["N", "P", "U", "S", "Ä", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "Äet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "Äet", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "Äetvrtak",
    "petak",
    "subota",
  ],
};

const dayPeriodValues$18 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uveÄe",
    night: "noÄu",
  },
};

const formattingDayPeriodValues$V = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uveÄe",
    night: "noÄu",
  },
};

const ordinalNumber$18 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return String(number) + ".";
};

(localize$18.localize = {
  ordinalNumber: ordinalNumber$18,

  era: (0, _index$8Q.buildLocalizeFn)({
    values: eraValues$18,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8Q.buildLocalizeFn)({
    values: quarterValues$18,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8Q.buildLocalizeFn)({
    values: monthValues$18,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$g,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$8Q.buildLocalizeFn)({
    values: dayValues$18,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8Q.buildLocalizeFn)({
    values: dayPeriodValues$18,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$V,
    defaultFormattingWidth: "wide",
  }),
});

var match$17 = {};

match$17.match = void 0;

var _index$8P = buildMatchFn$1;
var _index2$3Z = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$17 = /^(\d+)\./i;
const parseOrdinalNumberPattern$17 = /\d+/i;

const matchEraPatterns$17 = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i,
};
const parseEraPatterns$17 = {
  any: [/^pr/i, /^(po|nova)/i],
};

const matchQuarterPatterns$17 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i,
};
const parseQuarterPatterns$17 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$17 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i,
};
const parseMonthPatterns$17 = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$17 = {
  narrow: /^[npusÄc]/i,
  short: /^(ned|pon|uto|sre|(Äet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(Äet|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(Äetvrtak|cetvrtak)|petak|subota)/i,
};
const parseDayPatterns$17 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$17 = {
  any: /^(am|pm|ponoc|ponoÄ|(po)?podne|uvece|uveÄe|noÄu|poslije podne|ujutru)/i,
};
const parseDayPeriodPatterns$17 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(uvece|uveÄe)/i,
    night: /(nocu|noÄu)/i,
  },
};

(match$17.match = {
  ordinalNumber: (0, _index2$3Z.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$17,
    parsePattern: parseOrdinalNumberPattern$17,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8P.buildMatchFn)({
    matchPatterns: matchEraPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$17,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8P.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$17,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8P.buildMatchFn)({
    matchPatterns: matchMonthPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$17,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8P.buildMatchFn)({
    matchPatterns: matchDayPatterns$17,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$17,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8P.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$17,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$17,
    defaultParseWidth: "any",
  }),
});

bs.bs = void 0;
var _index$8O = formatDistance$2j;
var _index2$3Y = formatLong$1g;
var _index3$25 = formatRelative$2j;
var _index4$1A = localize$18;
var _index5$1r = match$17;

/**
 * @category Locales
 * @summary Bosnian locale.
 * @language Bosnian
 * @iso-639-2 bos
 * @author Branislav LaziÄ [@branislavlazic](https://github.com/branislavlazic)
 */
(bs.bs = {
  code: "bs",
  formatDistance: _index$8O.formatDistance,
  formatLong: _index2$3Y.formatLong,
  formatRelative: _index3$25.formatRelative,
  localize: _index4$1A.localize,
  match: _index5$1r.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var ca = {};

var formatDistance$2h = {};

formatDistance$2h.formatDistance = void 0;

/**
 * Davant de les xifres que es diuen amb vocal inicial, 1 i 11, s'apostrofen els articles el i la i la preposiciÃ³ de igual que si estiguessin escrits amb lletres.
 *    l'1 de juliol ('l'u')
 *    l'11 de novembre ('l'onze')
 *    l'11a clÃ usula del contracte ('l'onzena')
 *    la contractaciÃ³ d'11 jugadors ('d'onze')
 *    l'aval d'11.000 socis ('d'onze mil')
 *
 * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=apostrofaci%25F3+davant+xifres&action=Principal&method=detall_completa&numPagina=1&idHit=11236&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=11236&titol=apostrofaci%F3%20davant%20de%20xifres%20%2F%20apostrofaci%F3%20davant%20de%201%20i%2011&numeroResultat=1&clickLink=detall&tipusCerca=cerca.normes
 */

const formatDistanceLocale$16 = {
  lessThanXSeconds: {
    one: "menys d'un segon",
    eleven: "menys d'onze segons",
    other: "menys de {{count}} segons",
  },

  xSeconds: {
    one: "1 segon",
    other: "{{count}} segons",
  },

  halfAMinute: "mig minut",

  lessThanXMinutes: {
    one: "menys d'un minut",
    eleven: "menys d'onze minuts",
    other: "menys de {{count}} minuts",
  },

  xMinutes: {
    one: "1 minut",
    other: "{{count}} minuts",
  },

  aboutXHours: {
    one: "aproximadament una hora",
    other: "aproximadament {{count}} hores",
  },

  xHours: {
    one: "1 hora",
    other: "{{count}} hores",
  },

  xDays: {
    one: "1 dia",
    other: "{{count}} dies",
  },

  aboutXWeeks: {
    one: "aproximadament una setmana",
    other: "aproximadament {{count}} setmanes",
  },

  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanes",
  },

  aboutXMonths: {
    one: "aproximadament un mes",
    other: "aproximadament {{count}} mesos",
  },

  xMonths: {
    one: "1 mes",
    other: "{{count}} mesos",
  },

  aboutXYears: {
    one: "aproximadament un any",
    other: "aproximadament {{count}} anys",
  },

  xYears: {
    one: "1 any",
    other: "{{count}} anys",
  },

  overXYears: {
    one: "mÃ©s d'un any",
    eleven: "mÃ©s d'onze anys",
    other: "mÃ©s de {{count}} anys",
  },

  almostXYears: {
    one: "gairebÃ© un any",
    other: "gairebÃ© {{count}} anys",
  },
};

const formatDistance$2g = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$16[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 11 && tokenValue.eleven) {
    result = tokenValue.eleven;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "fa " + result;
    }
  }

  return result;
};
formatDistance$2h.formatDistance = formatDistance$2g;

var formatLong$1f = {};

formatLong$1f.formatLong = void 0;
var _index$8N = buildFormatLongFn$1;

const dateFormats$1f = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$1f = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1f = {
  full: "{{date}} 'a les' {{time}}",
  long: "{{date}} 'a les' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1f.formatLong = {
  date: (0, _index$8N.buildFormatLongFn)({
    formats: dateFormats$1f,
    defaultWidth: "full",
  }),

  time: (0, _index$8N.buildFormatLongFn)({
    formats: timeFormats$1f,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8N.buildFormatLongFn)({
    formats: dateTimeFormats$1f,
    defaultWidth: "full",
  }),
});

var formatRelative$2h = {};

formatRelative$2h.formatRelative = void 0;

const formatRelativeLocale$17 = {
  lastWeek: "'el' eeee 'passat a la' LT",
  yesterday: "'ahir a la' p",
  today: "'avui a la' p",
  tomorrow: "'demÃ  a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P",
};

const formatRelativeLocalePlural$3 = {
  lastWeek: "'el' eeee 'passat a les' p",
  yesterday: "'ahir a les' p",
  today: "'avui a les' p",
  tomorrow: "'demÃ  a les' p",
  nextWeek: "eeee 'a les' p",
  other: "P",
};

const formatRelative$2g = (token, date, _baseDate, _options) => {
  if (date.getHours() !== 1) {
    return formatRelativeLocalePlural$3[token];
  }
  return formatRelativeLocale$17[token];
};
formatRelative$2h.formatRelative = formatRelative$2g;

var localize$17 = {};

localize$17.localize = void 0;
var _index$8M = buildLocalizeFn$1;

/**
 * General information
 * Reference: https://aplicacions.llengua.gencat.cat
 * Reference: https://www.uoc.edu/portal/ca/servei-linguistic/convencions/abreviacions/simbols/simbols-habituals.html
 */

/**
 * Abans de Crist: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=abans+de+crist&action=Principal&method=detall_completa&numPagina=1&idHit=6876&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=6876&titol=abans%20de%20Crist%20(abreviatura)%20/%20abans%20de%20Crist%20(sigla)&numeroResultat=1&clickLink=detall&tipusCerca=cerca.fitxes
 * Desprest de Crist: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=despr%E9s+de+crist&action=Principal&method=detall_completa&numPagina=1&idHit=6879&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=6879&titol=despr%E9s%20de%20Crist%20(sigla)%20/%20despr%E9s%20de%20Crist%20(abreviatura)&numeroResultat=1&clickLink=detall&tipusCerca=cerca.fitxes
 */
const eraValues$17 = {
  narrow: ["aC", "dC"],
  abbreviated: ["a. de C.", "d. de C."],
  wide: ["abans de Crist", "desprÃ©s de Crist"],
};

const quarterValues$17 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1r trimestre", "2n trimestre", "3r trimestre", "4t trimestre"],
};

/**
 * Dins d'un text convÃ© fer servir la forma sencera dels mesos, ja que sempre Ã©s mÃ©s clar el mot sencer que l'abreviatura, encara que aquesta sigui forÃ§a coneguda.
 * Cal reservar, doncs, les abreviatures per a les llistes o classificacions, els grÃ fics, les taules o quadres estadÃ­stics, els textos publicitaris, etc.
 *
 * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=abreviacions+mesos&action=Principal&method=detall_completa&numPagina=1&idHit=8402&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=8402&titol=abreviatures%20dels%20mesos%20de%20l%27any&numeroResultat=5&clickLink=detall&tipusCerca=cerca.fitxes
 */
const monthValues$17 = {
  narrow: [
    "GN",
    "FB",
    "MÃ",
    "AB",
    "MG",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DS",
  ],

  /**
   * Les abreviatures dels mesos de l'any es formen seguint una de les normes generals de formaciÃ³ d'abreviatures.
   * S'escriu la primera sÃ­lÂ·laba i les consonants de la sÃ­lÂ·laba segÃ¼ent anteriors a la primera vocal.
   * Els mesos de marÃ§, maig i juny no s'abreugen perquÃ¨ sÃ³n paraules d'una sola sÃ­lÂ·laba.
   */
  abbreviated: [
    "gen.",
    "febr.",
    "marÃ§",
    "abr.",
    "maig",
    "juny",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "des.",
  ],

  wide: [
    "gener",
    "febrer",
    "marÃ§",
    "abril",
    "maig",
    "juny",
    "juliol",
    "agost",
    "setembre",
    "octubre",
    "novembre",
    "desembre",
  ],
};

/**
 * Les abreviatures dels dies de la setmana comencen totes amb la lletra d.
 * Tot seguit porten la consonant segÃ¼ent a la i, excepte en el cas de dimarts, dimecres i diumenge, en quÃ¨ aquesta consonant Ã©s la m i, per tant, hi podria haver confusiÃ³.
 * Per evitar-ho, s'ha substituÃ¯t la m per una t (en el cas de dimarts), una c (en el cas de dimecres) i una g (en el cas de diumenge), respectivament.
 *
 * Seguint la norma general d'Ãºs de les abreviatures, les dels dies de la setmana sempre porten punt final.
 * Igualment, van amb la primera lletra en majÃºscula quan la paraula sencera tambÃ© hi aniria.
 * En canvi, van amb la primera lletra en minÃºscula quan la inicial de la paraula sencera tambÃ© hi aniria.
 *
 * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=abreviatures+dies&action=Principal&method=detall_completa&numPagina=1&idHit=8387&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=8387&titol=abreviatures%20dels%20dies%20de%20la%20setmana&numeroResultat=1&clickLink=detall&tipusCerca=cerca.tot
 */
const dayValues$17 = {
  narrow: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  wide: [
    "diumenge",
    "dilluns",
    "dimarts",
    "dimecres",
    "dijous",
    "divendres",
    "dissabte",
  ],
};

/**
 * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?action=Principal&method=detall&input_cercar=parts+del+dia&numPagina=1&database=FITXES_PUB&idFont=12801&idHit=12801&tipusFont=Fitxes+de+l%27Optimot&numeroResultat=1&databases_avansada=&categories_avansada=&clickLink=detall&titol=Nom+de+les+parts+del+dia&tematica=&tipusCerca=cerca.fitxes
 */
const dayPeriodValues$17 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matÃ­",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit",
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matÃ­",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit",
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matÃ­",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit",
  },
};

const formattingDayPeriodValues$U = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matÃ­",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matÃ­",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit",
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matÃ­",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit",
  },
};

/**
 * Quan van en singular, els nombres ordinals es representen, en forma dâabreviatura, amb la xifra seguida de lâÃºltima lletra del mot desplegat.
 * Ãs optatiu posar punt desprÃ©s de la lletra.
 *
 * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/pdf/abrevia.pdf#page=18
 */
const ordinalNumber$17 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "r";
      case 2:
        return number + "n";
      case 3:
        return number + "r";
      case 4:
        return number + "t";
    }
  }
  return number + "Ã¨";
};

(localize$17.localize = {
  ordinalNumber: ordinalNumber$17,

  era: (0, _index$8M.buildLocalizeFn)({
    values: eraValues$17,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8M.buildLocalizeFn)({
    values: quarterValues$17,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8M.buildLocalizeFn)({
    values: monthValues$17,
    defaultWidth: "wide",
  }),

  day: (0, _index$8M.buildLocalizeFn)({
    values: dayValues$17,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8M.buildLocalizeFn)({
    values: dayPeriodValues$17,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$U,
    defaultFormattingWidth: "wide",
  }),
});

var match$16 = {};

match$16.match = void 0;

var _index$8L = buildMatchFn$1;
var _index2$3X = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$16 = /^(\d+)(Ã¨|r|n|r|t)?/i;
const parseOrdinalNumberPattern$16 = /\d+/i;

const matchEraPatterns$16 = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a. de C.|d. de C.)/i,
  wide: /^(abans de Crist|despr[eÃ©]s de Crist)/i,
};
const parseEraPatterns$16 = {
  narrow: [/^aC/i, /^dC/i],
  abbreviated: [/^(a. de C.)/i, /^(d. de C.)/i],
  wide: [/^(abans de Crist)/i, /^(despr[eÃ©]s de Crist)/i],
};

const matchQuarterPatterns$16 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](Ã¨|r|n|r|t)? trimestre/i,
};
const parseQuarterPatterns$16 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$16 = {
  narrow: /^(GN|FB|MÃ|AB|MG|JN|JL|AG|ST|OC|NV|DS)/i,
  abbreviated:
    /^(gen.|febr.|marÃ§|abr.|maig|juny|jul.|ag.|set.|oct.|nov.|des.)/i,
  wide: /^(gener|febrer|marÃ§|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)/i,
};
const parseMonthPatterns$16 = {
  narrow: [
    /^GN/i,
    /^FB/i,
    /^MÃ/i,
    /^AB/i,
    /^MG/i,
    /^JN/i,
    /^JL/i,
    /^AG/i,
    /^ST/i,
    /^OC/i,
    /^NV/i,
    /^DS/i,
  ],

  abbreviated: [
    /^gen./i,
    /^febr./i,
    /^marÃ§/i,
    /^abr./i,
    /^maig/i,
    /^juny/i,
    /^jul./i,
    /^ag./i,
    /^set./i,
    /^oct./i,
    /^nov./i,
    /^des./i,
  ],

  wide: [
    /^gener/i,
    /^febrer/i,
    /^marÃ§/i,
    /^abril/i,
    /^maig/i,
    /^juny/i,
    /^juliol/i,
    /^agost/i,
    /^setembre/i,
    /^octubre/i,
    /^novembre/i,
    /^desembre/i,
  ],
};

const matchDayPatterns$16 = {
  narrow: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  short: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  abbreviated: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  wide: /^(diumenge|dilluns|dimarts|dimecres|dijous|divendres|dissabte)/i,
};
const parseDayPatterns$16 = {
  narrow: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],

  abbreviated: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],

  wide: [
    /^diumenge/i,
    /^dilluns/i,
    /^dimarts/i,
    /^dimecres/i,
    /^dijous/i,
    /^divendres/i,
    /^disssabte/i,
  ],
};

const matchDayPeriodPatterns$16 = {
  narrow: /^(a|p|mn|md|(del|de la) (matÃ­|tarda|vespre|nit))/i,
  abbreviated:
    /^([ap]\.?\s?m\.?|mitjanit|migdia|(del|de la) (matÃ­|tarda|vespre|nit))/i,
  wide: /^(ante meridiem|post meridiem|mitjanit|migdia|(del|de la) (matÃ­|tarda|vespre|nit))/i,
};
const parseDayPeriodPatterns$16 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mitjanit/i,
    noon: /^migdia/i,
    morning: /matÃ­/i,
    afternoon: /tarda/i,
    evening: /vespre/i,
    night: /nit/i,
  },
};

(match$16.match = {
  ordinalNumber: (0, _index2$3X.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$16,
    parsePattern: parseOrdinalNumberPattern$16,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8L.buildMatchFn)({
    matchPatterns: matchEraPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$16,
    defaultParseWidth: "wide",
  }),

  quarter: (0, _index$8L.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$16,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8L.buildMatchFn)({
    matchPatterns: matchMonthPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$16,
    defaultParseWidth: "wide",
  }),

  day: (0, _index$8L.buildMatchFn)({
    matchPatterns: matchDayPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$16,
    defaultParseWidth: "wide",
  }),

  dayPeriod: (0, _index$8L.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$16,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$16,
    defaultParseWidth: "any",
  }),
});

ca.ca = void 0;
var _index$8K = formatDistance$2h;
var _index2$3W = formatLong$1f;
var _index3$24 = formatRelative$2h;
var _index4$1z = localize$17;
var _index5$1q = match$16;

/**
 * @category Locales
 * @summary Catalan locale.
 * @language Catalan
 * @iso-639-2 cat
 * @author Guillermo Grau [@guigrpa](https://github.com/guigrpa)
 * @author Alex Vizcaino [@avizcaino](https://github.com/avizcaino)
 */
(ca.ca = {
  code: "ca",
  formatDistance: _index$8K.formatDistance,
  formatLong: _index2$3W.formatLong,
  formatRelative: _index3$24.formatRelative,
  localize: _index4$1z.localize,
  match: _index5$1q.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var ckb = {};

var formatDistance$2f = {};

formatDistance$2f.formatDistance = void 0;

const formatDistanceLocale$15 = {
  lessThanXSeconds: {
    one: "Ú©ÛÙØªØ± ÙÛ ÛÛÚ© ÚØ±Ú©Û",
    other: "Ú©ÛÙØªØ± ÙÛ {{count}} ÚØ±Ú©Û",
  },

  xSeconds: {
    one: "1 ÚØ±Ú©Û",
    other: "{{count}} ÚØ±Ú©Û",
  },

  halfAMinute: "ÙÛÙ Ú©Ø§ØªÚÙÛØ±",

  lessThanXMinutes: {
    one: "Ú©ÛÙØªØ± ÙÛ ÛÛÚ© Ø®ÙÙÛÚ©",
    other: "Ú©ÛÙØªØ± ÙÛ {{count}} Ø®ÙÙÛÚ©",
  },

  xMinutes: {
    one: "1 Ø®ÙÙÛÚ©",
    other: "{{count}} Ø®ÙÙÛÚ©",
  },

  aboutXHours: {
    one: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û 1 Ú©Ø§ØªÚÙÛØ±",
    other: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û {{count}} Ú©Ø§ØªÚÙÛØ±",
  },

  xHours: {
    one: "1 Ú©Ø§ØªÚÙÛØ±",
    other: "{{count}} Ú©Ø§ØªÚÙÛØ±",
  },

  xDays: {
    one: "1 ÚÛÚ",
    other: "{{count}} ÚÛÚ",
  },

  aboutXWeeks: {
    one: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û 1 ÙÛÙØªÛ",
    other: "Ø¯ÙØ±ÙØ¨ÛØ±Û {{count}} ÙÛÙØªÛ",
  },

  xWeeks: {
    one: "1 ÙÛÙØªÛ",
    other: "{{count}} ÙÛÙØªÛ",
  },

  aboutXMonths: {
    one: "Ø¯Ø§ÙØ±ÙØ¨ÛØ±Û 1 ÙØ§ÙÚ¯",
    other: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û {{count}} ÙØ§ÙÚ¯",
  },

  xMonths: {
    one: "1 ÙØ§ÙÚ¯",
    other: "{{count}} ÙØ§ÙÚ¯",
  },

  aboutXYears: {
    one: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û  1 Ø³Ø§Úµ",
    other: "Ø¯ÛÙØ±ÙØ¨ÛØ±Û {{count}} Ø³Ø§Úµ",
  },

  xYears: {
    one: "1 Ø³Ø§Úµ",
    other: "{{count}} Ø³Ø§Úµ",
  },

  overXYears: {
    one: "Ø²ÛØ§ØªØ± ÙÛ Ø³Ø§ÚµÛÚ©",
    other: "Ø²ÛØ§ØªØ± ÙÛ {{count}} Ø³Ø§Úµ",
  },

  almostXYears: {
    one: "Ø¨ÛÙØ²ÛÚ©ÛÛÛ Ø³Ø§ÚµÛÚ©  ",
    other: "Ø¨ÛÙØ²ÛÚ©ÛÛÛ {{count}} Ø³Ø§Úµ",
  },
};

const formatDistance$2e = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$15[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÙÛ ÙØ§ÙÛÛ " + result + "Ø¯Ø§";
    } else {
      return result + "Ù¾ÛØ´ Ø¦ÛØ³ØªØ§";
    }
  }

  return result;
};
formatDistance$2f.formatDistance = formatDistance$2e;

var formatLong$1e = {};

formatLong$1e.formatLong = void 0;
var _index$8J = buildFormatLongFn$1;

const dateFormats$1e = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$1e = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1e = {
  full: "{{date}} 'Ú©Ø§ØªÚÙÛØ±' {{time}}",
  long: "{{date}} 'Ú©Ø§ØªÚÙÛØ±' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1e.formatLong = {
  date: (0, _index$8J.buildFormatLongFn)({
    formats: dateFormats$1e,
    defaultWidth: "full",
  }),

  time: (0, _index$8J.buildFormatLongFn)({
    formats: timeFormats$1e,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8J.buildFormatLongFn)({
    formats: dateTimeFormats$1e,
    defaultWidth: "full",
  }),
});

var formatRelative$2f = {};

formatRelative$2f.formatRelative = void 0;

const formatRelativeLocale$16 = {
  lastWeek: "'ÙÛÙØªÛÛ ÚØ§Ø¨Ø±Ø¯ÙÙ' eeee 'Ú©Ø§ØªÚÙÛØ±' p",
  yesterday: "'Ø¯ÙÛÙÛ Ú©Ø§ØªÚÙÛØ±' p",
  today: "'Ø¦ÛÙÚÛ Ú©Ø§ØªÚÙÛØ±' p",
  tomorrow: "'Ø¨ÛÛØ§ÙÛ Ú©Ø§ØªÚÙÛØ±' p",
  nextWeek: "eeee 'Ú©Ø§ØªÚÙÛØ±' p",
  other: "P",
};

const formatRelative$2e = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$16[token];
formatRelative$2f.formatRelative = formatRelative$2e;

var localize$16 = {};

localize$16.localize = void 0;

var _index$8I = buildLocalizeFn$1;

const eraValues$16 = {
  narrow: ["Ù¾", "Ø¯"],
  abbreviated: ["Ù¾-Ø²", "Ø¯-Ø²"],
  wide: ["Ù¾ÛØ´ Ø²Ø§ÛÙ", "Ø¯ÙØ§Û Ø²Ø§ÛÙ"],
};

const quarterValues$16 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ú1Ù", "Ú2Ù", "Ú3Ù", "Ú4Ù"],
  wide: ["ÚØ§Ø±ÛÚ¯Û ÛÛÚ©ÛÙ", "ÚØ§Ø±ÛÚ¯Û Ø¯ÙÙÛÙ", "ÚØ§Ø±ÛÚ¯Û Ø³ÛÛÛÙ", "ÚØ§Ø±ÛÚ¯Û ÚÙØ§Ø±ÛÙ"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$16 = {
  narrow: [
    "Ú©-Ø¯",
    "Ø´",
    "Ø¦Ø§",
    "Ù",
    "Ù",
    "Ø­",
    "Øª",
    "Ø¦Ø§",
    "Ø¦Û",
    "ØªØ´-Û",
    "ØªØ´-Ø¯",
    "Ú©-Û",
  ],

  abbreviated: [
    "Ú©Ø§Ù-Ø¯ÙÙ",
    "Ø´ÙØ¨",
    "Ø¦Ø§Ø¯",
    "ÙÛØ³",
    "ÙØ§ÛØ³",
    "Ø­ÙØ²",
    "ØªÛÙ",
    "Ø¦Ø§Ø¨",
    "Ø¦ÛÙ",
    "ØªØ´-ÛÛÚ©",
    "ØªØ´-Ø¯ÙÙ",
    "Ú©Ø§Ù-ÛÛÚ©",
  ],

  wide: [
    "Ú©Ø§ÙÙÙÙÛ Ø¯ÙÙÛÙ",
    "Ø´ÙØ¨Ø§Øª",
    "Ø¦Ø§Ø¯Ø§Ø±",
    "ÙÛØ³Ø§Ù",
    "ÙØ§ÛØ³",
    "Ø­ÙØ²ÛÛØ±Ø§Ù",
    "ØªÛÙÙÙØ²",
    "Ø¦Ø§Ø¨",
    "Ø¦ÛÛÙÙÙ",
    "ØªØ´Ø±ÛÙÛ ÛÛÚ©ÛÙ",
    "ØªØ´Ø±ÛÙÛ Ø¯ÙÙÛÙ",
    "Ú©Ø§ÙÙÙÙÛ ÛÛÚ©ÛÙ",
  ],
};

const dayValues$16 = {
  narrow: ["Û-Ø´", "Ø¯-Ø´", "Ø³-Ø´", "Ú-Ø´", "Ù¾-Ø´", "ÙÛ", "Ø´"],
  short: ["ÛÛ-Ø´Û", "Ø¯ÙÙ-Ø´Û", "Ø³Û-Ø´Û", "ÚÙ-Ø´Û", "Ù¾Û-Ø´Û", "ÙÛÛ", "Ø´Û"],
  abbreviated: [
    "ÛÛÚ©-Ø´ÛÙ",
    "Ø¯ÙÙ-Ø´ÛÙ",
    "Ø³Û-Ø´ÛÙ",
    "ÚÙØ§Ø±-Ø´ÛÙ",
    "Ù¾ÛÙØ¬-Ø´ÛÙ",
    "ÙÛÛÙÛ",
    "Ø´ÛÙÛ",
  ],

  wide: [
    "ÛÛÚ© Ø´ÛÙÛ",
    "Ø¯ÙÙ Ø´ÛÙÛ",
    "Ø³Û Ø´ÛÙÛ",
    "ÚÙØ§Ø± Ø´ÛÙÛ",
    "Ù¾ÛÙØ¬ Ø´ÛÙÛ",
    "ÙÛÛÙÛ",
    "Ø´ÛÙÛ",
  ],
};

const dayPeriodValues$16 = {
  narrow: {
    am: "Ù¾",
    pm: "Ø¯",
    midnight: "Ù-Ø´",
    noon: "Ù",
    morning: "Ø¨ÛÛØ§ÙÛ",
    afternoon: "Ø¯ÙØ§Û ÙÛÙÛÚÛ",
    evening: "Ø¦ÛÙØ§Ø±Û",
    night: "Ø´ÛÙ",
  },
  abbreviated: {
    am: "Ù¾-Ù",
    pm: "Ø¯-Ù",
    midnight: "ÙÛÙÛ Ø´ÛÙ",
    noon: "ÙÛÙÛÚÛ",
    morning: "Ø¨ÛÛØ§ÙÛ",
    afternoon: "Ø¯ÙØ§Û ÙÛÙÛÚÛ",
    evening: "Ø¦ÛÙØ§Ø±Û",
    night: "Ø´ÛÙ",
  },
  wide: {
    am: "Ù¾ÛØ´ ÙÛÙÛÚÛ",
    pm: "Ø¯ÙØ§Û ÙÛÙÛÚÛ",
    midnight: "ÙÛÙÛ Ø´ÛÙ",
    noon: "ÙÛÙÛÚÛ",
    morning: "Ø¨ÛÛØ§ÙÛ",
    afternoon: "Ø¯ÙØ§Û ÙÛÙÛÚÛ",
    evening: "Ø¦ÛÙØ§Ø±Û",
    night: "Ø´ÛÙ",
  },
};

const formattingDayPeriodValues$T = {
  narrow: {
    am: "Ù¾",
    pm: "Ø¯",
    midnight: "Ù-Ø´",
    noon: "Ù",
    morning: "ÙÛ Ø¨ÛÛØ§ÙÛØ¯Ø§",
    afternoon: "ÙÛ Ø¯ÙØ§Û ÙÛÙÛÚÛØ¯Ø§",
    evening: "ÙÛ Ø¦ÛÙØ§Ø±ÛØ¯Ø§",
    night: "ÙÛ Ø´ÛÙØ¯Ø§",
  },
  abbreviated: {
    am: "Ù¾-Ù",
    pm: "Ø¯-Ù",
    midnight: "ÙÛÙÛ Ø´ÛÙ",
    noon: "ÙÛÙÛÚÛ",
    morning: "ÙÛ Ø¨ÛÛØ§ÙÛØ¯Ø§",
    afternoon: "ÙÛ Ø¯ÙØ§Û ÙÛÙÛÚÛØ¯Ø§",
    evening: "ÙÛ Ø¦ÛÙØ§Ø±ÛØ¯Ø§",
    night: "ÙÛ Ø´ÛÙØ¯Ø§",
  },
  wide: {
    am: "Ù¾ÛØ´ ÙÛÙÛÚÛ",
    pm: "Ø¯ÙØ§Û ÙÛÙÛÚÛ",
    midnight: "ÙÛÙÛ Ø´ÛÙ",
    noon: "ÙÛÙÛÚÛ",
    morning: "ÙÛ Ø¨ÛÛØ§ÙÛØ¯Ø§",
    afternoon: "ÙÛ Ø¯ÙØ§Û ÙÛÙÛÚÛØ¯Ø§",
    evening: "ÙÛ Ø¦ÛÙØ§Ø±ÛØ¯Ø§",
    night: "ÙÛ Ø´ÛÙØ¯Ø§",
  },
};

const ordinalNumber$16 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$16.localize = {
  ordinalNumber: ordinalNumber$16,

  era: (0, _index$8I.buildLocalizeFn)({
    values: eraValues$16,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8I.buildLocalizeFn)({
    values: quarterValues$16,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8I.buildLocalizeFn)({
    values: monthValues$16,
    defaultWidth: "wide",
  }),

  day: (0, _index$8I.buildLocalizeFn)({
    values: dayValues$16,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8I.buildLocalizeFn)({
    values: dayPeriodValues$16,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$T,
    defaultFormattingWidth: "wide",
  }),
});

var match$15 = {};

match$15.match = void 0;

var _index$8H = buildMatchFn$1;
var _index2$3V = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$15 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$15 = /\d+/i;

const matchEraPatterns$15 = {
  narrow: /^(Ù¾|Ø¯)/i,
  abbreviated: /^(Ù¾-Ø²|Ø¯.Ø²)/i,
  wide: /^(Ù¾ÛØ´ Ø²Ø§ÛÙ| Ø¯ÙØ§Û Ø²Ø§ÛÙ)/i,
};
const parseEraPatterns$15 = {
  any: [/^Ø¯/g, /^Ù¾/g],
};

const matchQuarterPatterns$15 = {
  narrow: /^[1234]/i,
  abbreviated: /^Ù[1234]Ú/i,
  wide: /^(ÛÛÚ©ÛÙ|Ø¯ÙÙÛÙ|Ø³ÛÛÛÙ| ÚÙØ§Ø±ÛÙ) (ÚØ§Ø±ÛÚ¯Û)? quarter/i,
};
const parseQuarterPatterns$15 = {
  wide: [/ÚØ§Ø±ÛÚ¯Û ÛÛÚ©ÛÙ/, /ÚØ§Ø±ÛÚ¯Û Ø¯ÙÙÛÙ/, /ÚØ§Ø±ÛÚ¯Û Ø³ÙÛÛÙ/, /ÚØ§Ø±ÛÚ¯Û ÚÙØ§Ø±ÛÙ/],

  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$15 = {
  narrow: /^(Ú©-Ø¯|Ø´|Ø¦Ø§|Ù|Ù|Ø­|Øª|Ø¦Û|ØªØ´-Û|ØªØ´-Ø¯|Ú©-Û)/i,
  abbreviated:
    /^(Ú©Ø§Ù-Ø¯ÙÙ|Ø´ÙØ¨|Ø¦Ø§Ø¯|ÙÛØ³|ÙØ§ÛØ³|Ø­ÙØ²|ØªÛÙ|Ø¦Ø§Ø¨|Ø¦ÛÙ|ØªØ´-ÛÛÚ©|ØªØ´-Ø¯ÙÙ|Ú©Ø§Ù-ÛÛÚ©)/i,
  wide: /^(Ú©Ø§ÙÙÙÙÛ Ø¯ÙÙÛÙ|Ø´ÙØ¨Ø§Øª|Ø¦Ø§Ø¯Ø§Ø±|ÙÛØ³Ø§Ù|ÙØ§ÛØ³|Ø­ÙØ²ÛÛØ±Ø§Ù|ØªÛÙÙÙØ²|Ø¦Ø§Ø¨|Ø¦ÛÛÙÙÙ|ØªØ´Ø±ÛÙÛ ÛÛÚ©ÛÙ|ØªØ´Ø±ÛÙÛ Ø¯ÙÙÛÙ|Ú©Ø§ÙÙÙÙÛ ÛÛÚ©ÛÙ)/i,
};
const parseMonthPatterns$15 = {
  narrow: [
    /^Ú©-Ø¯/i,
    /^Ø´/i,
    /^Ø¦Ø§/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø­/i,
    /^Øª/i,
    /^Ø¦Ø§/i,
    /^Ø¦Û/i,
    /^ØªØ´-Û/i,
    /^ØªØ´-Ø¯/i,
    /^Ú©-Û/i,
  ],

  any: [
    /^Ú©Ø§Ù-Ø¯ÙÙ/i,
    /^Ø´ÙØ¨/i,
    /^Ø¦Ø§Ø¯/i,
    /^ÙÛØ³/i,
    /^ÙØ§ÛØ³/i,
    /^Ø­ÙØ²/i,
    /^ØªÛÙ/i,
    /^Ø¦Ø§Ø¨/i,
    /^Ø¦ÛÙ/i,
    /^ØªØ´-ÛÛÚ©/i,
    /^ØªØ´-Ø¯ÙÙ/i,
    /^|Ú©Ø§Ù-ÛÛÚ©/i,
  ],
};

const matchDayPatterns$15 = {
  narrow: /^(Ø´|Û|Ø¯|Ø³|Ú|Ù¾|ÙÛ)/i,
  short: /^(ÛÛ-Ø´Û|Ø¯ÙÙ-Ø´Û|Ø³Û-Ø´Û|ÚÙ-Ø´Û|Ù¾Û-Ø´Û|ÙÛ|Ø´Û)/i,
  abbreviated: /^(ÛÛÚ©-Ø´ÛÙ|Ø¯ÙÙ-Ø´ÛÙ|Ø³Û-Ø´ÛÙ|ÚÙØ§Ø±-Ø´ÛÙ|Ù¾ÛÙØ®-Ø´ÛÙ|ÙÛÛÙÛ|Ø´ÛÙÛ)/i,
  wide: /^(ÛÛÚ© Ø´ÛÙÛ|Ø¯ÙÙ Ø´ÛÙÛ|Ø³Û Ø´ÛÙÛ|ÚÙØ§Ø± Ø´ÛÙÛ|Ù¾ÛÙØ¬ Ø´ÛÙÛ|ÙÛÛÙÛ|Ø´ÛÙÛ)/i,
};
const parseDayPatterns$15 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$15 = {
  narrow: /^(Ù¾|Ø¯|Ù-Ø´|Ù| (Ø¨ÛÛØ§ÙÛ|Ø¯ÙØ§Û ÙÛÙÛÚÛ|Ø¦ÛÙØ§Ø±Û|Ø´ÛÙ))/i,
  abbreviated: /^(Ù¾-Ù|Ø¯-Ù|ÙÛÙÛ Ø´ÛÙ|ÙÛÙÛÚÛ|Ø¨ÛÛØ§ÙÛ|Ø¯ÙØ§Û ÙÛÙÛÚÛ|Ø¦ÛÙØ§Ø±Û|Ø´ÛÙ)/,
  wide: /^(Ù¾ÛØ´ ÙÛÙÛÚÛ|Ø¯ÙØ§Û ÙÛÙÛÚÛ|ÙÛÙÛÚÛ|ÙÛÙÛ Ø´ÛÙ|ÙÛØ¨ÛÛØ§ÙÛØ¯Ø§|ÙÛØ¯ÙØ§ÛÙÛÙÛÚÛØ¯Ø§|ÙÛ Ø¦ÛÙØ§Ø±ÛØ¯Ø§|ÙÛ Ø´ÛÙØ¯Ø§)/,
  any: /^(Ù¾|Ø¯|Ø¨ÛÛØ§ÙÛ|ÙÛÙÛÚÛ|Ø¦ÛÙØ§Ø±Û|Ø´ÛÙ)/,
};
const parseDayPeriodPatterns$15 = {
  any: {
    am: /^Ø¯/i,
    pm: /^Ù¾/i,
    midnight: /^Ù-Ø´/i,
    noon: /^Ù/i,
    morning: /Ø¨ÛÛØ§ÙÛ/i,
    afternoon: /Ø¯ÙØ§ÛÙÛÙÛÚÛ/i,
    evening: /Ø¦ÛÙØ§Ø±Û/i,
    night: /Ø´ÛÙ/i,
  },
};

(match$15.match = {
  ordinalNumber: (0, _index2$3V.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$15,
    parsePattern: parseOrdinalNumberPattern$15,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8H.buildMatchFn)({
    matchPatterns: matchEraPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$15,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8H.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$15,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8H.buildMatchFn)({
    matchPatterns: matchMonthPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$15,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8H.buildMatchFn)({
    matchPatterns: matchDayPatterns$15,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$15,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8H.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$15,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$15,
    defaultParseWidth: "any",
  }),
});

ckb.ckb = void 0;
var _index$8G = formatDistance$2f;
var _index2$3U = formatLong$1e;
var _index3$23 = formatRelative$2f;
var _index4$1y = localize$16;
var _index5$1p = match$15;

/**
 * @type {Locale}
 * @category Locales
 * @summary Central Kurdish locale.
 * @language Central Kurdish
 * @iso-639-2 kur
 * @author Revan Sarbast [@Revan99]{@link https://github.com/Revan99}
 */
(ckb.ckb = {
  code: "ckb",
  formatDistance: _index$8G.formatDistance,
  formatLong: _index2$3U.formatLong,
  formatRelative: _index3$23.formatRelative,
  localize: _index4$1y.localize,
  match: _index5$1p.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var cs = {};

var formatDistance$2d = {};

formatDistance$2d.formatDistance = void 0;

const formatDistanceLocale$14 = {
  lessThanXSeconds: {
    one: {
      regular: "mÃ©nÄ neÅ¾ 1 sekunda",
      past: "pÅed mÃ©nÄ neÅ¾ 1 sekundou",
      future: "za mÃ©nÄ neÅ¾ 1 sekundu",
    },
    few: {
      regular: "mÃ©nÄ neÅ¾ {{count}} sekundy",
      past: "pÅed mÃ©nÄ neÅ¾ {{count}} sekundami",
      future: "za mÃ©nÄ neÅ¾ {{count}} sekundy",
    },
    many: {
      regular: "mÃ©nÄ neÅ¾ {{count}} sekund",
      past: "pÅed mÃ©nÄ neÅ¾ {{count}} sekundami",
      future: "za mÃ©nÄ neÅ¾ {{count}} sekund",
    },
  },

  xSeconds: {
    one: {
      regular: "1 sekunda",
      past: "pÅed 1 sekundou",
      future: "za 1 sekundu",
    },
    few: {
      regular: "{{count}} sekundy",
      past: "pÅed {{count}} sekundami",
      future: "za {{count}} sekundy",
    },
    many: {
      regular: "{{count}} sekund",
      past: "pÅed {{count}} sekundami",
      future: "za {{count}} sekund",
    },
  },

  halfAMinute: {
    type: "other",
    other: {
      regular: "pÅ¯l minuty",
      past: "pÅed pÅ¯l minutou",
      future: "za pÅ¯l minuty",
    },
  },

  lessThanXMinutes: {
    one: {
      regular: "mÃ©nÄ neÅ¾ 1 minuta",
      past: "pÅed mÃ©nÄ neÅ¾ 1 minutou",
      future: "za mÃ©nÄ neÅ¾ 1 minutu",
    },
    few: {
      regular: "mÃ©nÄ neÅ¾ {{count}} minuty",
      past: "pÅed mÃ©nÄ neÅ¾ {{count}} minutami",
      future: "za mÃ©nÄ neÅ¾ {{count}} minuty",
    },
    many: {
      regular: "mÃ©nÄ neÅ¾ {{count}} minut",
      past: "pÅed mÃ©nÄ neÅ¾ {{count}} minutami",
      future: "za mÃ©nÄ neÅ¾ {{count}} minut",
    },
  },

  xMinutes: {
    one: {
      regular: "1 minuta",
      past: "pÅed 1 minutou",
      future: "za 1 minutu",
    },
    few: {
      regular: "{{count}} minuty",
      past: "pÅed {{count}} minutami",
      future: "za {{count}} minuty",
    },
    many: {
      regular: "{{count}} minut",
      past: "pÅed {{count}} minutami",
      future: "za {{count}} minut",
    },
  },

  aboutXHours: {
    one: {
      regular: "pÅibliÅ¾nÄ 1 hodina",
      past: "pÅibliÅ¾nÄ pÅed 1 hodinou",
      future: "pÅibliÅ¾nÄ za 1 hodinu",
    },
    few: {
      regular: "pÅibliÅ¾nÄ {{count}} hodiny",
      past: "pÅibliÅ¾nÄ pÅed {{count}} hodinami",
      future: "pÅibliÅ¾nÄ za {{count}} hodiny",
    },
    many: {
      regular: "pÅibliÅ¾nÄ {{count}} hodin",
      past: "pÅibliÅ¾nÄ pÅed {{count}} hodinami",
      future: "pÅibliÅ¾nÄ za {{count}} hodin",
    },
  },

  xHours: {
    one: {
      regular: "1 hodina",
      past: "pÅed 1 hodinou",
      future: "za 1 hodinu",
    },
    few: {
      regular: "{{count}} hodiny",
      past: "pÅed {{count}} hodinami",
      future: "za {{count}} hodiny",
    },
    many: {
      regular: "{{count}} hodin",
      past: "pÅed {{count}} hodinami",
      future: "za {{count}} hodin",
    },
  },

  xDays: {
    one: {
      regular: "1 den",
      past: "pÅed 1 dnem",
      future: "za 1 den",
    },
    few: {
      regular: "{{count}} dny",
      past: "pÅed {{count}} dny",
      future: "za {{count}} dny",
    },
    many: {
      regular: "{{count}} dnÃ­",
      past: "pÅed {{count}} dny",
      future: "za {{count}} dnÃ­",
    },
  },

  aboutXWeeks: {
    one: {
      regular: "pÅibliÅ¾nÄ 1 tÃ½den",
      past: "pÅibliÅ¾nÄ pÅed 1 tÃ½dnem",
      future: "pÅibliÅ¾nÄ za 1 tÃ½den",
    },

    few: {
      regular: "pÅibliÅ¾nÄ {{count}} tÃ½dny",
      past: "pÅibliÅ¾nÄ pÅed {{count}} tÃ½dny",
      future: "pÅibliÅ¾nÄ za {{count}} tÃ½dny",
    },

    many: {
      regular: "pÅibliÅ¾nÄ {{count}} tÃ½dnÅ¯",
      past: "pÅibliÅ¾nÄ pÅed {{count}} tÃ½dny",
      future: "pÅibliÅ¾nÄ za {{count}} tÃ½dnÅ¯",
    },
  },

  xWeeks: {
    one: {
      regular: "1 tÃ½den",
      past: "pÅed 1 tÃ½dnem",
      future: "za 1 tÃ½den",
    },

    few: {
      regular: "{{count}} tÃ½dny",
      past: "pÅed {{count}} tÃ½dny",
      future: "za {{count}} tÃ½dny",
    },

    many: {
      regular: "{{count}} tÃ½dnÅ¯",
      past: "pÅed {{count}} tÃ½dny",
      future: "za {{count}} tÃ½dnÅ¯",
    },
  },

  aboutXMonths: {
    one: {
      regular: "pÅibliÅ¾nÄ 1 mÄsÃ­c",
      past: "pÅibliÅ¾nÄ pÅed 1 mÄsÃ­cem",
      future: "pÅibliÅ¾nÄ za 1 mÄsÃ­c",
    },

    few: {
      regular: "pÅibliÅ¾nÄ {{count}} mÄsÃ­ce",
      past: "pÅibliÅ¾nÄ pÅed {{count}} mÄsÃ­ci",
      future: "pÅibliÅ¾nÄ za {{count}} mÄsÃ­ce",
    },

    many: {
      regular: "pÅibliÅ¾nÄ {{count}} mÄsÃ­cÅ¯",
      past: "pÅibliÅ¾nÄ pÅed {{count}} mÄsÃ­ci",
      future: "pÅibliÅ¾nÄ za {{count}} mÄsÃ­cÅ¯",
    },
  },

  xMonths: {
    one: {
      regular: "1 mÄsÃ­c",
      past: "pÅed 1 mÄsÃ­cem",
      future: "za 1 mÄsÃ­c",
    },

    few: {
      regular: "{{count}} mÄsÃ­ce",
      past: "pÅed {{count}} mÄsÃ­ci",
      future: "za {{count}} mÄsÃ­ce",
    },

    many: {
      regular: "{{count}} mÄsÃ­cÅ¯",
      past: "pÅed {{count}} mÄsÃ­ci",
      future: "za {{count}} mÄsÃ­cÅ¯",
    },
  },

  aboutXYears: {
    one: {
      regular: "pÅibliÅ¾nÄ 1 rok",
      past: "pÅibliÅ¾nÄ pÅed 1 rokem",
      future: "pÅibliÅ¾nÄ za 1 rok",
    },
    few: {
      regular: "pÅibliÅ¾nÄ {{count}} roky",
      past: "pÅibliÅ¾nÄ pÅed {{count}} roky",
      future: "pÅibliÅ¾nÄ za {{count}} roky",
    },
    many: {
      regular: "pÅibliÅ¾nÄ {{count}} rokÅ¯",
      past: "pÅibliÅ¾nÄ pÅed {{count}} roky",
      future: "pÅibliÅ¾nÄ za {{count}} rokÅ¯",
    },
  },

  xYears: {
    one: {
      regular: "1 rok",
      past: "pÅed 1 rokem",
      future: "za 1 rok",
    },
    few: {
      regular: "{{count}} roky",
      past: "pÅed {{count}} roky",
      future: "za {{count}} roky",
    },
    many: {
      regular: "{{count}} rokÅ¯",
      past: "pÅed {{count}} roky",
      future: "za {{count}} rokÅ¯",
    },
  },

  overXYears: {
    one: {
      regular: "vÃ­ce neÅ¾ 1 rok",
      past: "pÅed vÃ­ce neÅ¾ 1 rokem",
      future: "za vÃ­ce neÅ¾ 1 rok",
    },
    few: {
      regular: "vÃ­ce neÅ¾ {{count}} roky",
      past: "pÅed vÃ­ce neÅ¾ {{count}} roky",
      future: "za vÃ­ce neÅ¾ {{count}} roky",
    },
    many: {
      regular: "vÃ­ce neÅ¾ {{count}} rokÅ¯",
      past: "pÅed vÃ­ce neÅ¾ {{count}} roky",
      future: "za vÃ­ce neÅ¾ {{count}} rokÅ¯",
    },
  },

  almostXYears: {
    one: {
      regular: "skoro 1 rok",
      past: "skoro pÅed 1 rokem",
      future: "skoro za 1 rok",
    },
    few: {
      regular: "skoro {{count}} roky",
      past: "skoro pÅed {{count}} roky",
      future: "skoro za {{count}} roky",
    },
    many: {
      regular: "skoro {{count}} rokÅ¯",
      past: "skoro pÅed {{count}} roky",
      future: "skoro za {{count}} rokÅ¯",
    },
  },
};

const formatDistance$2c = (token, count, options) => {
  let pluralResult;

  const tokenValue = formatDistanceLocale$14[token];

  // cs pluralization
  if (tokenValue.type === "other") {
    pluralResult = tokenValue.other;
  } else if (count === 1) {
    pluralResult = tokenValue.one;
  } else if (count > 1 && count < 5) {
    pluralResult = tokenValue.few;
  } else {
    pluralResult = tokenValue.many;
  }

  // times
  const suffixExist = options?.addSuffix === true;
  const comparison = options?.comparison;

  let timeResult;
  if (suffixExist && comparison === -1) {
    timeResult = pluralResult.past;
  } else if (suffixExist && comparison === 1) {
    timeResult = pluralResult.future;
  } else {
    timeResult = pluralResult.regular;
  }

  return timeResult.replace("{{count}}", String(count));
};
formatDistance$2d.formatDistance = formatDistance$2c;

var formatLong$1d = {};

formatLong$1d.formatLong = void 0;
var _index$8F = buildFormatLongFn$1;

const dateFormats$1d = {
  full: "EEEE, d. MMMM yyyy",
  long: "d. MMMM yyyy",
  medium: "d. M. yyyy",
  short: "dd.MM.yyyy",
};

const timeFormats$1d = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$1d = {
  full: "{{date}} 'v' {{time}}",
  long: "{{date}} 'v' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1d.formatLong = {
  date: (0, _index$8F.buildFormatLongFn)({
    formats: dateFormats$1d,
    defaultWidth: "full",
  }),

  time: (0, _index$8F.buildFormatLongFn)({
    formats: timeFormats$1d,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8F.buildFormatLongFn)({
    formats: dateTimeFormats$1d,
    defaultWidth: "full",
  }),
});

var formatRelative$2d = {};

formatRelative$2d.formatRelative = void 0;

const accusativeWeekdays$5 = [
  "nedÄli",
  "pondÄlÃ­",
  "ÃºterÃ½",
  "stÅedu",
  "Ätvrtek",
  "pÃ¡tek",
  "sobotu",
];

const formatRelativeLocale$15 = {
  lastWeek: "'poslednÃ­' eeee 've' p",
  yesterday: "'vÄera v' p",
  today: "'dnes v' p",
  tomorrow: "'zÃ­tra v' p",
  nextWeek: (date) => {
    const day = date.getDay();
    return "'v " + accusativeWeekdays$5[day] + " o' p";
  },
  other: "P",
};

const formatRelative$2c = (token, date) => {
  const format = formatRelativeLocale$15[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$2d.formatRelative = formatRelative$2c;

var localize$15 = {};

localize$15.localize = void 0;
var _index$8E = buildLocalizeFn$1;

const eraValues$15 = {
  narrow: ["pÅ. n. l.", "n. l."],
  abbreviated: ["pÅ. n. l.", "n. l."],
  wide: ["pÅed naÅ¡Ã­m letopoÄtem", "naÅ¡eho letopoÄtu"],
};

const quarterValues$15 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. ÄtvrtletÃ­", "2. ÄtvrtletÃ­", "3. ÄtvrtletÃ­", "4. ÄtvrtletÃ­"],

  wide: ["1. ÄtvrtletÃ­", "2. ÄtvrtletÃ­", "3. ÄtvrtletÃ­", "4. ÄtvrtletÃ­"],
};

const monthValues$15 = {
  narrow: ["L", "Ã", "B", "D", "K", "Ä", "Ä", "S", "Z", "Å", "L", "P"],
  abbreviated: [
    "led",
    "Ãºno",
    "bÅe",
    "dub",
    "kvÄ",
    "Ävn",
    "Ävc",
    "srp",
    "zÃ¡Å",
    "ÅÃ­j",
    "lis",
    "pro",
  ],

  wide: [
    "leden",
    "Ãºnor",
    "bÅezen",
    "duben",
    "kvÄten",
    "Äerven",
    "Äervenec",
    "srpen",
    "zÃ¡ÅÃ­",
    "ÅÃ­jen",
    "listopad",
    "prosinec",
  ],
};

const formattingMonthValues$f = {
  narrow: ["L", "Ã", "B", "D", "K", "Ä", "Ä", "S", "Z", "Å", "L", "P"],
  abbreviated: [
    "led",
    "Ãºno",
    "bÅe",
    "dub",
    "kvÄ",
    "Ävn",
    "Ävc",
    "srp",
    "zÃ¡Å",
    "ÅÃ­j",
    "lis",
    "pro",
  ],

  wide: [
    "ledna",
    "Ãºnora",
    "bÅezna",
    "dubna",
    "kvÄtna",
    "Äervna",
    "Äervence",
    "srpna",
    "zÃ¡ÅÃ­",
    "ÅÃ­jna",
    "listopadu",
    "prosince",
  ],
};

const dayValues$15 = {
  narrow: ["ne", "po", "Ãºt", "st", "Ät", "pÃ¡", "so"],
  short: ["ne", "po", "Ãºt", "st", "Ät", "pÃ¡", "so"],
  abbreviated: ["ned", "pon", "Ãºte", "stÅ", "Ätv", "pÃ¡t", "sob"],
  wide: ["nedÄle", "pondÄlÃ­", "ÃºterÃ½", "stÅeda", "Ätvrtek", "pÃ¡tek", "sobota"],
};

const dayPeriodValues$15 = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
};

const formattingDayPeriodValues$S = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "pÅ¯lnoc",
    noon: "poledne",
    morning: "rÃ¡no",
    afternoon: "odpoledne",
    evening: "veÄer",
    night: "noc",
  },
};

const ordinalNumber$15 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$15.localize = {
  ordinalNumber: ordinalNumber$15,

  era: (0, _index$8E.buildLocalizeFn)({
    values: eraValues$15,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8E.buildLocalizeFn)({
    values: quarterValues$15,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8E.buildLocalizeFn)({
    values: monthValues$15,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$f,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$8E.buildLocalizeFn)({
    values: dayValues$15,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8E.buildLocalizeFn)({
    values: dayPeriodValues$15,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$S,
    defaultFormattingWidth: "wide",
  }),
});

var match$14 = {};

match$14.match = void 0;

var _index$8D = buildMatchFn$1;
var _index2$3T = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$14 = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$14 = /\d+/i;

const matchEraPatterns$14 = {
  narrow: /^(p[År](\.|ed) Kr\.|p[År](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(p[År](\.|ed) Kr\.|p[År](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(p[År](\.|ed) Kristem|p[År](\.|ed) na[Å¡s][Ã­i]m letopo[Äc]tem|po Kristu|na[Å¡s]eho letopo[Äc]tu)/i,
};

const parseEraPatterns$14 = {
  any: [/^p[År]/i, /^(po|n)/i],
};

const matchQuarterPatterns$14 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\. [Äc]tvrtlet[Ã­i]/i,
  wide: /^[1234]\. [Äc]tvrtlet[Ã­i]/i,
};
const parseQuarterPatterns$14 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$14 = {
  narrow: /^[lÃºubdkÄcszÅrlp]/i,
  abbreviated:
    /^(led|[Ãºu]no|b[År]e|dub|kv[Äe]|[Äc]vn|[Äc]vc|srp|z[Ã¡a][År]|[År][Ã­i]j|lis|pro)/i,
  wide: /^(leden|ledna|[Ãºu]nora?|b[År]ezen|b[År]ezna|duben|dubna|kv[Äe]ten|kv[Äe]tna|[Äc]erven(ec|ce)?|[Äc]ervna|srpen|srpna|z[Ã¡a][År][Ã­i]|[År][Ã­i]jen|[År][Ã­i]jna|listopad(a|u)?|prosinec|prosince)/i,
};
const parseMonthPatterns$14 = {
  narrow: [
    /^l/i,
    /^[Ãºu]/i,
    /^b/i,
    /^d/i,
    /^k/i,
    /^[Äc]/i,
    /^[Äc]/i,
    /^s/i,
    /^z/i,
    /^[År]/i,
    /^l/i,
    /^p/i,
  ],

  any: [
    /^led/i,
    /^[Ãºu]n/i,
    /^b[År]e/i,
    /^dub/i,
    /^kv[Äe]/i,
    /^[Äc]vn|[Äc]erven(?!\w)|[Äc]ervna/i,
    /^[Äc]vc|[Äc]erven(ec|ce)/i,
    /^srp/i,
    /^z[Ã¡a][År]/i,
    /^[År][Ã­i]j/i,
    /^lis/i,
    /^pro/i,
  ],
};

const matchDayPatterns$14 = {
  narrow: /^[npuÃºsÄps]/i,
  short: /^(ne|po|[Ãºu]t|st|[Äc]t|p[Ã¡a]|so)/i,
  abbreviated: /^(ned|pon|[Ãºu]te|st[rÅ]|[Äc]tv|p[Ã¡a]t|sob)/i,
  wide: /^(ned[Äe]le|pond[Äe]l[Ã­i]|[Ãºu]ter[Ã½y]|st[År]eda|[Äc]tvrtek|p[Ã¡a]tek|sobota)/i,
};

const parseDayPatterns$14 = {
  narrow: [/^n/i, /^p/i, /^[Ãºu]/i, /^s/i, /^[Äc]/i, /^p/i, /^s/i],
  any: [/^ne/i, /^po/i, /^[Ãºu]t/i, /^st/i, /^[Äc]t/i, /^p[Ã¡a]/i, /^so/i],
};

const matchDayPeriodPatterns$14 = {
  any: /^dopoledne|dop\.?|odpoledne|odp\.?|p[Å¯u]lnoc|poledne|r[Ã¡a]no|odpoledne|ve[Äc]er|(v )?noci?/i,
};
const parseDayPeriodPatterns$14 = {
  any: {
    am: /^dop/i,
    pm: /^odp/i,
    midnight: /^p[Å¯u]lnoc/i,
    noon: /^poledne/i,
    morning: /r[Ã¡a]no/i,
    afternoon: /odpoledne/i,
    evening: /ve[Äc]er/i,
    night: /noc/i,
  },
};

(match$14.match = {
  ordinalNumber: (0, _index2$3T.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$14,
    parsePattern: parseOrdinalNumberPattern$14,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8D.buildMatchFn)({
    matchPatterns: matchEraPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$14,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8D.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$14,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8D.buildMatchFn)({
    matchPatterns: matchMonthPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$14,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8D.buildMatchFn)({
    matchPatterns: matchDayPatterns$14,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$14,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8D.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$14,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$14,
    defaultParseWidth: "any",
  }),
});

cs.cs = void 0;
var _index$8C = formatDistance$2d;
var _index2$3S = formatLong$1d;
var _index3$22 = formatRelative$2d;
var _index4$1x = localize$15;
var _index5$1o = match$14;

/**
 * @category Locales
 * @summary Czech locale.
 * @language Czech
 * @iso-639-2 ces
 * @author David Rus [@davidrus](https://github.com/davidrus)
 * @author Pavel HrÃ¡ch [@SilenY](https://github.com/SilenY)
 * @author Jozef BÃ­roÅ¡ [@JozefBiros](https://github.com/JozefBiros)
 */
(cs.cs = {
  code: "cs",
  formatDistance: _index$8C.formatDistance,
  formatLong: _index2$3S.formatLong,
  formatRelative: _index3$22.formatRelative,
  localize: _index4$1x.localize,
  match: _index5$1o.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var cy = {};

var formatDistance$2b = {};

formatDistance$2b.formatDistance = void 0;

const formatDistanceLocale$13 = {
  lessThanXSeconds: {
    one: "llai na eiliad",
    other: "llai na {{count}} eiliad",
  },

  xSeconds: {
    one: "1 eiliad",
    other: "{{count}} eiliad",
  },

  halfAMinute: "hanner munud",

  lessThanXMinutes: {
    one: "llai na munud",
    two: "llai na 2 funud",
    other: "llai na {{count}} munud",
  },

  xMinutes: {
    one: "1 munud",
    two: "2 funud",
    other: "{{count}} munud",
  },

  aboutXHours: {
    one: "tua 1 awr",
    other: "tua {{count}} awr",
  },

  xHours: {
    one: "1 awr",
    other: "{{count}} awr",
  },

  xDays: {
    one: "1 diwrnod",
    two: "2 ddiwrnod",
    other: "{{count}} diwrnod",
  },

  aboutXWeeks: {
    one: "tua 1 wythnos",
    two: "tua pythefnos",
    other: "tua {{count}} wythnos",
  },

  xWeeks: {
    one: "1 wythnos",
    two: "pythefnos",
    other: "{{count}} wythnos",
  },

  aboutXMonths: {
    one: "tua 1 mis",
    two: "tua 2 fis",
    other: "tua {{count}} mis",
  },

  xMonths: {
    one: "1 mis",
    two: "2 fis",
    other: "{{count}} mis",
  },

  aboutXYears: {
    one: "tua 1 flwyddyn",
    two: "tua 2 flynedd",
    other: "tua {{count}} mlynedd",
  },

  xYears: {
    one: "1 flwyddyn",
    two: "2 flynedd",
    other: "{{count}} mlynedd",
  },

  overXYears: {
    one: "dros 1 flwyddyn",
    two: "dros 2 flynedd",
    other: "dros {{count}} mlynedd",
  },

  almostXYears: {
    one: "bron 1 flwyddyn",
    two: "bron 2 flynedd",
    other: "bron {{count}} mlynedd",
  },
};

const formatDistance$2a = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$13[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "mewn " + result;
    } else {
      return result + " yn Ã´l";
    }
  }

  return result;
};
formatDistance$2b.formatDistance = formatDistance$2a;

var formatLong$1c = {};

formatLong$1c.formatLong = void 0;
var _index$8B = buildFormatLongFn$1;

const dateFormats$1c = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$1c = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$1c = {
  full: "{{date}} 'am' {{time}}",
  long: "{{date}} 'am' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$1c.formatLong = {
  date: (0, _index$8B.buildFormatLongFn)({
    formats: dateFormats$1c,
    defaultWidth: "full",
  }),

  time: (0, _index$8B.buildFormatLongFn)({
    formats: timeFormats$1c,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8B.buildFormatLongFn)({
    formats: dateTimeFormats$1c,
    defaultWidth: "full",
  }),
});

var formatRelative$2b = {};

formatRelative$2b.formatRelative = void 0;

const formatRelativeLocale$14 = {
  lastWeek: "eeee 'diwethaf am' p",
  yesterday: "'ddoe am' p",
  today: "'heddiw am' p",
  tomorrow: "'yfory am' p",
  nextWeek: "eeee 'am' p",
  other: "P",
};

const formatRelative$2a = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$14[token];
formatRelative$2b.formatRelative = formatRelative$2a;

var localize$14 = {};

localize$14.localize = void 0;
var _index$8A = buildLocalizeFn$1;

const eraValues$14 = {
  narrow: ["C", "O"],
  abbreviated: ["CC", "OC"],
  wide: ["Cyn Crist", "Ar Ã´l Crist"],
};

const quarterValues$14 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ch1", "Ch2", "Ch3", "Ch4"],
  wide: ["Chwarter 1af", "2ail chwarter", "3ydd chwarter", "4ydd chwarter"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$14 = {
  narrow: ["I", "Ch", "Ma", "E", "Mi", "Me", "G", "A", "Md", "H", "T", "Rh"],

  abbreviated: [
    "Ion",
    "Chwe",
    "Maw",
    "Ebr",
    "Mai",
    "Meh",
    "Gor",
    "Aws",
    "Med",
    "Hyd",
    "Tach",
    "Rhag",
  ],

  wide: [
    "Ionawr",
    "Chwefror",
    "Mawrth",
    "Ebrill",
    "Mai",
    "Mehefin",
    "Gorffennaf",
    "Awst",
    "Medi",
    "Hydref",
    "Tachwedd",
    "Rhagfyr",
  ],
};

const dayValues$14 = {
  narrow: ["S", "Ll", "M", "M", "I", "G", "S"],
  short: ["Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa"],
  abbreviated: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
  wide: [
    "dydd Sul",
    "dydd Llun",
    "dydd Mawrth",
    "dydd Mercher",
    "dydd Iau",
    "dydd Gwener",
    "dydd Sadwrn",
  ],
};

const dayPeriodValues$14 = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos",
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos",
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos",
  },
};

const formattingDayPeriodValues$R = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos",
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos",
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos",
  },
};

const ordinalNumber$14 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  if (number < 20) {
    switch (number) {
      case 0:
        return number + "fed";
      case 1:
        return number + "af";
      case 2:
        return number + "ail";
      case 3:
      case 4:
        return number + "ydd";
      case 5:
      case 6:
        return number + "ed";
      case 7:
      case 8:
      case 9:
      case 10:
      case 12:
      case 15:
      case 18:
        return number + "fed";
      case 11:
      case 13:
      case 14:
      case 16:
      case 17:
      case 19:
        return number + "eg";
    }
  } else if ((number >= 50 && number <= 60) || number === 80 || number >= 100) {
    return number + "fed";
  }
  return number + "ain";
};

(localize$14.localize = {
  ordinalNumber: ordinalNumber$14,

  era: (0, _index$8A.buildLocalizeFn)({
    values: eraValues$14,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8A.buildLocalizeFn)({
    values: quarterValues$14,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8A.buildLocalizeFn)({
    values: monthValues$14,
    defaultWidth: "wide",
  }),

  day: (0, _index$8A.buildLocalizeFn)({
    values: dayValues$14,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8A.buildLocalizeFn)({
    values: dayPeriodValues$14,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$R,
    defaultFormattingWidth: "wide",
  }),
});

var match$13 = {};

match$13.match = void 0;

var _index$8z = buildMatchFn$1;
var _index2$3R = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$13 = /^(\d+)(af|ail|ydd|ed|fed|eg|ain)?/i;
const parseOrdinalNumberPattern$13 = /\d+/i;

const matchEraPatterns$13 = {
  narrow: /^(c|o)/i,
  abbreviated: /^(c\.?\s?c\.?|o\.?\s?c\.?)/i,
  wide: /^(cyn christ|ar Ã´l crist|ar ol crist)/i,
};
const parseEraPatterns$13 = {
  wide: [/^c/i, /^(ar Ã´l crist|ar ol crist)/i],
  any: [/^c/i, /^o/i],
};

const matchQuarterPatterns$13 = {
  narrow: /^[1234]/i,
  abbreviated: /^ch[1234]/i,
  wide: /^(chwarter 1af)|([234](ail|ydd)? chwarter)/i,
};
const parseQuarterPatterns$13 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$13 = {
  narrow: /^(i|ch|m|e|g|a|h|t|rh)/i,
  abbreviated: /^(ion|chwe|maw|ebr|mai|meh|gor|aws|med|hyd|tach|rhag)/i,
  wide: /^(ionawr|chwefror|mawrth|ebrill|mai|mehefin|gorffennaf|awst|medi|hydref|tachwedd|rhagfyr)/i,
};
const parseMonthPatterns$13 = {
  narrow: [
    /^i/i,
    /^ch/i,
    /^m/i,
    /^e/i,
    /^m/i,
    /^m/i,
    /^g/i,
    /^a/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^rh/i,
  ],

  any: [
    /^io/i,
    /^ch/i,
    /^maw/i,
    /^e/i,
    /^mai/i,
    /^meh/i,
    /^g/i,
    /^a/i,
    /^med/i,
    /^h/i,
    /^t/i,
    /^rh/i,
  ],
};

const matchDayPatterns$13 = {
  narrow: /^(s|ll|m|i|g)/i,
  short: /^(su|ll|ma|me|ia|gw|sa)/i,
  abbreviated: /^(sul|llun|maw|mer|iau|gwe|sad)/i,
  wide: /^dydd (sul|llun|mawrth|mercher|iau|gwener|sadwrn)/i,
};
const parseDayPatterns$13 = {
  narrow: [/^s/i, /^ll/i, /^m/i, /^m/i, /^i/i, /^g/i, /^s/i],
  wide: [
    /^dydd su/i,
    /^dydd ll/i,
    /^dydd ma/i,
    /^dydd me/i,
    /^dydd i/i,
    /^dydd g/i,
    /^dydd sa/i,
  ],

  any: [/^su/i, /^ll/i, /^ma/i, /^me/i, /^i/i, /^g/i, /^sa/i],
};

const matchDayPeriodPatterns$13 = {
  narrow: /^(b|h|hn|hd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i,
  any: /^(y\.?\s?[bh]\.?|hanner nos|hanner dydd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i,
};
const parseDayPeriodPatterns$13 = {
  any: {
    am: /^b|(y\.?\s?b\.?)/i,
    pm: /^h|(y\.?\s?h\.?)|(yr hwyr)/i,
    midnight: /^hn|hanner nos/i,
    noon: /^hd|hanner dydd/i,
    morning: /bore/i,
    afternoon: /prynhawn/i,
    evening: /^gyda'r nos$/i,
    night: /blah/i,
  },
};

(match$13.match = {
  ordinalNumber: (0, _index2$3R.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$13,
    parsePattern: parseOrdinalNumberPattern$13,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8z.buildMatchFn)({
    matchPatterns: matchEraPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$13,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8z.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$13,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8z.buildMatchFn)({
    matchPatterns: matchMonthPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$13,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8z.buildMatchFn)({
    matchPatterns: matchDayPatterns$13,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$13,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8z.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$13,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$13,
    defaultParseWidth: "any",
  }),
});

cy.cy = void 0;
var _index$8y = formatDistance$2b;
var _index2$3Q = formatLong$1c;
var _index3$21 = formatRelative$2b;
var _index4$1w = localize$14;
var _index5$1n = match$13;

/**
 * @category Locales
 * @summary Welsh locale.
 * @language Welsh
 * @iso-639-2 cym
 * @author Elwyn Malethan [@elmomalmo](https://github.com/elmomalmo)
 */
(cy.cy = {
  code: "cy",
  formatDistance: _index$8y.formatDistance,
  formatLong: _index2$3Q.formatLong,
  formatRelative: _index3$21.formatRelative,
  localize: _index4$1w.localize,
  match: _index5$1n.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var da = {};

var formatDistance$29 = {};

formatDistance$29.formatDistance = void 0;

const formatDistanceLocale$12 = {
  lessThanXSeconds: {
    one: "mindre end Ã©t sekund",
    other: "mindre end {{count}} sekunder",
  },

  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekunder",
  },

  halfAMinute: "Ã©t halvt minut",

  lessThanXMinutes: {
    one: "mindre end Ã©t minut",
    other: "mindre end {{count}} minutter",
  },

  xMinutes: {
    one: "1 minut",
    other: "{{count}} minutter",
  },

  aboutXHours: {
    one: "cirka 1 time",
    other: "cirka {{count}} timer",
  },

  xHours: {
    one: "1 time",
    other: "{{count}} timer",
  },

  xDays: {
    one: "1 dag",
    other: "{{count}} dage",
  },

  aboutXWeeks: {
    one: "cirka 1 uge",
    other: "cirka {{count}} uger",
  },

  xWeeks: {
    one: "1 uge",
    other: "{{count}} uger",
  },

  aboutXMonths: {
    one: "cirka 1 mÃ¥ned",
    other: "cirka {{count}} mÃ¥neder",
  },

  xMonths: {
    one: "1 mÃ¥ned",
    other: "{{count}} mÃ¥neder",
  },

  aboutXYears: {
    one: "cirka 1 Ã¥r",
    other: "cirka {{count}} Ã¥r",
  },

  xYears: {
    one: "1 Ã¥r",
    other: "{{count}} Ã¥r",
  },

  overXYears: {
    one: "over 1 Ã¥r",
    other: "over {{count}} Ã¥r",
  },

  almostXYears: {
    one: "nÃ¦sten 1 Ã¥r",
    other: "nÃ¦sten {{count}} Ã¥r",
  },
};

const formatDistance$28 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$12[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }

  return result;
};
formatDistance$29.formatDistance = formatDistance$28;

var formatLong$1b = {};

formatLong$1b.formatLong = void 0;
var _index$8x = buildFormatLongFn$1;

const dateFormats$1b = {
  full: "EEEE 'den' d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd/MM/y",
};

const timeFormats$1b = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1b = {
  full: "{{date}} 'kl'. {{time}}",
  long: "{{date}} 'kl'. {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$1b.formatLong = {
  date: (0, _index$8x.buildFormatLongFn)({
    formats: dateFormats$1b,
    defaultWidth: "full",
  }),

  time: (0, _index$8x.buildFormatLongFn)({
    formats: timeFormats$1b,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8x.buildFormatLongFn)({
    formats: dateTimeFormats$1b,
    defaultWidth: "full",
  }),
});

var formatRelative$29 = {};

formatRelative$29.formatRelative = void 0;

const formatRelativeLocale$13 = {
  lastWeek: "'sidste' eeee 'kl.' p",
  yesterday: "'i gÃ¥r kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "'pÃ¥' eeee 'kl.' p",
  other: "P",
};

const formatRelative$28 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$13[token];
formatRelative$29.formatRelative = formatRelative$28;

var localize$13 = {};

localize$13.localize = void 0;
var _index$8w = buildLocalizeFn$1;

const eraValues$13 = {
  narrow: ["fvt", "vt"],
  abbreviated: ["f.v.t.", "v.t."],
  wide: ["fÃ¸r vesterlandsk tidsregning", "vesterlandsk tidsregning"],
};

const quarterValues$13 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$13 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januar",
    "februar",
    "marts",
    "april",
    "maj",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "december",
  ],
};

// Note that 'Days - abbreviated - Formatting' has periods at the end.
// https://www.unicode.org/cldr/charts/32/summary/da.html#1760
// This makes grammatical sense in danish, as most abbreviations have periods.
const dayValues$13 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sÃ¸", "ma", "ti", "on", "to", "fr", "lÃ¸"],
  abbreviated: ["sÃ¸n.", "man.", "tir.", "ons.", "tor.", "fre.", "lÃ¸r."],

  wide: [
    "sÃ¸ndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lÃ¸rdag",
  ],
};

const dayPeriodValues$13 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat",
  },
};

const formattingDayPeriodValues$Q = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten",
  },
};

const ordinalNumber$13 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$13.localize = {
  ordinalNumber: ordinalNumber$13,

  era: (0, _index$8w.buildLocalizeFn)({
    values: eraValues$13,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8w.buildLocalizeFn)({
    values: quarterValues$13,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8w.buildLocalizeFn)({
    values: monthValues$13,
    defaultWidth: "wide",
  }),

  day: (0, _index$8w.buildLocalizeFn)({
    values: dayValues$13,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8w.buildLocalizeFn)({
    values: dayPeriodValues$13,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$Q,
    defaultFormattingWidth: "wide",
  }),
});

var match$12 = {};

match$12.match = void 0;

var _index$8v = buildMatchFn$1;
var _index2$3P = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$12 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$12 = /\d+/i;

const matchEraPatterns$12 = {
  narrow: /^(fKr|fvt|eKr|vt)/i,
  abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
  wide: /^(f.Kr.|fÃ¸r vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i,
};
const parseEraPatterns$12 = {
  any: [/^f/i, /^(v|e)/i],
};

const matchQuarterPatterns$12 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]. kvt\./i,
  wide: /^[1234]\.? kvartal/i,
};
const parseQuarterPatterns$12 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$12 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i,
};
const parseMonthPatterns$12 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$12 = {
  narrow: /^[smtofl]/i,
  short: /^(sÃ¸n.|man.|tir.|ons.|tor.|fre.|lÃ¸r.)/i,
  abbreviated: /^(sÃ¸n|man|tir|ons|tor|fre|lÃ¸r)/i,
  wide: /^(sÃ¸ndag|mandag|tirsdag|onsdag|torsdag|fredag|lÃ¸rdag)/i,
};
const parseDayPatterns$12 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i],
};

const matchDayPeriodPatterns$12 = {
  narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
  any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
};
const parseDayPeriodPatterns$12 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /midnat/i,
    noon: /middag/i,
    morning: /morgen/i,
    afternoon: /eftermiddag/i,
    evening: /aften/i,
    night: /nat/i,
  },
};

(match$12.match = {
  ordinalNumber: (0, _index2$3P.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$12,
    parsePattern: parseOrdinalNumberPattern$12,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8v.buildMatchFn)({
    matchPatterns: matchEraPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$12,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8v.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$12,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8v.buildMatchFn)({
    matchPatterns: matchMonthPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$12,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8v.buildMatchFn)({
    matchPatterns: matchDayPatterns$12,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$12,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8v.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$12,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$12,
    defaultParseWidth: "any",
  }),
});

da.da = void 0;
var _index$8u = formatDistance$29;
var _index2$3O = formatLong$1b;
var _index3$20 = formatRelative$29;
var _index4$1v = localize$13;
var _index5$1m = match$12;

/**
 * @category Locales
 * @summary Danish locale.
 * @language Danish
 * @iso-639-2 dan
 * @author Mathias WÃ¸bbe [@MathiasKandelborg](https://github.com/MathiasKandelborg)
 * @author Anders B. Hansen [@Andersbiha](https://github.com/Andersbiha)
 * @author [@kgram](https://github.com/kgram)
 * @author [@stefanbugge](https://github.com/stefanbugge)
 */
(da.da = {
  code: "da",
  formatDistance: _index$8u.formatDistance,
  formatLong: _index2$3O.formatLong,
  formatRelative: _index3$20.formatRelative,
  localize: _index4$1v.localize,
  match: _index5$1m.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var de = {};

var formatDistance$27 = {};

formatDistance$27.formatDistance = void 0;

const formatDistanceLocale$11 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden",
    },
    withPreposition: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden",
    },
  },

  xSeconds: {
    standalone: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden",
    },
    withPreposition: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden",
    },
  },

  halfAMinute: {
    standalone: "eine halbe Minute",
    withPreposition: "einer halben Minute",
  },

  lessThanXMinutes: {
    standalone: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten",
    },
    withPreposition: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten",
    },
  },

  xMinutes: {
    standalone: {
      one: "1 Minute",
      other: "{{count}} Minuten",
    },
    withPreposition: {
      one: "1 Minute",
      other: "{{count}} Minuten",
    },
  },

  aboutXHours: {
    standalone: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden",
    },
    withPreposition: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden",
    },
  },

  xHours: {
    standalone: {
      one: "1 Stunde",
      other: "{{count}} Stunden",
    },
    withPreposition: {
      one: "1 Stunde",
      other: "{{count}} Stunden",
    },
  },

  xDays: {
    standalone: {
      one: "1 Tag",
      other: "{{count}} Tage",
    },
    withPreposition: {
      one: "1 Tag",
      other: "{{count}} Tagen",
    },
  },

  aboutXWeeks: {
    standalone: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen",
    },
    withPreposition: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen",
    },
  },

  xWeeks: {
    standalone: {
      one: "1 Woche",
      other: "{{count}} Wochen",
    },
    withPreposition: {
      one: "1 Woche",
      other: "{{count}} Wochen",
    },
  },

  aboutXMonths: {
    standalone: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monate",
    },
    withPreposition: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monaten",
    },
  },

  xMonths: {
    standalone: {
      one: "1 Monat",
      other: "{{count}} Monate",
    },
    withPreposition: {
      one: "1 Monat",
      other: "{{count}} Monaten",
    },
  },

  aboutXYears: {
    standalone: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahre",
    },
    withPreposition: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahren",
    },
  },

  xYears: {
    standalone: {
      one: "1 Jahr",
      other: "{{count}} Jahre",
    },
    withPreposition: {
      one: "1 Jahr",
      other: "{{count}} Jahren",
    },
  },

  overXYears: {
    standalone: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahre",
    },
    withPreposition: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahren",
    },
  },

  almostXYears: {
    standalone: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahre",
    },
    withPreposition: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahren",
    },
  },
};

const formatDistance$26 = (token, count, options) => {
  let result;

  const tokenValue = options?.addSuffix
    ? formatDistanceLocale$11[token].withPreposition
    : formatDistanceLocale$11[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }

  return result;
};
formatDistance$27.formatDistance = formatDistance$26;

var formatLong$1a = {};

formatLong$1a.formatLong = void 0;
var _index$8t = buildFormatLongFn$1;

// DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008
const dateFormats$1a = {
  full: "EEEE, do MMMM y", // Montag, 7. Januar 2018
  long: "do MMMM y", // 7. Januar 2018
  medium: "do MMM y", // 7. Jan. 2018
  short: "dd.MM.y", // 07.01.2018
};

const timeFormats$1a = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$1a = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$1a.formatLong = {
  date: (0, _index$8t.buildFormatLongFn)({
    formats: dateFormats$1a,
    defaultWidth: "full",
  }),

  time: (0, _index$8t.buildFormatLongFn)({
    formats: timeFormats$1a,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8t.buildFormatLongFn)({
    formats: dateTimeFormats$1a,
    defaultWidth: "full",
  }),
});

var formatRelative$27 = {};

formatRelative$27.formatRelative = void 0;

const formatRelativeLocale$12 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P",
};

const formatRelative$26 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$12[token];
formatRelative$27.formatRelative = formatRelative$26;

var localize$12 = {};

localize$12.localize = void 0;
var _index$8s = buildLocalizeFn$1;

const eraValues$12 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"],
};

const quarterValues$12 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"],
};

// Note: in German, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$12 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "MÃ¤r",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez",
  ],

  wide: [
    "Januar",
    "Februar",
    "MÃ¤rz",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember",
  ],
};

// https://st.unicode.org/cldr-apps/v#/de/Gregorian/
const formattingMonthValues$e = {
  narrow: monthValues$12.narrow,
  abbreviated: [
    "Jan.",
    "Feb.",
    "MÃ¤rz",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez.",
  ],

  wide: monthValues$12.wide,
};

const dayValues$12 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag",
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/de.html#1881
const dayPeriodValues$12 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht",
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht",
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht",
  },
};
const formattingDayPeriodValues$P = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts",
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts",
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts",
  },
};

const ordinalNumber$12 = (dirtyNumber) => {
  const number = Number(dirtyNumber);

  return number + ".";
};

(localize$12.localize = {
  ordinalNumber: ordinalNumber$12,

  era: (0, _index$8s.buildLocalizeFn)({
    values: eraValues$12,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8s.buildLocalizeFn)({
    values: quarterValues$12,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8s.buildLocalizeFn)({
    values: monthValues$12,
    formattingValues: formattingMonthValues$e,
    defaultWidth: "wide",
  }),

  day: (0, _index$8s.buildLocalizeFn)({
    values: dayValues$12,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8s.buildLocalizeFn)({
    values: dayPeriodValues$12,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$P,
    defaultFormattingWidth: "wide",
  }),
});

var match$11 = {};

match$11.match = void 0;

var _index$8r = buildMatchFn$1;
var _index2$3N = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$11 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$11 = /\d+/i;

const matchEraPatterns$11 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i,
};
const parseEraPatterns$11 = {
  any: [/^v/i, /^n/i],
};

const matchQuarterPatterns$11 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i,
};
const parseQuarterPatterns$11 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$11 = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(j[aÃ¤]n|feb|mÃ¤r[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|mÃ¤rz|april|mai|juni|juli|august|september|oktober|november|dezember)/i,
};
const parseMonthPatterns$11 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^j[aÃ¤]/i,
    /^f/i,
    /^mÃ¤r/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$11 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i,
};
const parseDayPatterns$11 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$11 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated:
    /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i,
};
const parseDayPeriodPatterns$11 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i, // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i, // will never be matched. Night is matched by `pm`
  },
};

(match$11.match = {
  ordinalNumber: (0, _index2$3N.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$11,
    parsePattern: parseOrdinalNumberPattern$11,
    valueCallback: (value) => parseInt(value),
  }),

  era: (0, _index$8r.buildMatchFn)({
    matchPatterns: matchEraPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$11,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8r.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$11,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8r.buildMatchFn)({
    matchPatterns: matchMonthPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$11,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8r.buildMatchFn)({
    matchPatterns: matchDayPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$11,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8r.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$11,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$11,
    defaultParseWidth: "any",
  }),
});

de.de = void 0;
var _index$8q = formatDistance$27;
var _index2$3M = formatLong$1a;
var _index3$1$ = formatRelative$27;
var _index4$1u = localize$12;
var _index5$1l = match$11;

/**
 * @category Locales
 * @summary German locale.
 * @language German
 * @iso-639-2 deu
 * @author Thomas Eilmsteiner [@DeMuu](https://github.com/DeMuu)
 * @author Asia [@asia-t](https://github.com/asia-t)
 * @author Van Vuong Ngo [@vanvuongngo](https://github.com/vanvuongngo)
 * @author RomanErnst [@pex](https://github.com/pex)
 * @author Philipp Keck [@Philipp91](https://github.com/Philipp91)
 */
(de.de = {
  code: "de",
  formatDistance: _index$8q.formatDistance,
  formatLong: _index2$3M.formatLong,
  formatRelative: _index3$1$.formatRelative,
  localize: _index4$1u.localize,
  match: _index5$1l.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var deAT = {};

var localize$11 = {};

localize$11.localize = void 0;
var _index$8p = buildLocalizeFn$1;

const eraValues$11 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"],
};

const quarterValues$11 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"],
};

// Note: in German, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$11 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "JÃ¤n",
    "Feb",
    "MÃ¤r",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez",
  ],

  wide: [
    "JÃ¤nner",
    "Februar",
    "MÃ¤rz",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember",
  ],
};

// https://st.unicode.org/cldr-apps/v#/de_AT/Gregorian/
const formattingMonthValues$d = {
  narrow: monthValues$11.narrow,
  abbreviated: [
    "JÃ¤n.",
    "Feb.",
    "MÃ¤rz",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez.",
  ],

  wide: monthValues$11.wide,
};

const dayValues$11 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag",
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/de.html#1881
const dayPeriodValues$11 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht",
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht",
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht",
  },
};
const formattingDayPeriodValues$O = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts",
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts",
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts",
  },
};

const ordinalNumber$11 = (dirtyNumber) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$11.localize = {
  ordinalNumber: ordinalNumber$11,

  era: (0, _index$8p.buildLocalizeFn)({
    values: eraValues$11,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8p.buildLocalizeFn)({
    values: quarterValues$11,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8p.buildLocalizeFn)({
    values: monthValues$11,
    formattingValues: formattingMonthValues$d,
    defaultWidth: "wide",
  }),

  day: (0, _index$8p.buildLocalizeFn)({
    values: dayValues$11,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8p.buildLocalizeFn)({
    values: dayPeriodValues$11,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$O,
    defaultFormattingWidth: "wide",
  }),
});

deAT.deAT = void 0;
var _index$8o = formatDistance$27;
var _index2$3L = formatLong$1a;
var _index3$1_ = formatRelative$27;
var _index4$1t = match$11;

var _index5$1k = localize$11; // difference to 'de' locale

/**
 * @category Locales
 * @summary German locale (Austria).
 * @language German
 * @iso-639-2 deu
 * @author Christoph Tobias Stenglein [@cstenglein](https://github.com/cstenglein)
 */
(deAT.deAT = {
  code: "de-AT",
  formatDistance: _index$8o.formatDistance,
  formatLong: _index2$3L.formatLong,
  formatRelative: _index3$1_.formatRelative,
  localize: _index5$1k.localize,
  match: _index4$1t.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var el = {};

var formatDistance$25 = {};

formatDistance$25.formatDistance = void 0;

const formatDistanceLocale$10 = {
  lessThanXSeconds: {
    one: "Î»Î¹Î³ÏÏÎµÏÎ¿ Î±ÏÏ Î­Î½Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ¿",
    other: "Î»Î¹Î³ÏÏÎµÏÎ¿ Î±ÏÏ {{count}} Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±",
  },

  xSeconds: {
    one: "1 Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ¿",
    other: "{{count}} Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±",
  },

  halfAMinute: "Î¼Î¹ÏÏ Î»ÎµÏÏÏ",

  lessThanXMinutes: {
    one: "Î»Î¹Î³ÏÏÎµÏÎ¿ Î±ÏÏ Î­Î½Î± Î»ÎµÏÏÏ",
    other: "Î»Î¹Î³ÏÏÎµÏÎ¿ Î±ÏÏ {{count}} Î»ÎµÏÏÎ¬",
  },

  xMinutes: {
    one: "1 Î»ÎµÏÏÏ",
    other: "{{count}} Î»ÎµÏÏÎ¬",
  },

  aboutXHours: {
    one: "ÏÎµÏÎ¯ÏÎ¿Ï 1 ÏÏÎ±",
    other: "ÏÎµÏÎ¯ÏÎ¿Ï {{count}} ÏÏÎµÏ",
  },

  xHours: {
    one: "1 ÏÏÎ±",
    other: "{{count}} ÏÏÎµÏ",
  },

  xDays: {
    one: "1 Î·Î¼Î­ÏÎ±",
    other: "{{count}} Î·Î¼Î­ÏÎµÏ",
  },

  aboutXWeeks: {
    one: "ÏÎµÏÎ¯ÏÎ¿Ï 1 ÎµÎ²Î´Î¿Î¼Î¬Î´Î±",
    other: "ÏÎµÏÎ¯ÏÎ¿Ï {{count}} ÎµÎ²Î´Î¿Î¼Î¬Î´ÎµÏ",
  },

  xWeeks: {
    one: "1 ÎµÎ²Î´Î¿Î¼Î¬Î´Î±",
    other: "{{count}} ÎµÎ²Î´Î¿Î¼Î¬Î´ÎµÏ",
  },

  aboutXMonths: {
    one: "ÏÎµÏÎ¯ÏÎ¿Ï 1 Î¼Î®Î½Î±Ï",
    other: "ÏÎµÏÎ¯ÏÎ¿Ï {{count}} Î¼Î®Î½ÎµÏ",
  },

  xMonths: {
    one: "1 Î¼Î®Î½Î±Ï",
    other: "{{count}} Î¼Î®Î½ÎµÏ",
  },

  aboutXYears: {
    one: "ÏÎµÏÎ¯ÏÎ¿Ï 1 ÏÏÏÎ½Î¿",
    other: "ÏÎµÏÎ¯ÏÎ¿Ï {{count}} ÏÏÏÎ½Î¹Î±",
  },

  xYears: {
    one: "1 ÏÏÏÎ½Î¿",
    other: "{{count}} ÏÏÏÎ½Î¹Î±",
  },

  overXYears: {
    one: "ÏÎ¬Î½Ï Î±ÏÏ 1 ÏÏÏÎ½Î¿",
    other: "ÏÎ¬Î½Ï Î±ÏÏ {{count}} ÏÏÏÎ½Î¹Î±",
  },

  almostXYears: {
    one: "ÏÎµÏÎ¯ÏÎ¿Ï 1 ÏÏÏÎ½Î¿",
    other: "ÏÎµÏÎ¯ÏÎ¿Ï {{count}} ÏÏÏÎ½Î¹Î±",
  },
};

const formatDistance$24 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$10[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ÏÎµ " + result;
    } else {
      return result + " ÏÏÎ¹Î½";
    }
  }

  return result;
};
formatDistance$25.formatDistance = formatDistance$24;

var formatLong$19 = {};

formatLong$19.formatLong = void 0;
var _index$8n = buildFormatLongFn$1;

const dateFormats$19 = {
  full: "EEEE, d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "d/M/yy",
};

const timeFormats$19 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$19 = {
  full: "{{date}} - {{time}}",
  long: "{{date}} - {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$19.formatLong = {
  date: (0, _index$8n.buildFormatLongFn)({
    formats: dateFormats$19,
    defaultWidth: "full",
  }),

  time: (0, _index$8n.buildFormatLongFn)({
    formats: timeFormats$19,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8n.buildFormatLongFn)({
    formats: dateTimeFormats$19,
    defaultWidth: "full",
  }),
});

var formatRelative$25 = {};

formatRelative$25.formatRelative = void 0;

const formatRelativeLocale$11 = {
  lastWeek: (date) => {
    switch (date.getDay()) {
      case 6: //Î£Î¬Î²Î²Î±ÏÎ¿
        return "'ÏÎ¿ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿' eeee 'ÏÏÎ¹Ï' p";
      default:
        return "'ÏÎ·Î½ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î·' eeee 'ÏÏÎ¹Ï' p";
    }
  },
  yesterday: "'ÏÎ¸ÎµÏ ÏÏÎ¹Ï' p",
  today: "'ÏÎ®Î¼ÎµÏÎ± ÏÏÎ¹Ï' p",
  tomorrow: "'Î±ÏÏÎ¹Î¿ ÏÏÎ¹Ï' p",
  nextWeek: "eeee 'ÏÏÎ¹Ï' p",
  other: "P",
};

const formatRelative$24 = (token, date) => {
  const format = formatRelativeLocale$11[token];

  if (typeof format === "function") return format(date);

  return format;
};
formatRelative$25.formatRelative = formatRelative$24;

var localize$10 = {};

localize$10.localize = void 0;
var _index$8m = buildLocalizeFn$1;

const eraValues$10 = {
  narrow: ["ÏÎ§", "Î¼Î§"],
  abbreviated: ["Ï.Î§.", "Î¼.Î§."],
  wide: ["ÏÏÎ¿ Î§ÏÎ¹ÏÏÎ¿Ï", "Î¼ÎµÏÎ¬ Î§ÏÎ¹ÏÏÏÎ½"],
};

const quarterValues$10 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Î¤1", "Î¤2", "Î¤3", "Î¤4"],
  wide: ["1Î¿ ÏÏÎ¯Î¼Î·Î½Î¿", "2Î¿ ÏÏÎ¯Î¼Î·Î½Î¿", "3Î¿ ÏÏÎ¯Î¼Î·Î½Î¿", "4Î¿ ÏÏÎ¯Î¼Î·Î½Î¿"],
};

const monthValues$10 = {
  narrow: ["Î", "Î¦", "Î", "Î", "Î", "Î", "Î", "Î", "Î£", "Î", "Î", "Î"],
  abbreviated: [
    "ÎÎ±Î½",
    "Î¦ÎµÎ²",
    "ÎÎ¬Ï",
    "ÎÏÏ",
    "ÎÎ¬Î¹",
    "ÎÎ¿ÏÎ½",
    "ÎÎ¿ÏÎ»",
    "ÎÏÎ³",
    "Î£ÎµÏ",
    "ÎÎºÏ",
    "ÎÎ¿Î­",
    "ÎÎµÎº",
  ],

  wide: [
    "ÎÎ±Î½Î¿ÏÎ¬ÏÎ¹Î¿Ï",
    "Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï",
    "ÎÎ¬ÏÏÎ¹Î¿Ï",
    "ÎÏÏÎ¯Î»Î¹Î¿Ï",
    "ÎÎ¬Î¹Î¿Ï",
    "ÎÎ¿ÏÎ½Î¹Î¿Ï",
    "ÎÎ¿ÏÎ»Î¹Î¿Ï",
    "ÎÏÎ³Î¿ÏÏÏÎ¿Ï",
    "Î£ÎµÏÏÎ­Î¼Î²ÏÎ¹Î¿Ï",
    "ÎÎºÏÏÎ²ÏÎ¹Î¿Ï",
    "ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï",
    "ÎÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï",
  ],
};

const formattingMonthValues$c = {
  narrow: ["Î", "Î¦", "Î", "Î", "Î", "Î", "Î", "Î", "Î£", "Î", "Î", "Î"],
  abbreviated: [
    "ÎÎ±Î½",
    "Î¦ÎµÎ²",
    "ÎÎ±Ï",
    "ÎÏÏ",
    "ÎÎ±Î",
    "ÎÎ¿ÏÎ½",
    "ÎÎ¿ÏÎ»",
    "ÎÏÎ³",
    "Î£ÎµÏ",
    "ÎÎºÏ",
    "ÎÎ¿Îµ",
    "ÎÎµÎº",
  ],

  wide: [
    "ÎÎ±Î½Î¿ÏÎ±ÏÎ¯Î¿Ï",
    "Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï",
    "ÎÎ±ÏÏÎ¯Î¿Ï",
    "ÎÏÏÎ¹Î»Î¯Î¿Ï",
    "ÎÎ±ÎÎ¿Ï",
    "ÎÎ¿ÏÎ½Î¯Î¿Ï",
    "ÎÎ¿ÏÎ»Î¯Î¿Ï",
    "ÎÏÎ³Î¿ÏÏÏÎ¿Ï",
    "Î£ÎµÏÏÎµÎ¼Î²ÏÎ¯Î¿Ï",
    "ÎÎºÏÏÎ²ÏÎ¯Î¿Ï",
    "ÎÎ¿ÎµÎ¼Î²ÏÎ¯Î¿Ï",
    "ÎÎµÎºÎµÎ¼Î²ÏÎ¯Î¿Ï",
  ],
};

const dayValues$10 = {
  narrow: ["Î", "Î", "T", "Î¤", "Î ", "Î ", "Î£"],
  short: ["ÎÏ", "ÎÎµ", "Î¤Ï", "Î¤Îµ", "Î Î­", "Î Î±", "Î£Î¬"],
  abbreviated: ["ÎÏÏ", "ÎÎµÏ", "Î¤ÏÎ¯", "Î¤ÎµÏ", "Î Î­Î¼", "Î Î±Ï", "Î£Î¬Î²"],
  wide: [
    "ÎÏÏÎ¹Î±ÎºÎ®",
    "ÎÎµÏÏÎ­ÏÎ±",
    "Î¤ÏÎ¯ÏÎ·",
    "Î¤ÎµÏÎ¬ÏÏÎ·",
    "Î Î­Î¼ÏÏÎ·",
    "Î Î±ÏÎ±ÏÎºÎµÏÎ®",
    "Î£Î¬Î²Î²Î±ÏÎ¿",
  ],
};

const dayPeriodValues$10 = {
  narrow: {
    am: "ÏÎ¼",
    pm: "Î¼Î¼",
    midnight: "Î¼ÎµÏÎ¬Î½ÏÏÏÎ±",
    noon: "Î¼ÎµÏÎ·Î¼Î­ÏÎ¹",
    morning: "ÏÏÏÎ¯",
    afternoon: "Î±ÏÏÎ³ÎµÏÎ¼Î±",
    evening: "Î²ÏÎ¬Î´Ï",
    night: "Î½ÏÏÏÎ±",
  },
  abbreviated: {
    am: "Ï.Î¼.",
    pm: "Î¼.Î¼.",
    midnight: "Î¼ÎµÏÎ¬Î½ÏÏÏÎ±",
    noon: "Î¼ÎµÏÎ·Î¼Î­ÏÎ¹",
    morning: "ÏÏÏÎ¯",
    afternoon: "Î±ÏÏÎ³ÎµÏÎ¼Î±",
    evening: "Î²ÏÎ¬Î´Ï",
    night: "Î½ÏÏÏÎ±",
  },
  wide: {
    am: "Ï.Î¼.",
    pm: "Î¼.Î¼.",
    midnight: "Î¼ÎµÏÎ¬Î½ÏÏÏÎ±",
    noon: "Î¼ÎµÏÎ·Î¼Î­ÏÎ¹",
    morning: "ÏÏÏÎ¯",
    afternoon: "Î±ÏÏÎ³ÎµÏÎ¼Î±",
    evening: "Î²ÏÎ¬Î´Ï",
    night: "Î½ÏÏÏÎ±",
  },
};

const ordinalNumber$10 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;
  let suffix;

  if (unit === "year" || unit === "month") {
    suffix = "Î¿Ï";
  } else if (
    unit === "week" ||
    unit === "dayOfYear" ||
    unit === "day" ||
    unit === "hour" ||
    unit === "date"
  ) {
    suffix = "Î·";
  } else {
    suffix = "Î¿";
  }

  return number + suffix;
};

(localize$10.localize = {
  ordinalNumber: ordinalNumber$10,

  era: (0, _index$8m.buildLocalizeFn)({
    values: eraValues$10,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8m.buildLocalizeFn)({
    values: quarterValues$10,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8m.buildLocalizeFn)({
    values: monthValues$10,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$c,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$8m.buildLocalizeFn)({
    values: dayValues$10,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8m.buildLocalizeFn)({
    values: dayPeriodValues$10,
    defaultWidth: "wide",
  }),
});

var match$10 = {};

match$10.match = void 0;

var _index$8l = buildMatchFn$1;
var _index2$3K = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$10 = /^(\d+)(Î¿Ï|Î·|Î¿)?/i;
const parseOrdinalNumberPattern$10 = /\d+/i;

const matchEraPatterns$10 = {
  narrow: /^(ÏÎ§|Î¼Î§)/i,
  abbreviated: /^(Ï\.?\s?Ï\.?|Ï\.?\s?Îº\.?\s?Ï\.?|Î¼\.?\s?Ï\.?|Îº\.?\s?Ï\.?)/i,
  wide: /^(ÏÏÎ¿ Î§ÏÎ¹ÏÏÎ¿(Ï|Ï)|ÏÏÎ¹Î½ Î±Ï(Ï|Î¿) ÏÎ·Î½ ÎÎ¿Î¹Î½(Î®|Î·) Î§ÏÎ¿Î½Î¿Î»Î¿Î³(Î¯|Î¹)Î±|Î¼ÎµÏ(Î¬|Î±) Î§ÏÎ¹ÏÏ(Ï|Î¿)Î½|ÎÎ¿Î¹Î½(Î®|Î·) Î§ÏÎ¿Î½Î¿Î»Î¿Î³(Î¯|Î¹)Î±)/i,
};
const parseEraPatterns$10 = {
  any: [/^Ï/i, /^(Î¼|Îº)/i],
};

const matchQuarterPatterns$10 = {
  narrow: /^[1234]/i,
  abbreviated: /^Ï[1234]/i,
  wide: /^[1234]Î¿? ÏÏ(Î¯|Î¹)Î¼Î·Î½Î¿/i,
};
const parseQuarterPatterns$10 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$10 = {
  narrow: /^[Î¹ÏÎ¼Î±Î¼Î¹Î¹Î±ÏÎ¿Î½Î´]/i,
  abbreviated:
    /^(Î¹Î±Î½|ÏÎµÎ²|Î¼[Î¬Î±]Ï|Î±ÏÏ|Î¼[Î¬Î±][Î¹Î]|Î¹Î¿[ÏÏ]Î½|Î¹Î¿[ÏÏ]Î»|Î±[ÏÏ]Î³|ÏÎµÏ|Î¿ÎºÏ|Î½Î¿[Î­Îµ]|Î´ÎµÎº)/i,
  wide: /^(Î¼[Î¬Î±][Î¹Î]|Î±[ÏÏ]Î³Î¿[ÏÏ]ÏÏ)(Î¿Ï|Î¿Ï)|(Î¹Î±Î½Î¿Ï[Î¬Î±]Ï|ÏÎµÎ²ÏÎ¿Ï[Î¬Î±]Ï|Î¼[Î¬Î±]ÏÏ|Î±ÏÏ[Î¯Î¹]Î»|Î¹Î¿[ÏÏ]Î½|Î¹Î¿[ÏÏ]Î»|ÏÎµÏÏ[Î­Îµ]Î¼Î²Ï|Î¿ÎºÏ[ÏÏ]Î²Ï|Î½Î¿[Î­Îµ]Î¼Î²Ï|Î´ÎµÎº[Î­Îµ]Î¼Î²Ï)(Î¹Î¿Ï|Î¯Î¿Ï)/i,
};
const parseMonthPatterns$10 = {
  narrow: [
    /^Î¹/i,
    /^Ï/i,
    /^Î¼/i,
    /^Î±/i,
    /^Î¼/i,
    /^Î¹/i,
    /^Î¹/i,
    /^Î±/i,
    /^Ï/i,
    /^Î¿/i,
    /^Î½/i,
    /^Î´/i,
  ],

  any: [
    /^Î¹Î±/i,
    /^Ï/i,
    /^Î¼[Î¬Î±]Ï/i,
    /^Î±Ï/i,
    /^Î¼[Î¬Î±][Î¹Î]/i,
    /^Î¹Î¿[ÏÏ]Î½/i,
    /^Î¹Î¿[ÏÏ]Î»/i,
    /^Î±[ÏÏ]/i,
    /^Ï/i,
    /^Î¿/i,
    /^Î½/i,
    /^Î´/i,
  ],
};

const matchDayPatterns$10 = {
  narrow: /^[ÎºÎ´ÏÏÏ]/i,
  short: /^(ÎºÏ|Î´Îµ|ÏÏ|ÏÎµ|Ï[ÎµÎ­]|Ï[Î±Î¬]|Ï[Î±Î¬])/i,
  abbreviated: /^(ÎºÏÏ|Î´ÎµÏ|ÏÏÎ¹|ÏÎµÏ|ÏÎµÎ¼|ÏÎ±Ï|ÏÎ±Î²)/i,
  wide: /^(ÎºÏÏÎ¹Î±Îº(Î®|Î·)|Î´ÎµÏÏ(Î­|Îµ)ÏÎ±|ÏÏ(Î¯|Î¹)ÏÎ·|ÏÎµÏ(Î¬|Î±)ÏÏÎ·|Ï(Î­|Îµ)Î¼ÏÏÎ·|ÏÎ±ÏÎ±ÏÎºÎµÏ(Î®|Î·)|Ï(Î¬|Î±)Î²Î²Î±ÏÎ¿)/i,
};
const parseDayPatterns$10 = {
  narrow: [/^Îº/i, /^Î´/i, /^Ï/i, /^Ï/i, /^Ï/i, /^Ï/i, /^Ï/i],
  any: [/^Îº/i, /^Î´/i, /^ÏÏ/i, /^ÏÎµ/i, /^Ï[ÎµÎ­]/i, /^Ï[Î±Î¬]/i, /^Ï/i],
};

const matchDayPeriodPatterns$10 = {
  narrow:
    /^(ÏÎ¼|Î¼Î¼|Î¼ÎµÏ(Î¬|Î±)Î½ÏÏÏÎ±|Î¼ÎµÏÎ·Î¼(Î­|Îµ)ÏÎ¹|ÏÏÏ(Î¯|Î¹)|Î±Ï(Ï|Î¿)Î³ÎµÏÎ¼Î±|Î²Ï(Î¬|Î±)Î´Ï|Î½(Ï|Ï)ÏÏÎ±)/i,
  any: /^([ÏÎ¼]\.?\s?Î¼\.?|Î¼ÎµÏ(Î¬|Î±)Î½ÏÏÏÎ±|Î¼ÎµÏÎ·Î¼(Î­|Îµ)ÏÎ¹|ÏÏÏ(Î¯|Î¹)|Î±Ï(Ï|Î¿)Î³ÎµÏÎ¼Î±|Î²Ï(Î¬|Î±)Î´Ï|Î½(Ï|Ï)ÏÏÎ±)/i,
};
const parseDayPeriodPatterns$10 = {
  any: {
    am: /^ÏÎ¼|Ï\.\s?Î¼\./i,
    pm: /^Î¼Î¼|Î¼\.\s?Î¼\./i,
    midnight: /^Î¼ÎµÏÎ¬Î½/i,
    noon: /^Î¼ÎµÏÎ·Î¼(Î­|Îµ)/i,
    morning: /ÏÏÏ(Î¯|Î¹)/i,
    afternoon: /Î±Ï(Ï|Î¿)Î³ÎµÏÎ¼Î±/i,
    evening: /Î²Ï(Î¬|Î±)Î´Ï/i,
    night: /Î½(Ï|Ï)ÏÏÎ±/i,
  },
};

(match$10.match = {
  ordinalNumber: (0, _index2$3K.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$10,
    parsePattern: parseOrdinalNumberPattern$10,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8l.buildMatchFn)({
    matchPatterns: matchEraPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$10,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8l.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$10,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8l.buildMatchFn)({
    matchPatterns: matchMonthPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$10,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8l.buildMatchFn)({
    matchPatterns: matchDayPatterns$10,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$10,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8l.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$10,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$10,
    defaultParseWidth: "any",
  }),
});

el.el = void 0;
var _index$8k = formatDistance$25;
var _index2$3J = formatLong$19;
var _index3$1Z = formatRelative$25;
var _index4$1s = localize$10;
var _index5$1j = match$10;

/**
 * @category Locales
 * @summary Greek locale.
 * @language Greek
 * @iso-639-2 ell
 * @author Fanis Katsimpas [@fanixk](https://github.com/fanixk)
 * @author Theodoros Orfanidis [@teoulas](https://github.com/teoulas)
 */
(el.el = {
  code: "el",
  formatDistance: _index$8k.formatDistance,
  formatLong: _index2$3J.formatLong,
  formatRelative: _index3$1Z.formatRelative,
  localize: _index4$1s.localize,
  match: _index5$1j.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var enAU = {};

var formatDistance$23 = {};

formatDistance$23.formatDistance = void 0;

const formatDistanceLocale$$ = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds",
  },

  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds",
  },

  halfAMinute: "half a minute",

  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes",
  },

  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours",
  },

  xHours: {
    one: "1 hour",
    other: "{{count}} hours",
  },

  xDays: {
    one: "1 day",
    other: "{{count}} days",
  },

  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks",
  },

  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months",
  },

  xMonths: {
    one: "1 month",
    other: "{{count}} months",
  },

  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years",
  },

  xYears: {
    one: "1 year",
    other: "{{count}} years",
  },

  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years",
  },

  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years",
  },
};

const formatDistance$22 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$$[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }

  return result;
};
formatDistance$23.formatDistance = formatDistance$22;

var formatLong$18 = {};

formatLong$18.formatLong = void 0;
var _index$8j = buildFormatLongFn$1;

const dateFormats$18 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$18 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$18 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$18.formatLong = {
  date: (0, _index$8j.buildFormatLongFn)({
    formats: dateFormats$18,
    defaultWidth: "full",
  }),

  time: (0, _index$8j.buildFormatLongFn)({
    formats: timeFormats$18,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8j.buildFormatLongFn)({
    formats: dateTimeFormats$18,
    defaultWidth: "full",
  }),
});

var formatRelative$23 = {};

formatRelative$23.formatRelative = void 0;

const formatRelativeLocale$10 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P",
};

const formatRelative$22 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$10[token];
formatRelative$23.formatRelative = formatRelative$22;

var localize$$ = {};

localize$$.localize = void 0;
var _index$8i = buildLocalizeFn$1;

const eraValues$$ = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"],
};

const quarterValues$$ = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$$ = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],

  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
};

const dayValues$$ = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
};

const dayPeriodValues$$ = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
};

const formattingDayPeriodValues$N = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
};

const ordinalNumber$$ = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};

(localize$$.localize = {
  ordinalNumber: ordinalNumber$$,

  era: (0, _index$8i.buildLocalizeFn)({
    values: eraValues$$,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$8i.buildLocalizeFn)({
    values: quarterValues$$,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$8i.buildLocalizeFn)({
    values: monthValues$$,
    defaultWidth: "wide",
  }),

  day: (0, _index$8i.buildLocalizeFn)({
    values: dayValues$$,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$8i.buildLocalizeFn)({
    values: dayPeriodValues$$,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$N,
    defaultFormattingWidth: "wide",
  }),
});

var match$$ = {};

match$$.match = void 0;

var _index$8h = buildMatchFn$1;
var _index2$3I = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$$ = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$$ = /\d+/i;

const matchEraPatterns$$ = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i,
};
const parseEraPatterns$$ = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns$$ = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i,
};
const parseQuarterPatterns$$ = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$$ = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
};
const parseMonthPatterns$$ = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$$ = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
};
const parseDayPatterns$$ = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$$ = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns$$ = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

(match$$.match = {
  ordinalNumber: (0, _index2$3I.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$$,
    parsePattern: parseOrdinalNumberPattern$$,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$8h.buildMatchFn)({
    matchPatterns: matchEraPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$$,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$8h.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$$,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$8h.buildMatchFn)({
    matchPatterns: matchMonthPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$$,
    defaultParseWidth: "any",
  }),

  day: (0, _index$8h.buildMatchFn)({
    matchPatterns: matchDayPatterns$$,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$$,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$8h.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$$,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$$,
    defaultParseWidth: "any",
  }),
});

enAU.enAU = void 0;
var _index$8g = formatDistance$23;
var _index2$3H = formatLong$18;
var _index3$1Y = formatRelative$23;
var _index4$1r = localize$$;
var _index5$1i = match$$;

/**
 * @category Locales
 * @summary English locale (Australia).
 * @language English
 * @iso-639-2 eng
 * @author Julien Malige [@JulienMalige](https://github.com/JulienMalige)
 */
(enAU.enAU = {
  code: "en-AU",
  formatDistance: _index$8g.formatDistance,
  formatLong: _index2$3H.formatLong,
  formatRelative: _index3$1Y.formatRelative,
  localize: _index4$1r.localize,
  match: _index5$1i.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var enCA = {};

var formatDistance$21 = {};

formatDistance$21.formatDistance = void 0;

const formatDistanceLocale$_ = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds",
  },

  xSeconds: {
    one: "a second",
    other: "{{count}} seconds",
  },

  halfAMinute: "half a minute",

  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes",
  },

  xMinutes: {
    one: "a minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "about an hour",
    other: "about {{count}} hours",
  },

  xHours: {
    one: "an hour",
    other: "{{count}} hours",
  },

  xDays: {
    one: "a day",
    other: "{{count}} days",
  },

  aboutXWeeks: {
    one: "about a week",
    other: "about {{count}} weeks",
  },

  xWeeks: {
    one: "a week",
    other: "{{count}} weeks",
  },

  aboutXMonths: {
    one: "about a month",
    other: "about {{count}} months",
  },

  xMonths: {
    one: "a month",
    other: "{{count}} months",
  },

  aboutXYears: {
    one: "about a year",
    other: "about {{count}} years",
  },

  xYears: {
    one: "a year",
    other: "{{count}} years",
  },

  overXYears: {
    one: "over a year",
    other: "over {{count}} years",
  },

  almostXYears: {
    one: "almost a year",
    other: "almost {{count}} years",
  },
};

const formatDistance$20 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$_[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }

  return result;
};
formatDistance$21.formatDistance = formatDistance$20;

var formatLong$17 = {};

formatLong$17.formatLong = void 0;
var _index$8f = buildFormatLongFn$1;

const dateFormats$17 = {
  full: "EEEE, MMMM do, yyyy",
  long: "MMMM do, yyyy",
  medium: "MMM d, yyyy",
  short: "yyyy-MM-dd",
};

const timeFormats$17 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$17 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$17.formatLong = {
  date: (0, _index$8f.buildFormatLongFn)({
    formats: dateFormats$17,
    defaultWidth: "full",
  }),

  time: (0, _index$8f.buildFormatLongFn)({
    formats: timeFormats$17,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8f.buildFormatLongFn)({
    formats: dateTimeFormats$17,
    defaultWidth: "full",
  }),
});

enCA.enCA = void 0;
var _index$8e = formatRelative$23;
var _index2$3G = localize$$;
var _index3$1X = match$$;

var _index4$1q = formatDistance$21;
var _index5$1h = formatLong$17;

/**
 * @category Locales
 * @summary English locale (Canada).
 * @language English
 * @iso-639-2 eng
 * @author Mark Owsiak [@markowsiak](https://github.com/markowsiak)
 * @author Marco Imperatore [@mimperatore](https://github.com/mimperatore)
 */
(enCA.enCA = {
  code: "en-CA",
  formatDistance: _index4$1q.formatDistance,
  formatLong: _index5$1h.formatLong,
  formatRelative: _index$8e.formatRelative,
  localize: _index2$3G.localize,
  match: _index3$1X.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var enGB = {};

var formatLong$16 = {};

formatLong$16.formatLong = void 0;
var _index$8d = buildFormatLongFn$1;

const dateFormats$16 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$16 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$16 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$16.formatLong = {
  date: (0, _index$8d.buildFormatLongFn)({
    formats: dateFormats$16,
    defaultWidth: "full",
  }),

  time: (0, _index$8d.buildFormatLongFn)({
    formats: timeFormats$16,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8d.buildFormatLongFn)({
    formats: dateTimeFormats$16,
    defaultWidth: "full",
  }),
});

enGB.enGB = void 0;
var _index$8c = formatDistance$23;
var _index2$3F = formatRelative$23;
var _index3$1W = localize$$;
var _index4$1p = match$$;

var _index5$1g = formatLong$16;

/**
 * @category Locales
 * @summary English locale (United Kingdom).
 * @language English
 * @iso-639-2 eng
 * @author Alex [@glintik](https://github.com/glintik)
 */
(enGB.enGB = {
  code: "en-GB",
  formatDistance: _index$8c.formatDistance,
  formatLong: _index5$1g.formatLong,
  formatRelative: _index2$3F.formatRelative,
  localize: _index3$1W.localize,
  match: _index4$1p.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var enIE = {};

enIE.enIE = void 0;
var _index$8b = formatDistance$23;
var _index2$3E = formatRelative$23;
var _index3$1V = localize$$;
var _index4$1o = match$$;

var _index5$1f = formatLong$16;

/**
 * @category Locales
 * @summary English locale (Ireland).
 * @language English
 * @iso-639-2 eng
 * @author Tetiana [@tan75](https://github.com/tan75)
 */
(enIE.enIE = {
  code: "en-IE",
  formatDistance: _index$8b.formatDistance,
  formatLong: _index5$1f.formatLong,
  formatRelative: _index2$3E.formatRelative,
  localize: _index3$1V.localize,
  match: _index4$1o.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var enIN = {};

var formatLong$15 = {};

formatLong$15.formatLong = void 0;
var _index$8a = buildFormatLongFn$1;

const dateFormats$15 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM, yyyy",
  medium: "d MMM, yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$15 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$15 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$15.formatLong = {
  date: (0, _index$8a.buildFormatLongFn)({
    formats: dateFormats$15,
    defaultWidth: "full",
  }),

  time: (0, _index$8a.buildFormatLongFn)({
    formats: timeFormats$15,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$8a.buildFormatLongFn)({
    formats: dateTimeFormats$15,
    defaultWidth: "full",
  }),
});

enIN.enIN = void 0;
var _index$89 = formatDistance$23;
var _index2$3D = formatRelative$23;
var _index3$1U = localize$$;
var _index4$1n = match$$;

var _index5$1e = formatLong$15;

/**
 * @category Locales
 * @summary English locale (India).
 * @language English
 * @iso-639-2 eng
 * @author Galeel Bhasha Satthar [@gbhasha](https://github.com/gbhasha)
 */
(enIN.enIN = {
  code: "en-IN",
  formatDistance: _index$89.formatDistance,
  formatLong: _index5$1e.formatLong,
  formatRelative: _index2$3D.formatRelative,
  localize: _index3$1U.localize,
  match: _index4$1n.match,
  options: {
    weekStartsOn: 1, // Monday is the first day of the week.
    firstWeekContainsDate: 4, // The week that contains Jan 4th is the first week of the year.
  },
});

var enNZ = {};

var formatLong$14 = {};

formatLong$14.formatLong = void 0;
var _index$88 = buildFormatLongFn$1;

const dateFormats$14 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$14 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$14 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$14.formatLong = {
  date: (0, _index$88.buildFormatLongFn)({
    formats: dateFormats$14,
    defaultWidth: "full",
  }),

  time: (0, _index$88.buildFormatLongFn)({
    formats: timeFormats$14,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$88.buildFormatLongFn)({
    formats: dateTimeFormats$14,
    defaultWidth: "full",
  }),
});

enNZ.enNZ = void 0;
var _index$87 = formatDistance$23;
var _index2$3C = formatRelative$23;
var _index3$1T = localize$$;
var _index4$1m = match$$;

var _index5$1d = formatLong$14;

/**
 * @category Locales
 * @summary English locale (New Zealand).
 * @language English
 * @iso-639-2 eng
 * @author Murray Lucas [@muntact](https://github.com/muntact)
 */
(enNZ.enNZ = {
  code: "en-NZ",
  formatDistance: _index$87.formatDistance,
  formatLong: _index5$1d.formatLong,
  formatRelative: _index2$3C.formatRelative,
  localize: _index3$1T.localize,
  match: _index4$1m.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var enUS = {};

var formatLong$13 = {};

formatLong$13.formatLong = void 0;
var _index$86 = buildFormatLongFn$1;

const dateFormats$13 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$13 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$13 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$13.formatLong = {
  date: (0, _index$86.buildFormatLongFn)({
    formats: dateFormats$13,
    defaultWidth: "full",
  }),

  time: (0, _index$86.buildFormatLongFn)({
    formats: timeFormats$13,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$86.buildFormatLongFn)({
    formats: dateTimeFormats$13,
    defaultWidth: "full",
  }),
});

enUS.enUS = void 0;
var _index$85 = formatDistance$23;
var _index2$3B = formatLong$13;
var _index3$1S = formatRelative$23;
var _index4$1l = localize$$;
var _index5$1c = match$$;

/**
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */
(enUS.enUS = {
  code: "en-US",
  formatDistance: _index$85.formatDistance,
  formatLong: _index2$3B.formatLong,
  formatRelative: _index3$1S.formatRelative,
  localize: _index4$1l.localize,
  match: _index5$1c.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var enZA = {};

var formatLong$12 = {};

formatLong$12.formatLong = void 0;
var _index$84 = buildFormatLongFn$1;

const dateFormats$12 = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "yyyy/MM/dd",
};

const timeFormats$12 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$12 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$12.formatLong = {
  date: (0, _index$84.buildFormatLongFn)({
    formats: dateFormats$12,
    defaultWidth: "full",
  }),

  time: (0, _index$84.buildFormatLongFn)({
    formats: timeFormats$12,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$84.buildFormatLongFn)({
    formats: dateTimeFormats$12,
    defaultWidth: "full",
  }),
});

enZA.enZA = void 0;
var _index$83 = formatDistance$23;
var _index2$3A = formatRelative$23;
var _index3$1R = localize$$;
var _index4$1k = match$$;

var _index5$1b = formatLong$12;

/**
 * @category Locales
 * @summary English locale (South Africa).
 * @language English
 * @iso-639-2 eng
 * @author Shaila Kavrakova [@shaykav](https://github.com/shaykav)
 */
(enZA.enZA = {
  code: "en-ZA",
  formatDistance: _index$83.formatDistance,
  formatLong: _index5$1b.formatLong,
  formatRelative: _index2$3A.formatRelative,
  localize: _index3$1R.localize,
  match: _index4$1k.match,
  options: {
    weekStartsOn: 0, // Sunday is the first day of the week.
    firstWeekContainsDate: 1, // The week that contains Jan 1st is the first week of the year.
  },
});

var eo = {};

var formatDistance$1$ = {};

formatDistance$1$.formatDistance = void 0;

const formatDistanceLocale$Z = {
  lessThanXSeconds: {
    one: "malpli ol sekundo",
    other: "malpli ol {{count}} sekundoj",
  },

  xSeconds: {
    one: "1 sekundo",
    other: "{{count}} sekundoj",
  },

  halfAMinute: "duonminuto",

  lessThanXMinutes: {
    one: "malpli ol minuto",
    other: "malpli ol {{count}} minutoj",
  },

  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutoj",
  },

  aboutXHours: {
    one: "proksimume 1 horo",
    other: "proksimume {{count}} horoj",
  },

  xHours: {
    one: "1 horo",
    other: "{{count}} horoj",
  },

  xDays: {
    one: "1 tago",
    other: "{{count}} tagoj",
  },

  aboutXMonths: {
    one: "proksimume 1 monato",
    other: "proksimume {{count}} monatoj",
  },

  xWeeks: {
    one: "1 semajno",
    other: "{{count}} semajnoj",
  },

  aboutXWeeks: {
    one: "proksimume 1 semajno",
    other: "proksimume {{count}} semajnoj",
  },

  xMonths: {
    one: "1 monato",
    other: "{{count}} monatoj",
  },

  aboutXYears: {
    one: "proksimume 1 jaro",
    other: "proksimume {{count}} jaroj",
  },

  xYears: {
    one: "1 jaro",
    other: "{{count}} jaroj",
  },

  overXYears: {
    one: "pli ol 1 jaro",
    other: "pli ol {{count}} jaroj",
  },

  almostXYears: {
    one: "preskaÅ­ 1 jaro",
    other: "preskaÅ­ {{count}} jaroj",
  },
};

const formatDistance$1_ = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$Z[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options?.comparison && options.comparison > 0) {
      return "post " + result;
    } else {
      return "antaÅ­ " + result;
    }
  }

  return result;
};
formatDistance$1$.formatDistance = formatDistance$1_;

var formatLong$11 = {};

formatLong$11.formatLong = void 0;
var _index$82 = buildFormatLongFn$1;

const dateFormats$11 = {
  full: "EEEE, do 'de' MMMM y",
  long: "y-MMMM-dd",
  medium: "y-MMM-dd",
  short: "yyyy-MM-dd",
};

const timeFormats$11 = {
  full: "Ho 'horo kaj' m:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$11 = {
  any: "{{date}} {{time}}",
};

(formatLong$11.formatLong = {
  date: (0, _index$82.buildFormatLongFn)({
    formats: dateFormats$11,
    defaultWidth: "full",
  }),

  time: (0, _index$82.buildFormatLongFn)({
    formats: timeFormats$11,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$82.buildFormatLongFn)({
    formats: dateTimeFormats$11,
    defaultWidth: "any",
  }),
});

var formatRelative$21 = {};

formatRelative$21.formatRelative = void 0;

const formatRelativeLocale$$ = {
  lastWeek: "'pasinta' eeee 'je' p",
  yesterday: "'hieraÅ­ je' p",
  today: "'hodiaÅ­ je' p",
  tomorrow: "'morgaÅ­ je' p",
  nextWeek: "eeee 'je' p",
  other: "P",
};

const formatRelative$20 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$$[token];
formatRelative$21.formatRelative = formatRelative$20;

var localize$_ = {};

localize$_.localize = void 0;

var _index$81 = buildLocalizeFn$1;

const eraValues$_ = {
  narrow: ["aK", "pK"],
  abbreviated: ["a.K.E.", "p.K.E."],
  wide: ["antaÅ­ Komuna Erao", "Komuna Erao"],
};

const quarterValues$_ = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: [
    "1-a kvaronjaro",
    "2-a kvaronjaro",
    "3-a kvaronjaro",
    "4-a kvaronjaro",
  ],
};

const monthValues$_ = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "aÅ­g",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januaro",
    "februaro",
    "marto",
    "aprilo",
    "majo",
    "junio",
    "julio",
    "aÅ­gusto",
    "septembro",
    "oktobro",
    "novembro",
    "decembro",
  ],
};

const dayValues$_ = {
  narrow: ["D", "L", "M", "M", "Ä´", "V", "S"],
  short: ["di", "lu", "ma", "me", "Äµa", "ve", "sa"],
  abbreviated: ["dim", "lun", "mar", "mer", "ÄµaÅ­", "ven", "sab"],
  wide: [
    "dimanÄo",
    "lundo",
    "mardo",
    "merkredo",
    "ÄµaÅ­do",
    "vendredo",
    "sabato",
  ],
};

const dayPeriodValues$_ = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte",
  },
  abbreviated: {
    am: "a.t.m.",
    pm: "p.t.m.",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte",
  },
  wide: {
    am: "antaÅ­tagmeze",
    pm: "posttagmeze",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte",
  },
};

const ordinalNumber$_ = (dirtyNumber) => {
  const number = Number(dirtyNumber);
  return number + "-a";
};

(localize$_.localize = {
  ordinalNumber: ordinalNumber$_,

  era: (0, _index$81.buildLocalizeFn)({
    values: eraValues$_,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$81.buildLocalizeFn)({
    values: quarterValues$_,
    defaultWidth: "wide",
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    },
  }),

  month: (0, _index$81.buildLocalizeFn)({
    values: monthValues$_,
    defaultWidth: "wide",
  }),

  day: (0, _index$81.buildLocalizeFn)({
    values: dayValues$_,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$81.buildLocalizeFn)({
    values: dayPeriodValues$_,
    defaultWidth: "wide",
  }),
});

var match$_ = {};

match$_.match = void 0;
var _index$80 = buildMatchPatternFn$1;
var _index2$3z = buildMatchFn$1;

const matchOrdinalNumberPattern$_ = /^(\d+)(-?a)?/i;
const parseOrdinalNumberPattern$_ = /\d+/i;

const matchEraPatterns$_ = {
  narrow: /^([ap]k)/i,
  abbreviated: /^([ap]\.?\s?k\.?\s?e\.?)/i,
  wide: /^((antaÇ |post )?komuna erao)/i,
};
const parseEraPatterns$_ = {
  any: [/^a/i, /^[kp]/i],
};

const matchQuarterPatterns$_ = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](-?a)? kvaronjaro/i,
};
const parseQuarterPatterns$_ = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$_ = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|a(Å­|ux|uh|u)g|sep|okt|nov|dec)/i,
  wide: /^(januaro|februaro|marto|aprilo|majo|junio|julio|a(Å­|ux|uh|u)gusto|septembro|oktobro|novembro|decembro)/i,
};
const parseMonthPatterns$_ = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^a(u|Å­)/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$_ = {
  narrow: /^[dlmÄµjvs]/i,
  short: /^(di|lu|ma|me|(Äµ|jx|jh|j)a|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|(Äµ|jx|jh|j)a(Å­|ux|uh|u)|ven|sab)/i,
  wide: /^(diman(Ä|cx|ch|c)o|lundo|mardo|merkredo|(Äµ|jx|jh|j)a(Å­|ux|uh|u)do|vendredo|sabato)/i,
};
const parseDayPatterns$_ = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^(j|Äµ)/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^(j|Äµ)/i, /^v/i, /^s/i],
};

const matchDayPeriodPatterns$_ = {
  narrow: /^([ap]|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  abbreviated:
    /^([ap][.\s]?t[.\s]?m[.\s]?|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  wide: /^(anta(Å­|ux)tagmez|posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo]/i,
};
const parseDayPeriodPatterns$_ = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^noktom/i,
    noon: /^t/i,
    morning: /^m/i,
    afternoon: /^posttagmeze/i,
    evening: /^v/i,
    night: /^n/i,
  },
};

(match$_.match = {
  ordinalNumber: (0, _index$80.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$_,
    parsePattern: parseOrdinalNumberPattern$_,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index2$3z.buildMatchFn)({
    matchPatterns: matchEraPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$_,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$3z.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$_,
    defaultParseWidth: "any",
    valueCallback: function (index) {
      return index + 1;
    },
  }),

  month: (0, _index2$3z.buildMatchFn)({
    matchPatterns: matchMonthPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$_,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$3z.buildMatchFn)({
    matchPatterns: matchDayPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$_,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$3z.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$_,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$_,
    defaultParseWidth: "any",
  }),
});

eo.eo = void 0;
var _index$7$ = formatDistance$1$;
var _index2$3y = formatLong$11;
var _index3$1Q = formatRelative$21;
var _index4$1j = localize$_;
var _index5$1a = match$_;

/**
 * @category Locales
 * @summary Esperanto locale.
 * @language Esperanto
 * @iso-639-2 epo
 * @author date-fns
 */
(eo.eo = {
  code: "eo",
  formatDistance: _index$7$.formatDistance,
  formatLong: _index2$3y.formatLong,
  formatRelative: _index3$1Q.formatRelative,
  localize: _index4$1j.localize,
  match: _index5$1a.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var es = {};

var formatDistance$1Z = {};

formatDistance$1Z.formatDistance = void 0;

const formatDistanceLocale$Y = {
  lessThanXSeconds: {
    one: "menos de un segundo",
    other: "menos de {{count}} segundos",
  },

  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos",
  },

  halfAMinute: "medio minuto",

  lessThanXMinutes: {
    one: "menos de un minuto",
    other: "menos de {{count}} minutos",
  },

  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos",
  },

  aboutXHours: {
    one: "alrededor de 1 hora",
    other: "alrededor de {{count}} horas",
  },

  xHours: {
    one: "1 hora",
    other: "{{count}} horas",
  },

  xDays: {
    one: "1 dÃ­a",
    other: "{{count}} dÃ­as",
  },

  aboutXWeeks: {
    one: "alrededor de 1 semana",
    other: "alrededor de {{count}} semanas",
  },

  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas",
  },

  aboutXMonths: {
    one: "alrededor de 1 mes",
    other: "alrededor de {{count}} meses",
  },

  xMonths: {
    one: "1 mes",
    other: "{{count}} meses",
  },

  aboutXYears: {
    one: "alrededor de 1 aÃ±o",
    other: "alrededor de {{count}} aÃ±os",
  },

  xYears: {
    one: "1 aÃ±o",
    other: "{{count}} aÃ±os",
  },

  overXYears: {
    one: "mÃ¡s de 1 aÃ±o",
    other: "mÃ¡s de {{count}} aÃ±os",
  },

  almostXYears: {
    one: "casi 1 aÃ±o",
    other: "casi {{count}} aÃ±os",
  },
};

const formatDistance$1Y = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$Y[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hace " + result;
    }
  }

  return result;
};
formatDistance$1Z.formatDistance = formatDistance$1Y;

var formatLong$10 = {};

formatLong$10.formatLong = void 0;
var _index$7_ = buildFormatLongFn$1;

const dateFormats$10 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$10 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$10 = {
  full: "{{date}} 'a las' {{time}}",
  long: "{{date}} 'a las' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$10.formatLong = {
  date: (0, _index$7_.buildFormatLongFn)({
    formats: dateFormats$10,
    defaultWidth: "full",
  }),

  time: (0, _index$7_.buildFormatLongFn)({
    formats: timeFormats$10,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7_.buildFormatLongFn)({
    formats: dateTimeFormats$10,
    defaultWidth: "full",
  }),
});

var formatRelative$1$ = {};

formatRelative$1$.formatRelative = void 0;

const formatRelativeLocale$_ = {
  lastWeek: "'el' eeee 'pasado a la' p",
  yesterday: "'ayer a la' p",
  today: "'hoy a la' p",
  tomorrow: "'maÃ±ana a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P",
};

const formatRelativeLocalePlural$2 = {
  lastWeek: "'el' eeee 'pasado a las' p",
  yesterday: "'ayer a las' p",
  today: "'hoy a las' p",
  tomorrow: "'maÃ±ana a las' p",
  nextWeek: "eeee 'a las' p",
  other: "P",
};

const formatRelative$1_ = (token, date, _baseDate, _options) => {
  if (date.getHours() !== 1) {
    return formatRelativeLocalePlural$2[token];
  } else {
    return formatRelativeLocale$_[token];
  }
};
formatRelative$1$.formatRelative = formatRelative$1_;

var localize$Z = {};

localize$Z.localize = void 0;
var _index$7Z = buildLocalizeFn$1;

const eraValues$Z = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despuÃ©s de cristo"],
};

const quarterValues$Z = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1Âº trimestre", "2Âº trimestre", "3Âº trimestre", "4Âº trimestre"],
};

const monthValues$Z = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "ene",
    "feb",
    "mar",
    "abr",
    "may",
    "jun",
    "jul",
    "ago",
    "sep",
    "oct",
    "nov",
    "dic",
  ],

  wide: [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre",
  ],
};

const dayValues$Z = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "mi", "ju", "vi", "sÃ¡"],
  abbreviated: ["dom", "lun", "mar", "miÃ©", "jue", "vie", "sÃ¡b"],
  wide: [
    "domingo",
    "lunes",
    "martes",
    "miÃ©rcoles",
    "jueves",
    "viernes",
    "sÃ¡bado",
  ],
};

const dayPeriodValues$Z = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "maÃ±ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "maÃ±ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "maÃ±ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche",
  },
};

const formattingDayPeriodValues$M = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "de la maÃ±ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la maÃ±ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la maÃ±ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche",
  },
};

const ordinalNumber$Z = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "Âº";
};

(localize$Z.localize = {
  ordinalNumber: ordinalNumber$Z,

  era: (0, _index$7Z.buildLocalizeFn)({
    values: eraValues$Z,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7Z.buildLocalizeFn)({
    values: quarterValues$Z,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$7Z.buildLocalizeFn)({
    values: monthValues$Z,
    defaultWidth: "wide",
  }),

  day: (0, _index$7Z.buildLocalizeFn)({
    values: dayValues$Z,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7Z.buildLocalizeFn)({
    values: dayPeriodValues$Z,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$M,
    defaultFormattingWidth: "wide",
  }),
});

var match$Z = {};

match$Z.match = void 0;
var _index$7Y = buildMatchPatternFn$1;
var _index2$3x = buildMatchFn$1;

const matchOrdinalNumberPattern$Z = /^(\d+)(Âº)?/i;
const parseOrdinalNumberPattern$Z = /\d+/i;

const matchEraPatterns$Z = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes de la era com[uÃº]n|despu[eÃ©]s de cristo|era com[uÃº]n)/i,
};
const parseEraPatterns$Z = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes de la era com[uÃº]n)/i,
    /^(despu[eÃ©]s de cristo|era com[uÃº]n)/i,
  ],
};

const matchQuarterPatterns$Z = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](Âº)? trimestre/i,
};
const parseQuarterPatterns$Z = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$Z = {
  narrow: /^[efmajsond]/i,
  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
};
const parseMonthPatterns$Z = {
  narrow: [
    /^e/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^en/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^sep/i,
    /^oct/i,
    /^nov/i,
    /^dic/i,
  ],
};

const matchDayPatterns$Z = {
  narrow: /^[dlmjvs]/i,
  short: /^(do|lu|ma|mi|ju|vi|s[Ã¡a])/i,
  abbreviated: /^(dom|lun|mar|mi[Ã©e]|jue|vie|s[Ã¡a]b)/i,
  wide: /^(domingo|lunes|martes|mi[Ã©e]rcoles|jueves|viernes|s[Ã¡a]bado)/i,
};
const parseDayPatterns$Z = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i],
};

const matchDayPeriodPatterns$Z = {
  narrow: /^(a|p|mn|md|(de la|a las) (maÃ±ana|tarde|noche))/i,
  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maÃ±ana|tarde|noche))/i,
};
const parseDayPeriodPatterns$Z = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /maÃ±ana/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noche/i,
  },
};

(match$Z.match = {
  ordinalNumber: (0, _index$7Y.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$Z,
    parsePattern: parseOrdinalNumberPattern$Z,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index2$3x.buildMatchFn)({
    matchPatterns: matchEraPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Z,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$3x.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Z,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index2$3x.buildMatchFn)({
    matchPatterns: matchMonthPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Z,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$3x.buildMatchFn)({
    matchPatterns: matchDayPatterns$Z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Z,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$3x.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$Z,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Z,
    defaultParseWidth: "any",
  }),
});

es.es = void 0;
var _index$7X = formatDistance$1Z;
var _index2$3w = formatLong$10;
var _index3$1P = formatRelative$1$;
var _index4$1i = localize$Z;
var _index5$19 = match$Z;

/**
 * @category Locales
 * @summary Spanish locale.
 * @language Spanish
 * @iso-639-2 spa
 * @author Juan Angosto [@juanangosto](https://github.com/juanangosto)
 * @author Guillermo Grau [@guigrpa](https://github.com/guigrpa)
 * @author Fernando AgÃ¼ero [@fjaguero](https://github.com/fjaguero)
 * @author GastÃ³n Haro [@harogaston](https://github.com/harogaston)
 * @author Yago Carballo [@YagoCarballo](https://github.com/YagoCarballo)
 */
(es.es = {
  code: "es",
  formatDistance: _index$7X.formatDistance,
  formatLong: _index2$3w.formatLong,
  formatRelative: _index3$1P.formatRelative,
  localize: _index4$1i.localize,
  match: _index5$19.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var et = {};

var formatDistance$1X = {};

formatDistance$1X.formatDistance = void 0;

const formatDistanceLocale$X = {
  lessThanXSeconds: {
    standalone: {
      one: "vÃ¤hem kui Ã¼ks sekund",
      other: "vÃ¤hem kui {{count}} sekundit",
    },
    withPreposition: {
      one: "vÃ¤hem kui Ã¼he sekundi",
      other: "vÃ¤hem kui {{count}} sekundi",
    },
  },

  xSeconds: {
    standalone: {
      one: "Ã¼ks sekund",
      other: "{{count}} sekundit",
    },
    withPreposition: {
      one: "Ã¼he sekundi",
      other: "{{count}} sekundi",
    },
  },

  halfAMinute: {
    standalone: "pool minutit",
    withPreposition: "poole minuti",
  },

  lessThanXMinutes: {
    standalone: {
      one: "vÃ¤hem kui Ã¼ks minut",
      other: "vÃ¤hem kui {{count}} minutit",
    },
    withPreposition: {
      one: "vÃ¤hem kui Ã¼he minuti",
      other: "vÃ¤hem kui {{count}} minuti",
    },
  },

  xMinutes: {
    standalone: {
      one: "Ã¼ks minut",
      other: "{{count}} minutit",
    },
    withPreposition: {
      one: "Ã¼he minuti",
      other: "{{count}} minuti",
    },
  },

  aboutXHours: {
    standalone: {
      one: "umbes Ã¼ks tund",
      other: "umbes {{count}} tundi",
    },
    withPreposition: {
      one: "umbes Ã¼he tunni",
      other: "umbes {{count}} tunni",
    },
  },

  xHours: {
    standalone: {
      one: "Ã¼ks tund",
      other: "{{count}} tundi",
    },
    withPreposition: {
      one: "Ã¼he tunni",
      other: "{{count}} tunni",
    },
  },

  xDays: {
    standalone: {
      one: "Ã¼ks pÃ¤ev",
      other: "{{count}} pÃ¤eva",
    },
    withPreposition: {
      one: "Ã¼he pÃ¤eva",
      other: "{{count}} pÃ¤eva",
    },
  },

  aboutXWeeks: {
    standalone: {
      one: "umbes Ã¼ks nÃ¤dal",
      other: "umbes {{count}} nÃ¤dalat",
    },
    withPreposition: {
      one: "umbes Ã¼he nÃ¤dala",
      other: "umbes {{count}} nÃ¤dala",
    },
  },

  xWeeks: {
    standalone: {
      one: "Ã¼ks nÃ¤dal",
      other: "{{count}} nÃ¤dalat",
    },
    withPreposition: {
      one: "Ã¼he nÃ¤dala",
      other: "{{count}} nÃ¤dala",
    },
  },

  aboutXMonths: {
    standalone: {
      one: "umbes Ã¼ks kuu",
      other: "umbes {{count}} kuud",
    },
    withPreposition: {
      one: "umbes Ã¼he kuu",
      other: "umbes {{count}} kuu",
    },
  },

  xMonths: {
    standalone: {
      one: "Ã¼ks kuu",
      other: "{{count}} kuud",
    },
    withPreposition: {
      one: "Ã¼he kuu",
      other: "{{count}} kuu",
    },
  },

  aboutXYears: {
    standalone: {
      one: "umbes Ã¼ks aasta",
      other: "umbes {{count}} aastat",
    },
    withPreposition: {
      one: "umbes Ã¼he aasta",
      other: "umbes {{count}} aasta",
    },
  },

  xYears: {
    standalone: {
      one: "Ã¼ks aasta",
      other: "{{count}} aastat",
    },
    withPreposition: {
      one: "Ã¼he aasta",
      other: "{{count}} aasta",
    },
  },

  overXYears: {
    standalone: {
      one: "rohkem kui Ã¼ks aasta",
      other: "rohkem kui {{count}} aastat",
    },
    withPreposition: {
      one: "rohkem kui Ã¼he aasta",
      other: "rohkem kui {{count}} aasta",
    },
  },

  almostXYears: {
    standalone: {
      one: "peaaegu Ã¼ks aasta",
      other: "peaaegu {{count}} aastat",
    },
    withPreposition: {
      one: "peaaegu Ã¼he aasta",
      other: "peaaegu {{count}} aasta",
    },
  },
};

const formatDistance$1W = (token, count, options) => {
  const usageGroup = options?.addSuffix
    ? formatDistanceLocale$X[token].withPreposition
    : formatDistanceLocale$X[token].standalone;

  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " pÃ¤rast";
    } else {
      return result + " eest";
    }
  }

  return result;
};
formatDistance$1X.formatDistance = formatDistance$1W;

var formatLong$$ = {};

formatLong$$.formatLong = void 0;
var _index$7W = buildFormatLongFn$1;

const dateFormats$$ = {
  full: "EEEE, d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y",
};

const timeFormats$$ = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$$ = {
  full: "{{date}} 'kell' {{time}}",
  long: "{{date}} 'kell' {{time}}",
  medium: "{{date}}. {{time}}",
  short: "{{date}}. {{time}}",
};

(formatLong$$.formatLong = {
  date: (0, _index$7W.buildFormatLongFn)({
    formats: dateFormats$$,
    defaultWidth: "full",
  }),

  time: (0, _index$7W.buildFormatLongFn)({
    formats: timeFormats$$,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7W.buildFormatLongFn)({
    formats: dateTimeFormats$$,
    defaultWidth: "full",
  }),
});

var formatRelative$1Z = {};

formatRelative$1Z.formatRelative = void 0;

const formatRelativeLocale$Z = {
  lastWeek: "'eelmine' eeee 'kell' p",
  yesterday: "'eile kell' p",
  today: "'tÃ¤na kell' p",
  tomorrow: "'homme kell' p",
  nextWeek: "'jÃ¤rgmine' eeee 'kell' p",
  other: "P",
};

const formatRelative$1Y = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$Z[token];
formatRelative$1Z.formatRelative = formatRelative$1Y;

var localize$Y = {};

localize$Y.localize = void 0;
var _index$7V = buildLocalizeFn$1;

const eraValues$Y = {
  narrow: ["e.m.a", "m.a.j"],
  abbreviated: ["e.m.a", "m.a.j"],
  wide: ["enne meie ajaarvamist", "meie ajaarvamise jÃ¤rgi"],
};

const quarterValues$Y = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$Y = {
  narrow: ["J", "V", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jaan",
    "veebr",
    "mÃ¤rts",
    "apr",
    "mai",
    "juuni",
    "juuli",
    "aug",
    "sept",
    "okt",
    "nov",
    "dets",
  ],

  wide: [
    "jaanuar",
    "veebruar",
    "mÃ¤rts",
    "aprill",
    "mai",
    "juuni",
    "juuli",
    "august",
    "september",
    "oktoober",
    "november",
    "detsember",
  ],
};

const dayValues$Y = {
  narrow: ["P", "E", "T", "K", "N", "R", "L"],
  short: ["P", "E", "T", "K", "N", "R", "L"],
  abbreviated: [
    "pÃ¼hap.",
    "esmasp.",
    "teisip.",
    "kolmap.",
    "neljap.",
    "reede.",
    "laup.",
  ],

  wide: [
    "pÃ¼hapÃ¤ev",
    "esmaspÃ¤ev",
    "teisipÃ¤ev",
    "kolmapÃ¤ev",
    "neljapÃ¤ev",
    "reede",
    "laupÃ¤ev",
  ],
};

const dayPeriodValues$Y = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶",
    noon: "keskpÃ¤ev",
    morning: "hommik",
    afternoon: "pÃ¤rastlÃµuna",
    evening: "Ãµhtu",
    night: "Ã¶Ã¶",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶",
    noon: "keskpÃ¤ev",
    morning: "hommik",
    afternoon: "pÃ¤rastlÃµuna",
    evening: "Ãµhtu",
    night: "Ã¶Ã¶",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶",
    noon: "keskpÃ¤ev",
    morning: "hommik",
    afternoon: "pÃ¤rastlÃµuna",
    evening: "Ãµhtu",
    night: "Ã¶Ã¶",
  },
};

const formattingDayPeriodValues$L = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶l",
    noon: "keskpÃ¤eval",
    morning: "hommikul",
    afternoon: "pÃ¤rastlÃµunal",
    evening: "Ãµhtul",
    night: "Ã¶Ã¶sel",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶l",
    noon: "keskpÃ¤eval",
    morning: "hommikul",
    afternoon: "pÃ¤rastlÃµunal",
    evening: "Ãµhtul",
    night: "Ã¶Ã¶sel",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "keskÃ¶Ã¶l",
    noon: "keskpÃ¤eval",
    morning: "hommikul",
    afternoon: "pÃ¤rastlÃµunal",
    evening: "Ãµhtul",
    night: "Ã¶Ã¶sel",
  },
};

const ordinalNumber$Y = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$Y.localize = {
  ordinalNumber: ordinalNumber$Y,

  era: (0, _index$7V.buildLocalizeFn)({
    values: eraValues$Y,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7V.buildLocalizeFn)({
    values: quarterValues$Y,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7V.buildLocalizeFn)({
    values: monthValues$Y,
    defaultWidth: "wide",
    formattingValues: monthValues$Y,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$7V.buildLocalizeFn)({
    values: dayValues$Y,
    defaultWidth: "wide",
    formattingValues: dayValues$Y,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$7V.buildLocalizeFn)({
    values: dayPeriodValues$Y,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$L,
    defaultFormattingWidth: "wide",
  }),
});

var match$Y = {};

match$Y.match = void 0;

var _index$7U = buildMatchFn$1;
var _index2$3v = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$Y = /^\d+\./i;
const parseOrdinalNumberPattern$Y = /\d+/i;

const matchEraPatterns$Y = {
  narrow: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  abbreviated: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  wide: /^(enne meie ajaarvamist|meie ajaarvamise jÃ¤rgi|enne Kristust|pÃ¤rast Kristust)/i,
};
const parseEraPatterns$Y = {
  any: [/^e/i, /^(m|p)/i],
};

const matchQuarterPatterns$Y = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](\.)? kvartal/i,
};
const parseQuarterPatterns$Y = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$Y = {
  narrow: /^[jvmasond]/i,
  abbreviated: /^(jaan|veebr|mÃ¤rts|apr|mai|juuni|juuli|aug|sept|okt|nov|dets)/i,
  wide: /^(jaanuar|veebruar|mÃ¤rts|aprill|mai|juuni|juuli|august|september|oktoober|november|detsember)/i,
};
const parseMonthPatterns$Y = {
  narrow: [
    /^j/i,
    /^v/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^v/i,
    /^mÃ¤r/i,
    /^ap/i,
    /^mai/i,
    /^juun/i,
    /^juul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$Y = {
  narrow: /^[petknrl]/i,
  short: /^[petknrl]/i,
  abbreviated: /^(pÃ¼h?|esm?|tei?|kolm?|nel?|ree?|laup?)\.?/i,
  wide: /^(pÃ¼hapÃ¤ev|esmaspÃ¤ev|teisipÃ¤ev|kolmapÃ¤ev|neljapÃ¤ev|reede|laupÃ¤ev)/i,
};
const parseDayPatterns$Y = {
  any: [/^p/i, /^e/i, /^t/i, /^k/i, /^n/i, /^r/i, /^l/i],
};

const matchDayPeriodPatterns$Y = {
  any: /^(am|pm|keskÃ¶Ã¶l?|keskpÃ¤ev(al)?|hommik(ul)?|pÃ¤rastlÃµunal?|Ãµhtul?|Ã¶Ã¶(sel)?)/i,
};
const parseDayPeriodPatterns$Y = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^keskÃ¶/i,
    noon: /^keskp/i,
    morning: /hommik/i,
    afternoon: /pÃ¤rastlÃµuna/i,
    evening: /Ãµhtu/i,
    night: /Ã¶Ã¶/i,
  },
};

(match$Y.match = {
  ordinalNumber: (0, _index2$3v.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$Y,
    parsePattern: parseOrdinalNumberPattern$Y,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7U.buildMatchFn)({
    matchPatterns: matchEraPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Y,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7U.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Y,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7U.buildMatchFn)({
    matchPatterns: matchMonthPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Y,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7U.buildMatchFn)({
    matchPatterns: matchDayPatterns$Y,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Y,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7U.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$Y,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Y,
    defaultParseWidth: "any",
  }),
});

et.et = void 0;
var _index$7T = formatDistance$1X;
var _index2$3u = formatLong$$;
var _index3$1O = formatRelative$1Z;
var _index4$1h = localize$Y;
var _index5$18 = match$Y;

/**
 * @category Locales
 * @summary Estonian locale.
 * @language Estonian
 * @iso-639-2 est
 * @author Priit Hansen [@HansenPriit](https://github.com/priithansen)
 */
(et.et = {
  code: "et",
  formatDistance: _index$7T.formatDistance,
  formatLong: _index2$3u.formatLong,
  formatRelative: _index3$1O.formatRelative,
  localize: _index4$1h.localize,
  match: _index5$18.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var eu = {};

var formatDistance$1V = {};

formatDistance$1V.formatDistance = void 0;

const formatDistanceLocale$W = {
  lessThanXSeconds: {
    one: "segundo bat baino gutxiago",
    other: "{{count}} segundo baino gutxiago",
  },

  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundo",
  },

  halfAMinute: "minutu erdi",

  lessThanXMinutes: {
    one: "minutu bat baino gutxiago",
    other: "{{count}} minutu baino gutxiago",
  },

  xMinutes: {
    one: "1 minutu",
    other: "{{count}} minutu",
  },

  aboutXHours: {
    one: "1 ordu gutxi gorabehera",
    other: "{{count}} ordu gutxi gorabehera",
  },

  xHours: {
    one: "1 ordu",
    other: "{{count}} ordu",
  },

  xDays: {
    one: "1 egun",
    other: "{{count}} egun",
  },

  aboutXWeeks: {
    one: "aste 1 inguru",
    other: "{{count}} aste inguru",
  },

  xWeeks: {
    one: "1 aste",
    other: "{{count}} astean",
  },

  aboutXMonths: {
    one: "1 hilabete gutxi gorabehera",
    other: "{{count}} hilabete gutxi gorabehera",
  },

  xMonths: {
    one: "1 hilabete",
    other: "{{count}} hilabete",
  },

  aboutXYears: {
    one: "1 urte gutxi gorabehera",
    other: "{{count}} urte gutxi gorabehera",
  },

  xYears: {
    one: "1 urte",
    other: "{{count}} urte",
  },

  overXYears: {
    one: "1 urte baino gehiago",
    other: "{{count}} urte baino gehiago",
  },

  almostXYears: {
    one: "ia 1 urte",
    other: "ia {{count}} urte",
  },
};

const formatDistance$1U = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$W[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "duela " + result;
    }
  }

  return result;
};
formatDistance$1V.formatDistance = formatDistance$1U;

var formatLong$_ = {};

formatLong$_.formatLong = void 0;
var _index$7S = buildFormatLongFn$1;

const dateFormats$_ = {
  full: "EEEE, y'ko' MMMM'ren' d'a' y'ren'",
  long: "y'ko' MMMM'ren' d'a'",
  medium: "y MMM d",
  short: "yy/MM/dd",
};

const timeFormats$_ = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$_ = {
  full: "{{date}} 'tan' {{time}}",
  long: "{{date}} 'tan' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$_.formatLong = {
  date: (0, _index$7S.buildFormatLongFn)({
    formats: dateFormats$_,
    defaultWidth: "full",
  }),

  time: (0, _index$7S.buildFormatLongFn)({
    formats: timeFormats$_,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7S.buildFormatLongFn)({
    formats: dateTimeFormats$_,
    defaultWidth: "full",
  }),
});

var formatRelative$1X = {};

formatRelative$1X.formatRelative = void 0;

const formatRelativeLocale$Y = {
  lastWeek: "'joan den' eeee, LT",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P",
};

const formatRelativeLocalePlural$1 = {
  lastWeek: "'joan den' eeee, p",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P",
};

const formatRelative$1W = (token, date) => {
  if (date.getHours() !== 1) {
    return formatRelativeLocalePlural$1[token];
  }
  return formatRelativeLocale$Y[token];
};
formatRelative$1X.formatRelative = formatRelative$1W;

var localize$X = {};

localize$X.localize = void 0;
var _index$7R = buildLocalizeFn$1;

const eraValues$X = {
  narrow: ["k.a.", "k.o."],
  abbreviated: ["k.a.", "k.o."],
  wide: ["kristo aurretik", "kristo ondoren"],
};

const quarterValues$X = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1H", "2H", "3H", "4H"],
  wide: [
    "1. hiruhilekoa",
    "2. hiruhilekoa",
    "3. hiruhilekoa",
    "4. hiruhilekoa",
  ],
};

const monthValues$X = {
  narrow: ["u", "o", "m", "a", "m", "e", "u", "a", "i", "u", "a", "a"],
  abbreviated: [
    "urt",
    "ots",
    "mar",
    "api",
    "mai",
    "eka",
    "uzt",
    "abu",
    "ira",
    "urr",
    "aza",
    "abe",
  ],

  wide: [
    "urtarrila",
    "otsaila",
    "martxoa",
    "apirila",
    "maiatza",
    "ekaina",
    "uztaila",
    "abuztua",
    "iraila",
    "urria",
    "azaroa",
    "abendua",
  ],
};

const dayValues$X = {
  narrow: ["i", "a", "a", "a", "o", "o", "l"],
  short: ["ig", "al", "as", "az", "og", "or", "lr"],
  abbreviated: ["iga", "ast", "ast", "ast", "ost", "ost", "lar"],
  wide: [
    "igandea",
    "astelehena",
    "asteartea",
    "asteazkena",
    "osteguna",
    "ostirala",
    "larunbata",
  ],
};

const dayPeriodValues$X = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua",
  },
};

const formattingDayPeriodValues$K = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean",
  },
};

const ordinalNumber$X = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$X.localize = {
  ordinalNumber: ordinalNumber$X,

  era: (0, _index$7R.buildLocalizeFn)({
    values: eraValues$X,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7R.buildLocalizeFn)({
    values: quarterValues$X,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7R.buildLocalizeFn)({
    values: monthValues$X,
    defaultWidth: "wide",
  }),

  day: (0, _index$7R.buildLocalizeFn)({
    values: dayValues$X,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7R.buildLocalizeFn)({
    values: dayPeriodValues$X,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$K,
    defaultFormattingWidth: "wide",
  }),
});

var match$X = {};

match$X.match = void 0;

var _index$7Q = buildMatchFn$1;
var _index2$3t = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$X = /^(\d+)(.)?/i;
const parseOrdinalNumberPattern$X = /\d+/i;

const matchEraPatterns$X = {
  narrow: /^(k.a.|k.o.)/i,
  abbreviated: /^(k.a.|k.o.)/i,
  wide: /^(kristo aurretik|kristo ondoren)/i,
};
const parseEraPatterns$X = {
  narrow: [/^k.a./i, /^k.o./i],
  abbreviated: [/^(k.a.)/i, /^(k.o.)/i],
  wide: [/^(kristo aurretik)/i, /^(kristo ondoren)/i],
};

const matchQuarterPatterns$X = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]H/i,
  wide: /^[1234](.)? hiruhilekoa/i,
};
const parseQuarterPatterns$X = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$X = {
  narrow: /^[uomaei]/i,
  abbreviated: /^(urt|ots|mar|api|mai|eka|uzt|abu|ira|urr|aza|abe)/i,
  wide: /^(urtarrila|otsaila|martxoa|apirila|maiatza|ekaina|uztaila|abuztua|iraila|urria|azaroa|abendua)/i,
};
const parseMonthPatterns$X = {
  narrow: [
    /^u/i,
    /^o/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^e/i,
    /^u/i,
    /^a/i,
    /^i/i,
    /^u/i,
    /^a/i,
    /^a/i,
  ],

  any: [
    /^urt/i,
    /^ots/i,
    /^mar/i,
    /^api/i,
    /^mai/i,
    /^eka/i,
    /^uzt/i,
    /^abu/i,
    /^ira/i,
    /^urr/i,
    /^aza/i,
    /^abe/i,
  ],
};

const matchDayPatterns$X = {
  narrow: /^[iaol]/i,
  short: /^(ig|al|as|az|og|or|lr)/i,
  abbreviated: /^(iga|ast|ast|ast|ost|ost|lar)/i,
  wide: /^(igandea|astelehena|asteartea|asteazkena|osteguna|ostirala|larunbata)/i,
};
const parseDayPatterns$X = {
  narrow: [/^i/i, /^a/i, /^a/i, /^a/i, /^o/i, /^o/i, /^l/i],
  short: [/^ig/i, /^al/i, /^as/i, /^az/i, /^og/i, /^or/i, /^lr/i],
  abbreviated: [/^iga/i, /^ast/i, /^ast/i, /^ast/i, /^ost/i, /^ost/i, /^lar/i],

  wide: [
    /^igandea/i,
    /^astelehena/i,
    /^asteartea/i,
    /^asteazkena/i,
    /^osteguna/i,
    /^ostirala/i,
    /^larunbata/i,
  ],
};

const matchDayPeriodPatterns$X = {
  narrow: /^(a|p|ge|eg|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i,
  any: /^([ap]\.?\s?m\.?|gauerdia|eguerdia|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i,
};
const parseDayPeriodPatterns$X = {
  narrow: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^ge/i,
    noon: /^eg/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i,
  },
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^gauerdia/i,
    noon: /^eguerdia/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i,
  },
};

(match$X.match = {
  ordinalNumber: (0, _index2$3t.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$X,
    parsePattern: parseOrdinalNumberPattern$X,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7Q.buildMatchFn)({
    matchPatterns: matchEraPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$X,
    defaultParseWidth: "wide",
  }),

  quarter: (0, _index$7Q.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$X,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7Q.buildMatchFn)({
    matchPatterns: matchMonthPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$X,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7Q.buildMatchFn)({
    matchPatterns: matchDayPatterns$X,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$X,
    defaultParseWidth: "wide",
  }),

  dayPeriod: (0, _index$7Q.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$X,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$X,
    defaultParseWidth: "any",
  }),
});

eu.eu = void 0;
var _index$7P = formatDistance$1V;
var _index2$3s = formatLong$_;
var _index3$1N = formatRelative$1X;
var _index4$1g = localize$X;
var _index5$17 = match$X;

/**
 * @category Locales
 * @summary Basque locale.
 * @language Basque
 * @iso-639-2 eus
 * @author Jacob SÃ¶derblom [@JacobSoderblom](https://github.com/JacobSoderblom)
 */
(eu.eu = {
  code: "eu",
  formatDistance: _index$7P.formatDistance,
  formatLong: _index2$3s.formatLong,
  formatRelative: _index3$1N.formatRelative,
  localize: _index4$1g.localize,
  match: _index5$17.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var faIR = {};

var formatDistance$1T = {};

formatDistance$1T.formatDistance = void 0;

const formatDistanceLocale$V = {
  lessThanXSeconds: {
    one: "Ú©ÙØªØ± Ø§Ø² ÛÚ© Ø«Ø§ÙÛÙ",
    other: "Ú©ÙØªØ± Ø§Ø² {{count}} Ø«Ø§ÙÛÙ",
  },

  xSeconds: {
    one: "1 Ø«Ø§ÙÛÙ",
    other: "{{count}} Ø«Ø§ÙÛÙ",
  },

  halfAMinute: "ÙÛÙ Ø¯ÙÛÙÙ",

  lessThanXMinutes: {
    one: "Ú©ÙØªØ± Ø§Ø² ÛÚ© Ø¯ÙÛÙÙ",
    other: "Ú©ÙØªØ± Ø§Ø² {{count}} Ø¯ÙÛÙÙ",
  },

  xMinutes: {
    one: "1 Ø¯ÙÛÙÙ",
    other: "{{count}} Ø¯ÙÛÙÙ",
  },

  aboutXHours: {
    one: "Ø­Ø¯ÙØ¯ 1 Ø³Ø§Ø¹Øª",
    other: "Ø­Ø¯ÙØ¯ {{count}} Ø³Ø§Ø¹Øª",
  },

  xHours: {
    one: "1 Ø³Ø§Ø¹Øª",
    other: "{{count}} Ø³Ø§Ø¹Øª",
  },

  xDays: {
    one: "1 Ø±ÙØ²",
    other: "{{count}} Ø±ÙØ²",
  },

  aboutXWeeks: {
    one: "Ø­Ø¯ÙØ¯ 1 ÙÙØªÙ",
    other: "Ø­Ø¯ÙØ¯ {{count}} ÙÙØªÙ",
  },

  xWeeks: {
    one: "1 ÙÙØªÙ",
    other: "{{count}} ÙÙØªÙ",
  },

  aboutXMonths: {
    one: "Ø­Ø¯ÙØ¯ 1 ÙØ§Ù",
    other: "Ø­Ø¯ÙØ¯ {{count}} ÙØ§Ù",
  },

  xMonths: {
    one: "1 ÙØ§Ù",
    other: "{{count}} ÙØ§Ù",
  },

  aboutXYears: {
    one: "Ø­Ø¯ÙØ¯ 1 Ø³Ø§Ù",
    other: "Ø­Ø¯ÙØ¯ {{count}} Ø³Ø§Ù",
  },

  xYears: {
    one: "1 Ø³Ø§Ù",
    other: "{{count}} Ø³Ø§Ù",
  },

  overXYears: {
    one: "Ø¨ÛØ´ØªØ± Ø§Ø² 1 Ø³Ø§Ù",
    other: "Ø¨ÛØ´ØªØ± Ø§Ø² {{count}} Ø³Ø§Ù",
  },

  almostXYears: {
    one: "ÙØ²Ø¯ÛÚ© 1 Ø³Ø§Ù",
    other: "ÙØ²Ø¯ÛÚ© {{count}} Ø³Ø§Ù",
  },
};

const formatDistance$1S = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$V[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ø¯Ø± " + result;
    } else {
      return result + " ÙØ¨Ù";
    }
  }

  return result;
};
formatDistance$1T.formatDistance = formatDistance$1S;

var formatLong$Z = {};

formatLong$Z.formatLong = void 0;
var _index$7O = buildFormatLongFn$1;

const dateFormats$Z = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "yyyy/MM/dd",
};

const timeFormats$Z = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$Z = {
  full: "{{date}} 'Ø¯Ø±' {{time}}",
  long: "{{date}} 'Ø¯Ø±' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$Z.formatLong = {
  date: (0, _index$7O.buildFormatLongFn)({
    formats: dateFormats$Z,
    defaultWidth: "full",
  }),

  time: (0, _index$7O.buildFormatLongFn)({
    formats: timeFormats$Z,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7O.buildFormatLongFn)({
    formats: dateTimeFormats$Z,
    defaultWidth: "full",
  }),
});

var formatRelative$1V = {};

formatRelative$1V.formatRelative = void 0;

const formatRelativeLocale$X = {
  lastWeek: "eeee 'Ú¯Ø°Ø´ØªÙ Ø¯Ø±' p",
  yesterday: "'Ø¯ÛØ±ÙØ² Ø¯Ø±' p",
  today: "'Ø§ÙØ±ÙØ² Ø¯Ø±' p",
  tomorrow: "'ÙØ±Ø¯Ø§ Ø¯Ø±' p",
  nextWeek: "eeee 'Ø¯Ø±' p",
  other: "P",
};

const formatRelative$1U = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$X[token];
formatRelative$1V.formatRelative = formatRelative$1U;

var localize$W = {};

localize$W.localize = void 0;
var _index$7N = buildLocalizeFn$1;

const eraValues$W = {
  narrow: ["Ù", "Ø¨"],
  abbreviated: ["Ù.Ù.", "Ø¨.Ù."],
  wide: ["ÙØ¨Ù Ø§Ø² ÙÛÙØ§Ø¯", "Ø¨Ø¹Ø¯ Ø§Ø² ÙÛÙØ§Ø¯"],
};

const quarterValues$W = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ø³âÙ1", "Ø³âÙ2", "Ø³âÙ3", "Ø³âÙ4"],
  wide: ["Ø³ÙâÙØ§ÙÙ 1", "Ø³ÙâÙØ§ÙÙ 2", "Ø³ÙâÙØ§ÙÙ 3", "Ø³ÙâÙØ§ÙÙ 4"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$W = {
  narrow: ["Ú", "Ù", "Ù", "Ø¢", "Ù", "Ø¬", "Ø¬", "Ø¢", "Ø³", "Ø§", "Ù", "Ø¯"],
  abbreviated: [
    "ÚØ§ÙÙ",
    "ÙÙØ±",
    "ÙØ§Ø±Ø³",
    "Ø¢Ù¾Ø±",
    "ÙÛ",
    "Ø¬ÙÙ",
    "Ø¬ÙÙÙ",
    "Ø¢Ú¯Ù",
    "Ø³Ù¾ØªÙ",
    "Ø§Ú©ØªÙ",
    "ÙÙØ§ÙÙ",
    "Ø¯Ø³Ø§ÙÙ",
  ],

  wide: [
    "ÚØ§ÙÙÛÙ",
    "ÙÙØ±ÛÙ",
    "ÙØ§Ø±Ø³",
    "Ø¢Ù¾Ø±ÛÙ",
    "ÙÛ",
    "Ø¬ÙÙ",
    "Ø¬ÙÙØ§Û",
    "Ø¢Ú¯ÙØ³Øª",
    "Ø³Ù¾ØªØ§ÙØ¨Ø±",
    "Ø§Ú©ØªØ¨Ø±",
    "ÙÙØ§ÙØ¨Ø±",
    "Ø¯Ø³Ø§ÙØ¨Ø±",
  ],
};

const dayValues$W = {
  narrow: ["Û", "Ø¯", "Ø³", "Ú", "Ù¾", "Ø¬", "Ø´"],
  short: ["1Ø´", "2Ø´", "3Ø´", "4Ø´", "5Ø´", "Ø¬", "Ø´"],
  abbreviated: [
    "ÛÚ©Ø´ÙØ¨Ù",
    "Ø¯ÙØ´ÙØ¨Ù",
    "Ø³ÙâØ´ÙØ¨Ù",
    "ÚÙØ§Ø±Ø´ÙØ¨Ù",
    "Ù¾ÙØ¬Ø´ÙØ¨Ù",
    "Ø¬ÙØ¹Ù",
    "Ø´ÙØ¨Ù",
  ],

  wide: ["ÛÚ©Ø´ÙØ¨Ù", "Ø¯ÙØ´ÙØ¨Ù", "Ø³ÙâØ´ÙØ¨Ù", "ÚÙØ§Ø±Ø´ÙØ¨Ù", "Ù¾ÙØ¬Ø´ÙØ¨Ù", "Ø¬ÙØ¹Ù", "Ø´ÙØ¨Ù"],
};

const dayPeriodValues$W = {
  narrow: {
    am: "Ù",
    pm: "Ø¨",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "Øµ",
    afternoon: "Ø¨.Ø¸.",
    evening: "Ø¹",
    night: "Ø´",
  },
  abbreviated: {
    am: "Ù.Ø¸.",
    pm: "Ø¨.Ø¸.",
    midnight: "ÙÛÙÙâØ´Ø¨",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø­",
    afternoon: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    evening: "Ø¹ØµØ±",
    night: "Ø´Ø¨",
  },
  wide: {
    am: "ÙØ¨ÙâØ§Ø²Ø¸ÙØ±",
    pm: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    midnight: "ÙÛÙÙâØ´Ø¨",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø­",
    afternoon: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    evening: "Ø¹ØµØ±",
    night: "Ø´Ø¨",
  },
};

const formattingDayPeriodValues$J = {
  narrow: {
    am: "Ù",
    pm: "Ø¨",
    midnight: "Ù",
    noon: "Ø¸",
    morning: "Øµ",
    afternoon: "Ø¨.Ø¸.",
    evening: "Ø¹",
    night: "Ø´",
  },
  abbreviated: {
    am: "Ù.Ø¸.",
    pm: "Ø¨.Ø¸.",
    midnight: "ÙÛÙÙâØ´Ø¨",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø­",
    afternoon: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    evening: "Ø¹ØµØ±",
    night: "Ø´Ø¨",
  },
  wide: {
    am: "ÙØ¨ÙâØ§Ø²Ø¸ÙØ±",
    pm: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    midnight: "ÙÛÙÙâØ´Ø¨",
    noon: "Ø¸ÙØ±",
    morning: "ØµØ¨Ø­",
    afternoon: "Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±",
    evening: "Ø¹ØµØ±",
    night: "Ø´Ø¨",
  },
};

const ordinalNumber$W = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$W.localize = {
  ordinalNumber: ordinalNumber$W,

  era: (0, _index$7N.buildLocalizeFn)({
    values: eraValues$W,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7N.buildLocalizeFn)({
    values: quarterValues$W,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7N.buildLocalizeFn)({
    values: monthValues$W,
    defaultWidth: "wide",
  }),

  day: (0, _index$7N.buildLocalizeFn)({
    values: dayValues$W,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7N.buildLocalizeFn)({
    values: dayPeriodValues$W,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$J,
    defaultFormattingWidth: "wide",
  }),
});

var match$W = {};

match$W.match = void 0;

var _index$7M = buildMatchFn$1;
var _index2$3r = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$W = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$W = /\d+/i;

const matchEraPatterns$W = {
  narrow: /^(Ù|Ø¨)/i,
  abbreviated: /^(Ù\.?\s?Ù\.?|Ù\.?\s?Ø¯\.?\s?Ù\.?|Ù\.?\s?|Ø¯\.?\s?Ù\.?)/i,
  wide: /^(ÙØ¨Ù Ø§Ø² ÙÛÙØ§Ø¯|ÙØ¨Ù Ø§Ø² Ø¯ÙØ±Ø§Ù ÙØ´ØªØ±Ú©|ÙÛÙØ§Ø¯Û|Ø¯ÙØ±Ø§Ù ÙØ´ØªØ±Ú©|Ø¨Ø¹Ø¯ Ø§Ø² ÙÛÙØ§Ø¯)/i,
};
const parseEraPatterns$W = {
  any: [/^ÙØ¨Ù/i, /^Ø¨Ø¹Ø¯/i],
};

const matchQuarterPatterns$W = {
  narrow: /^[1234]/i,
  abbreviated: /^Ø³âÙ[1234]/i,
  wide: /^Ø³ÙâÙØ§ÙÙ [1234]/i,
};
const parseQuarterPatterns$W = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$W = {
  narrow: /^[Ø¬ÚÙÙØ¢Ø§ÙØ§Ø³ÙØ¯]/i,
  abbreviated:
    /^(Ø¬ÙÙ|ÚØ§ÙÙ|ÚØ§ÙÙÛÙ|ÙÙØ±ÛÙ|ÙÙØ±|ÙØ§Ø±Ø³|Ø¢ÙØ±ÛÙ|Ø¢Ù¾Ø±|ÙÙ|ÙÛ|ÚÙØ¦Ù|Ø¬ÙÙ|Ø¬ÙÙ|Ø¬ÙÙÙ|ÚÙØ¦ÛÙ|Ø§ÙØª|Ø¢Ú¯Ù|Ø³Ù¾ØªÙØ¨Ø±|Ø³Ù¾ØªØ§ÙØ¨Ø±|Ø§Ú©ØªØ¨Ø±|Ø§Ú©ØªÙØ¨Ø±|ÙÙØ§ÙØ¨Ø±|ÙÙØ§ÙÙ|Ø¯Ø³Ø§ÙØ¨Ø±|Ø¯Ø³Ø§ÙÙ|Ø¯Ø³Ù)/i,
  wide: /^(ÚØ§ÙÙÛÙ|Ø¬ÙÙØ±Û|ÙØ¨Ø±ÙØ±Û|ÙÙØ±ÛÙ|ÙØ§Ø±Ú|ÙØ§Ø±Ø³|Ø¢Ù¾Ø±ÛÙ|Ø§Ù¾Ø±ÛÙ|Ø§ÛÙ¾Ø±ÛÙ|Ø¢ÙØ±ÛÙ|ÙÙ|ÙÛ|ÚÙØ¦Ù|Ø¬ÙÙ|Ø¬ÙÙØ§Û|ÚÙØ¦ÛÙ|Ø¢Ú¯Ø³Øª|Ø§Ú¯Ø³Øª|Ø¢Ú¯ÙØ³Øª|Ø§ÙØª|Ø³Ù¾ØªÙØ¨Ø±|Ø³Ù¾ØªØ§ÙØ¨Ø±|Ø§Ú©ØªØ¨Ø±|Ø§Ú©ØªÙØ¨Ø±|ÙÙØ§ÙØ¨Ø±|ÙÙÙØ¨Ø±|Ø¯Ø³Ø§ÙØ¨Ø±|Ø¯Ø³ÙØ¨Ø±)/i,
};
const parseMonthPatterns$W = {
  narrow: [
    /^(Ú|Ø¬)/i,
    /^Ù/i,
    /^Ù/i,
    /^(Ø¢|Ø§)/i,
    /^Ù/i,
    /^(Ú|Ø¬)/i,
    /^(Ø¬|Ú)/i,
    /^(Ø¢|Ø§)/i,
    /^Ø³/i,
    /^Ø§/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^ÚØ§/i,
    /^Ù/i,
    /^ÙØ§/i,
    /^Ø¢Ù¾/i,
    /^(ÙÛ|ÙÙ)/i,
    /^(ÚÙØ¦Ù|Ø¬ÙÙ)/i,
    /^(ÚÙØ¦Û|Ø¬ÙÙ)/i,
    /^(Ø§ÙØª|Ø¢Ú¯)/i,
    /^Ø³/i,
    /^(Ø§ÙÚ©|Ø§Ú©)/i,
    /^Ù/i,
    /^Ø¯/i,
  ],
};

const matchDayPatterns$W = {
  narrow: /^[Ø´ÛØ¯Ø³ÚÙ¾Ø¬]/i,
  short: /^(Ø´|Ø¬|1Ø´|2Ø´|3Ø´|4Ø´|5Ø´)/i,
  abbreviated: /^(ÛÚ©Ø´ÙØ¨Ù|Ø¯ÙØ´ÙØ¨Ù|Ø³ÙâØ´ÙØ¨Ù|ÚÙØ§Ø±Ø´ÙØ¨Ù|Ù¾ÙØ¬âØ´ÙØ¨Ù|Ø¬ÙØ¹Ù|Ø´ÙØ¨Ù)/i,
  wide: /^(ÛÚ©Ø´ÙØ¨Ù|Ø¯ÙØ´ÙØ¨Ù|Ø³ÙâØ´ÙØ¨Ù|ÚÙØ§Ø±Ø´ÙØ¨Ù|Ù¾ÙØ¬âØ´ÙØ¨Ù|Ø¬ÙØ¹Ù|Ø´ÙØ¨Ù)/i,
};
const parseDayPatterns$W = {
  narrow: [/^Û/i, /^Ø¯Ù/i, /^Ø³/i, /^Ú/i, /^Ù¾/i, /^Ø¬/i, /^Ø´/i],
  any: [
    /^(Û|1Ø´|ÛÚ©Ø´ÙØ¨Ù)/i,
    /^(Ø¯|2Ø´|Ø¯ÙØ´ÙØ¨Ù)/i,
    /^(Ø³|3Ø´|Ø³ÙâØ´ÙØ¨Ù)/i,
    /^(Ú|4Ø´|ÚÙØ§Ø±Ø´ÙØ¨Ù)/i,
    /^(Ù¾|5Ø´|Ù¾ÙØ¬Ø´ÙØ¨Ù)/i,
    /^(Ø¬|Ø¬ÙØ¹Ù)/i,
    /^(Ø´|Ø´ÙØ¨Ù)/i,
  ],
};

const matchDayPeriodPatterns$W = {
  narrow: /^(Ø¨|Ù|Ù|Ø¸|Øµ|Ø¨.Ø¸.|Ø¹|Ø´)/i,
  abbreviated: /^(Ù.Ø¸.|Ø¨.Ø¸.|ÙÛÙÙâØ´Ø¨|Ø¸ÙØ±|ØµØ¨Ø­|Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±|Ø¹ØµØ±|Ø´Ø¨)/i,
  wide: /^(ÙØ¨ÙâØ§Ø²Ø¸ÙØ±|ÙÛÙÙâØ´Ø¨|Ø¸ÙØ±|ØµØ¨Ø­|Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±|Ø¹ØµØ±|Ø´Ø¨)/i,
};
const parseDayPeriodPatterns$W = {
  any: {
    am: /^(Ù|Ù.Ø¸.|ÙØ¨ÙâØ§Ø²Ø¸ÙØ±)/i,
    pm: /^(Ø¨|Ø¨.Ø¸.|Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±)/i,
    midnight: /^(âÙÛÙÙâØ´Ø¨|Ù)/i,
    noon: /^(Ø¸|Ø¸ÙØ±)/i,
    morning: /(Øµ|ØµØ¨Ø­)/i,
    afternoon: /(Ø¨|Ø¨.Ø¸.|Ø¨Ø¹Ø¯Ø§Ø²Ø¸ÙØ±)/i,
    evening: /(Ø¹|Ø¹ØµØ±)/i,
    night: /(Ø´|Ø´Ø¨)/i,
  },
};

(match$W.match = {
  ordinalNumber: (0, _index2$3r.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$W,
    parsePattern: parseOrdinalNumberPattern$W,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7M.buildMatchFn)({
    matchPatterns: matchEraPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$W,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7M.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$W,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7M.buildMatchFn)({
    matchPatterns: matchMonthPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$W,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7M.buildMatchFn)({
    matchPatterns: matchDayPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$W,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7M.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$W,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$W,
    defaultParseWidth: "any",
  }),
});

faIR.faIR = void 0;
var _index$7L = formatDistance$1T;
var _index2$3q = formatLong$Z;
var _index3$1M = formatRelative$1V;
var _index4$1f = localize$W;
var _index5$16 = match$W;

/**
 * @category Locales
 * @summary Persian/Farsi locale (Iran).
 * @language Persian
 * @iso-639-2 ira
 * @author Morteza Ziyae [@mort3za](https://github.com/mort3za)
 */
(faIR.faIR = {
  code: "fa-IR",
  formatDistance: _index$7L.formatDistance,
  formatLong: _index2$3q.formatLong,
  formatRelative: _index3$1M.formatRelative,
  localize: _index4$1f.localize,
  match: _index5$16.match,
  options: {
    weekStartsOn: 6 /* Saturday */,
    firstWeekContainsDate: 1,
  },
});

var fi = {};

var formatDistance$1R = {};

formatDistance$1R.formatDistance = void 0;

function futureSeconds(text) {
  return text.replace(/sekuntia?/, "sekunnin");
}

function futureMinutes(text) {
  return text.replace(/minuuttia?/, "minuutin");
}

function futureHours(text) {
  return text.replace(/tuntia?/, "tunnin");
}

function futureDays(text) {
  return text.replace(/pÃ¤ivÃ¤Ã¤?/, "pÃ¤ivÃ¤n");
}

function futureWeeks(text) {
  return text.replace(/(viikko|viikkoa)/, "viikon");
}

function futureMonths(text) {
  return text.replace(/(kuukausi|kuukautta)/, "kuukauden");
}

function futureYears(text) {
  return text.replace(/(vuosi|vuotta)/, "vuoden");
}

const formatDistanceLocale$U = {
  lessThanXSeconds: {
    one: "alle sekunti",
    other: "alle {{count}} sekuntia",
    futureTense: futureSeconds,
  },

  xSeconds: {
    one: "sekunti",
    other: "{{count}} sekuntia",
    futureTense: futureSeconds,
  },

  halfAMinute: {
    one: "puoli minuuttia",
    other: "puoli minuuttia",
    futureTense: (_text) => "puolen minuutin",
  },

  lessThanXMinutes: {
    one: "alle minuutti",
    other: "alle {{count}} minuuttia",
    futureTense: futureMinutes,
  },

  xMinutes: {
    one: "minuutti",
    other: "{{count}} minuuttia",
    futureTense: futureMinutes,
  },

  aboutXHours: {
    one: "noin tunti",
    other: "noin {{count}} tuntia",
    futureTense: futureHours,
  },

  xHours: {
    one: "tunti",
    other: "{{count}} tuntia",
    futureTense: futureHours,
  },

  xDays: {
    one: "pÃ¤ivÃ¤",
    other: "{{count}} pÃ¤ivÃ¤Ã¤",
    futureTense: futureDays,
  },

  aboutXWeeks: {
    one: "noin viikko",
    other: "noin {{count}} viikkoa",
    futureTense: futureWeeks,
  },

  xWeeks: {
    one: "viikko",
    other: "{{count}} viikkoa",
    futureTense: futureWeeks,
  },

  aboutXMonths: {
    one: "noin kuukausi",
    other: "noin {{count}} kuukautta",
    futureTense: futureMonths,
  },

  xMonths: {
    one: "kuukausi",
    other: "{{count}} kuukautta",
    futureTense: futureMonths,
  },

  aboutXYears: {
    one: "noin vuosi",
    other: "noin {{count}} vuotta",
    futureTense: futureYears,
  },

  xYears: {
    one: "vuosi",
    other: "{{count}} vuotta",
    futureTense: futureYears,
  },

  overXYears: {
    one: "yli vuosi",
    other: "yli {{count}} vuotta",
    futureTense: futureYears,
  },

  almostXYears: {
    one: "lÃ¤hes vuosi",
    other: "lÃ¤hes {{count}} vuotta",
    futureTense: futureYears,
  },
};

const formatDistance$1Q = (token, count, options) => {
  const tokenValue = formatDistanceLocale$U[token];
  const result =
    count === 1
      ? tokenValue.one
      : tokenValue.other.replace("{{count}}", String(count));

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return tokenValue.futureTense(result) + " kuluttua";
    } else {
      return result + " sitten";
    }
  }

  return result;
};
formatDistance$1R.formatDistance = formatDistance$1Q;

var formatLong$Y = {};

formatLong$Y.formatLong = void 0;
var _index$7K = buildFormatLongFn$1;

const dateFormats$Y = {
  full: "eeee d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "d.M.y",
};

const timeFormats$Y = {
  full: "HH.mm.ss zzzz",
  long: "HH.mm.ss z",
  medium: "HH.mm.ss",
  short: "HH.mm",
};

const dateTimeFormats$Y = {
  full: "{{date}} 'klo' {{time}}",
  long: "{{date}} 'klo' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$Y.formatLong = {
  date: (0, _index$7K.buildFormatLongFn)({
    formats: dateFormats$Y,
    defaultWidth: "full",
  }),

  time: (0, _index$7K.buildFormatLongFn)({
    formats: timeFormats$Y,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7K.buildFormatLongFn)({
    formats: dateTimeFormats$Y,
    defaultWidth: "full",
  }),
});

var formatRelative$1T = {};

formatRelative$1T.formatRelative = void 0;

const formatRelativeLocale$W = {
  lastWeek: "'viime' eeee 'klo' p",
  yesterday: "'eilen klo' p",
  today: "'tÃ¤nÃ¤Ã¤n klo' p",
  tomorrow: "'huomenna klo' p",
  nextWeek: "'ensi' eeee 'klo' p",
  other: "P",
};

const formatRelative$1S = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$W[token];
formatRelative$1T.formatRelative = formatRelative$1S;

var localize$V = {};

localize$V.localize = void 0;
var _index$7J = buildLocalizeFn$1;

const eraValues$V = {
  narrow: ["eaa.", "jaa."],
  abbreviated: ["eaa.", "jaa."],
  wide: ["ennen ajanlaskun alkua", "jÃ¤lkeen ajanlaskun alun"],
};

const quarterValues$V = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartaali", "2. kvartaali", "3. kvartaali", "4. kvartaali"],
};

const monthValues$V = {
  narrow: ["T", "H", "M", "H", "T", "K", "H", "E", "S", "L", "M", "J"],
  abbreviated: [
    "tammi",
    "helmi",
    "maalis",
    "huhti",
    "touko",
    "kesÃ¤",
    "heinÃ¤",
    "elo",
    "syys",
    "loka",
    "marras",
    "joulu",
  ],

  wide: [
    "tammikuu",
    "helmikuu",
    "maaliskuu",
    "huhtikuu",
    "toukokuu",
    "kesÃ¤kuu",
    "heinÃ¤kuu",
    "elokuu",
    "syyskuu",
    "lokakuu",
    "marraskuu",
    "joulukuu",
  ],
};

const formattingMonthValues$b = {
  narrow: monthValues$V.narrow,
  abbreviated: monthValues$V.abbreviated,
  wide: [
    "tammikuuta",
    "helmikuuta",
    "maaliskuuta",
    "huhtikuuta",
    "toukokuuta",
    "kesÃ¤kuuta",
    "heinÃ¤kuuta",
    "elokuuta",
    "syyskuuta",
    "lokakuuta",
    "marraskuuta",
    "joulukuuta",
  ],
};

const dayValues$V = {
  narrow: ["S", "M", "T", "K", "T", "P", "L"],
  short: ["su", "ma", "ti", "ke", "to", "pe", "la"],
  abbreviated: ["sunn.", "maan.", "tiis.", "kesk.", "torst.", "perj.", "la"],

  wide: [
    "sunnuntai",
    "maanantai",
    "tiistai",
    "keskiviikko",
    "torstai",
    "perjantai",
    "lauantai",
  ],
};

const formattingDayValues$3 = {
  narrow: dayValues$V.narrow,
  short: dayValues$V.short,
  abbreviated: dayValues$V.abbreviated,
  wide: [
    "sunnuntaina",
    "maanantaina",
    "tiistaina",
    "keskiviikkona",
    "torstaina",
    "perjantaina",
    "lauantaina",
  ],
};

const dayPeriodValues$V = {
  narrow: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyÃ¶",
    noon: "keskipÃ¤ivÃ¤",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yÃ¶llÃ¤",
  },
  abbreviated: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyÃ¶",
    noon: "keskipÃ¤ivÃ¤",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yÃ¶llÃ¤",
  },
  wide: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyÃ¶llÃ¤",
    noon: "keskipÃ¤ivÃ¤llÃ¤",
    morning: "aamupÃ¤ivÃ¤llÃ¤",
    afternoon: "iltapÃ¤ivÃ¤llÃ¤",
    evening: "illalla",
    night: "yÃ¶llÃ¤",
  },
};

const ordinalNumber$V = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$V.localize = {
  ordinalNumber: ordinalNumber$V,

  era: (0, _index$7J.buildLocalizeFn)({
    values: eraValues$V,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7J.buildLocalizeFn)({
    values: quarterValues$V,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7J.buildLocalizeFn)({
    values: monthValues$V,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$b,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$7J.buildLocalizeFn)({
    values: dayValues$V,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$3,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$7J.buildLocalizeFn)({
    values: dayPeriodValues$V,
    defaultWidth: "wide",
  }),
});

var match$V = {};

match$V.match = void 0;

var _index$7I = buildMatchFn$1;
var _index2$3p = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$V = /^(\d+)(\.)/i;
const parseOrdinalNumberPattern$V = /\d+/i;

const matchEraPatterns$V = {
  narrow: /^(e|j)/i,
  abbreviated: /^(eaa.|jaa.)/i,
  wide: /^(ennen ajanlaskun alkua|jÃ¤lkeen ajanlaskun alun)/i,
};
const parseEraPatterns$V = {
  any: [/^e/i, /^j/i],
};

const matchQuarterPatterns$V = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\.? kvartaali/i,
};
const parseQuarterPatterns$V = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$V = {
  narrow: /^[thmkeslj]/i,
  abbreviated:
    /^(tammi|helmi|maalis|huhti|touko|kesÃ¤|heinÃ¤|elo|syys|loka|marras|joulu)/i,
  wide: /^(tammikuu|helmikuu|maaliskuu|huhtikuu|toukokuu|kesÃ¤kuu|heinÃ¤kuu|elokuu|syyskuu|lokakuu|marraskuu|joulukuu)(ta)?/i,
};
const parseMonthPatterns$V = {
  narrow: [
    /^t/i,
    /^h/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^k/i,
    /^h/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^m/i,
    /^j/i,
  ],

  any: [
    /^ta/i,
    /^hel/i,
    /^maa/i,
    /^hu/i,
    /^to/i,
    /^k/i,
    /^hei/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^mar/i,
    /^j/i,
  ],
};

const matchDayPatterns$V = {
  narrow: /^[smtkpl]/i,
  short: /^(su|ma|ti|ke|to|pe|la)/i,
  abbreviated: /^(sunn.|maan.|tiis.|kesk.|torst.|perj.|la)/i,
  wide: /^(sunnuntai|maanantai|tiistai|keskiviikko|torstai|perjantai|lauantai)(na)?/i,
};
const parseDayPatterns$V = {
  narrow: [/^s/i, /^m/i, /^t/i, /^k/i, /^t/i, /^p/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^k/i, /^to/i, /^p/i, /^l/i],
};

const matchDayPeriodPatterns$V = {
  narrow:
    /^(ap|ip|keskiyÃ¶|keskipÃ¤ivÃ¤|aamupÃ¤ivÃ¤llÃ¤|iltapÃ¤ivÃ¤llÃ¤|illalla|yÃ¶llÃ¤)/i,
  any: /^(ap|ip|keskiyÃ¶llÃ¤|keskipÃ¤ivÃ¤llÃ¤|aamupÃ¤ivÃ¤llÃ¤|iltapÃ¤ivÃ¤llÃ¤|illalla|yÃ¶llÃ¤)/i,
};
const parseDayPeriodPatterns$V = {
  any: {
    am: /^ap/i,
    pm: /^ip/i,
    midnight: /^keskiyÃ¶/i,
    noon: /^keskipÃ¤ivÃ¤/i,
    morning: /aamupÃ¤ivÃ¤llÃ¤/i,
    afternoon: /iltapÃ¤ivÃ¤llÃ¤/i,
    evening: /illalla/i,
    night: /yÃ¶llÃ¤/i,
  },
};

(match$V.match = {
  ordinalNumber: (0, _index2$3p.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$V,
    parsePattern: parseOrdinalNumberPattern$V,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7I.buildMatchFn)({
    matchPatterns: matchEraPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$V,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7I.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$V,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7I.buildMatchFn)({
    matchPatterns: matchMonthPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$V,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7I.buildMatchFn)({
    matchPatterns: matchDayPatterns$V,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$V,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7I.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$V,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$V,
    defaultParseWidth: "any",
  }),
});

fi.fi = void 0;
var _index$7H = formatDistance$1R;
var _index2$3o = formatLong$Y;
var _index3$1L = formatRelative$1T;
var _index4$1e = localize$V;
var _index5$15 = match$V;

/**
 * @category Locales
 * @summary Finnish locale.
 * @language Finnish
 * @iso-639-2 fin
 * @author Pyry-Samuli Lahti [@Pyppe](https://github.com/Pyppe)
 * @author Edo Rivai [@mikolajgrzyb](https://github.com/mikolajgrzyb)
 * @author Samu Juvonen [@sjuvonen](https://github.com/sjuvonen)
 */
(fi.fi = {
  code: "fi",
  formatDistance: _index$7H.formatDistance,
  formatLong: _index2$3o.formatLong,
  formatRelative: _index3$1L.formatRelative,
  localize: _index4$1e.localize,
  match: _index5$15.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var fr = {};

var formatDistance$1P = {};

formatDistance$1P.formatDistance = void 0;

const formatDistanceLocale$T = {
  lessThanXSeconds: {
    one: "moins dâune seconde",
    other: "moins de {{count}} secondes",
  },

  xSeconds: {
    one: "1 seconde",
    other: "{{count}} secondes",
  },

  halfAMinute: "30 secondes",

  lessThanXMinutes: {
    one: "moins dâune minute",
    other: "moins de {{count}} minutes",
  },

  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "environ 1 heure",
    other: "environ {{count}} heures",
  },

  xHours: {
    one: "1 heure",
    other: "{{count}} heures",
  },

  xDays: {
    one: "1 jour",
    other: "{{count}} jours",
  },

  aboutXWeeks: {
    one: "environ 1 semaine",
    other: "environ {{count}} semaines",
  },

  xWeeks: {
    one: "1 semaine",
    other: "{{count}} semaines",
  },

  aboutXMonths: {
    one: "environ 1 mois",
    other: "environ {{count}} mois",
  },

  xMonths: {
    one: "1 mois",
    other: "{{count}} mois",
  },

  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans",
  },

  xYears: {
    one: "1 an",
    other: "{{count}} ans",
  },

  overXYears: {
    one: "plus dâun an",
    other: "plus de {{count}} ans",
  },

  almostXYears: {
    one: "presquâun an",
    other: "presque {{count}} ans",
  },
};

const formatDistance$1O = (token, count, options) => {
  let result;
  const form = formatDistanceLocale$T[token];
  if (typeof form === "string") {
    result = form;
  } else if (count === 1) {
    result = form.one;
  } else {
    result = form.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dans " + result;
    } else {
      return "il y a " + result;
    }
  }

  return result;
};
formatDistance$1P.formatDistance = formatDistance$1O;

var formatLong$X = {};

formatLong$X.formatLong = void 0;
var _index$7G = buildFormatLongFn$1;

const dateFormats$X = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$X = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$X = {
  full: "{{date}} 'Ã ' {{time}}",
  long: "{{date}} 'Ã ' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$X.formatLong = {
  date: (0, _index$7G.buildFormatLongFn)({
    formats: dateFormats$X,
    defaultWidth: "full",
  }),

  time: (0, _index$7G.buildFormatLongFn)({
    formats: timeFormats$X,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7G.buildFormatLongFn)({
    formats: dateTimeFormats$X,
    defaultWidth: "full",
  }),
});

var formatRelative$1R = {};

formatRelative$1R.formatRelative = void 0;

const formatRelativeLocale$V = {
  lastWeek: "eeee 'dernier Ã ' p",
  yesterday: "'hier Ã ' p",
  today: "'aujourdâhui Ã ' p",
  tomorrow: "'demain Ã ' p'",
  nextWeek: "eeee 'prochain Ã ' p",
  other: "P",
};

const formatRelative$1Q = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$V[token];
formatRelative$1R.formatRelative = formatRelative$1Q;

var localize$U = {};

localize$U.localize = void 0;
var _index$7F = buildLocalizeFn$1;

const eraValues$U = {
  narrow: ["av. J.-C", "ap. J.-C"],
  abbreviated: ["av. J.-C", "ap. J.-C"],
  wide: ["avant JÃ©sus-Christ", "aprÃ¨s JÃ©sus-Christ"],
};

const quarterValues$U = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1er trim.", "2Ã¨me trim.", "3Ã¨me trim.", "4Ã¨me trim."],
  wide: ["1er trimestre", "2Ã¨me trimestre", "3Ã¨me trimestre", "4Ã¨me trimestre"],
};

const monthValues$U = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "fÃ©vr.",
    "mars",
    "avr.",
    "mai",
    "juin",
    "juil.",
    "aoÃ»t",
    "sept.",
    "oct.",
    "nov.",
    "dÃ©c.",
  ],

  wide: [
    "janvier",
    "fÃ©vrier",
    "mars",
    "avril",
    "mai",
    "juin",
    "juillet",
    "aoÃ»t",
    "septembre",
    "octobre",
    "novembre",
    "dÃ©cembre",
  ],
};

const dayValues$U = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
  abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],

  wide: [
    "dimanche",
    "lundi",
    "mardi",
    "mercredi",
    "jeudi",
    "vendredi",
    "samedi",
  ],
};

const dayPeriodValues$U = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "soir",
    night: "mat.",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "matin",
    afternoon: "aprÃ¨s-midi",
    evening: "soir",
    night: "matin",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "du matin",
    afternoon: "de lâaprÃ¨s-midi",
    evening: "du soir",
    night: "du matin",
  },
};

const ordinalNumber$U = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;

  if (number === 0) return "0";

  const feminineUnits = ["year", "week", "hour", "minute", "second"];
  let suffix;

  if (number === 1) {
    suffix = unit && feminineUnits.includes(unit) ? "Ã¨re" : "er";
  } else {
    suffix = "Ã¨me";
  }

  return number + suffix;
};

const LONG_MONTHS_TOKENS = ["MMM", "MMMM"];

(localize$U.localize = {
  preprocessor: (date, parts) => {
    // Replaces the `do` tokens with `d` when used with long month tokens and the day of the month is greater than one.
    // Use case "do MMMM" => 1er aoÃ»t, 29 aoÃ»t
    // see https://github.com/date-fns/date-fns/issues/1391

    if (date.getDate() === 1) return parts;

    const hasLongMonthToken = parts.some(
      (part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value),
    );

    if (!hasLongMonthToken) return parts;

    return parts.map((part) =>
      part.isToken && part.value === "do"
        ? { isToken: true, value: "d" }
        : part,
    );
  },

  ordinalNumber: ordinalNumber$U,

  era: (0, _index$7F.buildLocalizeFn)({
    values: eraValues$U,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7F.buildLocalizeFn)({
    values: quarterValues$U,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7F.buildLocalizeFn)({
    values: monthValues$U,
    defaultWidth: "wide",
  }),

  day: (0, _index$7F.buildLocalizeFn)({
    values: dayValues$U,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7F.buildLocalizeFn)({
    values: dayPeriodValues$U,
    defaultWidth: "wide",
  }),
});

var match$U = {};

match$U.match = void 0;

var _index$7E = buildMatchFn$1;
var _index2$3n = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$U = /^(\d+)(iÃ¨me|Ã¨re|Ã¨me|er|e)?/i;
const parseOrdinalNumberPattern$U = /\d+/i;

const matchEraPatterns$U = {
  narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
  abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(avant JÃ©sus-Christ|aprÃ¨s JÃ©sus-Christ)/i,
};
const parseEraPatterns$U = {
  any: [/^av/i, /^ap/i],
};

const matchQuarterPatterns$U = {
  narrow: /^T?[1234]/i,
  abbreviated: /^[1234](er|Ã¨me|e)? trim\.?/i,
  wide: /^[1234](er|Ã¨me|e)? trimestre/i,
};
const parseQuarterPatterns$U = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$U = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(janv|fÃ©vr|mars|avr|mai|juin|juill|juil|aoÃ»t|sept|oct|nov|dÃ©c)\.?/i,
  wide: /^(janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i,
};
const parseMonthPatterns$U = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^av/i,
    /^ma/i,
    /^juin/i,
    /^juil/i,
    /^ao/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$U = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|lu|ma|me|je|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
  wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i,
};
const parseDayPatterns$U = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i],
};

const matchDayPeriodPatterns$U = {
  narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
  any: /^([ap]\.?\s?m\.?|du matin|de l'aprÃ¨s[-\s]midi|du soir|de la nuit)/i,
};
const parseDayPeriodPatterns$U = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /soir/i,
    night: /nuit/i,
  },
};

(match$U.match = {
  ordinalNumber: (0, _index2$3n.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$U,
    parsePattern: parseOrdinalNumberPattern$U,
    valueCallback: (value) => parseInt(value),
  }),

  era: (0, _index$7E.buildMatchFn)({
    matchPatterns: matchEraPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$U,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7E.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$U,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7E.buildMatchFn)({
    matchPatterns: matchMonthPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$U,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7E.buildMatchFn)({
    matchPatterns: matchDayPatterns$U,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$U,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7E.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$U,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$U,
    defaultParseWidth: "any",
  }),
});

fr.fr = void 0;
var _index$7D = formatDistance$1P;
var _index2$3m = formatLong$X;
var _index3$1K = formatRelative$1R;
var _index4$1d = localize$U;
var _index5$14 = match$U;

/**
 * @category Locales
 * @summary French locale.
 * @language French
 * @iso-639-2 fra
 * @author Jean Dupouy [@izeau](https://github.com/izeau)
 * @author FranÃ§ois B [@fbonzon](https://github.com/fbonzon)
 */
(fr.fr = {
  code: "fr",
  formatDistance: _index$7D.formatDistance,
  formatLong: _index2$3m.formatLong,
  formatRelative: _index3$1K.formatRelative,
  localize: _index4$1d.localize,
  match: _index5$14.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var frCA = {};

var formatLong$W = {};

formatLong$W.formatLong = void 0;
var _index$7C = buildFormatLongFn$1;

const dateFormats$W = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "yy-MM-dd",
};

const timeFormats$W = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$W = {
  full: "{{date}} 'Ã ' {{time}}",
  long: "{{date}} 'Ã ' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$W.formatLong = {
  date: (0, _index$7C.buildFormatLongFn)({
    formats: dateFormats$W,
    defaultWidth: "full",
  }),

  time: (0, _index$7C.buildFormatLongFn)({
    formats: timeFormats$W,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7C.buildFormatLongFn)({
    formats: dateTimeFormats$W,
    defaultWidth: "full",
  }),
});

frCA.frCA = void 0;
var _index$7B = formatDistance$1P;
var _index2$3l = formatRelative$1R;
var _index3$1J = localize$U;
var _index4$1c = match$U;

var _index5$13 = formatLong$W; // Same as fr
// Unique for fr-CA
/**
 * @category Locales
 * @summary French locale (Canada).
 * @language French
 * @iso-639-2 fra
 * @author Jean Dupouy [@izeau](https://github.com/izeau)
 * @author FranÃ§ois B [@fbonzon](https://github.com/fbonzon)
 * @author Gabriele Petrioli [@gpetrioli](https://github.com/gpetrioli)
 */
(frCA.frCA = {
  code: "fr-CA",
  formatDistance: _index$7B.formatDistance,
  formatLong: _index5$13.formatLong,
  formatRelative: _index2$3l.formatRelative,
  localize: _index3$1J.localize,
  match: _index4$1c.match,

  // Unique for fr-CA
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var frCH = {};

var formatLong$V = {};

formatLong$V.formatLong = void 0;
var _index$7A = buildFormatLongFn$1;

const dateFormats$V = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y",
};

const timeFormats$V = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$V = {
  full: "{{date}} 'Ã ' {{time}}",
  long: "{{date}} 'Ã ' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$V.formatLong = {
  date: (0, _index$7A.buildFormatLongFn)({
    formats: dateFormats$V,
    defaultWidth: "full",
  }),

  time: (0, _index$7A.buildFormatLongFn)({
    formats: timeFormats$V,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7A.buildFormatLongFn)({
    formats: dateTimeFormats$V,
    defaultWidth: "full",
  }),
});

var formatRelative$1P = {};

formatRelative$1P.formatRelative = void 0;

const formatRelativeLocale$U = {
  lastWeek: "eeee 'la semaine derniÃ¨re Ã ' p",
  yesterday: "'hier Ã ' p",
  today: "'aujourdâhui Ã ' p",
  tomorrow: "'demain Ã ' p'",
  nextWeek: "eeee 'la semaine prochaine Ã ' p",
  other: "P",
};

const formatRelative$1O = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$U[token];
formatRelative$1P.formatRelative = formatRelative$1O;

frCH.frCH = void 0;
var _index$7z = formatDistance$1P;
var _index2$3k = localize$U;
var _index3$1I = match$U;

var _index4$1b = formatLong$V;
var _index5$12 = formatRelative$1P; // Same as fr
// Unique for fr-CH
/**
 * @category Locales
 * @summary French locale (Switzerland).
 * @language French
 * @iso-639-2 fra
 * @author Jean Dupouy [@izeau](https://github.com/izeau)
 * @author FranÃ§ois B [@fbonzon](https://github.com/fbonzon)
 * @author Van Vuong Ngo [@vanvuongngo](https://github.com/vanvuongngo)
 * @author Alex Hoeing [@dcbn](https://github.com/dcbn)
 */
(frCH.frCH = {
  code: "fr-CH",
  formatDistance: _index$7z.formatDistance,
  formatLong: _index4$1b.formatLong,
  formatRelative: _index5$12.formatRelative,
  localize: _index2$3k.localize,
  match: _index3$1I.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var fy = {};

var formatDistance$1N = {};

formatDistance$1N.formatDistance = void 0;

const formatDistanceLocale$S = {
  lessThanXSeconds: {
    one: "minder as 1 sekonde",
    other: "minder as {{count}} sekonden",
  },

  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekonden",
  },

  halfAMinute: "oardel minÃºt",

  lessThanXMinutes: {
    one: "minder as 1 minÃºt",
    other: "minder as {{count}} minuten",
  },

  xMinutes: {
    one: "1 minÃºt",
    other: "{{count}} minuten",
  },

  aboutXHours: {
    one: "sawat 1 oere",
    other: "sawat {{count}} oere",
  },

  xHours: {
    one: "1 oere",
    other: "{{count}} oere",
  },

  xDays: {
    one: "1 dei",
    other: "{{count}} dagen",
  },

  aboutXWeeks: {
    one: "sawat 1 wike",
    other: "sawat {{count}} wiken",
  },

  xWeeks: {
    one: "1 wike",
    other: "{{count}} wiken",
  },

  aboutXMonths: {
    one: "sawat 1 moanne",
    other: "sawat {{count}} moannen",
  },

  xMonths: {
    one: "1 moanne",
    other: "{{count}} moannen",
  },

  aboutXYears: {
    one: "sawat 1 jier",
    other: "sawat {{count}} jier",
  },

  xYears: {
    one: "1 jier",
    other: "{{count}} jier",
  },

  overXYears: {
    one: "mear as 1 jier",
    other: "mear as {{count}}s jier",
  },

  almostXYears: {
    one: "hast 1 jier",
    other: "hast {{count}} jier",
  },
};

const formatDistance$1M = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$S[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "oer " + result;
    } else {
      return result + " lyn";
    }
  }

  return result;
};
formatDistance$1N.formatDistance = formatDistance$1M;

var formatLong$U = {};

formatLong$U.formatLong = void 0;
var _index$7y = buildFormatLongFn$1;

const dateFormats$U = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y",
};

const timeFormats$U = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$U = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$U.formatLong = {
  date: (0, _index$7y.buildFormatLongFn)({
    formats: dateFormats$U,
    defaultWidth: "full",
  }),

  time: (0, _index$7y.buildFormatLongFn)({
    formats: timeFormats$U,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7y.buildFormatLongFn)({
    formats: dateTimeFormats$U,
    defaultWidth: "full",
  }),
});

var formatRelative$1N = {};

formatRelative$1N.formatRelative = void 0;

const formatRelativeLocale$T = {
  lastWeek: "'Ã´frÃ»ne' eeee 'om' p",
  yesterday: "'juster om' p",
  today: "'hjoed om' p",
  tomorrow: "'moarn om' p",
  nextWeek: "eeee 'om' p",
  other: "P",
};

const formatRelative$1M = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$T[token];
formatRelative$1N.formatRelative = formatRelative$1M;

var localize$T = {};

localize$T.localize = void 0;
var _index$7x = buildLocalizeFn$1;

const eraValues$T = {
  narrow: ["f.K.", "n.K."],
  abbreviated: ["f.Kr.", "n.Kr."],
  wide: ["foar Kristus", "nei Kristus"],
};

const quarterValues$T = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e fearnsjier", "2e fearnsjier", "3e fearnsjier", "4e fearnsjier"],
};

const monthValues$T = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mai.",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des.",
  ],

  wide: [
    "jannewaris",
    "febrewaris",
    "maart",
    "april",
    "maaie",
    "juny",
    "july",
    "augustus",
    "septimber",
    "oktober",
    "novimber",
    "desimber",
  ],
};

const dayValues$T = {
  narrow: ["s", "m", "t", "w", "t", "f", "s"],
  short: ["si", "mo", "ti", "wo", "to", "fr", "so"],
  abbreviated: ["snein", "moa", "tii", "woa", "ton", "fre", "sneon"],
  wide: [
    "snein",
    "moandei",
    "tiisdei",
    "woansdei",
    "tongersdei",
    "freed",
    "sneon",
  ],
};

const dayPeriodValues$T = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jÃ»ns",
    night: "nachts",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jÃ»ns",
    night: "nachts",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jÃ»ns",
    night: "nachts",
  },
};

const ordinalNumber$T = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "e";
};

(localize$T.localize = {
  ordinalNumber: ordinalNumber$T,

  era: (0, _index$7x.buildLocalizeFn)({
    values: eraValues$T,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7x.buildLocalizeFn)({
    values: quarterValues$T,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7x.buildLocalizeFn)({
    values: monthValues$T,
    defaultWidth: "wide",
  }),

  day: (0, _index$7x.buildLocalizeFn)({
    values: dayValues$T,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7x.buildLocalizeFn)({
    values: dayPeriodValues$T,
    defaultWidth: "wide",
  }),
});

var match$T = {};

match$T.match = void 0;

var _index$7w = buildMatchFn$1;
var _index2$3j = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$T = /^(\d+)e?/i;
const parseOrdinalNumberPattern$T = /\d+/i;

const matchEraPatterns$T = {
  narrow: /^([fn]\.? ?K\.?)/,
  abbreviated: /^([fn]\. ?Kr\.?)/,
  wide: /^((foar|nei) Kristus)/,
};
const parseEraPatterns$T = {
  any: [/^f/, /^n/],
};

const matchQuarterPatterns$T = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e fearnsjier/i,
};

const parseQuarterPatterns$T = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$T = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(jan.|feb.|mrt.|apr.|mai.|jun.|jul.|aug.|sep.|okt.|nov.|des.)/i,
  wide: /^(jannewaris|febrewaris|maart|april|maaie|juny|july|augustus|septimber|oktober|novimber|desimber)/i,
};
const parseMonthPatterns$T = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^des/i,
  ],
};

const matchDayPatterns$T = {
  narrow: /^[smtwf]/i,
  short: /^(si|mo|ti|wo|to|fr|so)/i,
  abbreviated: /^(snein|moa|tii|woa|ton|fre|sneon)/i,
  wide: /^(snein|moandei|tiisdei|woansdei|tongersdei|freed|sneon)/i,
};
const parseDayPatterns$T = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^sn/i, /^mo/i, /^ti/i, /^wo/i, /^to/i, /^fr/i, /^sn/i],
};

const matchDayPeriodPatterns$T = {
  any: /^(am|pm|middernacht|middeis|moarns|middei|jÃ»ns|nachts)/i,
};
const parseDayPeriodPatterns$T = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^middei/i,
    morning: /moarns/i,
    afternoon: /^middeis/i,
    evening: /jÃ»ns/i,
    night: /nachts/i,
  },
};

(match$T.match = {
  ordinalNumber: (0, _index2$3j.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$T,
    parsePattern: parseOrdinalNumberPattern$T,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7w.buildMatchFn)({
    matchPatterns: matchEraPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$T,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7w.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$T,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7w.buildMatchFn)({
    matchPatterns: matchMonthPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$T,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7w.buildMatchFn)({
    matchPatterns: matchDayPatterns$T,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$T,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7w.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$T,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$T,
    defaultParseWidth: "any",
  }),
});

fy.fy = void 0;
var _index$7v = formatDistance$1N;
var _index2$3i = formatLong$U;
var _index3$1H = formatRelative$1N;
var _index4$1a = localize$T;
var _index5$11 = match$T;

/**
 * @category Locales
 * @summary Western Frisian locale (Netherlands).
 * @language West Frisian
 * @iso-639-2 fry
 * @author Damon Asberg [@damon02](https://github.com/damon02)
 */
(fy.fy = {
  code: "fy",
  formatDistance: _index$7v.formatDistance,
  formatLong: _index2$3i.formatLong,
  formatRelative: _index3$1H.formatRelative,
  localize: _index4$1a.localize,
  match: _index5$11.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var gd = {};

var formatDistance$1L = {};

formatDistance$1L.formatDistance = void 0;

const formatDistanceLocale$R = {
  lessThanXSeconds: {
    one: "nas lugha na diog",
    other: "nas lugha na {{count}} diogan",
  },

  xSeconds: {
    one: "1 diog",
    two: "2 dhiog",
    twenty: "20 diog",
    other: "{{count}} diogan",
  },

  halfAMinute: "leth mhionaid",

  lessThanXMinutes: {
    one: "nas lugha na mionaid",
    other: "nas lugha na {{count}} mionaidean",
  },

  xMinutes: {
    one: "1 mionaid",
    two: "2 mhionaid",
    twenty: "20 mionaid",
    other: "{{count}} mionaidean",
  },

  aboutXHours: {
    one: "mu uair de thÃ¬de",
    other: "mu {{count}} uairean de thÃ¬de",
  },

  xHours: {
    one: "1 uair de thÃ¬de",
    two: "2 uair de thÃ¬de",
    twenty: "20 uair de thÃ¬de",
    other: "{{count}} uairean de thÃ¬de",
  },

  xDays: {
    one: "1 lÃ ",
    other: "{{count}} lÃ ",
  },

  aboutXWeeks: {
    one: "mu 1 seachdain",
    other: "mu {{count}} seachdainean",
  },

  xWeeks: {
    one: "1 seachdain",
    other: "{{count}} seachdainean",
  },

  aboutXMonths: {
    one: "mu mhÃ¬os",
    other: "mu {{count}} mÃ¬osan",
  },

  xMonths: {
    one: "1 mÃ¬os",
    other: "{{count}} mÃ¬osan",
  },

  aboutXYears: {
    one: "mu bhliadhna",
    other: "mu {{count}} bliadhnaichean",
  },

  xYears: {
    one: "1 bhliadhna",
    other: "{{count}} bliadhna",
  },

  overXYears: {
    one: "cÃ²rr is bliadhna",
    other: "cÃ²rr is {{count}} bliadhnaichean",
  },

  almostXYears: {
    one: "cha mhÃ²r bliadhna",
    other: "cha mhÃ²r {{count}} bliadhnaichean",
  },
};

const formatDistance$1K = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$R[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else if (count === 20 && !!tokenValue.twenty) {
    result = tokenValue.twenty;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "ann an " + result;
    } else {
      return "o chionn " + result;
    }
  }

  return result;
};
formatDistance$1L.formatDistance = formatDistance$1K;

var formatLong$T = {};

formatLong$T.formatLong = void 0;
var _index$7u = buildFormatLongFn$1;

const dateFormats$T = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$T = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$T = {
  full: "{{date}} 'aig' {{time}}",
  long: "{{date}} 'aig' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$T.formatLong = {
  date: (0, _index$7u.buildFormatLongFn)({
    formats: dateFormats$T,
    defaultWidth: "full",
  }),

  time: (0, _index$7u.buildFormatLongFn)({
    formats: timeFormats$T,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7u.buildFormatLongFn)({
    formats: dateTimeFormats$T,
    defaultWidth: "full",
  }),
});

var formatRelative$1L = {};

formatRelative$1L.formatRelative = void 0;

const formatRelativeLocale$S = {
  lastWeek: "'mu dheireadh' eeee 'aig' p", //FIX
  yesterday: "'an-dÃ¨ aig' p",
  today: "'an-diugh aig' p",
  tomorrow: "'a-mÃ ireach aig' p",
  nextWeek: "eeee 'aig' p",
  other: "P",
};

const formatRelative$1K = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$S[token];
formatRelative$1L.formatRelative = formatRelative$1K;

var localize$S = {};

localize$S.localize = void 0;
var _index$7t = buildLocalizeFn$1;

const eraValues$S = {
  narrow: ["R", "A"],
  abbreviated: ["RC", "AD"],
  wide: ["ro ChrÃ¬osta", "anno domini"],
};

const quarterValues$S = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["C1", "C2", "C3", "C4"],
  wide: [
    "a' chiad chairteal",
    "an dÃ rna cairteal",
    "an treas cairteal",
    "an ceathramh cairteal",
  ],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$S = {
  narrow: ["F", "G", "M", "G", "C", "Ã", "I", "L", "S", "D", "S", "D"],
  abbreviated: [
    "Faoi",
    "Gear",
    "MÃ rt",
    "Gibl",
    "CÃ¨it",
    "Ãgmh",
    "Iuch",
    "LÃ¹n",
    "Sult",
    "DÃ mh",
    "Samh",
    "DÃ¹bh",
  ],

  wide: [
    "Am Faoilleach",
    "An Gearran",
    "Am MÃ rt",
    "An Giblean",
    "An CÃ¨itean",
    "An t-Ãgmhios",
    "An t-Iuchar",
    "An LÃ¹nastal",
    "An t-Sultain",
    "An DÃ mhair",
    "An t-Samhain",
    "An DÃ¹bhlachd",
  ],
};

const dayValues$S = {
  narrow: ["D", "L", "M", "C", "A", "H", "S"],
  short: ["DÃ²", "Lu", "MÃ ", "Ci", "Ar", "Ha", "Sa"],
  abbreviated: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
  wide: [
    "DidÃ²mhnaich",
    "Diluain",
    "DimÃ irt",
    "Diciadain",
    "Diardaoin",
    "Dihaoine",
    "Disathairne",
  ],
};

const dayPeriodValues$S = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche",
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan lÃ ",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche",
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan lÃ ",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche",
  },
};

const formattingDayPeriodValues$I = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche",
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan lÃ ",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche",
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan lÃ ",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche",
  },
};

const ordinalNumber$S = (dirtyNumber) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "d";
      case 2:
        return number + "na";
    }
  }

  if (rem100 === 12) {
    return number + "na";
  }

  return number + "mh";
};

(localize$S.localize = {
  ordinalNumber: ordinalNumber$S,

  era: (0, _index$7t.buildLocalizeFn)({
    values: eraValues$S,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7t.buildLocalizeFn)({
    values: quarterValues$S,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7t.buildLocalizeFn)({
    values: monthValues$S,
    defaultWidth: "wide",
  }),

  day: (0, _index$7t.buildLocalizeFn)({
    values: dayValues$S,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7t.buildLocalizeFn)({
    values: dayPeriodValues$S,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$I,
    defaultFormattingWidth: "wide",
  }),
});

var match$S = {};

match$S.match = void 0;

var _index$7s = buildMatchFn$1;
var _index2$3h = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$S = /^(\d+)(d|na|tr|mh)?/i;
const parseOrdinalNumberPattern$S = /\d+/i;

const matchEraPatterns$S = {
  narrow: /^(r|a)/i,
  abbreviated: /^(r\.?\s?c\.?|r\.?\s?a\.?\s?c\.?|a\.?\s?d\.?|a\.?\s?c\.?)/i,
  wide: /^(ro ChrÃ¬osta|ron aois choitchinn|anno domini|aois choitcheann)/i,
};
const parseEraPatterns$S = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns$S = {
  narrow: /^[1234]/i,
  abbreviated: /^c[1234]/i,
  wide: /^[1234](cd|na|tr|mh)? cairteal/i,
};
const parseQuarterPatterns$S = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$S = {
  narrow: /^[fgmcÃ²ilsd]/i,
  abbreviated: /^(faoi|gear|mÃ rt|gibl|cÃ¨it|Ã²gmh|iuch|lÃ¹n|sult|dÃ mh|samh|dÃ¹bh)/i,
  wide: /^(am faoilleach|an gearran|am mÃ rt|an giblean|an cÃ¨itean|an t-Ãgmhios|an t-Iuchar|an lÃ¹nastal|an t-Sultain|an dÃ mhair|an t-Samhain|an dÃ¹bhlachd)/i,
};
const parseMonthPatterns$S = {
  narrow: [
    /^f/i,
    /^g/i,
    /^m/i,
    /^g/i,
    /^c/i,
    /^Ã²/i,
    /^i/i,
    /^l/i,
    /^s/i,
    /^d/i,
    /^s/i,
    /^d/i,
  ],

  any: [
    /^fa/i,
    /^ge/i,
    /^mÃ /i,
    /^gi/i,
    /^c/i,
    /^Ã²/i,
    /^i/i,
    /^l/i,
    /^su/i,
    /^d/i,
    /^sa/i,
    /^d/i,
  ],
};

const matchDayPatterns$S = {
  narrow: /^[dlmcahs]/i,
  short: /^(dÃ²|lu|mÃ |ci|ar|ha|sa)/i,
  abbreviated: /^(did|dil|dim|dic|dia|dih|dis)/i,
  wide: /^(didÃ²mhnaich|diluain|dimÃ irt|diciadain|diardaoin|dihaoine|disathairne)/i,
};
const parseDayPatterns$S = {
  narrow: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i],
  any: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i],
};

const matchDayPeriodPatterns$S = {
  narrow: /^(a|p|mi|n|(san|aig) (madainn|feasgar|feasgar|oidhche))/i,
  any: /^([ap]\.?\s?m\.?|meadhan oidhche|meadhan lÃ |(san|aig) (madainn|feasgar|feasgar|oidhche))/i,
};
const parseDayPeriodPatterns$S = {
  any: {
    am: /^m/i,
    pm: /^f/i,
    midnight: /^meadhan oidhche/i,
    noon: /^meadhan lÃ /i,
    morning: /sa mhadainn/i,
    afternoon: /feasgar/i,
    evening: /feasgar/i,
    night: /air an oidhche/i,
  },
};

(match$S.match = {
  ordinalNumber: (0, _index2$3h.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$S,
    parsePattern: parseOrdinalNumberPattern$S,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7s.buildMatchFn)({
    matchPatterns: matchEraPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$S,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7s.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$S,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7s.buildMatchFn)({
    matchPatterns: matchMonthPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$S,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7s.buildMatchFn)({
    matchPatterns: matchDayPatterns$S,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$S,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7s.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$S,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$S,
    defaultParseWidth: "any",
  }),
});

gd.gd = void 0;
var _index$7r = formatDistance$1L;
var _index2$3g = formatLong$T;
var _index3$1G = formatRelative$1L;
var _index4$19 = localize$S;
var _index5$10 = match$S;

/**
 * @category Locales
 * @summary Scottish Gaelic.
 * @language Scottish Gaelic
 * @iso-639-2 gla
 * @author Lee Driscoll [@leedriscoll](https://github.com/leedriscoll)
 */
(gd.gd = {
  code: "gd",
  formatDistance: _index$7r.formatDistance,
  formatLong: _index2$3g.formatLong,
  formatRelative: _index3$1G.formatRelative,
  localize: _index4$19.localize,
  match: _index5$10.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var gl = {};

var formatDistance$1J = {};

formatDistance$1J.formatDistance = void 0;

const formatDistanceLocale$Q = {
  lessThanXSeconds: {
    one: "menos dun segundo",
    other: "menos de {{count}} segundos",
  },

  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos",
  },

  halfAMinute: "medio minuto",

  lessThanXMinutes: {
    one: "menos dun minuto",
    other: "menos de {{count}} minutos",
  },

  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos",
  },

  aboutXHours: {
    one: "arredor dunha hora",
    other: "arredor de {{count}} horas",
  },

  xHours: {
    one: "1 hora",
    other: "{{count}} horas",
  },

  xDays: {
    one: "1 dÃ­a",
    other: "{{count}} dÃ­as",
  },

  aboutXWeeks: {
    one: "arredor dunha semana",
    other: "arredor de {{count}} semanas",
  },

  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas",
  },

  aboutXMonths: {
    one: "arredor de 1 mes",
    other: "arredor de {{count}} meses",
  },

  xMonths: {
    one: "1 mes",
    other: "{{count}} meses",
  },

  aboutXYears: {
    one: "arredor dun ano",
    other: "arredor de {{count}} anos",
  },

  xYears: {
    one: "1 ano",
    other: "{{count}} anos",
  },

  overXYears: {
    one: "mÃ¡is dun ano",
    other: "mÃ¡is de {{count}} anos",
  },

  almostXYears: {
    one: "case un ano",
    other: "case {{count}} anos",
  },
};

const formatDistance$1I = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$Q[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hai " + result;
    }
  }

  return result;
};
formatDistance$1J.formatDistance = formatDistance$1I;

var formatLong$S = {};

formatLong$S.formatLong = void 0;
var _index$7q = buildFormatLongFn$1;

const dateFormats$S = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$S = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$S = {
  full: "{{date}} 'Ã¡s' {{time}}",
  long: "{{date}} 'Ã¡s' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$S.formatLong = {
  date: (0, _index$7q.buildFormatLongFn)({
    formats: dateFormats$S,
    defaultWidth: "full",
  }),

  time: (0, _index$7q.buildFormatLongFn)({
    formats: timeFormats$S,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7q.buildFormatLongFn)({
    formats: dateTimeFormats$S,
    defaultWidth: "full",
  }),
});

var formatRelative$1J = {};

formatRelative$1J.formatRelative = void 0;

const formatRelativeLocale$R = {
  lastWeek: "'o' eeee 'pasado Ã¡' LT",
  yesterday: "'onte Ã¡' p",
  today: "'hoxe Ã¡' p",
  tomorrow: "'maÃ±Ã¡ Ã¡' p",
  nextWeek: "eeee 'Ã¡' p",
  other: "P",
};

const formatRelativeLocalePlural = {
  lastWeek: "'o' eeee 'pasado Ã¡s' p",
  yesterday: "'onte Ã¡s' p",
  today: "'hoxe Ã¡s' p",
  tomorrow: "'maÃ±Ã¡ Ã¡s' p",
  nextWeek: "eeee 'Ã¡s' p",
  other: "P",
};

const formatRelative$1I = (token, date, _baseDate, _options) => {
  if (date.getHours() !== 1) {
    return formatRelativeLocalePlural[token];
  }
  return formatRelativeLocale$R[token];
};
formatRelative$1J.formatRelative = formatRelative$1I;

var localize$R = {};

localize$R.localize = void 0;
var _index$7p = buildLocalizeFn$1;

const eraValues$R = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despois de cristo"],
};

const quarterValues$R = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1Âº trimestre", "2Âº trimestre", "3Âº trimestre", "4Âº trimestre"],
};

const monthValues$R = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "xan",
    "feb",
    "mar",
    "abr",
    "mai",
    "xun",
    "xul",
    "ago",
    "set",
    "out",
    "nov",
    "dec",
  ],

  wide: [
    "xaneiro",
    "febreiro",
    "marzo",
    "abril",
    "maio",
    "xuÃ±o",
    "xullo",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "decembro",
  ],
};

const dayValues$R = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "me", "xo", "ve", "sa"],
  abbreviated: ["dom", "lun", "mar", "mer", "xov", "ven", "sab"],
  wide: ["domingo", "luns", "martes", "mÃ©rcores", "xoves", "venres", "sÃ¡bado"],
};

const dayPeriodValues$R = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "maÃ±Ã¡",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "mediodÃ­a",
    morning: "maÃ±Ã¡",
    afternoon: "tarde",
    evening: "tardiÃ±a",
    night: "noite",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "mediodÃ­a",
    morning: "maÃ±Ã¡",
    afternoon: "tarde",
    evening: "tardiÃ±a",
    night: "noite",
  },
};

const formattingDayPeriodValues$H = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da maÃ±Ã¡",
    afternoon: "da tarde",
    evening: "da tardiÃ±a",
    night: "da noite",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "mediodÃ­a",
    morning: "da maÃ±Ã¡",
    afternoon: "da tarde",
    evening: "da tardiÃ±a",
    night: "da noite",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "mediodÃ­a",
    morning: "da maÃ±Ã¡",
    afternoon: "da tarde",
    evening: "da tardiÃ±a",
    night: "da noite",
  },
};

const ordinalNumber$R = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "Âº";
};

(localize$R.localize = {
  ordinalNumber: ordinalNumber$R,

  era: (0, _index$7p.buildLocalizeFn)({
    values: eraValues$R,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7p.buildLocalizeFn)({
    values: quarterValues$R,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7p.buildLocalizeFn)({
    values: monthValues$R,
    defaultWidth: "wide",
  }),

  day: (0, _index$7p.buildLocalizeFn)({
    values: dayValues$R,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7p.buildLocalizeFn)({
    values: dayPeriodValues$R,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$H,
    defaultFormattingWidth: "wide",
  }),
});

var match$R = {};

match$R.match = void 0;

var _index$7o = buildMatchFn$1;
var _index2$3f = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$R = /^(\d+)(Âº)?/i;
const parseOrdinalNumberPattern$R = /\d+/i;

const matchEraPatterns$R = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era com[uÃº]n|despois de cristo|era com[uÃº]n)/i,
};
const parseEraPatterns$R = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era com[uÃº]n)/i,
    /^(despois de cristo|era com[uÃº]n)/i,
  ],
};

const matchQuarterPatterns$R = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](Âº)? trimestre/i,
};
const parseQuarterPatterns$R = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$R = {
  narrow: /^[xfmasond]/i,
  abbreviated: /^(xan|feb|mar|abr|mai|xun|xul|ago|set|out|nov|dec)/i,
  wide: /^(xaneiro|febreiro|marzo|abril|maio|xuÃ±o|xullo|agosto|setembro|outubro|novembro|decembro)/i,
};
const parseMonthPatterns$R = {
  narrow: [
    /^x/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^x/i,
    /^x/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^xan/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^xun/i,
    /^xul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dec/i,
  ],
};

const matchDayPatterns$R = {
  narrow: /^[dlmxvs]/i,
  short: /^(do|lu|ma|me|xo|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|xov|ven|sab)/i,
  wide: /^(domingo|luns|martes|m[eÃ©]rcores|xoves|venres|s[Ã¡a]bado)/i,
};
const parseDayPatterns$R = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^x/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^me/i, /^xo/i, /^ve/i, /^sa/i],
};

const matchDayPeriodPatterns$R = {
  narrow: /^(a|p|mn|md|(da|[aÃ¡]s) (maÃ±[aÃ¡]|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|medianoite|mediod[iÃ­]a|(da|[aÃ¡]s) (maÃ±[aÃ¡]|tarde|noite))/i,
};
const parseDayPeriodPatterns$R = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /maÃ±[aÃ¡]/i,
    afternoon: /tarde/i,
    evening: /tardiÃ±a/i,
    night: /noite/i,
  },
};

(match$R.match = {
  ordinalNumber: (0, _index2$3f.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$R,
    parsePattern: parseOrdinalNumberPattern$R,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7o.buildMatchFn)({
    matchPatterns: matchEraPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$R,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7o.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$R,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7o.buildMatchFn)({
    matchPatterns: matchMonthPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$R,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7o.buildMatchFn)({
    matchPatterns: matchDayPatterns$R,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$R,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7o.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$R,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$R,
    defaultParseWidth: "any",
  }),
});

gl.gl = void 0;
var _index$7n = formatDistance$1J;
var _index2$3e = formatLong$S;
var _index3$1F = formatRelative$1J;
var _index4$18 = localize$R;
var _index5$$ = match$R;

/**
 * @category Locales
 * @summary Galician locale.
 * @language Galician
 * @iso-639-2 glg
 * @author Alberto Doval - Cocodin Technology[@cocodinTech](https://github.com/cocodinTech)
 * @author Fidel Pita [@fidelpita](https://github.com/fidelpita)
 */
(gl.gl = {
  code: "gl",
  formatDistance: _index$7n.formatDistance,
  formatLong: _index2$3e.formatLong,
  formatRelative: _index3$1F.formatRelative,
  localize: _index4$18.localize,
  match: _index5$$.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var gu = {};

var formatDistance$1H = {};

formatDistance$1H.formatDistance = void 0;

// Source: https://www.unicode.org/cldr/charts/32/summary/gu.html
const formatDistanceLocale$P = {
  lessThanXSeconds: {
    one: "àª¹àª®àª£àª¾àª", // CLDR #1461
    other: "âàªàª¶àª°à« {{count}} àª¸à«àªàªàª¡",
  },

  xSeconds: {
    one: "1 àª¸à«àªàªàª¡",
    other: "{{count}} àª¸à«àªàªàª¡",
  },

  halfAMinute: "àªàª¡àª§à« àª®àª¿àª¨àª¿àª",

  lessThanXMinutes: {
    one: "àª àª®àª¿àª¨àª¿àª", // CLDR #1448
    other: "âàªàª¶àª°à« {{count}} àª®àª¿àª¨àª¿àª",
  },

  xMinutes: {
    one: "1 àª®àª¿àª¨àª¿àª",
    other: "{{count}} àª®àª¿àª¨àª¿àª",
  },

  aboutXHours: {
    one: "âàªàª¶àª°à« 1 àªàª²àª¾àª",
    other: "âàªàª¶àª°à« {{count}} àªàª²àª¾àª",
  },

  xHours: {
    one: "1 àªàª²àª¾àª",
    other: "{{count}} àªàª²àª¾àª",
  },

  xDays: {
    one: "1 àª¦àª¿àªµàª¸",
    other: "{{count}} àª¦àª¿àªµàª¸",
  },

  aboutXWeeks: {
    one: "àªàª¶àª°à« 1 àªàª àªµàª¾àª¡àª¿àª¯à«àª",
    other: "àªàª¶àª°à« {{count}} àªàª àªµàª¾àª¡àª¿àª¯àª¾",
  },

  xWeeks: {
    one: "1 àªàª àªµàª¾àª¡àª¿àª¯à«àª",
    other: "{{count}} àªàª àªµàª¾àª¡àª¿àª¯àª¾",
  },

  aboutXMonths: {
    one: "àªàª¶àª°à« 1 àª®àª¹àª¿àª¨à«",
    other: "àªàª¶àª°à« {{count}} àª®àª¹àª¿àª¨àª¾",
  },

  xMonths: {
    one: "1 àª®àª¹àª¿àª¨à«",
    other: "{{count}} àª®àª¹àª¿àª¨àª¾",
  },

  aboutXYears: {
    one: "àªàª¶àª°à« 1 àªµàª°à«àª·",
    other: "àªàª¶àª°à« {{count}} àªµàª°à«àª·",
  },

  xYears: {
    one: "1 àªµàª°à«àª·",
    other: "{{count}} àªµàª°à«àª·",
  },

  overXYears: {
    one: "1 àªµàª°à«àª·àª¥à« àªµàª§à«",
    other: "{{count}} àªµàª°à«àª·àª¥à« àªµàª§à«",
  },

  almostXYears: {
    one: "àª²àªàª­àª 1 àªµàª°à«àª·",
    other: "àª²àªàª­àª {{count}} àªµàª°à«àª·",
  },
};

const formatDistance$1G = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$P[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "àª®àª¾àª";
    } else {
      return result + " àªªàª¹à«àª²àª¾àª";
    }
  }

  return result;
};
formatDistance$1H.formatDistance = formatDistance$1G;

var formatLong$R = {};

formatLong$R.formatLong = void 0;
var _index$7m = buildFormatLongFn$1;

//Source: https://www.unicode.org/cldr/charts/32/summary/gu.html
const dateFormats$R = {
  full: "EEEE, d MMMM, y", // CLDR #1825
  long: "d MMMM, y", // CLDR #1826
  medium: "d MMM, y", // CLDR #1827
  short: "d/M/yy", // CLDR #1828
};

const timeFormats$R = {
  full: "hh:mm:ss a zzzz", // CLDR #1829
  long: "hh:mm:ss a z", // CLDR #1830
  medium: "hh:mm:ss a", // CLDR #1831
  short: "hh:mm a", // CLDR #1832
};

const dateTimeFormats$R = {
  full: "{{date}} {{time}}", // CLDR #1833
  long: "{{date}} {{time}}", // CLDR #1834
  medium: "{{date}} {{time}}", // CLDR #1835
  short: "{{date}} {{time}}", // CLDR #1836
};

(formatLong$R.formatLong = {
  date: (0, _index$7m.buildFormatLongFn)({
    formats: dateFormats$R,
    defaultWidth: "full",
  }),

  time: (0, _index$7m.buildFormatLongFn)({
    formats: timeFormats$R,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7m.buildFormatLongFn)({
    formats: dateTimeFormats$R,
    defaultWidth: "full",
  }),
});

var formatRelative$1H = {};

formatRelative$1H.formatRelative = void 0;

// Source: https://www.unicode.org/cldr/charts/32/summary/gu.html

const formatRelativeLocale$Q = {
  lastWeek: "'àªªàª¾àªàª²àª¾' eeee p", // CLDR #1384
  yesterday: "'àªàªàªàª¾àª²à«' p", // CLDR #1409
  today: "'àªàªà«' p", // CLDR #1410
  tomorrow: "'àªàªµàª¤à«àªàª¾àª²à«' p", // CLDR #1411
  nextWeek: "eeee p", // CLDR #1386
  other: "P",
};

const formatRelative$1G = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$Q[token];
formatRelative$1H.formatRelative = formatRelative$1G;

var localize$Q = {};

localize$Q.localize = void 0;
var _index$7l = buildLocalizeFn$1;

// https://www.unicode.org/cldr/charts/32/summary/gu.html
// #1621 - #1630
const eraValues$Q = {
  narrow: ["àªàª¸àªªà«", "àªàª¸"],
  abbreviated: ["àª.àª¸.àªªà«àª°à«àªµà«", "àª.àª¸."],
  wide: ["àªàª¸àªµà«àª¸àª¨ àªªà«àª°à«àªµà«", "àªàª¸àªµà«àª¸àª¨"],
};

// https://www.unicode.org/cldr/charts/32/summary/gu.html
// #1631 - #1654
const quarterValues$Q = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1àª²à« àª¤à«àª°àª¿àª®àª¾àª¸", "2àªà« àª¤à«àª°àª¿àª®àª¾àª¸", "3àªà« àª¤à«àª°àª¿àª®àª¾àª¸", "4àª¥à« àª¤à«àª°àª¿àª®àª¾àª¸"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

// https://www.unicode.org/cldr/charts/32/summary/gu.html
// #1655 - #1726
const monthValues$Q = {
  narrow: ["àªàª¾", "àª«à«", "àª®àª¾", "àª", "àª®à«", "àªà«", "àªà«", "àª", "àª¸", "àª", "àª¨", "àª¡àª¿"],

  abbreviated: [
    "àªàª¾àª¨à«àª¯à«",
    "àª«à«àª¬à«àª°à«",
    "àª®àª¾àª°à«àª",
    "àªàªªà«àª°àª¿àª²",
    "àª®à«",
    "àªà«àª¨",
    "àªà«àª²àª¾àª",
    "àªàªàª¸à«àª",
    "àª¸àªªà«àªà«",
    "àªàªà«àªà«",
    "àª¨àªµà«",
    "àª¡àª¿àª¸à«",
  ],

  wide: [
    "àªàª¾àª¨à«àª¯à«àªàª°à«",
    "àª«à«àª¬à«àª°à«àªàª°à«",
    "àª®àª¾àª°à«àª",
    "àªàªªà«àª°àª¿àª²",
    "àª®à«",
    "àªà«àª¨",
    "àªà«àª²àª¾àª",
    "àªàªàª¸à«àª",
    "àª¸àªªà«àªà«àª®à«àª¬àª°",
    "àªàªà«àªà«àª¬àª°",
    "àª¨àªµà«àª®à«àª¬àª°",
    "àª¡àª¿àª¸à«àª®à«àª¬àª°",
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/gu.html
// #1727 - #1768
const dayValues$Q = {
  narrow: ["àª°", "àª¸à«", "àª®àª", "àª¬à«", "àªà«", "àª¶à«", "àª¶"],
  short: ["àª°", "àª¸à«", "àª®àª", "àª¬à«", "àªà«", "àª¶à«", "àª¶"],
  abbreviated: ["àª°àªµàª¿", "àª¸à«àª®", "àª®àªàªàª³", "àª¬à«àª§", "àªà«àª°à«", "àª¶à«àªà«àª°", "àª¶àª¨àª¿"],
  wide: [
    "àª°àªµàª¿àªµàª¾àª°" /* Sunday */,
    "àª¸à«àª®àªµàª¾àª°" /* Monday */,
    "àª®àªàªàª³àªµàª¾àª°" /* Tuesday */,
    "àª¬à«àª§àªµàª¾àª°" /* Wednesday */,
    "àªà«àª°à«àªµàª¾àª°" /* Thursday */,
    "àª¶à«àªà«àª°àªµàª¾àª°" /* Friday */,
    "àª¶àª¨àª¿àªµàª¾àª°" /* Saturday */,
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/gu.html
// #1783 - #1824
const dayPeriodValues$Q = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "àª®.àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬.",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "âàª®àª§à«àª¯àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬àªªà«àª°à«",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "âàª®àª§à«àª¯àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬àªªà«àª°à«",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
};

const formattingDayPeriodValues$G = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "àª®.àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬àªªà«àª°à«",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "àª®àª§à«àª¯àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬àªªà«àª°à«",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "âàª®àª§à«àª¯àª°àª¾àª¤à«àª°àª¿",
    noon: "àª¬àªªà«àª°à«",
    morning: "àª¸àªµàª¾àª°à«",
    afternoon: "àª¬àªªà«àª°à«",
    evening: "àª¸àª¾àªàªà«",
    night: "àª°àª¾àª¤à«àª°à«",
  },
};

const ordinalNumber$Q = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$Q.localize = {
  ordinalNumber: ordinalNumber$Q,

  era: (0, _index$7l.buildLocalizeFn)({
    values: eraValues$Q,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7l.buildLocalizeFn)({
    values: quarterValues$Q,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7l.buildLocalizeFn)({
    values: monthValues$Q,
    defaultWidth: "wide",
  }),

  day: (0, _index$7l.buildLocalizeFn)({
    values: dayValues$Q,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7l.buildLocalizeFn)({
    values: dayPeriodValues$Q,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$G,
    defaultFormattingWidth: "wide",
  }),
});

var match$Q = {};

match$Q.match = void 0;

var _index$7k = buildMatchFn$1;
var _index2$3d = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$Q = /^(\d+)(àª²|àª|àª¥|àª à«àª |àª®)?/i;
const parseOrdinalNumberPattern$Q = /\d+/i;

const matchEraPatterns$Q = {
  narrow: /^(àªàª¸àªªà«|àªàª¸)/i,
  abbreviated: /^(àª\.àª¸\.àªªà«àª°à«àªµà«|àª\.àª¸\.)/i,
  wide: /^(àªàª¸àªµà«àª¸àª¨\sàªªà«àª°à«àªµà«|àªàª¸àªµà«àª¸àª¨)/i,
};
const parseEraPatterns$Q = {
  any: [/^àªàª¸àªªà«/i, /^àªàª¸/i],
};

const matchQuarterPatterns$Q = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](àª²à«|àªà«|àª¥à«)? àª¤à«àª°àª¿àª®àª¾àª¸/i,
};
const parseQuarterPatterns$Q = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$Q = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[àªàª¾àª«à«àª®àª¾àªàª®à«àªà«àªà«àªàª¸àªàª¨àª¡àª¿]/i,
  abbreviated:
    /^(àªàª¾àª¨à«àª¯à«|àª«à«àª¬à«àª°à«|àª®àª¾àª°à«àª|àªàªªà«àª°àª¿àª²|àª®à«|àªà«àª¨|àªà«àª²àª¾àª|àªàªàª¸à«àª|àª¸àªªà«àªà«|àªàªà«àªà«|àª¨àªµà«|àª¡àª¿àª¸à«)/i,
  wide: /^(àªàª¾àª¨à«àª¯à«àªàª°à«|àª«à«àª¬à«àª°à«àªàª°à«|àª®àª¾àª°à«àª|àªàªªà«àª°àª¿àª²|àª®à«|àªà«àª¨|àªà«àª²àª¾àª|àªàªàª¸à«àª|àª¸àªªà«àªà«àª®à«àª¬àª°|àªàªà«àªà«àª¬àª°|àª¨àªµà«àª®à«àª¬àª°|àª¡àª¿àª¸à«àª®à«àª¬àª°)/i,
};
const parseMonthPatterns$Q = {
  narrow: [
    /^àªàª¾/i,
    /^àª«à«/i,
    /^àª®àª¾/i,
    /^àª/i,
    /^àª®à«/i,
    /^àªà«/i,
    /^àªà«/i,
    /^àªàª/i,
    /^àª¸/i,
    /^àªàªà«àªà«/i,
    /^àª¨/i,
    /^àª¡àª¿/i,
  ],

  any: [
    /^àªàª¾/i,
    /^àª«à«/i,
    /^àª®àª¾/i,
    /^àª/i,
    /^àª®à«/i,
    /^àªà«/i,
    /^àªà«/i,
    /^àªàª/i,
    /^àª¸/i,
    /^àªàªà«àªà«/i,
    /^àª¨/i,
    /^àª¡àª¿/i,
  ],
};

const matchDayPatterns$Q = {
  narrow: /^(àª°|àª¸à«|àª®àª|àª¬à«|àªà«|àª¶à«|àª¶)/i,
  short: /^(àª°|àª¸à«|àª®àª|àª¬à«|àªà«|àª¶à«|àª¶)/i,
  abbreviated: /^(àª°àªµàª¿|àª¸à«àª®|àª®àªàªàª³|àª¬à«àª§|àªà«àª°à«|àª¶à«àªà«àª°|àª¶àª¨àª¿)/i,
  wide: /^(àª°àªµàª¿àªµàª¾àª°|àª¸à«àª®àªµàª¾àª°|àª®àªàªàª³àªµàª¾àª°|àª¬à«àª§àªµàª¾àª°|àªà«àª°à«àªµàª¾àª°|àª¶à«àªà«àª°àªµàª¾àª°|àª¶àª¨àª¿àªµàª¾àª°)/i,
};
const parseDayPatterns$Q = {
  narrow: [/^àª°/i, /^àª¸à«/i, /^àª®àª/i, /^àª¬à«/i, /^àªà«/i, /^àª¶à«/i, /^àª¶/i],
  any: [/^àª°/i, /^àª¸à«/i, /^àª®àª/i, /^àª¬à«/i, /^àªà«/i, /^àª¶à«/i, /^àª¶/i],
};

const matchDayPeriodPatterns$Q = {
  narrow: /^(a|p|àª®\.?|àª¸|àª¬|àª¸àª¾àª|àª°àª¾)/i,
  any: /^(a|p|àª®\.?|àª¸|àª¬|àª¸àª¾àª|àª°àª¾)/i,
};
const parseDayPeriodPatterns$Q = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^àª®\.?/i,
    noon: /^àª¬/i,
    morning: /àª¸/i,
    afternoon: /àª¬/i,
    evening: /àª¸àª¾àª/i,
    night: /àª°àª¾/i,
  },
};

(match$Q.match = {
  ordinalNumber: (0, _index2$3d.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$Q,
    parsePattern: parseOrdinalNumberPattern$Q,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$7k.buildMatchFn)({
    matchPatterns: matchEraPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$Q,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7k.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$Q,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7k.buildMatchFn)({
    matchPatterns: matchMonthPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$Q,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7k.buildMatchFn)({
    matchPatterns: matchDayPatterns$Q,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$Q,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7k.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$Q,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$Q,
    defaultParseWidth: "any",
  }),
});

gu.gu = void 0;
var _index$7j = formatDistance$1H;
var _index2$3c = formatLong$R;
var _index3$1E = formatRelative$1H;
var _index4$17 = localize$Q;
var _index5$_ = match$Q;

/**
 * @category Locales
 * @summary Gujarati locale (India).
 * @language Gujarati
 * @iso-639-2 guj
 * @author Manaday Mavani [@ManadayM](https://github.com/manadaym)
 */
(gu.gu = {
  code: "gu",
  formatDistance: _index$7j.formatDistance,
  formatLong: _index2$3c.formatLong,
  formatRelative: _index3$1E.formatRelative,
  localize: _index4$17.localize,
  match: _index5$_.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var he = {};

var formatDistance$1F = {};

formatDistance$1F.formatDistance = void 0;

const formatDistanceLocale$O = {
  lessThanXSeconds: {
    one: "×¤×××ª ××©× ×××",
    two: "×¤×××ª ××©×ª× ×©× ×××ª",
    other: "×¤×××ª ×Ö¾{{count}} ×©× ×××ª",
  },

  xSeconds: {
    one: "×©× ×××",
    two: "×©×ª× ×©× ×××ª",
    other: "{{count}} ×©× ×××ª",
  },

  halfAMinute: "××¦× ××§×",

  lessThanXMinutes: {
    one: "×¤×××ª ×××§×",
    two: "×¤×××ª ××©×ª× ××§××ª",
    other: "×¤×××ª ×Ö¾{{count}} ××§××ª",
  },

  xMinutes: {
    one: "××§×",
    two: "×©×ª× ××§××ª",
    other: "{{count}} ××§××ª",
  },

  aboutXHours: {
    one: "××©×¢×",
    two: "××©×¢×ª×××",
    other: "×Ö¾{{count}} ×©×¢××ª",
  },

  xHours: {
    one: "×©×¢×",
    two: "×©×¢×ª×××",
    other: "{{count}} ×©×¢××ª",
  },

  xDays: {
    one: "×××",
    two: "××××××",
    other: "{{count}} ××××",
  },

  aboutXWeeks: {
    one: "××©×××¢",
    two: "××©×××¢×××",
    other: "×Ö¾{{count}} ×©×××¢××ª",
  },

  xWeeks: {
    one: "×©×××¢",
    two: "×©×××¢×××",
    other: "{{count}} ×©×××¢××ª",
  },

  aboutXMonths: {
    one: "×××××©",
    two: "×××××©×××",
    other: "×Ö¾{{count}} ××××©××",
  },

  xMonths: {
    one: "××××©",
    two: "××××©×××",
    other: "{{count}} ××××©××",
  },

  aboutXYears: {
    one: "××©× ×",
    two: "××©× ×ª×××",
    other: "×Ö¾{{count}} ×©× ××",
  },

  xYears: {
    one: "×©× ×",
    two: "×©× ×ª×××",
    other: "{{count}} ×©× ××",
  },

  overXYears: {
    one: "×××ª×¨ ××©× ×",
    two: "×××ª×¨ ××©× ×ª×××",
    other: "×××ª×¨ ×Ö¾{{count}} ×©× ××",
  },

  almostXYears: {
    one: "×××¢× ×©× ×",
    two: "×××¢× ×©× ×ª×××",
    other: "×××¢× {{count}} ×©× ××",
  },
};

const formatDistance$1E = (token, count, options) => {
  // Return word instead of `in one day` or `one day ago`
  if (token === "xDays" && options?.addSuffix && count <= 2) {
    if (options.comparison && options.comparison > 0) {
      return count === 1 ? "×××¨" : "×××¨×ª×××";
    }

    return count === 1 ? "××ª×××" : "×©××©××";
  }

  let result;

  const tokenValue = formatDistanceLocale$O[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "××¢×× " + result;
    } else {
      return "××¤× × " + result;
    }
  }

  return result;
};
formatDistance$1F.formatDistance = formatDistance$1E;

var formatLong$Q = {};

formatLong$Q.formatLong = void 0;
var _index$7i = buildFormatLongFn$1;

const dateFormats$Q = {
  full: "EEEE, d ×MMMM y",
  long: "d ×MMMM y",
  medium: "d ×MMM y",
  short: "d.M.y",
};

const timeFormats$Q = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$Q = {
  full: "{{date}} '××©×¢×' {{time}}",
  long: "{{date}} '××©×¢×' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$Q.formatLong = {
  date: (0, _index$7i.buildFormatLongFn)({
    formats: dateFormats$Q,
    defaultWidth: "full",
  }),

  time: (0, _index$7i.buildFormatLongFn)({
    formats: timeFormats$Q,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7i.buildFormatLongFn)({
    formats: dateTimeFormats$Q,
    defaultWidth: "full",
  }),
});

var formatRelative$1F = {};

formatRelative$1F.formatRelative = void 0;

const formatRelativeLocale$P = {
  lastWeek: "eeee '×©×¢××¨ ××©×¢×' p",
  yesterday: "'××ª××× ××©×¢×' p",
  today: "'×××× ××©×¢×' p",
  tomorrow: "'×××¨ ××©×¢×' p",
  nextWeek: "eeee '××©×¢×' p",
  other: "P",
};

const formatRelative$1E = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$P[token];
formatRelative$1F.formatRelative = formatRelative$1E;

var localize$P = {};

localize$P.localize = void 0;
var _index$7h = buildLocalizeFn$1;

const eraValues$P = {
  narrow: ["××¤× ××´×¡", "××¡×¤××¨×"],
  abbreviated: ["××¤× ××´×¡", "××¡×¤××¨×"],
  wide: ["××¤× × ××¡×¤××¨×", "××¡×¤××¨×"],
};

const quarterValues$P = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["×¨××¢×× 1", "×¨××¢×× 2", "×¨××¢×× 3", "×¨××¢×× 4"],
};

const monthValues$P = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],

  abbreviated: [
    "×× ××³",
    "×¤××¨×³",
    "××¨×¥",
    "××¤×¨×³",
    "×××",
    "××× ×",
    "××××",
    "××××³",
    "×¡×¤××³",
    "×××§×³",
    "× ×××³",
    "××¦××³",
  ],

  wide: [
    "×× ×××¨",
    "×¤××¨×××¨",
    "××¨×¥",
    "××¤×¨××",
    "×××",
    "××× ×",
    "××××",
    "×××××¡×",
    "×¡×¤××××¨",
    "×××§××××¨",
    "× ×××××¨",
    "××¦×××¨",
  ],
};

const dayValues$P = {
  narrow: ["××³", "××³", "××³", "××³", "××³", "××³", "×©×³"],
  short: ["××³", "××³", "××³", "××³", "××³", "××³", "×©×³"],
  abbreviated: [
    "××× ××³",
    "××× ××³",
    "××× ××³",
    "××× ××³",
    "××× ××³",
    "××× ××³",
    "×©××ª",
  ],

  wide: [
    "××× ×¨××©××",
    "××× ×©× ×",
    "××× ×©×××©×",
    "××× ×¨×××¢×",
    "××× ××××©×",
    "××× ×©××©×",
    "××× ×©××ª",
  ],
};

const dayPeriodValues$P = {
  narrow: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "×××§×¨",
    afternoon: "×××¨ ××¦××¨×××",
    evening: "×¢×¨×",
    night: "××××",
  },
  abbreviated: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "×××§×¨",
    afternoon: "×××¨ ××¦××¨×××",
    evening: "×¢×¨×",
    night: "××××",
  },
  wide: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "×××§×¨",
    afternoon: "×××¨ ××¦××¨×××",
    evening: "×¢×¨×",
    night: "××××",
  },
};

const formattingDayPeriodValues$F = {
  narrow: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "××××§×¨",
    afternoon: "××¦××¨×××",
    evening: "××¢×¨×",
    night: "×××××",
  },
  abbreviated: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "××××§×¨",
    afternoon: "×××¨ ××¦××¨×××",
    evening: "××¢×¨×",
    night: "×××××",
  },
  wide: {
    am: "××¤× ××´×¦",
    pm: "××××´×¦",
    midnight: "××¦××ª",
    noon: "×¦××¨×××",
    morning: "××××§×¨",
    afternoon: "×××¨ ××¦××¨×××",
    evening: "××¢×¨×",
    night: "×××××",
  },
};

const ordinalNumber$P = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  // We only show words till 10
  if (number <= 0 || number > 10) return String(number);

  const unit = String(options?.unit);

  const isFemale = ["year", "hour", "minute", "second"].indexOf(unit) >= 0;

  const male = [
    "×¨××©××",
    "×©× ×",
    "×©×××©×",
    "×¨×××¢×",
    "××××©×",
    "×©××©×",
    "×©×××¢×",
    "×©××× ×",
    "×ª×©××¢×",
    "×¢×©××¨×",
  ];

  const female = [
    "×¨××©×× ×",
    "×©× ×××",
    "×©×××©××ª",
    "×¨×××¢××ª",
    "××××©××ª",
    "×©××©××ª",
    "×©×××¢××ª",
    "×©××× ××ª",
    "×ª×©××¢××ª",
    "×¢×©××¨××ª",
  ];

  const index = number - 1;
  return isFemale ? female[index] : male[index];
};

(localize$P.localize = {
  ordinalNumber: ordinalNumber$P,

  era: (0, _index$7h.buildLocalizeFn)({
    values: eraValues$P,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7h.buildLocalizeFn)({
    values: quarterValues$P,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7h.buildLocalizeFn)({
    values: monthValues$P,
    defaultWidth: "wide",
  }),

  day: (0, _index$7h.buildLocalizeFn)({
    values: dayValues$P,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7h.buildLocalizeFn)({
    values: dayPeriodValues$P,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$F,
    defaultFormattingWidth: "wide",
  }),
});

var match$P = {};

match$P.match = void 0;

var _index$7g = buildMatchFn$1;
var _index2$3b = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$P =
  /^(\d+|(×¨××©××|×©× ×|×©×××©×|×¨×××¢×|××××©×|×©××©×|×©×××¢×|×©××× ×|×ª×©××¢×|×¢×©××¨×|×¨××©×× ×|×©× ×××|×©×××©××ª|×¨×××¢××ª|××××©××ª|×©××©××ª|×©×××¢××ª|×©××× ××ª|×ª×©××¢××ª|×¢×©××¨××ª))/i;
const parseOrdinalNumberPattern$P = /^(\d+|×¨×|×©× |×©×|×¨×|×|×©×|×©×|×©×|×ª|×¢)/i;

const matchEraPatterns$P = {
  narrow: /^×(×¡×¤××¨×|×¤× ××´×¡)/i,
  abbreviated: /^×(×¡×¤××¨×|×¤× ××´×¡)/i,
  wide: /^×(×¤× × ×)?×¡×¤××¨×/i,
};
const parseEraPatterns$P = {
  any: [/^××¤/i, /^××¡/i],
};

const matchQuarterPatterns$P = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^×¨××¢×× [1234]/i,
};
const parseQuarterPatterns$P = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$P = {
  narrow: /^\d+/i,
  abbreviated: /^(×× ×|×¤××¨|××¨×¥|××¤×¨|×××|××× ×|××××|×××|×¡×¤×|×××§|× ××|××¦×)×³?/i,
  wide: /^(×× ×××¨|×¤××¨×××¨|××¨×¥|××¤×¨××|×××|××× ×|××××|×××××¡×|×¡×¤××××¨|×××§××××¨|× ×××××¨|××¦×××¨)/i,
};
const parseMonthPatterns$P = {
  narrow: [
    /^1$/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i,
  ],

  any: [
    /^×× /i,
    /^×¤/i,
    /^××¨/i,
    /^××¤/i,
    /^××/i,
    /^××× /i,
    /^×××/i,
    /^×××/i,
    /^×¡/i,
    /^×××§/i,
    /^× /i,
    /^×/i,
  ],
};

const matchDayPatterns$P = {
  narrow: /^[×××××××©]×³/i,
  short: /^[×××××××©]×³/i,
  abbreviated: /^(×©××ª|××× (×|×|×|×|×|×)×³)/i,
  wide: /^××× (×¨××©××|×©× ×|×©×××©×|×¨×××¢×|××××©×|×©××©×|×©××ª)/i,
};
const parseDayPatterns$P = {
  abbreviated: [/××³$/i, /××³$/i, /××³$/i, /××³$/i, /××³$/i, /××³$/i, /^×©/i],
  wide: [/×$/i, /× ×$/i, /×××©×$/i, /×¢×$/i, /×××©×$/i, /×©××©×$/i, /×ª$/i],
  any: [/^×/i, /^×/i, /^×/i, /^×/i, /^×/i, /^×/i, /^×©/i],
};

const matchDayPeriodPatterns$P = {
  any: /^(×××¨ ×|×)?(××¦××ª|×¦××¨×××|×××§×¨|×¢×¨×|××××|××××´×¦|××¤× ××´×¦)/i,
};
const parseDayPeriodPatterns$P = {
  any: {
    am: /^××¤/i,
    pm: /^×××/i,
    midnight: /^×/i,
    noon: /^×¦/i,
    morning: /×××§×¨/i,
    afternoon: /××¦|×××¨/i,
    evening: /×¢×¨×/i,
    night: /××××/i,
  },
};

const ordinalName = ["×¨×", "×©× ", "×©×", "×¨×", "×", "×©×", "×©×", "×©×", "×ª", "×¢"];

(match$P.match = {
  ordinalNumber: (0, _index2$3b.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$P,
    parsePattern: parseOrdinalNumberPattern$P,
    valueCallback: (value) => {
      const number = parseInt(value, 10);
      return isNaN(number) ? ordinalName.indexOf(value) + 1 : number;
    },
  }),

  era: (0, _index$7g.buildMatchFn)({
    matchPatterns: matchEraPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$P,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7g.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$P,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7g.buildMatchFn)({
    matchPatterns: matchMonthPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$P,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7g.buildMatchFn)({
    matchPatterns: matchDayPatterns$P,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$P,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7g.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$P,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$P,
    defaultParseWidth: "any",
  }),
});

he.he = void 0;
var _index$7f = formatDistance$1F;
var _index2$3a = formatLong$Q;
var _index3$1D = formatRelative$1F;
var _index4$16 = localize$P;
var _index5$Z = match$P;

/**
 * @category Locales
 * @summary Hebrew locale.
 * @language Hebrew
 * @iso-639-2 heb
 * @author Nir Lahad [@nirlah](https://github.com/nirlah)
 */
(he.he = {
  code: "he",
  formatDistance: _index$7f.formatDistance,
  formatLong: _index2$3a.formatLong,
  formatRelative: _index3$1D.formatRelative,
  localize: _index4$16.localize,
  match: _index5$Z.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var hi = {};

var formatDistance$1D = {};

var localize$O = {};

localize$O.localeToNumber = localeToNumber;
localize$O.localize = void 0;
localize$O.numberToLocale = numberToLocale;
var _index$7e = buildLocalizeFn$1;

const numberValues = {
  locale: {
    1: "à¥§",
    2: "à¥¨",
    3: "à¥©",
    4: "à¥ª",
    5: "à¥«",
    6: "à¥¬",
    7: "à¥­",
    8: "à¥®",
    9: "à¥¯",
    0: "à¥¦",
  },
  number: {
    "à¥§": "1",
    "à¥¨": "2",
    "à¥©": "3",
    "à¥ª": "4",
    "à¥«": "5",
    "à¥¬": "6",
    "à¥­": "7",
    "à¥®": "8",
    "à¥¯": "9",
    "à¥¦": "0",
  },
};

// CLDR #1585 - #1592
const eraValues$O = {
  narrow: ["à¤à¤¸à¤¾-à¤ªà¥à¤°à¥à¤µ", "à¤à¤¸à¥à¤µà¥"],
  abbreviated: ["à¤à¤¸à¤¾-à¤ªà¥à¤°à¥à¤µ", "à¤à¤¸à¥à¤µà¥"],
  wide: ["à¤à¤¸à¤¾-à¤ªà¥à¤°à¥à¤µ", "à¤à¤¸à¤µà¥ à¤¸à¤¨"],
};

// CLDR #1593 - #1616
const quarterValues$O = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["à¤¤à¤¿1", "à¤¤à¤¿2", "à¤¤à¤¿3", "à¤¤à¤¿4"],
  wide: ["à¤ªà¤¹à¤²à¥ à¤¤à¤¿à¤®à¤¾à¤¹à¥", "à¤¦à¥à¤¸à¤°à¥ à¤¤à¤¿à¤®à¤¾à¤¹à¥", "à¤¤à¥à¤¸à¤°à¥ à¤¤à¤¿à¤®à¤¾à¤¹à¥", "à¤à¥à¤¥à¥ à¤¤à¤¿à¤®à¤¾à¤¹à¥"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
// https://www.unicode.org/cldr/charts/32/summary/hi.html
// CLDR #1617 - #1688
const monthValues$O = {
  narrow: [
    "à¤",
    "à¤«à¤¼",
    "à¤®à¤¾",
    "à¤",
    "à¤®à¤",
    "à¤à¥",
    "à¤à¥",
    "à¤à¤",
    "à¤¸à¤¿",
    "à¤à¤à¥à¤à¥",
    "à¤¨",
    "à¤¦à¤¿",
  ],

  abbreviated: [
    "à¤à¤¨",
    "à¤«à¤¼à¤°",
    "à¤®à¤¾à¤°à¥à¤",
    "à¤à¤ªà¥à¤°à¥à¤²",
    "à¤®à¤",
    "à¤à¥à¤¨",
    "à¤à¥à¤²",
    "à¤à¤",
    "à¤¸à¤¿à¤¤",
    "à¤à¤à¥à¤à¥",
    "à¤¨à¤µ",
    "à¤¦à¤¿à¤¸",
  ],

  wide: [
    "à¤à¤¨à¤µà¤°à¥",
    "à¤«à¤¼à¤°à¤µà¤°à¥",
    "à¤®à¤¾à¤°à¥à¤",
    "à¤à¤ªà¥à¤°à¥à¤²",
    "à¤®à¤",
    "à¤à¥à¤¨",
    "à¤à¥à¤²à¤¾à¤",
    "à¤à¤à¤¸à¥à¤¤",
    "à¤¸à¤¿à¤¤à¤à¤¬à¤°",
    "à¤à¤à¥à¤à¥à¤¬à¤°",
    "à¤¨à¤µà¤à¤¬à¤°",
    "à¤¦à¤¿à¤¸à¤à¤¬à¤°",
  ],
};

// CLDR #1689 - #1744
const dayValues$O = {
  narrow: ["à¤°", "à¤¸à¥", "à¤®à¤", "à¤¬à¥", "à¤à¥", "à¤¶à¥", "à¤¶"],
  short: ["à¤°", "à¤¸à¥", "à¤®à¤", "à¤¬à¥", "à¤à¥", "à¤¶à¥", "à¤¶"],
  abbreviated: ["à¤°à¤µà¤¿", "à¤¸à¥à¤®", "à¤®à¤à¤à¤²", "à¤¬à¥à¤§", "à¤à¥à¤°à¥", "à¤¶à¥à¤à¥à¤°", "à¤¶à¤¨à¤¿"],
  wide: [
    "à¤°à¤µà¤¿à¤µà¤¾à¤°",
    "à¤¸à¥à¤®à¤µà¤¾à¤°",
    "à¤®à¤à¤à¤²à¤µà¤¾à¤°",
    "à¤¬à¥à¤§à¤µà¤¾à¤°",
    "à¤à¥à¤°à¥à¤µà¤¾à¤°",
    "à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°",
    "à¤¶à¤¨à¤¿à¤µà¤¾à¤°",
  ],
};

const dayPeriodValues$O = {
  narrow: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
  abbreviated: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
  wide: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
};

const formattingDayPeriodValues$E = {
  narrow: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
  abbreviated: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
  wide: {
    am: "à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨",
    pm: "à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨",
    midnight: "à¤®à¤§à¥à¤¯à¤°à¤¾à¤¤à¥à¤°à¤¿",
    noon: "à¤¦à¥à¤ªà¤¹à¤°",
    morning: "à¤¸à¥à¤¬à¤¹",
    afternoon: "à¤¦à¥à¤ªà¤¹à¤°",
    evening: "à¤¶à¤¾à¤®",
    night: "à¤°à¤¾à¤¤",
  },
};

const ordinalNumber$O = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return numberToLocale(number);
};

function localeToNumber(locale) {
  const enNumber = locale.toString().replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function (match) {
    return numberValues.number[match];
  });
  return Number(enNumber);
}

function numberToLocale(enNumber) {
  return enNumber.toString().replace(/\d/g, function (match) {
    return numberValues.locale[match];
  });
}

(localize$O.localize = {
  ordinalNumber: ordinalNumber$O,

  era: (0, _index$7e.buildLocalizeFn)({
    values: eraValues$O,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$7e.buildLocalizeFn)({
    values: quarterValues$O,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$7e.buildLocalizeFn)({
    values: monthValues$O,
    defaultWidth: "wide",
  }),

  day: (0, _index$7e.buildLocalizeFn)({
    values: dayValues$O,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$7e.buildLocalizeFn)({
    values: dayPeriodValues$O,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$E,
    defaultFormattingWidth: "wide",
  }),
});

formatDistance$1D.formatDistance = void 0;
var _index$7d = localize$O;

// Source: https://www.unicode.org/cldr/charts/32/summary/hi.html

const formatDistanceLocale$N = {
  lessThanXSeconds: {
    one: "à¥§ à¤¸à¥à¤à¤à¤¡ à¤¸à¥ à¤à¤®", // CLDR #1310
    other: "{{count}} à¤¸à¥à¤à¤à¤¡ à¤¸à¥ à¤à¤®",
  },

  xSeconds: {
    one: "à¥§ à¤¸à¥à¤à¤à¤¡",
    other: "{{count}} à¤¸à¥à¤à¤à¤¡",
  },

  halfAMinute: "à¤à¤§à¤¾ à¤®à¤¿à¤¨à¤",

  lessThanXMinutes: {
    one: "à¥§ à¤®à¤¿à¤¨à¤ à¤¸à¥ à¤à¤®",
    other: "{{count}} à¤®à¤¿à¤¨à¤ à¤¸à¥ à¤à¤®",
  },

  xMinutes: {
    one: "à¥§ à¤®à¤¿à¤¨à¤", // CLDR #1307
    other: "{{count}} à¤®à¤¿à¤¨à¤",
  },

  aboutXHours: {
    one: "à¤²à¤à¤­à¤ à¥§ à¤à¤à¤à¤¾",
    other: "à¤²à¤à¤­à¤ {{count}} à¤à¤à¤à¥",
  },

  xHours: {
    one: "à¥§ à¤à¤à¤à¤¾", // CLDR #1304
    other: "{{count}} à¤à¤à¤à¥", // CLDR #4467
  },

  xDays: {
    one: "à¥§ à¤¦à¤¿à¤¨", // CLDR #1286
    other: "{{count}} à¤¦à¤¿à¤¨",
  },

  aboutXWeeks: {
    one: "à¤²à¤à¤­à¤ à¥§ à¤¸à¤ªà¥à¤¤à¤¾à¤¹",
    other: "à¤²à¤à¤­à¤ {{count}} à¤¸à¤ªà¥à¤¤à¤¾à¤¹",
  },

  xWeeks: {
    one: "à¥§ à¤¸à¤ªà¥à¤¤à¤¾à¤¹",
    other: "{{count}} à¤¸à¤ªà¥à¤¤à¤¾à¤¹",
  },

  aboutXMonths: {
    one: "à¤²à¤à¤­à¤ à¥§ à¤®à¤¹à¥à¤¨à¤¾",
    other: "à¤²à¤à¤­à¤ {{count}} à¤®à¤¹à¥à¤¨à¥",
  },

  xMonths: {
    one: "à¥§ à¤®à¤¹à¥à¤¨à¤¾",
    other: "{{count}} à¤®à¤¹à¥à¤¨à¥",
  },

  aboutXYears: {
    one: "à¤²à¤à¤­à¤ à¥§ à¤µà¤°à¥à¤·",
    other: "à¤²à¤à¤­à¤ {{count}} à¤µà¤°à¥à¤·", // CLDR #4823
  },

  xYears: {
    one: "à¥§ à¤µà¤°à¥à¤·",
    other: "{{count}} à¤µà¤°à¥à¤·",
  },

  overXYears: {
    one: "à¥§ à¤µà¤°à¥à¤· à¤¸à¥ à¤à¤§à¤¿à¤",
    other: "{{count}} à¤µà¤°à¥à¤· à¤¸à¥ à¤à¤§à¤¿à¤",
  },

  almostXYears: {
    one: "à¤²à¤à¤­à¤ à¥§ à¤µà¤°à¥à¤·",
    other: "à¤²à¤à¤­à¤ {{count}} à¤µà¤°à¥à¤·",
  },
};

const formatDistance$1C = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$N[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      (0, _index$7d.numberToLocale)(count),
    );
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "à¤®à¥ ";
    } else {
      return result + " à¤ªà¤¹à¤²à¥";
    }
  }

  return result;
};
formatDistance$1D.formatDistance = formatDistance$1C;

var formatLong$P = {};

formatLong$P.formatLong = void 0;
var _index$7c = buildFormatLongFn$1;

const dateFormats$P = {
  full: "EEEE, do MMMM, y", // CLDR #1787
  long: "do MMMM, y", // CLDR #1788
  medium: "d MMM, y", // CLDR #1789
  short: "dd/MM/yyyy", // CLDR #1790
};

const timeFormats$P = {
  full: "h:mm:ss a zzzz", // CLDR #1791
  long: "h:mm:ss a z", // CLDR #1792
  medium: "h:mm:ss a", // CLDR #1793
  short: "h:mm a", // CLDR #1794
};

const dateTimeFormats$P = {
  full: "{{date}} 'à¤à¥' {{time}}", // CLDR #1795
  long: "{{date}} 'à¤à¥' {{time}}", // CLDR #1796
  medium: "{{date}}, {{time}}", // CLDR #1797
  short: "{{date}}, {{time}}", // CLDR #1798
};

(formatLong$P.formatLong = {
  date: (0, _index$7c.buildFormatLongFn)({
    formats: dateFormats$P,
    defaultWidth: "full",
  }),

  time: (0, _index$7c.buildFormatLongFn)({
    formats: timeFormats$P,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$7c.buildFormatLongFn)({
    formats: dateTimeFormats$P,
    defaultWidth: "full",
  }),
});

var formatRelative$1D = {};

formatRelative$1D.formatRelative = void 0;

const formatRelativeLocale$O = {
  lastWeek: "'à¤ªà¤¿à¤à¤²à¥' eeee p",
  yesterday: "'à¤à¤²' p",
  today: "'à¤à¤' p",
  tomorrow: "'à¤à¤²' p",
  nextWeek: "eeee 'à¤à¥' p",
  other: "P",
};

const formatRelative$1C = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$O[token];
formatRelative$1D.formatRelative = formatRelative$1C;

var match$O = {};

match$O.match = void 0;

var _index$7b = buildMatchFn$1;
var _index2$39 = buildMatchPatternFn$1;
var _index3$1C = localize$O;

const matchOrdinalNumberPattern$O = /^[à¥¦à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯]+/i;
const parseOrdinalNumberPattern$O = /^[à¥¦à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯]+/i;

const matchEraPatterns$O = {
  narrow: /^(à¤à¤¸à¤¾-à¤ªà¥à¤°à¥à¤µ|à¤à¤¸à¥à¤µà¥)/i,
  abbreviated: /^(à¤à¤¸à¤¾\.?\s?à¤ªà¥à¤°à¥à¤µ\.?|à¤à¤¸à¤¾\.?)/i,
  wide: /^(à¤à¤¸à¤¾-à¤ªà¥à¤°à¥à¤µ|à¤à¤¸à¤µà¥ à¤ªà¥à¤°à¥à¤µ|à¤à¤¸à¤µà¥ à¤¸à¤¨|à¤à¤¸à¤µà¥)/i,
};

const parseEraPatterns$O = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns$O = {
  narrow: /^[1234]/i,
  abbreviated: /^à¤¤à¤¿[1234]/i,
  wide: /^[1234](à¤ªà¤¹à¤²à¥|à¤¦à¥à¤¸à¤°à¥|à¤¤à¥à¤¸à¤°à¥|à¤à¥à¤¥à¥)? à¤¤à¤¿à¤®à¤¾à¤¹à¥/i,
};
const parseQuarterPatterns$O = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$O = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[à¤à¤«à¤¼à¤®à¤¾à¤à¤ªà¥à¤®à¤à¤à¥à¤¨à¤à¥à¤à¤à¤¸à¤¿à¤à¤à¥à¤¤à¤¨à¤¦à¤¿]/i,
  abbreviated: /^(à¤à¤¨|à¤«à¤¼à¤°|à¤®à¤¾à¤°à¥à¤|à¤à¤ªà¥|à¤®à¤|à¤à¥à¤¨|à¤à¥à¤²|à¤à¤|à¤¸à¤¿à¤¤|à¤à¤à¥à¤¤à¥|à¤¨à¤µ|à¤¦à¤¿à¤¸)/i,
  wide: /^(à¤à¤¨à¤µà¤°à¥|à¤«à¤¼à¤°à¤µà¤°à¥|à¤®à¤¾à¤°à¥à¤|à¤à¤ªà¥à¤°à¥à¤²|à¤®à¤|à¤à¥à¤¨|à¤à¥à¤²à¤¾à¤|à¤à¤à¤¸à¥à¤¤|à¤¸à¤¿à¤¤à¤à¤¬à¤°|à¤à¤à¥à¤¤à¥à¤¬à¤°|à¤¨à¤µà¤à¤¬à¤°|à¤¦à¤¿à¤¸à¤à¤¬à¤°)/i,
};
const parseMonthPatterns$O = {
  narrow: [
    /^à¤/i,
    /^à¤«à¤¼/i,
    /^à¤®à¤¾/i,
    /^à¤à¤ªà¥/i,
    /^à¤®à¤/i,
    /^à¤à¥/i,
    /^à¤à¥/i,
    /^à¤à¤/i,
    /^à¤¸à¤¿/i,
    /^à¤à¤à¥à¤¤à¥/i,
    /^à¤¨/i,
    /^à¤¦à¤¿/i,
  ],

  any: [
    /^à¤à¤¨/i,
    /^à¤«à¤¼/i,
    /^à¤®à¤¾/i,
    /^à¤à¤ªà¥/i,
    /^à¤®à¤/i,
    /^à¤à¥/i,
    /^à¤à¥/i,
    /^à¤à¤/i,
    /^à¤¸à¤¿/i,
    /^à¤à¤à¥à¤¤à¥/i,
    /^à¤¨à¤µ/i,
    /^à¤¦à¤¿à¤¸/i,
  ],
};

const matchDayPatterns$O = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[à¤°à¤µà¤¿à¤¸à¥à¤®à¤®à¤à¤à¤²à¤¬à¥à¤§à¤à¥à¤°à¥à¤¶à¥à¤à¥à¤°à¤¶à¤¨à¤¿]/i,
  short: /^(à¤°à¤µà¤¿|à¤¸à¥à¤®|à¤®à¤à¤à¤²|à¤¬à¥à¤§|à¤à¥à¤°à¥|à¤¶à¥à¤à¥à¤°|à¤¶à¤¨à¤¿)/i,
  abbreviated: /^(à¤°à¤µà¤¿|à¤¸à¥à¤®|à¤®à¤à¤à¤²|à¤¬à¥à¤§|à¤à¥à¤°à¥|à¤¶à¥à¤à¥à¤°|à¤¶à¤¨à¤¿)/i,
  wide: /^(à¤°à¤µà¤¿à¤µà¤¾à¤°|à¤¸à¥à¤®à¤µà¤¾à¤°|à¤®à¤à¤à¤²à¤µà¤¾à¤°|à¤¬à¥à¤§à¤µà¤¾à¤°|à¤à¥à¤°à¥à¤µà¤¾à¤°|à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°|à¤¶à¤¨à¤¿à¤µà¤¾à¤°)/i,
};
const parseDayPatterns$O = {
  narrow: [/^à¤°à¤µà¤¿/i, /^à¤¸à¥à¤®/i, /^à¤®à¤à¤à¤²/i, /^à¤¬à¥à¤§/i, /^à¤à¥à¤°à¥/i, /^à¤¶à¥à¤à¥à¤°/i, /^à¤¶à¤¨à¤¿/i],

  any: [/^à¤°à¤µà¤¿/i, /^à¤¸à¥à¤®/i, /^à¤®à¤à¤à¤²/i, /^à¤¬à¥à¤§/i, /^à¤à¥à¤°à¥/i, /^à¤¶à¥à¤à¥à¤°/i, /^à¤¶à¤¨à¤¿/i],
};

const matchDayPeriodPatterns$O = {
  narrow: /^(à¤ªà¥|à¤|à¤®|à¤¦.\?|à¤¸à¥|à¤¦à¥|à¤¶à¤¾|à¤°à¤¾)/i,
  any: /^(à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨|à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨|à¤®|à¤¦.\?|à¤¸à¥|à¤¦à¥|à¤¶à¤¾|à¤°à¤¾)/i,
};
const parseDayPeriodPatterns$O = {
  any: {
    am: /^à¤ªà¥à¤°à¥à¤µà¤¾à¤¹à¥à¤¨/i,
    pm: /^à¤à¤ªà¤°à¤¾à¤¹à¥à¤¨/i,
    midnight: /^à¤®à¤§à¥à¤¯/i,
    noon: /^à¤¦à¥/i,
    morning: /à¤¸à¥/i,
    afternoon: /à¤¦à¥/i,
    evening: /à¤¶à¤¾/i,
    night: /à¤°à¤¾/i,
  },
};

(match$O.match = {
  ordinalNumber: (0, _index2$39.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$O,
    parsePattern: parseOrdinalNumberPattern$O,
    valueCallback: _index3$1C.localeToNumber,
  }),

  era: (0, _index$7b.buildMatchFn)({
    matchPatterns: matchEraPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$O,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$7b.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$O,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$7b.buildMatchFn)({
    matchPatterns: matchMonthPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$O,
    defaultParseWidth: "any",
  }),

  day: (0, _index$7b.buildMatchFn)({
    matchPatterns: matchDayPatterns$O,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$O,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$7b.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$O,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$O,
    defaultParseWidth: "any",
  }),
});

hi.hi = void 0;
var _index$7a = formatDistance$1D;
var _index2$38 = formatLong$P;
var _index3$1B = formatRelative$1D;
var _index4$15 = localize$O;
var _index5$Y = match$O;

/**
 * @category Locales
 * @summary Hindi locale (India).
 * @language Hindi
 * @iso-639-2 hin
 * @author Mukesh Mandiwal [@mukeshmandiwal](https://github.com/mukeshmandiwal)
 */
(hi.hi = {
  code: "hi",
  formatDistance: _index$7a.formatDistance,
  formatLong: _index2$38.formatLong,
  formatRelative: _index3$1B.formatRelative,
  localize: _index4$15.localize,
  match: _index5$Y.match,
  options: {
    weekStartsOn: 0 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var hr = {};

var formatDistance$1B = {};

formatDistance$1B.formatDistance = void 0;

const formatDistanceLocale$M = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu",
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi",
  },

  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu",
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi",
  },

  halfAMinute: "pola minute",

  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu",
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta",
  },

  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu",
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta",
  },

  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat",
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati",
  },

  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat",
    },
    dual: "{{count}} sata",
    other: "{{count}} sati",
  },

  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan",
    },
    dual: "{{count}} dana",
    other: "{{count}} dana",
  },

  aboutXWeeks: {
    one: {
      standalone: "oko 1 tjedan",
      withPrepositionAgo: "oko 1 tjedan",
      withPrepositionIn: "oko 1 tjedan",
    },
    dual: "oko {{count}} tjedna",
    other: "oko {{count}} tjedana",
  },

  xWeeks: {
    one: {
      standalone: "1 tjedan",
      withPrepositionAgo: "1 tjedan",
      withPrepositionIn: "1 tjedan",
    },
    dual: "{{count}} tjedna",
    other: "{{count}} tjedana",
  },

  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec",
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci",
  },

  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec",
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci",
  },

  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu",
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina",
  },

  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu",
    },
    dual: "{{count}} godine",
    other: "{{count}} godina",
  },

  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu",
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina",
  },

  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu",
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina",
  },
};

const formatDistance$1A = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$M[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (
    count % 10 > 1 &&
    count % 10 < 5 && // if last digit is between 2 and 4
    String(count).substr(-2, 1) !== "1" // unless the 2nd to last digit is "1"
  ) {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }

  return result;
};
formatDistance$1B.formatDistance = formatDistance$1A;

var formatLong$O = {};

formatLong$O.formatLong = void 0;
var _index$79 = buildFormatLongFn$1;

const dateFormats$O = {
  full: "EEEE, d. MMMM y.",
  long: "d. MMMM y.",
  medium: "d. MMM y.",
  short: "dd. MM. y.",
};

const timeFormats$O = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$O = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$O.formatLong = {
  date: (0, _index$79.buildFormatLongFn)({
    formats: dateFormats$O,
    defaultWidth: "full",
  }),

  time: (0, _index$79.buildFormatLongFn)({
    formats: timeFormats$O,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$79.buildFormatLongFn)({
    formats: dateTimeFormats$O,
    defaultWidth: "full",
  }),
});

var formatRelative$1B = {};

formatRelative$1B.formatRelative = void 0;

const formatRelativeLocale$N = {
  lastWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'proÅ¡lu nedjelju u' p";
      case 3:
        return "'proÅ¡lu srijedu u' p";
      case 6:
        return "'proÅ¡lu subotu u' p";
      default:
        return "'proÅ¡li' EEEE 'u' p";
    }
  },
  yesterday: "'juÄer u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'iduÄu nedjelju u' p";
      case 3:
        return "'iduÄu srijedu u' p";
      case 6:
        return "'iduÄu subotu u' p";
      default:
        return "'proÅ¡li' EEEE 'u' p";
    }
  },
  other: "P",
};

const formatRelative$1A = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$N[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$1B.formatRelative = formatRelative$1A;

var localize$N = {};

localize$N.localize = void 0;
var _index$78 = buildLocalizeFn$1;

const eraValues$N = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Kr.", "po. Kr."],
  wide: ["Prije Krista", "Poslije Krista"],
};

const quarterValues$N = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$N = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "sij",
    "velj",
    "oÅ¾u",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro",
  ],

  wide: [
    "sijeÄanj",
    "veljaÄa",
    "oÅ¾ujak",
    "travanj",
    "svibanj",
    "lipanj",
    "srpanj",
    "kolovoz",
    "rujan",
    "listopad",
    "studeni",
    "prosinac",
  ],
};

const formattingMonthValues$a = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "sij",
    "velj",
    "oÅ¾u",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro",
  ],

  wide: [
    "sijeÄnja",
    "veljaÄe",
    "oÅ¾ujka",
    "travnja",
    "svibnja",
    "lipnja",
    "srpnja",
    "kolovoza",
    "rujna",
    "listopada",
    "studenog",
    "prosinca",
  ],
};

const dayValues$N = {
  narrow: ["N", "P", "U", "S", "Ä", "P", "S"],
  short: ["ned", "pon", "uto", "sri", "Äet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sri", "Äet", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "Äetvrtak",
    "petak",
    "subota",
  ],
};

const formattingDayPeriodValues$D = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveÄer",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveÄer",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "naveÄer",
    night: "noÄu",
  },
};

const dayPeriodValues$N = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveÄer",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "naveÄer",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "naveÄer",
    night: "noÄu",
  },
};

const ordinalNumber$N = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$N.localize = {
  ordinalNumber: ordinalNumber$N,

  era: (0, _index$78.buildLocalizeFn)({
    values: eraValues$N,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$78.buildLocalizeFn)({
    values: quarterValues$N,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$78.buildLocalizeFn)({
    values: monthValues$N,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$a,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$78.buildLocalizeFn)({
    values: dayValues$N,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$78.buildLocalizeFn)({
    values: dayPeriodValues$N,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$D,
    defaultFormattingWidth: "wide",
  }),
});

var match$N = {};

match$N.match = void 0;

var _index$77 = buildMatchFn$1;
var _index2$37 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$N = /^(\d+)\./i;
const parseOrdinalNumberPattern$N = /\d+/i;

const matchEraPatterns$N = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Kr\.|po\.\s?Kr\.)/i,
  wide: /^(Prije Krista|prije nove ere|Poslije Krista|nova era)/i,
};
const parseEraPatterns$N = {
  any: [/^pr/i, /^(po|nova)/i],
};

const matchQuarterPatterns$N = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i,
};
const parseQuarterPatterns$N = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$N = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(sij|velj|(oÅ¾u|ozu)|tra|svi|lip|srp|kol|ruj|lis|stu|pro)/i,
  wide: /^((sijeÄanj|sijeÄnja|sijecanj|sijecnja)|(veljaÄa|veljaÄe|veljaca|veljace)|(oÅ¾ujak|oÅ¾ujka|ozujak|ozujka)|(travanj|travnja)|(svibanj|svibnja)|(lipanj|lipnja)|(srpanj|srpnja)|(kolovoz|kolovoza)|(rujan|rujna)|(listopad|listopada)|(studeni|studenog)|(prosinac|prosinca))/i,
};
const parseMonthPatterns$N = {
  narrow: [
    /1/i,
    /2/i,
    /3/i,
    /4/i,
    /5/i,
    /6/i,
    /7/i,
    /8/i,
    /9/i,
    /10/i,
    /11/i,
    /12/i,
  ],

  abbreviated: [
    /^sij/i,
    /^velj/i,
    /^(oÅ¾u|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i,
  ],

  wide: [
    /^sij/i,
    /^velj/i,
    /^(oÅ¾u|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i,
  ],
};

const matchDayPatterns$N = {
  narrow: /^[npusÄc]/i,
  short: /^(ned|pon|uto|sri|(Äet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sri|(Äet|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(Äetvrtak|cetvrtak)|petak|subota)/i,
};
const parseDayPatterns$N = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$N = {
  any: /^(am|pm|ponoc|ponoÄ|(po)?podne|navecer|naveÄer|noÄu|poslije podne|ujutro)/i,
};
const parseDayPeriodPatterns$N = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(navece|naveÄe)/i,
    night: /(nocu|noÄu)/i,
  },
};

(match$N.match = {
  ordinalNumber: (0, _index2$37.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$N,
    parsePattern: parseOrdinalNumberPattern$N,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$77.buildMatchFn)({
    matchPatterns: matchEraPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$N,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$77.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$N,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$77.buildMatchFn)({
    matchPatterns: matchMonthPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$N,
    defaultParseWidth: "wide",
  }),

  day: (0, _index$77.buildMatchFn)({
    matchPatterns: matchDayPatterns$N,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$N,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$77.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$N,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$N,
    defaultParseWidth: "any",
  }),
});

hr.hr = void 0;
var _index$76 = formatDistance$1B;
var _index2$36 = formatLong$O;
var _index3$1A = formatRelative$1B;
var _index4$14 = localize$N;
var _index5$X = match$N;

/**
 * @category Locales
 * @summary Croatian locale.
 * @language Croatian
 * @iso-639-2 hrv
 * @author Matija MarohniÄ [@silvenon](https://github.com/silvenon)
 * @author Manico [@manico](https://github.com/manico)
 * @author Ivan JerÅ¾abek [@jerzabek](https://github.com/jerzabek)
 */
(hr.hr = {
  code: "hr",
  formatDistance: _index$76.formatDistance,
  formatLong: _index2$36.formatLong,
  formatRelative: _index3$1A.formatRelative,
  localize: _index4$14.localize,
  match: _index5$X.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var ht = {};

var formatDistance$1z = {};

formatDistance$1z.formatDistance = void 0;

const formatDistanceLocale$L = {
  lessThanXSeconds: {
    one: "mwens pase yon segond",
    other: "mwens pase {{count}} segond",
  },

  xSeconds: {
    one: "1 segond",
    other: "{{count}} segond",
  },

  halfAMinute: "30 segond",

  lessThanXMinutes: {
    one: "mwens pase yon minit",
    other: "mwens pase {{count}} minit",
  },

  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit",
  },

  aboutXHours: {
    one: "anviwon inÃ¨",
    other: "anviwon {{count}} Ã¨",
  },

  xHours: {
    one: "1 lÃ¨",
    other: "{{count}} lÃ¨",
  },

  xDays: {
    one: "1 jou",
    other: "{{count}} jou",
  },

  aboutXWeeks: {
    one: "anviwon 1 semÃ¨n",
    other: "anviwon {{count}} semÃ¨n",
  },

  xWeeks: {
    one: "1 semÃ¨n",
    other: "{{count}} semÃ¨n",
  },

  aboutXMonths: {
    one: "anviwon 1 mwa",
    other: "anviwon {{count}} mwa",
  },

  xMonths: {
    one: "1 mwa",
    other: "{{count}} mwa",
  },

  aboutXYears: {
    one: "anviwon 1 an",
    other: "anviwon {{count}} an",
  },

  xYears: {
    one: "1 an",
    other: "{{count}} an",
  },

  overXYears: {
    one: "plis pase 1 an",
    other: "plis pase {{count}} an",
  },

  almostXYears: {
    one: "prÃ¨ske 1 an",
    other: "prÃ¨ske {{count}} an",
  },
};

const formatDistance$1y = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$L[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "nan " + result;
    } else {
      return "sa fÃ¨ " + result;
    }
  }

  return result;
};
formatDistance$1z.formatDistance = formatDistance$1y;

var formatLong$N = {};

formatLong$N.formatLong = void 0;
var _index$75 = buildFormatLongFn$1;

const dateFormats$N = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$N = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$N = {
  full: "{{date}} 'nan lÃ¨' {{time}}",
  long: "{{date}} 'nan lÃ¨' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$N.formatLong = {
  date: (0, _index$75.buildFormatLongFn)({
    formats: dateFormats$N,
    defaultWidth: "full",
  }),

  time: (0, _index$75.buildFormatLongFn)({
    formats: timeFormats$N,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$75.buildFormatLongFn)({
    formats: dateTimeFormats$N,
    defaultWidth: "full",
  }),
});

var formatRelative$1z = {};

formatRelative$1z.formatRelative = void 0;

const formatRelativeLocale$M = {
  lastWeek: "eeee 'pase nan lÃ¨' p",
  yesterday: "'yÃ¨ nan lÃ¨' p",
  today: "'jodi a' p",
  tomorrow: "'demen nan lÃ¨' p'",
  nextWeek: "eeee 'pwochen nan lÃ¨' p",
  other: "P",
};

const formatRelative$1y = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$M[token];
formatRelative$1z.formatRelative = formatRelative$1y;

var localize$M = {};

localize$M.localize = void 0;
var _index$74 = buildLocalizeFn$1;

const eraValues$M = {
  narrow: ["av. J.-K", "ap. J.-K"],
  abbreviated: ["av. J.-K", "ap. J.-K"],
  wide: ["anvan Jezi Kris", "apre Jezi Kris"],
};

const quarterValues$M = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1ye trim.", "2yÃ¨m trim.", "3yÃ¨m trim.", "4yÃ¨m trim."],
  wide: ["1ye trimÃ¨s", "2yÃ¨m trimÃ¨s", "3yÃ¨m trimÃ¨s", "4yÃ¨m trimÃ¨s"],
};

const monthValues$M = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "fevr.",
    "mas",
    "avr.",
    "me",
    "jen",
    "jiyÃ¨",
    "out",
    "sept.",
    "okt.",
    "nov.",
    "des.",
  ],

  wide: [
    "janvye",
    "fevrye",
    "mas",
    "avril",
    "me",
    "jen",
    "jiyÃ¨",
    "out",
    "septanm",
    "oktÃ²b",
    "novanm",
    "desanm",
  ],
};

const dayValues$M = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "le", "ma", "mÃ¨", "je", "va", "sa"],
  abbreviated: ["dim.", "len.", "mad.", "mÃ¨k.", "jed.", "van.", "sam."],

  wide: ["dimanch", "lendi", "madi", "mÃ¨kredi", "jedi", "vandredi", "samdi"],
};

const dayPeriodValues$M = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "swa",
    night: "mat.",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "maten",
    afternoon: "aprÃ¨midi",
    evening: "swa",
    night: "maten",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "nan maten",
    afternoon: "nan aprÃ¨midi",
    evening: "nan aswÃ¨",
    night: "nan maten",
  },
};

const ordinalNumber$M = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  if (number === 0) return String(number);

  const suffix = number === 1 ? "ye" : "yÃ¨m";

  return number + suffix;
};

(localize$M.localize = {
  ordinalNumber: ordinalNumber$M,

  era: (0, _index$74.buildLocalizeFn)({
    values: eraValues$M,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$74.buildLocalizeFn)({
    values: quarterValues$M,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$74.buildLocalizeFn)({
    values: monthValues$M,
    defaultWidth: "wide",
  }),

  day: (0, _index$74.buildLocalizeFn)({
    values: dayValues$M,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$74.buildLocalizeFn)({
    values: dayPeriodValues$M,
    defaultWidth: "wide",
  }),
});

var match$M = {};

match$M.match = void 0;

var _index$73 = buildMatchFn$1;
var _index2$35 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$M = /^(\d+)(ye|yÃ¨m)?/i;
const parseOrdinalNumberPattern$M = /\d+/i;

const matchEraPatterns$M = {
  narrow: /^(av\.J\.K|ap\.J\.K|ap\.J\.-K)/i,
  abbreviated: /^(av\.J\.-K|av\.J-K|apr\.J\.-K|apr\.J-K|ap\.J-K)/i,
  wide: /^(avan Jezi Kris|apre Jezi Kris)/i,
};
const parseEraPatterns$M = {
  any: [/^av/i, /^ap/i],
};

const matchQuarterPatterns$M = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](ye|yÃ¨m)? trimÃ¨s/i,
};
const parseQuarterPatterns$M = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$M = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|fevr|mas|avr|me|jen|jiyÃ¨|out|sept|okt|nov|des)\.?/i,
  wide: /^(janvye|fevrye|mas|avril|me|jen|jiyÃ¨|out|septanm|oktÃ²b|novanm|desanm)/i,
};
const parseMonthPatterns$M = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^av/i,
    /^me/i,
    /^je/i,
    /^ji/i,
    /^ou/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$M = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|le|ma|me|je|va|sa)/i,
  abbreviated: /^(dim|len|mad|mÃ¨k|jed|van|sam)\.?/i,
  wide: /^(dimanch|lendi|madi|mÃ¨kredi|jedi|vandredi|samdi)/i,
};
const parseDayPatterns$M = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^le/i, /^ma/i, /^mÃ¨/i, /^je/i, /^va/i, /^sa/i],
};

const matchDayPeriodPatterns$M = {
  narrow: /^(a|p|minwit|midi|mat\.?|ap\.?m\.?|swa)/i,
  any: /^([ap]\.?\s?m\.?|nan maten|nan aprÃ¨midi|nan aswÃ¨)/i,
};
const parseDayPeriodPatterns$M = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /sw/i,
    night: /nwit/i,
  },
};

(match$M.match = {
  ordinalNumber: (0, _index2$35.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$M,
    parsePattern: parseOrdinalNumberPattern$M,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$73.buildMatchFn)({
    matchPatterns: matchEraPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$M,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$73.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$M,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$73.buildMatchFn)({
    matchPatterns: matchMonthPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$M,
    defaultParseWidth: "any",
  }),

  day: (0, _index$73.buildMatchFn)({
    matchPatterns: matchDayPatterns$M,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$M,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$73.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$M,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$M,
    defaultParseWidth: "any",
  }),
});

ht.ht = void 0;
var _index$72 = formatDistance$1z;
var _index2$34 = formatLong$N;
var _index3$1z = formatRelative$1z;
var _index4$13 = localize$M;
var _index5$W = match$M;

/**
 * @category Locales
 * @summary Haitian Creole locale.
 * @language Haitian Creole
 * @iso-639-2 hat
 * @author Rubens Mariuzzo [@rmariuzzo](https://github.com/rmariuzzo)
 * @author Watson Marcelain [@watsongm24](https://github.com/watsongm24)
 */
(ht.ht = {
  code: "ht",
  formatDistance: _index$72.formatDistance,
  formatLong: _index2$34.formatLong,
  formatRelative: _index3$1z.formatRelative,
  localize: _index4$13.localize,
  match: _index5$W.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var hu = {};

var formatDistance$1x = {};

formatDistance$1x.formatDistance = void 0;

const translations$1 = {
  about: "kÃ¶rÃ¼lbelÃ¼l",
  over: "tÃ¶bb mint",
  almost: "majdnem",
  lessthan: "kevesebb mint",
};

const withoutSuffixes = {
  xseconds: " mÃ¡sodperc",
  halfaminute: "fÃ©l perc",
  xminutes: " perc",
  xhours: " Ã³ra",
  xdays: " nap",
  xweeks: " hÃ©t",
  xmonths: " hÃ³nap",
  xyears: " Ã©v",
};

const withSuffixes = {
  xseconds: {
    "-1": " mÃ¡sodperccel ezelÅtt",
    1: " mÃ¡sodperc mÃºlva",
    0: " mÃ¡sodperce",
  },
  halfaminute: {
    "-1": "fÃ©l perccel ezelÅtt",
    1: "fÃ©l perc mÃºlva",
    0: "fÃ©l perce",
  },
  xminutes: {
    "-1": " perccel ezelÅtt",
    1: " perc mÃºlva",
    0: " perce",
  },
  xhours: {
    "-1": " Ã³rÃ¡val ezelÅtt",
    1: " Ã³ra mÃºlva",
    0: " Ã³rÃ¡ja",
  },
  xdays: {
    "-1": " nappal ezelÅtt",
    1: " nap mÃºlva",
    0: " napja",
  },
  xweeks: {
    "-1": " hÃ©ttel ezelÅtt",
    1: " hÃ©t mÃºlva",
    0: " hete",
  },
  xmonths: {
    "-1": " hÃ³nappal ezelÅtt",
    1: " hÃ³nap mÃºlva",
    0: " hÃ³napja",
  },
  xyears: {
    "-1": " Ã©vvel ezelÅtt",
    1: " Ã©v mÃºlva",
    0: " Ã©ve",
  },
};

const formatDistance$1w = (token, count, options) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;

  const addSuffix = options?.addSuffix === true;
  const key = unit.toLowerCase();
  const comparison = options?.comparison || 0;

  const translated = addSuffix
    ? withSuffixes[key][comparison]
    : withoutSuffixes[key];

  let result = key === "halfaminute" ? translated : count + translated;

  if (adverb) {
    const adv = adverb[0].toLowerCase();
    result = translations$1[adv] + " " + result;
  }

  return result;
};
formatDistance$1x.formatDistance = formatDistance$1w;

var formatLong$M = {};

formatLong$M.formatLong = void 0;
var _index$71 = buildFormatLongFn$1;

const dateFormats$M = {
  full: "y. MMMM d., EEEE",
  long: "y. MMMM d.",
  medium: "y. MMM d.",
  short: "y. MM. dd.",
};

const timeFormats$M = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$M = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$M.formatLong = {
  date: (0, _index$71.buildFormatLongFn)({
    formats: dateFormats$M,
    defaultWidth: "full",
  }),

  time: (0, _index$71.buildFormatLongFn)({
    formats: timeFormats$M,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$71.buildFormatLongFn)({
    formats: dateTimeFormats$M,
    defaultWidth: "full",
  }),
});

var formatRelative$1x = {};

formatRelative$1x.formatRelative = void 0;

const accusativeWeekdays$4 = [
  "vasÃ¡rnap",
  "hÃ©tfÅn",
  "kedden",
  "szerdÃ¡n",
  "csÃ¼tÃ¶rtÃ¶kÃ¶n",
  "pÃ©nteken",
  "szombaton",
];

function week(isFuture) {
  return (date) => {
    const weekday = accusativeWeekdays$4[date.getDay()];
    const prefix = isFuture ? "" : "'mÃºlt' ";
    return `${prefix}'${weekday}' p'-kor'`;
  };
}
const formatRelativeLocale$L = {
  lastWeek: week(false),
  yesterday: "'tegnap' p'-kor'",
  today: "'ma' p'-kor'",
  tomorrow: "'holnap' p'-kor'",
  nextWeek: week(true),
  other: "P",
};

const formatRelative$1w = (token, date) => {
  const format = formatRelativeLocale$L[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$1x.formatRelative = formatRelative$1w;

var localize$L = {};

localize$L.localize = void 0;
var _index$70 = buildLocalizeFn$1;

const eraValues$L = {
  narrow: ["ie.", "isz."],
  abbreviated: ["i. e.", "i. sz."],
  wide: ["Krisztus elÅtt", "idÅszÃ¡mÃ­tÃ¡sunk szerint"],
};

const quarterValues$L = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. n.Ã©v", "2. n.Ã©v", "3. n.Ã©v", "4. n.Ã©v"],
  wide: ["1. negyedÃ©v", "2. negyedÃ©v", "3. negyedÃ©v", "4. negyedÃ©v"],
};

const formattingQuarterValues$3 = {
  narrow: ["I.", "II.", "III.", "IV."],
  abbreviated: ["I. n.Ã©v", "II. n.Ã©v", "III. n.Ã©v", "IV. n.Ã©v"],
  wide: ["I. negyedÃ©v", "II. negyedÃ©v", "III. negyedÃ©v", "IV. negyedÃ©v"],
};

const monthValues$L = {
  narrow: ["J", "F", "M", "Ã", "M", "J", "J", "A", "Sz", "O", "N", "D"],

  abbreviated: [
    "jan.",
    "febr.",
    "mÃ¡rc.",
    "Ã¡pr.",
    "mÃ¡j.",
    "jÃºn.",
    "jÃºl.",
    "aug.",
    "szept.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januÃ¡r",
    "februÃ¡r",
    "mÃ¡rcius",
    "Ã¡prilis",
    "mÃ¡jus",
    "jÃºnius",
    "jÃºlius",
    "augusztus",
    "szeptember",
    "oktÃ³ber",
    "november",
    "december",
  ],
};

const dayValues$L = {
  narrow: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
  short: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  abbreviated: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  wide: [
    "vasÃ¡rnap",
    "hÃ©tfÅ",
    "kedd",
    "szerda",
    "csÃ¼tÃ¶rtÃ¶k",
    "pÃ©ntek",
    "szombat",
  ],
};

const dayPeriodValues$L = {
  narrow: {
    am: "de.",
    pm: "du.",
    midnight: "Ã©jfÃ©l",
    noon: "dÃ©l",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "Ã©jjel",
  },
  abbreviated: {
    am: "de.",
    pm: "du.",
    midnight: "Ã©jfÃ©l",
    noon: "dÃ©l",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "Ã©jjel",
  },
  wide: {
    am: "de.",
    pm: "du.",
    midnight: "Ã©jfÃ©l",
    noon: "dÃ©l",
    morning: "reggel",
    afternoon: "dÃ©lutÃ¡n",
    evening: "este",
    night: "Ã©jjel",
  },
};

const ordinalNumber$L = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$L.localize = {
  ordinalNumber: ordinalNumber$L,

  era: (0, _index$70.buildLocalizeFn)({
    values: eraValues$L,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$70.buildLocalizeFn)({
    values: quarterValues$L,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
    formattingValues: formattingQuarterValues$3,
    defaultFormattingWidth: "wide",
  }),

  month: (0, _index$70.buildLocalizeFn)({
    values: monthValues$L,
    defaultWidth: "wide",
  }),

  day: (0, _index$70.buildLocalizeFn)({
    values: dayValues$L,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$70.buildLocalizeFn)({
    values: dayPeriodValues$L,
    defaultWidth: "wide",
  }),
});

var match$L = {};

match$L.match = void 0;

var _index$6$ = buildMatchFn$1;
var _index2$33 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$L = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$L = /\d+/i;

const matchEraPatterns$L = {
  narrow: /^(ie\.|isz\.)/i,
  abbreviated: /^(i\.\s?e\.?|b?\s?c\s?e|i\.\s?sz\.?)/i,
  wide: /^(Krisztus elÅtt|idÅszÃ¡mÃ­tÃ¡sunk elÅtt|idÅszÃ¡mÃ­tÃ¡sunk szerint|i\. sz\.)/i,
};
const parseEraPatterns$L = {
  narrow: [/ie/i, /isz/i],
  abbreviated: [/^(i\.?\s?e\.?|b\s?ce)/i, /^(i\.?\s?sz\.?|c\s?e)/i],
  any: [/elÅtt/i, /(szerint|i. sz.)/i],
};

const matchQuarterPatterns$L = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^[1234]?\.?\s?n\.Ã©v/i,
  wide: /^([1234]|I|II|III|IV)?\.?\s?negyedÃ©v/i,
};
const parseQuarterPatterns$L = {
  any: [/1|I$/i, /2|II$/i, /3|III/i, /4|IV/i],
};

const matchMonthPatterns$L = {
  narrow: /^[jfmaÃ¡sond]|sz/i,
  abbreviated:
    /^(jan\.?|febr\.?|mÃ¡rc\.?|Ã¡pr\.?|mÃ¡j\.?|jÃºn\.?|jÃºl\.?|aug\.?|szept\.?|okt\.?|nov\.?|dec\.?)/i,
  wide: /^(januÃ¡r|februÃ¡r|mÃ¡rcius|Ã¡prilis|mÃ¡jus|jÃºnius|jÃºlius|augusztus|szeptember|oktÃ³ber|november|december)/i,
};
const parseMonthPatterns$L = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a|Ã¡/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s|sz/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mÃ¡r/i,
    /^Ã¡p/i,
    /^mÃ¡j/i,
    /^jÃºn/i,
    /^jÃºl/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$L = {
  narrow: /^([vhkpc]|sz|cs|sz)/i,
  short: /^([vhkp]|sze|cs|szo)/i,
  abbreviated: /^([vhkp]|sze|cs|szo)/i,
  wide: /^(vasÃ¡rnap|hÃ©tfÅ|kedd|szerda|csÃ¼tÃ¶rtÃ¶k|pÃ©ntek|szombat)/i,
};
const parseDayPatterns$L = {
  narrow: [/^v/i, /^h/i, /^k/i, /^sz/i, /^c/i, /^p/i, /^sz/i],
  any: [/^v/i, /^h/i, /^k/i, /^sze/i, /^c/i, /^p/i, /^szo/i],
};

const matchDayPeriodPatterns$L = {
  any: /^((de|du)\.?|Ã©jfÃ©l|dÃ©lutÃ¡n|dÃ©l|reggel|este|Ã©jjel)/i,
};
const parseDayPeriodPatterns$L = {
  any: {
    am: /^de\.?/i,
    pm: /^du\.?/i,
    midnight: /^Ã©jf/i,
    noon: /^dÃ©/i,
    morning: /reg/i,
    afternoon: /^dÃ©lu\.?/i,
    evening: /es/i,
    night: /Ã©jj/i,
  },
};

(match$L.match = {
  ordinalNumber: (0, _index2$33.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$L,
    parsePattern: parseOrdinalNumberPattern$L,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6$.buildMatchFn)({
    matchPatterns: matchEraPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$L,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6$.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$L,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6$.buildMatchFn)({
    matchPatterns: matchMonthPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$L,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6$.buildMatchFn)({
    matchPatterns: matchDayPatterns$L,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$L,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6$.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$L,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$L,
    defaultParseWidth: "any",
  }),
});

hu.hu = void 0;
var _index$6_ = formatDistance$1x;
var _index2$32 = formatLong$M;
var _index3$1y = formatRelative$1x;
var _index4$12 = localize$L;
var _index5$V = match$L;

/**
 * @category Locales
 * @summary Hungarian locale.
 * @language Hungarian
 * @iso-639-2 hun
 * @author Pavlo Shpak [@pshpak](https://github.com/pshpak)
 * @author Eduardo Pardo [@eduardopsll](https://github.com/eduardopsll)
 * @author Zoltan Szepesi [@twodcube](https://github.com/twodcube)
 */
(hu.hu = {
  code: "hu",
  formatDistance: _index$6_.formatDistance,
  formatLong: _index2$32.formatLong,
  formatRelative: _index3$1y.formatRelative,
  localize: _index4$12.localize,
  match: _index5$V.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var hy = {};

var formatDistance$1v = {};

formatDistance$1v.formatDistance = void 0;

const formatDistanceLocale$K = {
  lessThanXSeconds: {
    one: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ«Õ¹ ÖÕ¡Õ¶ 1 Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶",
    other: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ«Õ¹ ÖÕ¡Õ¶ {{count}} Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶",
  },

  xSeconds: {
    one: "1 Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶",
    other: "{{count}} Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶",
  },

  halfAMinute: "Õ¯Õ¥Õ½ ÖÕ¸ÕºÕ¥",

  lessThanXMinutes: {
    one: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ«Õ¹ ÖÕ¡Õ¶ 1 ÖÕ¸ÕºÕ¥",
    other: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ«Õ¹ ÖÕ¡Õ¶ {{count}} ÖÕ¸ÕºÕ¥",
  },

  xMinutes: {
    one: "1 ÖÕ¸ÕºÕ¥",
    other: "{{count}} ÖÕ¸ÕºÕ¥",
  },

  aboutXHours: {
    one: "Õ´Õ¸Õ¿ 1 ÕªÕ¡Õ´",
    other: "Õ´Õ¸Õ¿ {{count}} ÕªÕ¡Õ´",
  },

  xHours: {
    one: "1 ÕªÕ¡Õ´",
    other: "{{count}} ÕªÕ¡Õ´",
  },

  xDays: {
    one: "1 ÖÖ",
    other: "{{count}} ÖÖ",
  },

  aboutXWeeks: {
    one: "Õ´Õ¸Õ¿ 1 Õ·Õ¡Õ¢Õ¡Õ©",
    other: "Õ´Õ¸Õ¿ {{count}} Õ·Õ¡Õ¢Õ¡Õ©",
  },

  xWeeks: {
    one: "1 Õ·Õ¡Õ¢Õ¡Õ©",
    other: "{{count}} Õ·Õ¡Õ¢Õ¡Õ©",
  },

  aboutXMonths: {
    one: "Õ´Õ¸Õ¿ 1 Õ¡Õ´Õ«Õ½",
    other: "Õ´Õ¸Õ¿ {{count}} Õ¡Õ´Õ«Õ½",
  },

  xMonths: {
    one: "1 Õ¡Õ´Õ«Õ½",
    other: "{{count}} Õ¡Õ´Õ«Õ½",
  },

  aboutXYears: {
    one: "Õ´Õ¸Õ¿ 1 Õ¿Õ¡ÖÕ«",
    other: "Õ´Õ¸Õ¿ {{count}} Õ¿Õ¡ÖÕ«",
  },

  xYears: {
    one: "1 Õ¿Õ¡ÖÕ«",
    other: "{{count}} Õ¿Õ¡ÖÕ«",
  },

  overXYears: {
    one: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ¡Õ¶ 1 Õ¿Õ¡ÖÕ«",
    other: "Õ¡Õ¾Õ¥Õ¬Õ« ÖÕ¡Õ¶ {{count}} Õ¿Õ¡ÖÕ«",
  },

  almostXYears: {
    one: "Õ°Õ¡Õ´Õ¡ÖÕµÕ¡ 1 Õ¿Õ¡ÖÕ«",
    other: "Õ°Õ¡Õ´Õ¡ÖÕµÕ¡ {{count}} Õ¿Õ¡ÖÕ«",
  },
};

const formatDistance$1u = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$K[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " Õ°Õ¥Õ¿Õ¸";
    } else {
      return result + " Õ¡Õ¼Õ¡Õ»";
    }
  }

  return result;
};
formatDistance$1v.formatDistance = formatDistance$1u;

var formatLong$L = {};

formatLong$L.formatLong = void 0;
var _index$6Z = buildFormatLongFn$1;

const dateFormats$L = {
  full: "d MMMM, y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd.MM.yyyy",
};

const timeFormats$L = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$L = {
  full: "{{date}} 'Õªâ¤'{{time}}",
  long: "{{date}} 'Õªâ¤'{{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$L.formatLong = {
  date: (0, _index$6Z.buildFormatLongFn)({
    formats: dateFormats$L,
    defaultWidth: "full",
  }),

  time: (0, _index$6Z.buildFormatLongFn)({
    formats: timeFormats$L,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6Z.buildFormatLongFn)({
    formats: dateTimeFormats$L,
    defaultWidth: "full",
  }),
});

var formatRelative$1v = {};

formatRelative$1v.formatRelative = void 0;

const formatRelativeLocale$K = {
  lastWeek: "'Õ¶Õ¡Õ­Õ¸ÖÕ¤' eeee p'ÖÕ«Õ¶'",
  yesterday: "'Õ¥ÖÕ¥Õ¯' p'ÖÕ«Õ¶'",
  today: "'Õ¡ÕµÕ½ÖÖ' p'ÖÕ«Õ¶'",
  tomorrow: "'Õ¾Õ¡Õ²Õ¨' p'ÖÕ«Õ¶'",
  nextWeek: "'Õ°Õ¡Õ»Õ¸ÖÕ¤' eeee p'ÖÕ«Õ¶'",
  other: "P",
};

const formatRelative$1u = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$K[token];
formatRelative$1v.formatRelative = formatRelative$1u;

var localize$K = {};

localize$K.localize = void 0;
var _index$6Y = buildLocalizeFn$1;

const eraValues$K = {
  narrow: ["Õ", "Õ"],
  abbreviated: ["ÕÔ±", "ÕÔ¹"],
  wide: ["ÕÖÕ«Õ½Õ¿Õ¸Õ½Õ«Ö Õ¡Õ¼Õ¡Õ»", "ÕÕ¥Ö Õ©Õ¾Õ¡ÖÕ¯Õ¸ÖÕ©ÕµÕ¡Õ¶"],
};

const quarterValues$K = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Õ1", "Õ2", "Õ3", "Õ4"],
  wide: ["1ÖÕ«Õ¶ ÖÕ¡Õ¼Õ¸ÖÕ¤", "2ÖÖÕ¤ ÖÕ¡Õ¼Õ¸ÖÕ¤", "3ÖÖÕ¤ ÖÕ¡Õ¼Õ¸ÖÕ¤", "4ÖÖÕ¤ ÖÕ¡Õ¼Õ¸ÖÕ¤"],
};

const monthValues$K = {
  narrow: ["Õ", "Õ", "Õ", "Ô±", "Õ", "Õ", "Õ", "Õ", "Õ", "Õ", "Õ", "Ô´"],
  abbreviated: [
    "Õ°Õ¸ÖÕ¶",
    "ÖÕ¥Õ¿",
    "Õ´Õ¡Ö",
    "Õ¡ÕºÖ",
    "Õ´Õ¡Õµ",
    "Õ°Õ¸ÖÕ¶",
    "Õ°Õ¸ÖÕ¬",
    "ÖÕ£Õ½",
    "Õ½Õ¥Õº",
    "Õ°Õ¸Õ¯",
    "Õ¶Õ¸Õµ",
    "Õ¤Õ¥Õ¯",
  ],

  wide: [
    "Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö",
    "ÖÕ¥Õ¿ÖÕ¾Õ¡Ö",
    "Õ´Õ¡ÖÕ¿",
    "Õ¡ÕºÖÕ«Õ¬",
    "Õ´Õ¡ÕµÕ«Õ½",
    "Õ°Õ¸ÖÕ¶Õ«Õ½",
    "Õ°Õ¸ÖÕ¬Õ«Õ½",
    "ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½",
    "Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö",
    "Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö",
    "Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö",
    "Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö",
  ],
};

const dayValues$K = {
  narrow: ["Ô¿", "Ôµ", "Ôµ", "Õ", "Õ", "Õ", "Õ"],
  short: ["Õ¯Ö", "Õ¥Ö", "Õ¥Ö", "Õ¹Ö", "Õ°Õ£", "Õ¸ÖÖ", "Õ·Õ¢"],
  abbreviated: ["Õ¯Õ«Ö", "Õ¥ÖÕ¯", "Õ¥ÖÖ", "Õ¹Õ¸Ö", "Õ°Õ¶Õ£", "Õ¸ÖÖÕ¢", "Õ·Õ¡Õ¢"],
  wide: [
    "Õ¯Õ«ÖÕ¡Õ¯Õ«",
    "Õ¥ÖÕ¯Õ¸ÖÕ·Õ¡Õ¢Õ©Õ«",
    "Õ¥ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«",
    "Õ¹Õ¸ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«",
    "Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ«",
    "Õ¸ÖÖÕ¢Õ¡Õ©",
    "Õ·Õ¡Õ¢Õ¡Õ©",
  ],
};

const dayPeriodValues$K = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "Õ¯Õ¥Õ½Õ£Õ·",
    noon: "Õ¯Õ¥Õ½ÖÖ",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸",
    night: "Õ£Õ«Õ·Õ¥Ö",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥Ö",
    noon: "Õ¯Õ¥Õ½ÖÖ",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸",
    night: "Õ£Õ«Õ·Õ¥Ö",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥Ö",
    noon: "Õ¯Õ¥Õ½ÖÖ",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸",
    night: "Õ£Õ«Õ·Õ¥Ö",
  },
};

const formattingDayPeriodValues$C = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "Õ¯Õ¥Õ½Õ£Õ·",
    noon: "Õ¯Õ¥Õ½ÖÖ",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¨",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯Õ¨",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶",
    night: "Õ£Õ«Õ·Õ¥ÖÕ¨",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥ÖÕ«Õ¶",
    noon: "Õ¯Õ¥Õ½ÖÖÕ«Õ¶",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¨",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯Õ¨",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶",
    night: "Õ£Õ«Õ·Õ¥ÖÕ¨",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥ÖÕ«Õ¶",
    noon: "Õ¯Õ¥Õ½ÖÖÕ«Õ¶",
    morning: "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¨",
    afternoon: "ÖÕ¥ÖÕ¥Õ¯Õ¨",
    evening: "Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶",
    night: "Õ£Õ«Õ·Õ¥ÖÕ¨",
  },
};

const ordinalNumber$K = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  const rem100 = number % 100;
  if (rem100 < 10) {
    if (rem100 % 10 === 1) {
      return number + "ÖÕ«Õ¶";
    }
  }
  return number + "ÖÖÕ¤";
};

(localize$K.localize = {
  ordinalNumber: ordinalNumber$K,

  era: (0, _index$6Y.buildLocalizeFn)({
    values: eraValues$K,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6Y.buildLocalizeFn)({
    values: quarterValues$K,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6Y.buildLocalizeFn)({
    values: monthValues$K,
    defaultWidth: "wide",
  }),

  day: (0, _index$6Y.buildLocalizeFn)({
    values: dayValues$K,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6Y.buildLocalizeFn)({
    values: dayPeriodValues$K,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$C,
    defaultFormattingWidth: "wide",
  }),
});

var match$K = {};

match$K.match = void 0;

var _index$6X = buildMatchFn$1;
var _index2$31 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$K = /^(\d+)((-|Ö)?(Õ«Õ¶|ÖÕ¤))?/i;
const parseOrdinalNumberPattern$K = /\d+/i;

const matchEraPatterns$K = {
  narrow: /^(Õ|Õ)/i,
  abbreviated: /^(Õ\.?\s?Ô±\.?|Õ\.?\s?Ô¹\.?\s?Ô±\.?|Õ\.?\s?Ô¹\.?|Õ\.?\s?Õ\.?)/i,
  wide: /^(ÖÖÕ«Õ½Õ¿Õ¸Õ½Õ«Ö Õ¡Õ¼Õ¡Õ»|Õ´Õ¥Ö Õ©Õ¾Õ¡ÖÕ¯Õ¸ÖÕ©ÕµÕ¸ÖÕ¶Õ«Ö Õ¡Õ¼Õ¡Õ»|Õ´Õ¥Ö Õ©Õ¾Õ¡ÖÕ¯Õ¸ÖÕ©ÕµÕ¡Õ¶|ÖÖÕ«Õ½Õ¿Õ¸Õ½Õ«Ö Õ°Õ¥Õ¿Õ¸)/i,
};
const parseEraPatterns$K = {
  any: [/^Ö/i, /^Õ´/i],
};

const matchQuarterPatterns$K = {
  narrow: /^[1234]/i,
  abbreviated: /^Ö[1234]/i,
  wide: /^[1234]((-|Ö)?(Õ«Õ¶|ÖÕ¤)) ÖÕ¡Õ¼Õ¸ÖÕ¤/i,
};
const parseQuarterPatterns$K = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$K = {
  narrow: /^[Õ°ÖÕ´Õ¡ÖÕ½Õ¶Õ¤]/i,
  abbreviated: /^(Õ°Õ¸ÖÕ¶|ÖÕ¥Õ¿|Õ´Õ¡Ö|Õ¡ÕºÖ|Õ´Õ¡Õµ|Õ°Õ¸ÖÕ¶|Õ°Õ¸ÖÕ¬|ÖÕ£Õ½|Õ½Õ¥Õº|Õ°Õ¸Õ¯|Õ¶Õ¸Õµ|Õ¤Õ¥Õ¯)/i,
  wide: /^(Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö|ÖÕ¥Õ¿ÖÕ¾Õ¡Ö|Õ´Õ¡ÖÕ¿|Õ¡ÕºÖÕ«Õ¬|Õ´Õ¡ÕµÕ«Õ½|Õ°Õ¸ÖÕ¶Õ«Õ½|Õ°Õ¸ÖÕ¬Õ«Õ½|ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½|Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö|Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö|Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö|Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö)/i,
};
const parseMonthPatterns$K = {
  narrow: [
    /^Õ°/i,
    /^Ö/i,
    /^Õ´/i,
    /^Õ¡/i,
    /^Õ´/i,
    /^Õ°/i,
    /^Õ°/i,
    /^Ö/i,
    /^Õ½/i,
    /^Õ°/i,
    /^Õ¶/i,
    /^Õ¤/i,
  ],

  any: [
    /^Õ°Õ¸Ö/i,
    /^Ö/i,
    /^Õ´Õ¡Ö/i,
    /^Õ¡/i,
    /^Õ´Õ¡Õµ/i,
    /^Õ°Õ¸ÖÕ¶/i,
    /^Õ°Õ¸ÖÕ¬/i,
    /^Ö/i,
    /^Õ½/i,
    /^Õ°Õ¸Õ¯/i,
    /^Õ¶/i,
    /^Õ¤/i,
  ],
};

const matchDayPatterns$K = {
  narrow: /^[Õ¥Õ¹Õ°Õ¸Õ·Õ¯]/i,
  short: /^(Õ¯Ö|Õ¥Ö|Õ¥Ö|Õ¹Ö|Õ°Õ£|Õ¸ÖÖ|Õ·Õ¢)/i,
  abbreviated: /^(Õ¯Õ«Ö|Õ¥ÖÕ¯|Õ¥ÖÖ|Õ¹Õ¸Ö|Õ°Õ¶Õ£|Õ¸ÖÖÕ¢|Õ·Õ¡Õ¢)/i,
  wide: /^(Õ¯Õ«ÖÕ¡Õ¯Õ«|Õ¥ÖÕ¯Õ¸ÖÕ·Õ¡Õ¢Õ©Õ«|Õ¥ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«|Õ¹Õ¸ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«|Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ«|Õ¸ÖÖÕ¢Õ¡Õ©|Õ·Õ¡Õ¢Õ¡Õ©)/i,
};
const parseDayPatterns$K = {
  narrow: [/^Õ¯/i, /^Õ¥/i, /^Õ¥/i, /^Õ¹/i, /^Õ°/i, /^(Õ¸|Õ)/, /^Õ·/i],
  short: [/^Õ¯/i, /^Õ¥Ö/i, /^Õ¥Ö/i, /^Õ¹/i, /^Õ°/i, /^(Õ¸|Õ)/, /^Õ·/i],
  abbreviated: [/^Õ¯/i, /^Õ¥ÖÕ¯/i, /^Õ¥ÖÖ/i, /^Õ¹/i, /^Õ°/i, /^(Õ¸|Õ)/, /^Õ·/i],

  wide: [/^Õ¯/i, /^Õ¥ÖÕ¯/i, /^Õ¥ÖÕ¥/i, /^Õ¹/i, /^Õ°/i, /^(Õ¸|Õ)/, /^Õ·/i],
};

const matchDayPeriodPatterns$K = {
  narrow: /^([ap]|Õ¯Õ¥Õ½Õ£Õ·|Õ¯Õ¥Õ½ÖÖ|(Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¨?|ÖÕ¥ÖÕ¥Õ¯Õ¨?|Õ¥ÖÕ¥Õ¯Õ¸(ÕµÕ¡Õ¶)?|Õ£Õ«Õ·Õ¥ÖÕ¨?))/i,
  any: /^([ap]\.?\s?m\.?|Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥Ö(Õ«Õ¶)?|Õ¯Õ¥Õ½ÖÖ(Õ«Õ¶)?|(Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¨?|ÖÕ¥ÖÕ¥Õ¯Õ¨?|Õ¥ÖÕ¥Õ¯Õ¸(ÕµÕ¡Õ¶)?|Õ£Õ«Õ·Õ¥ÖÕ¨?))/i,
};
const parseDayPeriodPatterns$K = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /Õ¯Õ¥Õ½Õ£Õ«Õ·Õ¥Ö/i,
    noon: /Õ¯Õ¥Õ½ÖÖ/i,
    morning: /Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿/i,
    afternoon: /ÖÕ¥ÖÕ¥Õ¯/i,
    evening: /Õ¥ÖÕ¥Õ¯Õ¸/i,
    night: /Õ£Õ«Õ·Õ¥Ö/i,
  },
};

(match$K.match = {
  ordinalNumber: (0, _index2$31.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$K,
    parsePattern: parseOrdinalNumberPattern$K,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6X.buildMatchFn)({
    matchPatterns: matchEraPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$K,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6X.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$K,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6X.buildMatchFn)({
    matchPatterns: matchMonthPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$K,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6X.buildMatchFn)({
    matchPatterns: matchDayPatterns$K,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$K,
    defaultParseWidth: "wide",
  }),

  dayPeriod: (0, _index$6X.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$K,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$K,
    defaultParseWidth: "any",
  }),
});

hy.hy = void 0;
var _index$6W = formatDistance$1v;
var _index2$30 = formatLong$L;
var _index3$1x = formatRelative$1v;
var _index4$11 = localize$K;
var _index5$U = match$K;

/**
 * @category Locales
 * @summary Armenian locale
 * @language Armenian
 * @iso-639-2 arm
 * @author Alex Igityan [@alexigityan](https://github.com/alexigityan)
 */
(hy.hy = {
  code: "hy",
  formatDistance: _index$6W.formatDistance,
  formatLong: _index2$30.formatLong,
  formatRelative: _index3$1x.formatRelative,
  localize: _index4$11.localize,
  match: _index5$U.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var id = {};

var formatDistance$1t = {};

formatDistance$1t.formatDistance = void 0;

const formatDistanceLocale$J = {
  lessThanXSeconds: {
    one: "kurang dari 1 detik",
    other: "kurang dari {{count}} detik",
  },

  xSeconds: {
    one: "1 detik",
    other: "{{count}} detik",
  },

  halfAMinute: "setengah menit",

  lessThanXMinutes: {
    one: "kurang dari 1 menit",
    other: "kurang dari {{count}} menit",
  },

  xMinutes: {
    one: "1 menit",
    other: "{{count}} menit",
  },

  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam",
  },

  xHours: {
    one: "1 jam",
    other: "{{count}} jam",
  },

  xDays: {
    one: "1 hari",
    other: "{{count}} hari",
  },

  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu",
  },

  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu",
  },

  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan",
  },

  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan",
  },

  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun",
  },

  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun",
  },

  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun",
  },

  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun",
  },
};

const formatDistance$1s = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$J[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dalam waktu " + result;
    } else {
      return result + " yang lalu";
    }
  }

  return result;
};
formatDistance$1t.formatDistance = formatDistance$1s;

var formatLong$K = {};

formatLong$K.formatLong = void 0;
var _index$6V = buildFormatLongFn$1;

const dateFormats$K = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy",
};

const timeFormats$K = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm",
};

const dateTimeFormats$K = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$K.formatLong = {
  date: (0, _index$6V.buildFormatLongFn)({
    formats: dateFormats$K,
    defaultWidth: "full",
  }),

  time: (0, _index$6V.buildFormatLongFn)({
    formats: timeFormats$K,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6V.buildFormatLongFn)({
    formats: dateTimeFormats$K,
    defaultWidth: "full",
  }),
});

var formatRelative$1t = {};

formatRelative$1t.formatRelative = void 0;

const formatRelativeLocale$J = {
  lastWeek: "eeee 'lalu pukul' p",
  yesterday: "'Kemarin pukul' p",
  today: "'Hari ini pukul' p",
  tomorrow: "'Besok pukul' p",
  nextWeek: "eeee 'pukul' p",
  other: "P",
};

const formatRelative$1s = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$J[token];
formatRelative$1t.formatRelative = formatRelative$1s;

var localize$J = {};

localize$J.localize = void 0;
var _index$6U = buildLocalizeFn$1;

// All data for localization are taken from this page
// https://www.unicode.org/cldr/charts/32/summary/id.html
const eraValues$J = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masehi", "Masehi"],
};

const quarterValues$J = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["Kuartal ke-1", "Kuartal ke-2", "Kuartal ke-3", "Kuartal ke-4"],
};

// Note: in Indonesian, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$J = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Agt",
    "Sep",
    "Okt",
    "Nov",
    "Des",
  ],

  wide: [
    "Januari",
    "Februari",
    "Maret",
    "April",
    "Mei",
    "Juni",
    "Juli",
    "Agustus",
    "September",
    "Oktober",
    "November",
    "Desember",
  ],
};

const dayValues$J = {
  narrow: ["M", "S", "S", "R", "K", "J", "S"],
  short: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  abbreviated: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  wide: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
};

const dayPeriodValues$J = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
};

const formattingDayPeriodValues$B = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam",
  },
};

const ordinalNumber$J = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // Can't use "pertama", "kedua" because can't be parsed

  return "ke-" + number;
};

(localize$J.localize = {
  ordinalNumber: ordinalNumber$J,

  era: (0, _index$6U.buildLocalizeFn)({
    values: eraValues$J,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6U.buildLocalizeFn)({
    values: quarterValues$J,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6U.buildLocalizeFn)({
    values: monthValues$J,
    defaultWidth: "wide",
  }),

  day: (0, _index$6U.buildLocalizeFn)({
    values: dayValues$J,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6U.buildLocalizeFn)({
    values: dayPeriodValues$J,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$B,
    defaultFormattingWidth: "wide",
  }),
});

var match$J = {};

match$J.match = void 0;

var _index$6T = buildMatchFn$1;
var _index2$2$ = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$J = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$J = /\d+/i;

const matchEraPatterns$J = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
  wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i,
};
const parseEraPatterns$J = {
  any: [/^s/i, /^(m|e)/i],
};

const matchQuarterPatterns$J = {
  narrow: /^[1234]/i,
  abbreviated: /^K-?\s[1234]/i,
  wide: /^Kuartal ke-?\s?[1234]/i,
};
const parseQuarterPatterns$J = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$J = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
  wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i,
};
const parseMonthPatterns$J = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$J = {
  narrow: /^[srkjm]/i,
  short: /^(min|sen|sel|rab|kam|jum|sab)/i,
  abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
  wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i,
};
const parseDayPatterns$J = {
  narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i],
};

const matchDayPeriodPatterns$J = {
  narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
};
const parseDayPeriodPatterns$J = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pagi/i,
    afternoon: /siang/i,
    evening: /sore/i,
    night: /malam/i,
  },
};

(match$J.match = {
  ordinalNumber: (0, _index2$2$.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$J,
    parsePattern: parseOrdinalNumberPattern$J,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6T.buildMatchFn)({
    matchPatterns: matchEraPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$J,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6T.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$J,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6T.buildMatchFn)({
    matchPatterns: matchMonthPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$J,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6T.buildMatchFn)({
    matchPatterns: matchDayPatterns$J,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$J,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6T.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$J,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$J,
    defaultParseWidth: "any",
  }),
});

id.id = void 0;
var _index$6S = formatDistance$1t;
var _index2$2_ = formatLong$K;
var _index3$1w = formatRelative$1t;
var _index4$10 = localize$J;
var _index5$T = match$J;

/**
 * @category Locales
 * @summary Indonesian locale.
 * @language Indonesian
 * @iso-639-2 ind
 * @author Rahmat Budiharso [@rbudiharso](https://github.com/rbudiharso)
 * @author Benget Nata [@bentinata](https://github.com/bentinata)
 * @author Budi Irawan [@deerawan](https://github.com/deerawan)
 * @author Try Ajitiono [@imballinst](https://github.com/imballinst)
 */
(id.id = {
  code: "id",
  formatDistance: _index$6S.formatDistance,
  formatLong: _index2$2_.formatLong,
  formatRelative: _index3$1w.formatRelative,
  localize: _index4$10.localize,
  match: _index5$T.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var is = {};

var formatDistance$1r = {};

formatDistance$1r.formatDistance = void 0;

const formatDistanceLocale$I = {
  lessThanXSeconds: {
    one: "minna en 1 sekÃºnda",
    other: "minna en {{count}} sekÃºndur",
  },

  xSeconds: {
    one: "1 sekÃºnda",
    other: "{{count}} sekÃºndur",
  },

  halfAMinute: "hÃ¡lf mÃ­nÃºta",

  lessThanXMinutes: {
    one: "minna en 1 mÃ­nÃºta",
    other: "minna en {{count}} mÃ­nÃºtur",
  },

  xMinutes: {
    one: "1 mÃ­nÃºta",
    other: "{{count}} mÃ­nÃºtur",
  },

  aboutXHours: {
    one: "u.Ã¾.b. 1 klukkustund",
    other: "u.Ã¾.b. {{count}} klukkustundir",
  },

  xHours: {
    one: "1 klukkustund",
    other: "{{count}} klukkustundir",
  },

  xDays: {
    one: "1 dagur",
    other: "{{count}} dagar",
  },

  aboutXWeeks: {
    one: "um viku",
    other: "um {{count}} vikur",
  },

  xWeeks: {
    one: "1 viku",
    other: "{{count}} vikur",
  },

  aboutXMonths: {
    one: "u.Ã¾.b. 1 mÃ¡nuÃ°ur",
    other: "u.Ã¾.b. {{count}} mÃ¡nuÃ°ir",
  },

  xMonths: {
    one: "1 mÃ¡nuÃ°ur",
    other: "{{count}} mÃ¡nuÃ°ir",
  },

  aboutXYears: {
    one: "u.Ã¾.b. 1 Ã¡r",
    other: "u.Ã¾.b. {{count}} Ã¡r",
  },

  xYears: {
    one: "1 Ã¡r",
    other: "{{count}} Ã¡r",
  },

  overXYears: {
    one: "meira en 1 Ã¡r",
    other: "meira en {{count}} Ã¡r",
  },

  almostXYears: {
    one: "nÃ¦stum 1 Ã¡r",
    other: "nÃ¦stum {{count}} Ã¡r",
  },
};

const formatDistance$1q = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$I[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ã­ " + result;
    } else {
      return result + " sÃ­Ã°an";
    }
  }

  return result;
};
formatDistance$1r.formatDistance = formatDistance$1q;

var formatLong$J = {};

formatLong$J.formatLong = void 0;
var _index$6R = buildFormatLongFn$1;

const dateFormats$J = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "d.MM.y",
};

const timeFormats$J = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$J = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$J.formatLong = {
  date: (0, _index$6R.buildFormatLongFn)({
    formats: dateFormats$J,
    defaultWidth: "full",
  }),

  time: (0, _index$6R.buildFormatLongFn)({
    formats: timeFormats$J,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6R.buildFormatLongFn)({
    formats: dateTimeFormats$J,
    defaultWidth: "full",
  }),
});

var formatRelative$1r = {};

formatRelative$1r.formatRelative = void 0;

const formatRelativeLocale$I = {
  lastWeek: "'sÃ­Ã°asta' dddd 'kl.' p",
  yesterday: "'Ã­ gÃ¦r kl.' p",
  today: "'Ã­ dag kl.' p",
  tomorrow: "'Ã¡ morgun kl.' p",
  nextWeek: "dddd 'kl.' p",
  other: "P",
};

const formatRelative$1q = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$I[token];
formatRelative$1r.formatRelative = formatRelative$1q;

var localize$I = {};

localize$I.localize = void 0;
var _index$6Q = buildLocalizeFn$1;

const eraValues$I = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fyrir Krist", "eftir Krist"],
};

const quarterValues$I = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1F", "2F", "3F", "4F"],
  wide: ["1. fjÃ³rÃ°ungur", "2. fjÃ³rÃ°ungur", "3. fjÃ³rÃ°ungur", "4. fjÃ³rÃ°ungur"],
};

const monthValues$I = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "Ã", "S", "Ã", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "aprÃ­l",
    "maÃ­",
    "jÃºnÃ­",
    "jÃºlÃ­",
    "Ã¡gÃºst",
    "sept.",
    "okt.",
    "nÃ³v.",
    "des.",
  ],

  wide: [
    "janÃºar",
    "febrÃºar",
    "mars",
    "aprÃ­l",
    "maÃ­",
    "jÃºnÃ­",
    "jÃºlÃ­",
    "Ã¡gÃºst",
    "september",
    "oktÃ³ber",
    "nÃ³vember",
    "desember",
  ],
};

const dayValues$I = {
  narrow: ["S", "M", "Ã", "M", "F", "F", "L"],
  short: ["Su", "MÃ¡", "Ãr", "Mi", "Fi", "FÃ¶", "La"],
  abbreviated: ["sun.", "mÃ¡n.", "Ã¾ri.", "miÃ°.", "fim.", "fÃ¶s.", "lau."],

  wide: [
    "sunnudagur",
    "mÃ¡nudagur",
    "Ã¾riÃ°judagur",
    "miÃ°vikudagur",
    "fimmtudagur",
    "fÃ¶studagur",
    "laugardagur",
  ],
};

const dayPeriodValues$I = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: "miÃ°nÃ¦tti",
    noon: "hÃ¡degi",
    morning: "morgunn",
    afternoon: "sÃ­Ã°degi",
    evening: "kvÃ¶ld",
    night: "nÃ³tt",
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: "miÃ°nÃ¦tti",
    noon: "hÃ¡degi",
    morning: "morgunn",
    afternoon: "sÃ­Ã°degi",
    evening: "kvÃ¶ld",
    night: "nÃ³tt",
  },
  wide: {
    am: "fyrir hÃ¡degi",
    pm: "eftir hÃ¡degi",
    midnight: "miÃ°nÃ¦tti",
    noon: "hÃ¡degi",
    morning: "morgunn",
    afternoon: "sÃ­Ã°degi",
    evening: "kvÃ¶ld",
    night: "nÃ³tt",
  },
};

const formattingDayPeriodValues$A = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: "Ã¡ miÃ°nÃ¦tti",
    noon: "Ã¡ hÃ¡degi",
    morning: "aÃ° morgni",
    afternoon: "sÃ­Ã°degis",
    evening: "um kvÃ¶ld",
    night: "um nÃ³tt",
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: "Ã¡ miÃ°nÃ¦tti",
    noon: "Ã¡ hÃ¡degi",
    morning: "aÃ° morgni",
    afternoon: "sÃ­Ã°degis",
    evening: "um kvÃ¶ld",
    night: "um nÃ³tt",
  },
  wide: {
    am: "fyrir hÃ¡degi",
    pm: "eftir hÃ¡degi",
    midnight: "Ã¡ miÃ°nÃ¦tti",
    noon: "Ã¡ hÃ¡degi",
    morning: "aÃ° morgni",
    afternoon: "sÃ­Ã°degis",
    evening: "um kvÃ¶ld",
    night: "um nÃ³tt",
  },
};

const ordinalNumber$I = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  return number + ".";
};

(localize$I.localize = {
  ordinalNumber: ordinalNumber$I,

  era: (0, _index$6Q.buildLocalizeFn)({
    values: eraValues$I,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6Q.buildLocalizeFn)({
    values: quarterValues$I,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6Q.buildLocalizeFn)({
    values: monthValues$I,
    defaultWidth: "wide",
  }),

  day: (0, _index$6Q.buildLocalizeFn)({
    values: dayValues$I,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6Q.buildLocalizeFn)({
    values: dayPeriodValues$I,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$A,
    defaultFormattingWidth: "wide",
  }),
});

var match$I = {};

match$I.match = void 0;

var _index$6P = buildMatchFn$1;
var _index2$2Z = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$I = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$I = /\d+(\.)?/i;

const matchEraPatterns$I = {
  narrow: /^(f\.Kr\.|e\.Kr\.)/i,
  abbreviated: /^(f\.Kr\.|e\.Kr\.)/i,
  wide: /^(fyrir Krist|eftir Krist)/i,
};
const parseEraPatterns$I = {
  any: [/^(f\.Kr\.)/i, /^(e\.Kr\.)/i],
};

const matchQuarterPatterns$I = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^q[1234]\.?/i,
  wide: /^[1234]\.? fjÃ³rÃ°ungur/i,
};
const parseQuarterPatterns$I = {
  any: [/1\.?/i, /2\.?/i, /3\.?/i, /4\.?/i],
};

const matchMonthPatterns$I = {
  narrow: /^[jfmÃ¡sÃ³nd]/i,
  abbreviated:
    /^(jan\.|feb\.|mars\.|aprÃ­l\.|maÃ­|jÃºnÃ­|jÃºlÃ­|Ã¡gust|sep\.|oct\.|nov\.|dec\.)/i,
  wide: /^(januar|febrÃºar|mars|aprÃ­l|maÃ­|jÃºnÃ­|jÃºlÃ­|Ã¡gust|september|oktÃ³ber|nÃ³vember|desember)/i,
};

const parseMonthPatterns$I = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^Ã¡/i,
    /^s/i,
    /^Ã³/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maÃ­/i,
    /^jÃºn/i,
    /^jÃºl/i,
    /^Ã¡u/i,
    /^s/i,
    /^Ã³/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$I = {
  narrow: /^[smtwf]/i,
  short: /^(su|mÃ¡|Ã¾r|mi|fi|fÃ¶|la)/i,
  abbreviated: /^(sun|mÃ¡n|Ã¾ri|miÃ°|fim|fÃ¶s|lau)\.?/i,
  wide: /^(sunnudagur|mÃ¡nudagur|Ã¾riÃ°judagur|miÃ°vikudagur|fimmtudagur|fÃ¶studagur|laugardagur)/i,
};
const parseDayPatterns$I = {
  narrow: [/^s/i, /^m/i, /^Ã¾/i, /^m/i, /^f/i, /^f/i, /^l/i],
  any: [/^su/i, /^mÃ¡/i, /^Ã¾r/i, /^mi/i, /^fi/i, /^fÃ¶/i, /^la/i],
};

const matchDayPeriodPatterns$I = {
  narrow: /^(f|e|sÃ­Ã°degis|(Ã¡|aÃ°|um) (morgni|kvÃ¶ld|nÃ³tt|miÃ°nÃ¦tti))/i,
  any: /^(fyrir hÃ¡degi|eftir hÃ¡degi|[ef]\.?h\.?|sÃ­Ã°degis|morgunn|(Ã¡|aÃ°|um) (morgni|kvÃ¶ld|nÃ³tt|miÃ°nÃ¦tti))/i,
};
const parseDayPeriodPatterns$I = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^mi/i,
    noon: /^hÃ¡/i,
    morning: /morgunn/i,
    afternoon: /sÃ­Ã°degi/i,
    evening: /kvÃ¶ld/i,
    night: /nÃ³tt/i,
  },
};

(match$I.match = {
  ordinalNumber: (0, _index2$2Z.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$I,
    parsePattern: parseOrdinalNumberPattern$I,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6P.buildMatchFn)({
    matchPatterns: matchEraPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$I,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6P.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$I,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6P.buildMatchFn)({
    matchPatterns: matchMonthPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$I,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6P.buildMatchFn)({
    matchPatterns: matchDayPatterns$I,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$I,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6P.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$I,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$I,
    defaultParseWidth: "any",
  }),
});

is.is = void 0;
var _index$6O = formatDistance$1r;
var _index2$2Y = formatLong$J;
var _index3$1v = formatRelative$1r;
var _index4$$ = localize$I;
var _index5$S = match$I;

/**
 * @category Locales
 * @summary Icelandic locale.
 * @language Icelandic
 * @iso-639-2 isl
 * @author Derek Blank [@derekblank](https://github.com/derekblank)
 * @author ArnÃ³r Ãmir [@lamayg](https://github.com/lamayg)
 */
(is.is = {
  code: "is",
  formatDistance: _index$6O.formatDistance,
  formatLong: _index2$2Y.formatLong,
  formatRelative: _index3$1v.formatRelative,
  localize: _index4$$.localize,
  match: _index5$S.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var it = {};

var formatDistance$1p = {};

formatDistance$1p.formatDistance = void 0;

const formatDistanceLocale$H = {
  lessThanXSeconds: {
    one: "meno di un secondo",
    other: "meno di {{count}} secondi",
  },

  xSeconds: {
    one: "un secondo",
    other: "{{count}} secondi",
  },

  halfAMinute: "alcuni secondi",

  lessThanXMinutes: {
    one: "meno di un minuto",
    other: "meno di {{count}} minuti",
  },

  xMinutes: {
    one: "un minuto",
    other: "{{count}} minuti",
  },

  aboutXHours: {
    one: "circa un'ora",
    other: "circa {{count}} ore",
  },

  xHours: {
    one: "un'ora",
    other: "{{count}} ore",
  },

  xDays: {
    one: "un giorno",
    other: "{{count}} giorni",
  },

  aboutXWeeks: {
    one: "circa una settimana",
    other: "circa {{count}} settimane",
  },

  xWeeks: {
    one: "una settimana",
    other: "{{count}} settimane",
  },

  aboutXMonths: {
    one: "circa un mese",
    other: "circa {{count}} mesi",
  },

  xMonths: {
    one: "un mese",
    other: "{{count}} mesi",
  },

  aboutXYears: {
    one: "circa un anno",
    other: "circa {{count}} anni",
  },

  xYears: {
    one: "un anno",
    other: "{{count}} anni",
  },

  overXYears: {
    one: "piÃ¹ di un anno",
    other: "piÃ¹ di {{count}} anni",
  },

  almostXYears: {
    one: "quasi un anno",
    other: "quasi {{count}} anni",
  },
};

const formatDistance$1o = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$H[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "tra " + result;
    } else {
      return result + " fa";
    }
  }

  return result;
};
formatDistance$1p.formatDistance = formatDistance$1o;

var formatLong$I = {};

formatLong$I.formatLong = void 0;
var _index$6N = buildFormatLongFn$1;

const dateFormats$I = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$I = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$I = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$I.formatLong = {
  date: (0, _index$6N.buildFormatLongFn)({
    formats: dateFormats$I,
    defaultWidth: "full",
  }),

  time: (0, _index$6N.buildFormatLongFn)({
    formats: timeFormats$I,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6N.buildFormatLongFn)({
    formats: dateTimeFormats$I,
    defaultWidth: "full",
  }),
});

var formatRelative$1p = {};

formatRelative$1p.formatRelative = void 0;
var _index$6M = isSameWeek$1;

const weekdays$2 = [
  "domenica",
  "lunedÃ¬",
  "martedÃ¬",
  "mercoledÃ¬",
  "giovedÃ¬",
  "venerdÃ¬",
  "sabato",
];

function lastWeek$5(day) {
  switch (day) {
    case 0:
      return "'domenica scorsa alle' p";
    default:
      return "'" + weekdays$2[day] + " scorso alle' p";
  }
}

function thisWeek$5(day) {
  return "'" + weekdays$2[day] + " alle' p";
}

function nextWeek$5(day) {
  switch (day) {
    case 0:
      return "'domenica prossima alle' p";
    default:
      return "'" + weekdays$2[day] + " prossimo alle' p";
  }
}

const formatRelativeLocale$H = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$6M.isSameWeek)(date, baseDate, options)) {
      return thisWeek$5(day);
    } else {
      return lastWeek$5(day);
    }
  },
  yesterday: "'ieri alle' p",
  today: "'oggi alle' p",
  tomorrow: "'domani alle' p",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$6M.isSameWeek)(date, baseDate, options)) {
      return thisWeek$5(day);
    } else {
      return nextWeek$5(day);
    }
  },
  other: "P",
};

const formatRelative$1o = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$H[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$1p.formatRelative = formatRelative$1o;

var localize$H = {};

localize$H.localize = void 0;
var _index$6L = buildLocalizeFn$1;

const eraValues$H = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["avanti Cristo", "dopo Cristo"],
};

const quarterValues$H = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1Âº trimestre", "2Âº trimestre", "3Âº trimestre", "4Âº trimestre"],
};

const monthValues$H = {
  narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "gen",
    "feb",
    "mar",
    "apr",
    "mag",
    "giu",
    "lug",
    "ago",
    "set",
    "ott",
    "nov",
    "dic",
  ],

  wide: [
    "gennaio",
    "febbraio",
    "marzo",
    "aprile",
    "maggio",
    "giugno",
    "luglio",
    "agosto",
    "settembre",
    "ottobre",
    "novembre",
    "dicembre",
  ],
};

const dayValues$H = {
  narrow: ["D", "L", "M", "M", "G", "V", "S"],
  short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  wide: [
    "domenica",
    "lunedÃ¬",
    "martedÃ¬",
    "mercoledÃ¬",
    "giovedÃ¬",
    "venerdÃ¬",
    "sabato",
  ],
};

const dayPeriodValues$H = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte",
  },
};

const formattingDayPeriodValues$z = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte",
  },
};

const ordinalNumber$H = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return String(number);
};

(localize$H.localize = {
  ordinalNumber: ordinalNumber$H,

  era: (0, _index$6L.buildLocalizeFn)({
    values: eraValues$H,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6L.buildLocalizeFn)({
    values: quarterValues$H,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6L.buildLocalizeFn)({
    values: monthValues$H,
    defaultWidth: "wide",
  }),

  day: (0, _index$6L.buildLocalizeFn)({
    values: dayValues$H,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6L.buildLocalizeFn)({
    values: dayPeriodValues$H,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$z,
    defaultFormattingWidth: "wide",
  }),
});

var match$H = {};

match$H.match = void 0;

var _index$6K = buildMatchFn$1;
var _index2$2X = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$H = /^(\d+)(Âº)?/i;
const parseOrdinalNumberPattern$H = /\d+/i;

const matchEraPatterns$H = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
  wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i,
};
const parseEraPatterns$H = {
  any: [/^a/i, /^(d|e)/i],
};

const matchQuarterPatterns$H = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](Âº)? trimestre/i,
};
const parseQuarterPatterns$H = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$H = {
  narrow: /^[gfmalsond]/i,
  abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
  wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i,
};
const parseMonthPatterns$H = {
  narrow: [
    /^g/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^g/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ge/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mag/i,
    /^gi/i,
    /^l/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$H = {
  narrow: /^[dlmgvs]/i,
  short: /^(do|lu|ma|me|gi|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
  wide: /^(domenica|luned[i|Ã¬]|marted[i|Ã¬]|mercoled[i|Ã¬]|gioved[i|Ã¬]|venerd[i|Ã¬]|sabato)/i,
};
const parseDayPatterns$H = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i],
};

const matchDayPeriodPatterns$H = {
  narrow:
    /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
  any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
};
const parseDayPeriodPatterns$H = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mezza/i,
    noon: /^mezzo/i,
    morning: /mattina/i,
    afternoon: /pomeriggio/i,
    evening: /sera/i,
    night: /notte/i,
  },
};

(match$H.match = {
  ordinalNumber: (0, _index2$2X.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$H,
    parsePattern: parseOrdinalNumberPattern$H,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6K.buildMatchFn)({
    matchPatterns: matchEraPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$H,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6K.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$H,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6K.buildMatchFn)({
    matchPatterns: matchMonthPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$H,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6K.buildMatchFn)({
    matchPatterns: matchDayPatterns$H,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$H,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6K.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$H,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$H,
    defaultParseWidth: "any",
  }),
});

it.it = void 0;
var _index$6J = formatDistance$1p;
var _index2$2W = formatLong$I;
var _index3$1u = formatRelative$1p;
var _index4$_ = localize$H;
var _index5$R = match$H;

/**
 * @category Locales
 * @summary Italian locale.
 * @language Italian
 * @iso-639-2 ita
 * @author Alberto Restifo [@albertorestifo](https://github.com/albertorestifo)
 * @author Giovanni Polimeni [@giofilo](https://github.com/giofilo)
 * @author Vincenzo Carrese [@vin-car](https://github.com/vin-car)
 */
(it.it = {
  code: "it",
  formatDistance: _index$6J.formatDistance,
  formatLong: _index2$2W.formatLong,
  formatRelative: _index3$1u.formatRelative,
  localize: _index4$_.localize,
  match: _index5$R.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var itCH = {};

var formatLong$H = {};

formatLong$H.formatLong = void 0;
var _index$6I = buildFormatLongFn$1;

const dateFormats$H = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y",
};

const timeFormats$H = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$H = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$H.formatLong = {
  date: (0, _index$6I.buildFormatLongFn)({
    formats: dateFormats$H,
    defaultWidth: "full",
  }),

  time: (0, _index$6I.buildFormatLongFn)({
    formats: timeFormats$H,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6I.buildFormatLongFn)({
    formats: dateTimeFormats$H,
    defaultWidth: "full",
  }),
});

itCH.itCH = void 0;
var _index$6H = formatDistance$1p;
var _index2$2V = formatRelative$1p;
var _index3$1t = localize$H;
var _index4$Z = match$H;
var _index5$Q = formatLong$H;

/**
 * @category Locales
 * @summary Italian locale (Switzerland).
 * @language Italian
 * @iso-639-2 ita
 * @author Mike Peyer [@maic66](https://github.com/maic66)
 */
(itCH.itCH = {
  code: "it-CH",
  formatDistance: _index$6H.formatDistance,
  formatLong: _index5$Q.formatLong,
  formatRelative: _index2$2V.formatRelative,
  localize: _index3$1t.localize,
  match: _index4$Z.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var ja = {};

var formatDistance$1n = {};

formatDistance$1n.formatDistance = void 0;

const formatDistanceLocale$G = {
  lessThanXSeconds: {
    one: "1ç§æªæº",
    other: "{{count}}ç§æªæº",
    oneWithSuffix: "ç´1ç§",
    otherWithSuffix: "ç´{{count}}ç§",
  },

  xSeconds: {
    one: "1ç§",
    other: "{{count}}ç§",
  },

  halfAMinute: "30ç§",

  lessThanXMinutes: {
    one: "1åæªæº",
    other: "{{count}}åæªæº",
    oneWithSuffix: "ç´1å",
    otherWithSuffix: "ç´{{count}}å",
  },

  xMinutes: {
    one: "1å",
    other: "{{count}}å",
  },

  aboutXHours: {
    one: "ç´1æé",
    other: "ç´{{count}}æé",
  },

  xHours: {
    one: "1æé",
    other: "{{count}}æé",
  },

  xDays: {
    one: "1æ¥",
    other: "{{count}}æ¥",
  },

  aboutXWeeks: {
    one: "ç´1é±é",
    other: "ç´{{count}}é±é",
  },

  xWeeks: {
    one: "1é±é",
    other: "{{count}}é±é",
  },

  aboutXMonths: {
    one: "ç´1ãæ",
    other: "ç´{{count}}ãæ",
  },

  xMonths: {
    one: "1ãæ",
    other: "{{count}}ãæ",
  },

  aboutXYears: {
    one: "ç´1å¹´",
    other: "ç´{{count}}å¹´",
  },

  xYears: {
    one: "1å¹´",
    other: "{{count}}å¹´",
  },

  overXYears: {
    one: "1å¹´ä»¥ä¸",
    other: "{{count}}å¹´ä»¥ä¸",
  },

  almostXYears: {
    one: "1å¹´è¿ã",
    other: "{{count}}å¹´è¿ã",
  },
};

const formatDistance$1m = (token, count, options) => {
  options = options || {};

  let result;

  const tokenValue = formatDistanceLocale$G[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }

  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "å¾";
    } else {
      return result + "å";
    }
  }

  return result;
};
formatDistance$1n.formatDistance = formatDistance$1m;

var formatLong$G = {};

formatLong$G.formatLong = void 0;
var _index$6G = buildFormatLongFn$1;

const dateFormats$G = {
  full: "yå¹´Mædæ¥EEEE",
  long: "yå¹´Mædæ¥",
  medium: "y/MM/dd",
  short: "y/MM/dd",
};

const timeFormats$G = {
  full: "Hæmmåssç§ zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$G = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$G.formatLong = {
  date: (0, _index$6G.buildFormatLongFn)({
    formats: dateFormats$G,
    defaultWidth: "full",
  }),

  time: (0, _index$6G.buildFormatLongFn)({
    formats: timeFormats$G,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6G.buildFormatLongFn)({
    formats: dateTimeFormats$G,
    defaultWidth: "full",
  }),
});

var formatRelative$1n = {};

formatRelative$1n.formatRelative = void 0;

const formatRelativeLocale$G = {
  lastWeek: "åé±ã®eeeeã®p",
  yesterday: "æ¨æ¥ã®p",
  today: "ä»æ¥ã®p",
  tomorrow: "ææ¥ã®p",
  nextWeek: "ç¿é±ã®eeeeã®p",
  other: "P",
};

const formatRelative$1m = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$G[token];
};
formatRelative$1n.formatRelative = formatRelative$1m;

var localize$G = {};

localize$G.localize = void 0;
var _index$6F = buildLocalizeFn$1;

const eraValues$G = {
  narrow: ["BC", "AC"],
  abbreviated: ["ç´åå", "è¥¿æ¦"],
  wide: ["ç´åå", "è¥¿æ¦"],
};

const quarterValues$G = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["ç¬¬1ååæ", "ç¬¬2ååæ", "ç¬¬3ååæ", "ç¬¬4ååæ"],
};

const monthValues$G = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],

  abbreviated: [
    "1æ",
    "2æ",
    "3æ",
    "4æ",
    "5æ",
    "6æ",
    "7æ",
    "8æ",
    "9æ",
    "10æ",
    "11æ",
    "12æ",
  ],

  wide: [
    "1æ",
    "2æ",
    "3æ",
    "4æ",
    "5æ",
    "6æ",
    "7æ",
    "8æ",
    "9æ",
    "10æ",
    "11æ",
    "12æ",
  ],
};

const dayValues$G = {
  narrow: ["æ¥", "æ", "ç«", "æ°´", "æ¨", "é", "å"],
  short: ["æ¥", "æ", "ç«", "æ°´", "æ¨", "é", "å"],
  abbreviated: ["æ¥", "æ", "ç«", "æ°´", "æ¨", "é", "å"],
  wide: ["æ¥ææ¥", "æææ¥", "ç«ææ¥", "æ°´ææ¥", "æ¨ææ¥", "éææ¥", "åææ¥"],
};

const dayPeriodValues$G = {
  narrow: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
  abbreviated: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
  wide: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
};
const formattingDayPeriodValues$y = {
  narrow: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
  abbreviated: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
  wide: {
    am: "åå",
    pm: "åå¾",
    midnight: "æ·±å¤",
    noon: "æ­£å",
    morning: "æ",
    afternoon: "åå¾",
    evening: "å¤",
    night: "æ·±å¤",
  },
};

const ordinalNumber$G = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = String(options?.unit);

  switch (unit) {
    case "year":
      return `${number}å¹´`;
    case "quarter":
      return `ç¬¬${number}ååæ`;
    case "month":
      return `${number}æ`;
    case "week":
      return `ç¬¬${number}é±`;
    case "date":
      return `${number}æ¥`;
    case "hour":
      return `${number}æ`;
    case "minute":
      return `${number}å`;
    case "second":
      return `${number}ç§`;
    default:
      return `${number}`;
  }
};

(localize$G.localize = {
  ordinalNumber: ordinalNumber$G,

  era: (0, _index$6F.buildLocalizeFn)({
    values: eraValues$G,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6F.buildLocalizeFn)({
    values: quarterValues$G,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$6F.buildLocalizeFn)({
    values: monthValues$G,
    defaultWidth: "wide",
  }),

  day: (0, _index$6F.buildLocalizeFn)({
    values: dayValues$G,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6F.buildLocalizeFn)({
    values: dayPeriodValues$G,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$y,
    defaultFormattingWidth: "wide",
  }),
});

var match$G = {};

match$G.match = void 0;
var _index$6E = buildMatchPatternFn$1;
var _index2$2U = buildMatchFn$1;

const matchOrdinalNumberPattern$G = /^ç¬¬?\d+(å¹´|ååæ|æ|é±|æ¥|æ|å|ç§)?/i;
const parseOrdinalNumberPattern$G = /\d+/i;

const matchEraPatterns$G = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^(ç´å[åå¾]|è¥¿æ¦)/i,
  wide: /^(ç´å[åå¾]|è¥¿æ¦)/i,
};
const parseEraPatterns$G = {
  narrow: [/^B/i, /^A/i],
  any: [/^(ç´åå)/i, /^(è¥¿æ¦|ç´åå¾)/i],
};

const matchQuarterPatterns$G = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^ç¬¬[1234ä¸äºä¸åï¼ï¼ï¼ï¼]ååæ/i,
};
const parseQuarterPatterns$G = {
  any: [/(1|ä¸|ï¼)/i, /(2|äº|ï¼)/i, /(3|ä¸|ï¼)/i, /(4|å|ï¼)/i],
};

const matchMonthPatterns$G = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])æ/i,
  wide: /^([123456789]|1[012])æ/i,
};
const parseMonthPatterns$G = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/,
  ],
};

const matchDayPatterns$G = {
  narrow: /^[æ¥æç«æ°´æ¨éå]/,
  short: /^[æ¥æç«æ°´æ¨éå]/,
  abbreviated: /^[æ¥æç«æ°´æ¨éå]/,
  wide: /^[æ¥æç«æ°´æ¨éå]ææ¥/,
};
const parseDayPatterns$G = {
  any: [/^æ¥/, /^æ/, /^ç«/, /^æ°´/, /^æ¨/, /^é/, /^å/],
};

const matchDayPeriodPatterns$G = {
  any: /^(AM|PM|åå|åå¾|æ­£å|æ·±å¤|çå¤ä¸­|å¤|æ)/i,
};
const parseDayPeriodPatterns$G = {
  any: {
    am: /^(A|åå)/i,
    pm: /^(P|åå¾)/i,
    midnight: /^æ·±å¤|çå¤ä¸­/i,
    noon: /^æ­£å/i,
    morning: /^æ/i,
    afternoon: /^åå¾/i,
    evening: /^å¤/i,
    night: /^æ·±å¤/i,
  },
};

(match$G.match = {
  ordinalNumber: (0, _index$6E.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$G,
    parsePattern: parseOrdinalNumberPattern$G,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index2$2U.buildMatchFn)({
    matchPatterns: matchEraPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$G,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index2$2U.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$G,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index2$2U.buildMatchFn)({
    matchPatterns: matchMonthPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$G,
    defaultParseWidth: "any",
  }),

  day: (0, _index2$2U.buildMatchFn)({
    matchPatterns: matchDayPatterns$G,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$G,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index2$2U.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$G,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$G,
    defaultParseWidth: "any",
  }),
});

ja.ja = void 0;
var _index$6D = formatDistance$1n;
var _index2$2T = formatLong$G;
var _index3$1s = formatRelative$1n;
var _index4$Y = localize$G;
var _index5$P = match$G;

/**
 * @category Locales
 * @summary Japanese locale.
 * @language Japanese
 * @iso-639-2 jpn
 * @author Thomas Eilmsteiner [@DeMuu](https://github.com/DeMuu)
 * @author Yamagishi Kazutoshi [@ykzts](https://github.com/ykzts)
 * @author Luca Ban [@mesqueeb](https://github.com/mesqueeb)
 * @author Terrence Lam [@skyuplam](https://github.com/skyuplam)
 * @author Taiki IKeda [@so99ynoodles](https://github.com/so99ynoodles)
 */
(ja.ja = {
  code: "ja",
  formatDistance: _index$6D.formatDistance,
  formatLong: _index2$2T.formatLong,
  formatRelative: _index3$1s.formatRelative,
  localize: _index4$Y.localize,
  match: _index5$P.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var jaHira = {};

var formatDistance$1l = {};

formatDistance$1l.formatDistance = void 0;

const formatDistanceLocale$F = {
  lessThanXSeconds: {
    one: "1ã³ããã¿ã¾ã",
    other: "{{count}}ã³ããã¿ã¾ã",
    oneWithSuffix: "ãã1ã³ãã",
    otherWithSuffix: "ãã{{count}}ã³ãã",
  },

  xSeconds: {
    one: "1ã³ãã",
    other: "{{count}}ã³ãã",
  },

  halfAMinute: "30ã³ãã",

  lessThanXMinutes: {
    one: "1ã·ãã¿ã¾ã",
    other: "{{count}}ãµãã¿ã¾ã",
    oneWithSuffix: "ãã1ã·ã",
    otherWithSuffix: "ãã{{count}}ãµã",
  },

  xMinutes: {
    one: "1ã·ã",
    other: "{{count}}ãµã",
  },

  aboutXHours: {
    one: "ãã1ããã",
    other: "ãã{{count}}ããã",
  },

  xHours: {
    one: "1ããã",
    other: "{{count}}ããã",
  },

  xDays: {
    one: "1ã«ã¡",
    other: "{{count}}ã«ã¡",
  },

  aboutXWeeks: {
    one: "ãã1ããããã",
    other: "ãã{{count}}ããããã",
  },

  xWeeks: {
    one: "1ããããã",
    other: "{{count}}ããããã",
  },

  aboutXMonths: {
    one: "ãã1ããã¤",
    other: "ãã{{count}}ããã¤",
  },

  xMonths: {
    one: "1ããã¤",
    other: "{{count}}ããã¤",
  },

  aboutXYears: {
    one: "ãã1ã­ã",
    other: "ãã{{count}}ã­ã",
  },

  xYears: {
    one: "1ã­ã",
    other: "{{count}}ã­ã",
  },

  overXYears: {
    one: "1ã­ããããã",
    other: "{{count}}ã­ããããã",
  },

  almostXYears: {
    one: "1ã­ãã¡ãã",
    other: "{{count}}ã­ãã¡ãã",
  },
};

const formatDistance$1k = (token, count, options) => {
  options = options || {};

  let result;

  const tokenValue = formatDistanceLocale$F[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }

  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "ãã¨";
    } else {
      return result + "ã¾ã";
    }
  }

  return result;
};
formatDistance$1l.formatDistance = formatDistance$1k;

var formatLong$F = {};

formatLong$F.formatLong = void 0;
var _index$6C = buildFormatLongFn$1;

const dateFormats$F = {
  full: "yã­ãMãã¤dã«ã¡EEEE",
  long: "yã­ãMãã¤dã«ã¡",
  medium: "y/MM/dd",
  short: "y/MM/dd",
};

const timeFormats$F = {
  full: "Hãmmãµãssã³ãã zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$F = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$F.formatLong = {
  date: (0, _index$6C.buildFormatLongFn)({
    formats: dateFormats$F,
    defaultWidth: "full",
  }),

  time: (0, _index$6C.buildFormatLongFn)({
    formats: timeFormats$F,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6C.buildFormatLongFn)({
    formats: dateTimeFormats$F,
    defaultWidth: "full",
  }),
});

var formatRelative$1l = {};

formatRelative$1l.formatRelative = void 0;

const formatRelativeLocale$F = {
  lastWeek: "ãããããã®eeeeã®p",
  yesterday: "ãã®ãã®p",
  today: "ãããã®p",
  tomorrow: "ãããã®p",
  nextWeek: "ãããããã®eeeeã®p",
  other: "P",
};

const formatRelative$1k = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale$F[token];
};
formatRelative$1l.formatRelative = formatRelative$1k;

var localize$F = {};

localize$F.localize = void 0;

var _index$6B = buildLocalizeFn$1;

const eraValues$F = {
  narrow: ["BC", "AC"],
  abbreviated: ["ããããã", "ãããã"],
  wide: ["ããããã", "ãããã"],
};

const quarterValues$F = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["ã ã1ãã¯ãã", "ã ã2ãã¯ãã", "ã ã3ãã¯ãã", "ã ã4ãã¯ãã"],
};

const monthValues$F = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],

  abbreviated: [
    "1ãã¤",
    "2ãã¤",
    "3ãã¤",
    "4ãã¤",
    "5ãã¤",
    "6ãã¤",
    "7ãã¤",
    "8ãã¤",
    "9ãã¤",
    "10ãã¤",
    "11ãã¤",
    "12ãã¤",
  ],

  wide: [
    "1ãã¤",
    "2ãã¤",
    "3ãã¤",
    "4ãã¤",
    "5ãã¤",
    "6ãã¤",
    "7ãã¤",
    "8ãã¤",
    "9ãã¤",
    "10ãã¤",
    "11ãã¤",
    "12ãã¤",
  ],
};

const dayValues$F = {
  narrow: ["ã«ã¡", "ãã¤", "ã", "ãã", "ãã", "ãã", "ã©"],
  short: ["ã«ã¡", "ãã¤", "ã", "ãã", "ãã", "ãã", "ã©"],
  abbreviated: ["ã«ã¡", "ãã¤", "ã", "ãã", "ãã", "ãã", "ã©"],
  wide: [
    "ã«ã¡ããã³",
    "ãã¤ããã³",
    "ãããã³",
    "ããããã³",
    "ããããã³",
    "ããããã³",
    "ã©ããã³",
  ],
};

const dayPeriodValues$F = {
  narrow: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
  abbreviated: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
  wide: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
};
const formattingDayPeriodValues$x = {
  narrow: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
  abbreviated: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
  wide: {
    am: "ããã",
    pm: "ãã",
    midnight: "ããã",
    noon: "ãããã",
    morning: "ãã",
    afternoon: "ãã",
    evening: "ãã",
    night: "ããã",
  },
};

const ordinalNumber$F = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = String(options?.unit);

  switch (unit) {
    case "year":
      return `${number}ã­ã`;
    case "quarter":
      return `ã ã${number}ãã¯ãã`;
    case "month":
      return `${number}ãã¤`;
    case "week":
      return `ã ã${number}ããã`;
    case "date":
      return `${number}ã«ã¡`;
    case "hour":
      return `${number}ã`;
    case "minute":
      return `${number}ãµã`;
    case "second":
      return `${number}ã³ãã`;
    default:
      return `${number}`;
  }
};

(localize$F.localize = {
  ordinalNumber: ordinalNumber$F,

  era: (0, _index$6B.buildLocalizeFn)({
    values: eraValues$F,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6B.buildLocalizeFn)({
    values: quarterValues$F,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$6B.buildLocalizeFn)({
    values: monthValues$F,
    defaultWidth: "wide",
  }),

  day: (0, _index$6B.buildLocalizeFn)({
    values: dayValues$F,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6B.buildLocalizeFn)({
    values: dayPeriodValues$F,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$x,
    defaultFormattingWidth: "wide",
  }),
});

var match$F = {};

match$F.match = void 0;

var _index$6A = buildMatchFn$1;
var _index2$2S = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$F =
  /^ã ?ã?\d+(ã­ã|ãã¯ãã|ãã¤|ããã|ã«ã¡|ã|ãµã|ã³ãã)?/i;
const parseOrdinalNumberPattern$F = /\d+/i;

const matchEraPatterns$F = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^(ããã[åå¾]|ãããã)/i,
  wide: /^(ããã[åå¾]|ãããã)/i,
};
const parseEraPatterns$F = {
  narrow: [/^B/i, /^A/i],
  any: [/^(ããããã)/i, /^(ãããã|ãããã)/i],
};

const matchQuarterPatterns$F = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^ã ã[1234ä¸äºä¸åï¼ï¼ï¼ï¼]ãã¯ãã/i,
};
const parseQuarterPatterns$F = {
  any: [/(1|ä¸|ï¼)/i, /(2|äº|ï¼)/i, /(3|ä¸|ï¼)/i, /(4|å|ï¼)/i],
};

const matchMonthPatterns$F = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])ãã¤/i,
  wide: /^([123456789]|1[012])ãã¤/i,
};
const parseMonthPatterns$F = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/,
  ],
};

const matchDayPatterns$F = {
  narrow: /^(ã«ã¡|ãã¤|ã|ãã|ãã|ãã|ã©)/,
  short: /^(ã«ã¡|ãã¤|ã|ãã|ãã|ãã|ã©)/,
  abbreviated: /^(ã«ã¡|ãã¤|ã|ãã|ãã|ãã|ã©)/,
  wide: /^(ã«ã¡|ãã¤|ã|ãã|ãã|ãã|ã©)ããã³/,
};
const parseDayPatterns$F = {
  any: [/^ã«ã¡/, /^ãã¤/, /^ã/, /^ãã/, /^ãã/, /^ãã/, /^ã©/],
};

const matchDayPeriodPatterns$F = {
  any: /^(AM|PM|ããã|ãã|ãããã|ããã|ã¾ããªã|ãã|ãã)/i,
};
const parseDayPeriodPatterns$F = {
  any: {
    am: /^(A|ããã)/i,
    pm: /^(P|ãã)/i,
    midnight: /^ããã|ã¾ããªã/i,
    noon: /^ãããã/i,
    morning: /^ãã/i,
    afternoon: /^ãã/i,
    evening: /^ãã/i,
    night: /^ããã/i,
  },
};

(match$F.match = {
  ordinalNumber: (0, _index2$2S.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$F,
    parsePattern: parseOrdinalNumberPattern$F,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index$6A.buildMatchFn)({
    matchPatterns: matchEraPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$F,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6A.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$F,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6A.buildMatchFn)({
    matchPatterns: matchMonthPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$F,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6A.buildMatchFn)({
    matchPatterns: matchDayPatterns$F,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$F,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6A.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$F,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$F,
    defaultParseWidth: "any",
  }),
});

jaHira.jaHira = void 0;
var _index$6z = formatDistance$1l;
var _index2$2R = formatLong$F;
var _index3$1r = formatRelative$1l;
var _index4$X = localize$F;
var _index5$O = match$F;

/**
 * @category Locales
 * @summary Japanese (Hiragana) locale.
 * @language Japanese (Hiragana)
 * @iso-639-2 jpn
 * @author Eri Hiramatsu [@Eritutteo](https://github.com/Eritutteo)
 */
(jaHira.jaHira = {
  code: "ja-Hira",
  formatDistance: _index$6z.formatDistance,
  formatLong: _index2$2R.formatLong,
  formatRelative: _index3$1r.formatRelative,
  localize: _index4$X.localize,
  match: _index5$O.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var ka = {};

var formatDistance$1j = {};

formatDistance$1j.formatDistance = void 0;

const formatDistanceLocale$E = {
  lessThanXSeconds: {
    past: "{{count}} á¬áááá ááááááá á®ááá¡ á¬áá",
    present: "{{count}} á¬áááá ááááááá",
    future: "{{count}} á¬áááá ááááááá¨á",
  },

  xSeconds: {
    past: "{{count}} á¬áááá¡ á¬áá",
    present: "{{count}} á¬ááá",
    future: "{{count}} á¬ááá¨á",
  },

  halfAMinute: {
    past: "ááá®áááá á á¬á£ááá¡ á¬áá",
    present: "ááá®áááá á á¬á£áá",
    future: "ááá®áááá á á¬á£áá¨á",
  },

  lessThanXMinutes: {
    past: "{{count}} á¬á£ááá ááááááá á®ááá¡ á¬áá",
    present: "{{count}} á¬á£ááá ááááááá",
    future: "{{count}} á¬á£ááá ááááááá¨á",
  },

  xMinutes: {
    past: "{{count}} á¬á£ááá¡ á¬áá",
    present: "{{count}} á¬á£áá",
    future: "{{count}} á¬á£áá¨á",
  },

  aboutXHours: {
    past: "áááá®áááááá {{count}} á¡ááááá¡ á¬áá",
    present: "áááá®áááááá {{count}} á¡áááá",
    future: "áááá®áááááá {{count}} á¡áááá¨á",
  },

  xHours: {
    past: "{{count}} á¡ááááá¡ á¬áá",
    present: "{{count}} á¡áááá",
    future: "{{count}} á¡áááá¨á",
  },

  xDays: {
    past: "{{count}} áá¦áá¡ á¬áá",
    present: "{{count}} áá¦á",
    future: "{{count}} áá¦áá¨á",
  },

  aboutXWeeks: {
    past: "áááá®áááááá {{count}} áááá áá¡ á¬áá",
    present: "áááá®áááááá {{count}} áááá á",
    future: "áááá®áááááá {{count}} áááá áá¨á",
  },

  xWeeks: {
    past: "{{count}} áááá áá¡ áááá á",
    present: "{{count}} áááá á",
    future: "{{count}} áááá áá¨á",
  },

  aboutXMonths: {
    past: "áááá®áááááá {{count}} áááá¡ á¬áá",
    present: "áááá®áááááá {{count}} ááá",
    future: "áááá®áááááá {{count}} áááá¨á",
  },

  xMonths: {
    past: "{{count}} áááá¡ á¬áá",
    present: "{{count}} ááá",
    future: "{{count}} áááá¨á",
  },

  aboutXYears: {
    past: "áááá®áááááá {{count}} á¬ááá¡ á¬áá",
    present: "áááá®áááááá {{count}} á¬ááá",
    future: "áááá®áááááá {{count}} á¬ááá¨á",
  },

  xYears: {
    past: "{{count}} á¬ááá¡ á¬áá",
    present: "{{count}} á¬ááá",
    future: "{{count}} á¬ááá¨á",
  },

  overXYears: {
    past: "{{count}} á¬áááá ááá¢á á®ááá¡ á¬áá",
    present: "{{count}} á¬áááá ááá¢á",
    future: "{{count}} á¬áááá ááá¢á á®ááá¡ á¨ááááá",
  },

  almostXYears: {
    past: "áááá¥ááá¡ {{count}} á¬ááá¡ á¬áá",
    present: "áááá¥ááá¡ {{count}} á¬ááá",
    future: "áááá¥ááá¡ {{count}} á¬ááá¨á",
  },
};

const formatDistance$1i = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$E[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (
    options?.addSuffix &&
    options.comparison &&
    options.comparison > 0
  ) {
    result = tokenValue.future.replace("{{count}}", String(count));
  } else if (options?.addSuffix) {
    result = tokenValue.past.replace("{{count}}", String(count));
  } else {
    result = tokenValue.present.replace("{{count}}", String(count));
  }

  return result;
};
formatDistance$1j.formatDistance = formatDistance$1i;

var formatLong$E = {};

formatLong$E.formatLong = void 0;
var _index$6y = buildFormatLongFn$1;

const dateFormats$E = {
  full: "EEEE, do MMMM, y",
  long: "do, MMMM, y",
  medium: "d, MMM, y",
  short: "dd/MM/yyyy",
};

const timeFormats$E = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$E = {
  full: "{{date}} {{time}}'-áá'",
  long: "{{date}} {{time}}'-áá'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$E.formatLong = {
  date: (0, _index$6y.buildFormatLongFn)({
    formats: dateFormats$E,
    defaultWidth: "full",
  }),

  time: (0, _index$6y.buildFormatLongFn)({
    formats: timeFormats$E,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6y.buildFormatLongFn)({
    formats: dateTimeFormats$E,
    defaultWidth: "full",
  }),
});

var formatRelative$1j = {};

formatRelative$1j.formatRelative = void 0;

const formatRelativeLocale$E = {
  lastWeek: "'á¬ááá' eeee p'-áá'",
  yesterday: "'áá£á¨áá' p'-áá'",
  today: "'áá¦áá¡' p'-áá'",
  tomorrow: "'á®ááá' p'-áá'",
  nextWeek: "'á¨áááááá' eeee p'-áá'",
  other: "P",
};

const formatRelative$1i = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$E[token];
formatRelative$1j.formatRelative = formatRelative$1i;

var localize$E = {};

localize$E.localize = void 0;
var _index$6x = buildLocalizeFn$1;

const eraValues$E = {
  narrow: ["á©.á¬-ááá", "á©.á¬"],
  abbreviated: ["á©á.á¬-ááá", "á©á.á¬"],
  wide: ["á©áááá¡ á¬ááááá¦á ááªá®ááááá", "á©áááá á¬ááááá¦á ááªá®ááá"],
};

const quarterValues$E = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-áá áá", "2-á áá", "3-á áá", "4-á áá"],
  wide: ["1-áá áááá á¢ááá", "2-á áááá á¢ááá", "3-á áááá á¢ááá", "4-á áááá á¢ááá"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$E = {
  narrow: [
    "áá",
    "áá",
    "áá",
    "áá",
    "áá¡",
    "áá",
    "áá",
    "áá",
    "á¡á",
    "áá¥",
    "áá",
    "áá",
  ],

  abbreviated: [
    "ááá",
    "ááá",
    "ááá ",
    "ááá ",
    "ááá",
    "ááá",
    "ááá",
    "ááá",
    "á¡áá¥",
    "áá¥á¢",
    "ááá",
    "ááá",
  ],

  wide: [
    "áááááá á",
    "ááááá áááá",
    "ááá á¢á",
    "ááá ááá",
    "áááá¡á",
    "ááááá¡á",
    "ááááá¡á",
    "ááááá¡á¢á",
    "á¡áá¥á¢ááááá á",
    "áá¥á¢ááááá á",
    "ááááááá á",
    "áááááááá á",
  ],
};

const dayValues$E = {
  narrow: ["áá", "áá ", "á¡á", "áá", "á®á£", "áá", "á¨á"],
  short: ["ááá", "áá á¨", "á¡áá", "ááá®", "á®á£á", "ááá ", "á¨áá"],
  abbreviated: ["ááá", "áá á¨", "á¡áá", "ááá®", "á®á£á", "ááá ", "á¨áá"],
  wide: [
    "áááá á",
    "áá á¨ááááá",
    "á¡ááá¨ááááá",
    "ááá®á¨ááááá",
    "á®á£áá¨ááááá",
    "ááá áá¡áááá",
    "á¨ááááá",
  ],
};

const dayPeriodValues$E = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "á¨á£áá¦ááá",
    noon: "á¨á£ááá¦á",
    morning: "áááá",
    afternoon: "á¡áá¦ááá",
    evening: "á¡áá¦ááá",
    night: "á¦ááá",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "á¨á£áá¦ááá",
    noon: "á¨á£ááá¦á",
    morning: "áááá",
    afternoon: "á¡áá¦ááá",
    evening: "á¡áá¦ááá",
    night: "á¦ááá",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "á¨á£áá¦ááá",
    noon: "á¨á£ááá¦á",
    morning: "áááá",
    afternoon: "á¡áá¦ááá",
    evening: "á¡áá¦ááá",
    night: "á¦ááá",
  },
};

const formattingDayPeriodValues$w = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "á¨á£áá¦áááá",
    noon: "á¨á£ááá¦áá¡áá¡",
    morning: "ááááá",
    afternoon: "ááá¨á£ááá¦ááá¡",
    evening: "á¡áá¦áááá¡",
    night: "á¦áááá",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "á¨á£áá¦áááá",
    noon: "á¨á£ááá¦áá¡áá¡",
    morning: "ááááá",
    afternoon: "ááá¨á£ááá¦ááá¡",
    evening: "á¡áá¦áááá¡",
    night: "á¦áááá",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "á¨á£áá¦áááá",
    noon: "á¨á£ááá¦áá¡áá¡",
    morning: "ááááá",
    afternoon: "ááá¨á£ááá¦ááá¡",
    evening: "á¡áá¦áááá¡",
    night: "á¦áááá",
  },
};

const ordinalNumber$E = (dirtyNumber) => {
  const number = Number(dirtyNumber);

  if (number === 1) {
    return number + "-áá";
  }

  return number + "-á";
};

(localize$E.localize = {
  ordinalNumber: ordinalNumber$E,

  era: (0, _index$6x.buildLocalizeFn)({
    values: eraValues$E,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6x.buildLocalizeFn)({
    values: quarterValues$E,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6x.buildLocalizeFn)({
    values: monthValues$E,
    defaultWidth: "wide",
  }),

  day: (0, _index$6x.buildLocalizeFn)({
    values: dayValues$E,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6x.buildLocalizeFn)({
    values: dayPeriodValues$E,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$w,
    defaultFormattingWidth: "wide",
  }),
});

var match$E = {};

match$E.match = void 0;

var _index$6w = buildMatchFn$1;
var _index2$2Q = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$E = /^(\d+)(-áá|-á)?/i;
const parseOrdinalNumberPattern$E = /\d+/i;

const matchEraPatterns$E = {
  narrow: /^(á©á?\.á¬)/i,
  abbreviated: /^(á©á?\.á¬)/i,
  wide: /^(á©áááá¡ á¬ááááá¦á ááªá®ááááá|á¥á áá¡á¢áá¨áááááá|á©áááá á¬ááááá¦á ááªá®ááá|á¥á áá¡á¢áá¨áááááá)/i,
};
const parseEraPatterns$E = {
  any: [
    /^(á©áááá¡ á¬ááááá¦á ááªá®ááááá|á¥á áá¡á¢áá¨áááááá)/i,
    /^(á©áááá á¬ááááá¦á ááªá®ááá|á¥á áá¡á¢áá¨áááááá)/i,
  ],
};

const matchQuarterPatterns$E = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-(áá|á)? áá/i,
  wide: /^[1234]-(áá|á)? áááá á¢ááá/i,
};
const parseQuarterPatterns$E = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$E = {
  any: /^(áá|áá|áá|áá|áá¡|áá|áá|áá|á¡á|áá¥|áá|áá)/i,
};
const parseMonthPatterns$E = {
  any: [
    /^áá/i,
    /^á/i,
    /^ááá /i,
    /^áá/i,
    /^ááá/i,
    /^á?áá/i,
    /^á?áá/i,
    /^áá/i,
    /^á¡/i,
    /^á/i,
    /^á/i,
    /^á/i,
  ],
};

const matchDayPatterns$E = {
  narrow: /^(áá|áá |á¡á|áá|á®á£|áá|á¨á)/i,
  short: /^(ááá|áá á¨|á¡áá|ááá®|á®á£á|ááá |á¨áá)/i,
  wide: /^(áááá á|áá á¨ááááá|á¡ááá¨ááááá|ááá®á¨ááááá|á®á£áá¨ááááá|ááá áá¡áááá|á¨ááááá)/i,
};
const parseDayPatterns$E = {
  any: [/^áá/i, /^áá /i, /^á¡á/i, /^áá/i, /^á®á£/i, /^áá/i, /^á¨á/i],
};

const matchDayPeriodPatterns$E = {
  any: /^([ap]\.?\s?m\.?|á¨á£áá¦|ááá)/i,
};
const parseDayPeriodPatterns$E = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^á¨á£áá¦/i,
    noon: /^á¨á£ááá¦/i,
    morning: /^ááá/i,
    afternoon: /ááá¨á£ááá¦ááá¡/i,
    evening: /á¡áá¦ááá/i,
    night: /á¦áá/i,
  },
};

(match$E.match = {
  ordinalNumber: (0, _index2$2Q.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$E,
    parsePattern: parseOrdinalNumberPattern$E,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6w.buildMatchFn)({
    matchPatterns: matchEraPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$E,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6w.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$E,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6w.buildMatchFn)({
    matchPatterns: matchMonthPatterns$E,
    defaultMatchWidth: "any",
    parsePatterns: parseMonthPatterns$E,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6w.buildMatchFn)({
    matchPatterns: matchDayPatterns$E,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$E,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6w.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$E,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$E,
    defaultParseWidth: "any",
  }),
});

ka.ka = void 0;
var _index$6v = formatDistance$1j;
var _index2$2P = formatLong$E;
var _index3$1q = formatRelative$1j;
var _index4$W = localize$E;
var _index5$N = match$E;

/**
 * @category Locales
 * @summary Georgian locale.
 * @language Georgian
 * @iso-639-2 geo
 * @author Lado Lomidze [@Landish](https://github.com/Landish)
 * @author Nick Shvelidze [@shvelo](https://github.com/shvelo)
 */
(ka.ka = {
  code: "ka",
  formatDistance: _index$6v.formatDistance,
  formatLong: _index2$2P.formatLong,
  formatRelative: _index3$1q.formatRelative,
  localize: _index4$W.localize,
  match: _index5$N.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var kk = {};

var formatDistance$1h = {};

formatDistance$1h.formatDistance = void 0;

const formatDistanceLocale$D = {
  lessThanXSeconds: {
    regular: {
      one: "1 ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ Ð°Ð·",
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ Ð°Ð·",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ Ð°Ð·",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ Ð°Ð·",
    },
    future: {
      one: "Ð±ÑÑ ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  xSeconds: {
    regular: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
    },
    past: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´ Ð±Ò±ÑÑÐ½",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ Ð±Ò±ÑÑÐ½",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ Ð±Ò±ÑÑÐ½",
    },
    future: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  halfAMinute: (options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "Ð¶Ð°ÑÑÑ Ð¼Ð¸Ð½ÑÑ ÑÑÑÐ½Ð´Ðµ";
      } else {
        return "Ð¶Ð°ÑÑÑ Ð¼Ð¸Ð½ÑÑ Ð±Ò±ÑÑÐ½";
      }
    }

    return "Ð¶Ð°ÑÑÑ Ð¼Ð¸Ð½ÑÑ";
  },

  lessThanXMinutes: {
    regular: {
      one: "1 Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ Ð°Ð·",
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ Ð°Ð·",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ Ð°Ð·",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ Ð°Ð·",
    },
    future: {
      one: "Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¼ ",
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¼",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¼",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¼",
    },
  },

  xMinutes: {
    regular: {
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑ",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ",
    },
    past: {
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑ Ð±Ò±ÑÑÐ½",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ Ð±Ò±ÑÑÐ½",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ Ð±Ò±ÑÑÐ½",
    },
    future: {
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  aboutXHours: {
    regular: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°Ñ",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°Ñ",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°Ñ",
    },
    future: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°ÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°ÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} ÑÐ°ÒÐ°ÑÑÐ°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  xHours: {
    regular: {
      singularNominative: "{{count}} ÑÐ°ÒÐ°Ñ",
      singularGenitive: "{{count}} ÑÐ°ÒÐ°Ñ",
      pluralGenitive: "{{count}} ÑÐ°ÒÐ°Ñ",
    },
  },

  xDays: {
    regular: {
      singularNominative: "{{count}} ÐºÒ¯Ð½",
      singularGenitive: "{{count}} ÐºÒ¯Ð½",
      pluralGenitive: "{{count}} ÐºÒ¯Ð½",
    },
    future: {
      singularNominative: "{{count}} ÐºÒ¯Ð½Ð½ÐµÐ½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} ÐºÒ¯Ð½Ð½ÐµÐ½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} ÐºÒ¯Ð½Ð½ÐµÐ½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  aboutXWeeks: {
    type: "weeks",
    one: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ 1 Ð°Ð¿ÑÐ°",
    other: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¿ÑÐ°",
  },

  xWeeks: {
    type: "weeks",
    one: "1 Ð°Ð¿ÑÐ°",
    other: "{{count}} Ð°Ð¿ÑÐ°",
  },

  aboutXMonths: {
    regular: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹",
    },
    future: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð°Ð¹Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  xMonths: {
    regular: {
      singularNominative: "{{count}} Ð°Ð¹",
      singularGenitive: "{{count}} Ð°Ð¹",
      pluralGenitive: "{{count}} Ð°Ð¹",
    },
  },

  aboutXYears: {
    regular: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»",
    },
    future: {
      singularNominative: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "ÑÐ°Ð¼Ð°Ð¼ÐµÐ½ {{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  xYears: {
    regular: {
      singularNominative: "{{count}} Ð¶ÑÐ»",
      singularGenitive: "{{count}} Ð¶ÑÐ»",
      pluralGenitive: "{{count}} Ð¶ÑÐ»",
    },
    future: {
      singularNominative: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },

  overXYears: {
    regular: {
      singularNominative: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
      singularGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
      pluralGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
    },
    future: {
      singularNominative: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
      singularGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
      pluralGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ Ð°ÑÑÐ°Ð¼",
    },
  },

  almostXYears: {
    regular: {
      singularNominative: "{{count}} Ð¶ÑÐ»ÒÐ° Ð¶Ð°ÒÑÐ½",
      singularGenitive: "{{count}} Ð¶ÑÐ»ÒÐ° Ð¶Ð°ÒÑÐ½",
      pluralGenitive: "{{count}} Ð¶ÑÐ»ÒÐ° Ð¶Ð°ÒÑÐ½",
    },
    future: {
      singularNominative: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      singularGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
      pluralGenitive: "{{count}} Ð¶ÑÐ»Ð´Ð°Ð½ ÐºÐµÐ¹ÑÐ½",
    },
  },
};

function declension$4(scheme, count) {
  // scheme for count=1 exists
  if (scheme.one && count === 1) return scheme.one;

  const rem10 = count % 10;
  const rem100 = count % 100;

  // 1, 21, 31, ...
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count));

    // 2, 3, 4, 22, 23, 24, 32 ...
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count));

    // 5, 6, 7, 8, 9, 10, 11, ...
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count));
  }
}

const formatDistance$1g = (token, count, options) => {
  const tokenValue = formatDistanceLocale$D[token];

  if (typeof tokenValue === "function") return tokenValue(options);

  if (tokenValue.type === "weeks") {
    return count === 1
      ? tokenValue.one
      : tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      if (tokenValue.future) {
        return declension$4(tokenValue.future, count);
      } else {
        return declension$4(tokenValue.regular, count) + " ÐºÐµÐ¹ÑÐ½";
      }
    } else {
      if (tokenValue.past) {
        return declension$4(tokenValue.past, count);
      } else {
        return declension$4(tokenValue.regular, count) + " Ð±Ò±ÑÑÐ½";
      }
    }
  } else {
    return declension$4(tokenValue.regular, count);
  }
};
formatDistance$1h.formatDistance = formatDistance$1g;

var formatLong$D = {};

formatLong$D.formatLong = void 0;
var _index$6u = buildFormatLongFn$1;

const dateFormats$D = {
  full: "EEEE, do MMMM y 'Ð¶.'",
  long: "do MMMM y 'Ð¶.'",
  medium: "d MMM y 'Ð¶.'",
  short: "dd.MM.yyyy",
};

const timeFormats$D = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$D = {
  any: "{{date}}, {{time}}",
};

(formatLong$D.formatLong = {
  date: (0, _index$6u.buildFormatLongFn)({
    formats: dateFormats$D,
    defaultWidth: "full",
  }),

  time: (0, _index$6u.buildFormatLongFn)({
    formats: timeFormats$D,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6u.buildFormatLongFn)({
    formats: dateTimeFormats$D,
    defaultWidth: "any",
  }),
});

var formatRelative$1h = {};

formatRelative$1h.formatRelative = void 0;
var _index$6t = isSameWeek$1;

const accusativeWeekdays$3 = [
  "Ð¶ÐµÐºÑÐµÐ½Ð±ÑÐ´Ðµ",
  "Ð´Ò¯Ð¹ÑÐµÐ½Ð±ÑÐ´Ðµ",
  "ÑÐµÐ¹ÑÐµÐ½Ð±ÑÐ´Ðµ",
  "ÑÓÑÑÐµÐ½Ð±ÑÐ´Ðµ",
  "Ð±ÐµÐ¹ÑÐµÐ½Ð±ÑÐ´Ðµ",
  "Ð¶Ò±Ð¼Ð°Ð´Ð°",
  "ÑÐµÐ½Ð±ÑÐ´Ðµ",
];

function lastWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];

  return "'Ó©ÑÐºÐµÐ½ " + weekday + " ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'";
}

function thisWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];

  return "'" + weekday + " ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'";
}

function nextWeek$4(day) {
  const weekday = accusativeWeekdays$3[day];

  return "'ÐºÐµÐ»ÐµÑÑ " + weekday + " ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'";
}

const formatRelativeLocale$D = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$6t.isSameWeek)(date, baseDate, options)) {
      return thisWeek$4(day);
    } else {
      return lastWeek$4(day);
    }
  },
  yesterday: "'ÐºÐµÑÐµ ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'",
  today: "'Ð±Ò¯Ð³ÑÐ½ ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'",
  tomorrow: "'ÐµÑÑÐµÒ£ ÑÐ°ÒÐ°Ñ' p'-Ð´Ðµ'",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$6t.isSameWeek)(date, baseDate, options)) {
      return thisWeek$4(day);
    } else {
      return nextWeek$4(day);
    }
  },
  other: "P",
};

const formatRelative$1g = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$D[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$1h.formatRelative = formatRelative$1g;

var localize$D = {};

localize$D.localize = void 0;
var _index$6s = buildLocalizeFn$1;

const eraValues$D = {
  narrow: ["Ð±.Ð·.Ð´.", "Ð±.Ð·."],
  abbreviated: ["Ð±.Ð·.Ð´.", "Ð±.Ð·."],
  wide: ["Ð±ÑÐ·Ð´ÑÒ£ Ð·Ð°Ð¼Ð°Ð½ÑÐ¼ÑÐ·ÒÐ° Ð´ÐµÐ¹ÑÐ½", "Ð±ÑÐ·Ð´ÑÒ£ Ð·Ð°Ð¼Ð°Ð½ÑÐ¼ÑÐ·"],
};

const quarterValues$D = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ÑÑ ÑÐ¾Ò.", "2-ÑÑ ÑÐ¾Ò.", "3-ÑÑ ÑÐ¾Ò.", "4-ÑÑ ÑÐ¾Ò."],
  wide: ["1-ÑÑ ÑÐ¾ÒÑÐ°Ð½", "2-ÑÑ ÑÐ¾ÒÑÐ°Ð½", "3-ÑÑ ÑÐ¾ÒÑÐ°Ð½", "4-ÑÑ ÑÐ¾ÒÑÐ°Ð½"],
};

const monthValues$D = {
  narrow: ["Ò", "Ð", "Ð", "Ð¡", "Ð", "Ð", "Ð¨", "Ð¢", "Ò", "Ò", "Ò", "Ð"],
  abbreviated: [
    "ÒÐ°Ò£",
    "Ð°ÒÐ¿",
    "Ð½Ð°Ñ",
    "ÑÓÑ",
    "Ð¼Ð°Ð¼",
    "Ð¼Ð°Ñ",
    "ÑÑÐ»",
    "ÑÐ°Ð¼",
    "ÒÑÑ",
    "ÒÐ°Ð·",
    "ÒÐ°Ñ",
    "Ð¶ÐµÐ»",
  ],

  wide: [
    "ÒÐ°Ò£ÑÐ°Ñ",
    "Ð°ÒÐ¿Ð°Ð½",
    "Ð½Ð°ÑÑÑÐ·",
    "ÑÓÑÑÑ",
    "Ð¼Ð°Ð¼ÑÑ",
    "Ð¼Ð°ÑÑÑÐ¼",
    "ÑÑÐ»Ð´Ðµ",
    "ÑÐ°Ð¼ÑÐ·",
    "ÒÑÑÐºÒ¯Ð¹ÐµÐº",
    "ÒÐ°Ð·Ð°Ð½",
    "ÒÐ°ÑÐ°ÑÐ°",
    "Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½",
  ],
};
const formattingMonthValues$9 = {
  narrow: ["Ò", "Ð", "Ð", "Ð¡", "Ð", "Ð", "Ð¨", "Ð¢", "Ò", "Ò", "Ò", "Ð"],
  abbreviated: [
    "ÒÐ°Ò£",
    "Ð°ÒÐ¿",
    "Ð½Ð°Ñ",
    "ÑÓÑ",
    "Ð¼Ð°Ð¼",
    "Ð¼Ð°Ñ",
    "ÑÑÐ»",
    "ÑÐ°Ð¼",
    "ÒÑÑ",
    "ÒÐ°Ð·",
    "ÒÐ°Ñ",
    "Ð¶ÐµÐ»",
  ],

  wide: [
    "ÒÐ°Ò£ÑÐ°Ñ",
    "Ð°ÒÐ¿Ð°Ð½",
    "Ð½Ð°ÑÑÑÐ·",
    "ÑÓÑÑÑ",
    "Ð¼Ð°Ð¼ÑÑ",
    "Ð¼Ð°ÑÑÑÐ¼",
    "ÑÑÐ»Ð´Ðµ",
    "ÑÐ°Ð¼ÑÐ·",
    "ÒÑÑÐºÒ¯Ð¹ÐµÐº",
    "ÒÐ°Ð·Ð°Ð½",
    "ÒÐ°ÑÐ°ÑÐ°",
    "Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½",
  ],
};

const dayValues$D = {
  narrow: ["Ð", "Ð", "Ð¡", "Ð¡", "Ð", "Ð", "Ð¡"],
  short: ["Ð¶Ñ", "Ð´Ñ", "ÑÑ", "ÑÑ", "Ð±Ñ", "Ð¶Ð¼", "ÑÐ±"],
  abbreviated: ["Ð¶Ñ", "Ð´Ñ", "ÑÑ", "ÑÑ", "Ð±Ñ", "Ð¶Ð¼", "ÑÐ±"],
  wide: [
    "Ð¶ÐµÐºÑÐµÐ½Ð±Ñ",
    "Ð´Ò¯Ð¹ÑÐµÐ½Ð±Ñ",
    "ÑÐµÐ¹ÑÐµÐ½Ð±Ñ",
    "ÑÓÑÑÐµÐ½Ð±Ñ",
    "Ð±ÐµÐ¹ÑÐµÐ½Ð±Ñ",
    "Ð¶Ò±Ð¼Ð°",
    "ÑÐµÐ½Ð±Ñ",
  ],
};

const dayPeriodValues$D = {
  narrow: {
    am: "Ð¢Ð",
    pm: "Ð¢Ð",
    midnight: "ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑ",
    noon: "ÑÒ¯Ñ",
    morning: "ÑÐ°Ò£",
    afternoon: "ÐºÒ¯Ð½Ð´ÑÐ·",
    evening: "ÐºÐµÑ",
    night: "ÑÒ¯Ð½",
  },
  wide: {
    am: "Ð¢Ð",
    pm: "Ð¢Ð",
    midnight: "ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑ",
    noon: "ÑÒ¯Ñ",
    morning: "ÑÐ°Ò£",
    afternoon: "ÐºÒ¯Ð½Ð´ÑÐ·",
    evening: "ÐºÐµÑ",
    night: "ÑÒ¯Ð½",
  },
};

const formattingDayPeriodValues$v = {
  narrow: {
    am: "Ð¢Ð",
    pm: "Ð¢Ð",
    midnight: "ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑÐ½Ð´Ð°",
    noon: "ÑÒ¯Ñ",
    morning: "ÑÐ°Ò£",
    afternoon: "ÐºÒ¯Ð½",
    evening: "ÐºÐµÑ",
    night: "ÑÒ¯Ð½",
  },
  wide: {
    am: "Ð¢Ð",
    pm: "Ð¢Ð",
    midnight: "ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑÐ½Ð´Ð°",
    noon: "ÑÒ¯ÑÑÐµ",
    morning: "ÑÐ°Ò£ÐµÑÑÐµÒ£",
    afternoon: "ÐºÒ¯Ð½Ð´ÑÐ·",
    evening: "ÐºÐµÑÑÐµ",
    night: "ÑÒ¯Ð½Ð´Ðµ",
  },
};

const suffixes = {
  0: "-ÑÑ",
  1: "-ÑÑ",
  2: "-ÑÑ",
  3: "-ÑÑ",
  4: "-ÑÑ",
  5: "-ÑÑ",
  6: "-ÑÑ",
  7: "-ÑÑ",
  8: "-ÑÑ",
  9: "-ÑÑ",
  10: "-ÑÑ",
  20: "-ÑÑ",
  30: "-ÑÑ",
  40: "-ÑÑ",
  50: "-ÑÑ",
  60: "-ÑÑ",
  70: "-ÑÑ",
  80: "-ÑÑ",
  90: "-ÑÑ",
  100: "-ÑÑ",
};

const ordinalNumber$D = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const mod10 = number % 10;
  const b = number >= 100 ? 100 : null;
  const suffix =
    suffixes[number] || suffixes[mod10] || (b && suffixes[b]) || "";

  return number + suffix;
};

(localize$D.localize = {
  ordinalNumber: ordinalNumber$D,

  era: (0, _index$6s.buildLocalizeFn)({
    values: eraValues$D,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6s.buildLocalizeFn)({
    values: quarterValues$D,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6s.buildLocalizeFn)({
    values: monthValues$D,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$9,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$6s.buildLocalizeFn)({
    values: dayValues$D,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6s.buildLocalizeFn)({
    values: dayPeriodValues$D,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$v,
    defaultFormattingWidth: "wide",
  }),
});

var match$D = {};

match$D.match = void 0;

var _index$6r = buildMatchFn$1;
var _index2$2O = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$D = /^(\d+)(-?(ÑÑ|ÑÑ))?/i;
const parseOrdinalNumberPattern$D = /\d+/i;

const matchEraPatterns$D = {
  narrow: /^((Ð± )?Ð·\.?\s?Ð´\.?)/i,
  abbreviated: /^((Ð± )?Ð·\.?\s?Ð´\.?)/i,
  wide: /^(Ð±ÑÐ·Ð´ÑÒ£ Ð·Ð°Ð¼Ð°Ð½ÑÐ¼ÑÐ·ÒÐ° Ð´ÐµÐ¹ÑÐ½|Ð±ÑÐ·Ð´ÑÒ£ Ð·Ð°Ð¼Ð°Ð½ÑÐ¼ÑÐ·|Ð±ÑÐ·Ð´ÑÒ£ Ð·Ð°Ð¼Ð°Ð½ÑÐ¼ÑÐ·Ð´Ð°Ð½)/i,
};
const parseEraPatterns$D = {
  any: [/^Ð±/i, /^Ð·/i],
};

const matchQuarterPatterns$D = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?ÑÑ)? ÑÐ¾Ò.?/i,
  wide: /^[1234](-?ÑÑ)? ÑÐ¾ÒÑÐ°Ð½/i,
};
const parseQuarterPatterns$D = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$D = {
  narrow: /^(Ò|Ð°|Ð½|Ñ|Ð¼|Ð¼Ð°Ñ|Ñ|Ñ|ÒÑÑ|ÒÐ°Ð·|ÒÐ°Ñ|Ð¶)/i,
  abbreviated: /^(ÒÐ°Ò£|Ð°ÒÐ¿|Ð½Ð°Ñ|ÑÓÑ|Ð¼Ð°Ð¼|Ð¼Ð°Ñ|ÑÑÐ»|ÑÐ°Ð¼|ÒÑÑ|ÒÐ°Ð·|ÒÐ°Ñ|Ð¶ÐµÐ»)/i,
  wide: /^(ÒÐ°Ò£ÑÐ°Ñ|Ð°ÒÐ¿Ð°Ð½|Ð½Ð°ÑÑÑÐ·|ÑÓÑÑÑ|Ð¼Ð°Ð¼ÑÑ|Ð¼Ð°ÑÑÑÐ¼|ÑÑÐ»Ð´Ðµ|ÑÐ°Ð¼ÑÐ·|ÒÑÑÐºÒ¯Ð¹ÐµÐº|ÒÐ°Ð·Ð°Ð½|ÒÐ°ÑÐ°ÑÐ°|Ð¶ÐµÐ»ÑÐ¾ÒÑÐ°Ð½)/i,
};
const parseMonthPatterns$D = {
  narrow: [
    /^Ò/i,
    /^Ð°/i,
    /^Ð½/i,
    /^Ñ/i,
    /^Ð¼/i,
    /^Ð¼/i,
    /^Ñ/i,
    /^Ñ/i,
    /^Ò/i,
    /^Ò/i,
    /^Ò/i,
    /^Ð¶/i,
  ],

  abbreviated: [
    /^ÒÐ°Ò£/i,
    /^Ð°ÒÐ¿/i,
    /^Ð½Ð°Ñ/i,
    /^ÑÓÑ/i,
    /^Ð¼Ð°Ð¼/i,
    /^Ð¼Ð°Ñ/i,
    /^ÑÑÐ»/i,
    /^ÑÐ°Ð¼/i,
    /^ÒÑÑ/i,
    /^ÒÐ°Ð·/i,
    /^ÒÐ°Ñ/i,
    /^Ð¶ÐµÐ»/i,
  ],

  any: [
    /^Ò/i,
    /^Ð°/i,
    /^Ð½/i,
    /^Ñ/i,
    /^Ð¼/i,
    /^Ð¼/i,
    /^Ñ/i,
    /^Ñ/i,
    /^Ò/i,
    /^Ò/i,
    /^Ò/i,
    /^Ð¶/i,
  ],
};

const matchDayPatterns$D = {
  narrow: /^(Ð¶|Ð´|Ñ|Ñ|Ð±|Ð¶|Ñ)/i,
  short: /^(Ð¶Ñ|Ð´Ñ|ÑÑ|ÑÑ|Ð±Ñ|Ð¶Ð¼|ÑÐ±)/i,
  wide: /^(Ð¶ÐµÐºÑÐµÐ½Ð±Ñ|Ð´Ò¯Ð¹ÑÐµÐ½Ð±Ñ|ÑÐµÐ¹ÑÐµÐ½Ð±Ñ|ÑÓÑÑÐµÐ½Ð±Ñ|Ð±ÐµÐ¹ÑÐµÐ½Ð±Ñ|Ð¶Ò±Ð¼Ð°|ÑÐµÐ½Ð±Ñ)/i,
};
const parseDayPatterns$D = {
  narrow: [/^Ð¶/i, /^Ð´/i, /^Ñ/i, /^Ñ/i, /^Ð±/i, /^Ð¶/i, /^Ñ/i],
  short: [/^Ð¶Ñ/i, /^Ð´Ñ/i, /^ÑÑ/i, /^ÑÑ/i, /^Ð±Ñ/i, /^Ð¶Ð¼/i, /^ÑÐ±/i],
  any: [
    /^Ð¶[ÐµÐº]/i,
    /^Ð´[Ò¯Ð¹]/i,
    /^Ñe[Ð¹]/i,
    /^ÑÓ[Ñ]/i,
    /^Ð±[ÐµÐ¹]/i,
    /^Ð¶[Ò±Ð¼]/i,
    /^ÑÐµ[Ð½]/i,
  ],
};

const matchDayPeriodPatterns$D = {
  narrow:
    /^Ð¢\.?\s?[ÐÐ]\.?|ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑÐ½Ð´Ð°|((ÑÒ¯ÑÑÐµ|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð´Ð°|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð¼ÐµÐ½|ÑÐ°Ò£|ÐºÒ¯Ð½Ð´ÑÐ·|ÐºÒ¯Ð½|ÐºÐµÑÑÐµ|ÐºÐµÑ|ÑÒ¯Ð½Ð´Ðµ|ÑÒ¯Ð½)\.?)/i,
  wide: /^Ð¢\.?\s?[ÐÐ]\.?|ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑÐ½Ð´Ð°|((ÑÒ¯ÑÑÐµ|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð´Ð°|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð¼ÐµÐ½|ÑÐ°Ò£|ÐºÒ¯Ð½Ð´ÑÐ·|ÐºÒ¯Ð½|ÐºÐµÑÑÐµ|ÐºÐµÑ|ÑÒ¯Ð½Ð´Ðµ|ÑÒ¯Ð½)\.?)/i,
  any: /^Ð¢\.?\s?[ÐÐ]\.?|ÑÒ¯Ð½ Ð¾ÑÑÐ°ÑÑÐ½Ð´Ð°|((ÑÒ¯ÑÑÐµ|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð´Ð°|ÑÐ°Ò£ÐµÑÑÐµÒ£|ÑÐ°Ò£Ð¼ÐµÐ½|ÑÐ°Ò£|ÐºÒ¯Ð½Ð´ÑÐ·|ÐºÒ¯Ð½|ÐºÐµÑÑÐµ|ÐºÐµÑ|ÑÒ¯Ð½Ð´Ðµ|ÑÒ¯Ð½)\.?)/i,
};
const parseDayPeriodPatterns$D = {
  any: {
    am: /^Ð¢Ð/i,
    pm: /^Ð¢Ð/i,
    midnight: /^ÑÒ¯Ð½ Ð¾ÑÑÐ°/i,
    noon: /^ÐºÒ¯Ð½Ð´ÑÐ·/i,
    morning: /ÑÐ°Ò£/i,
    afternoon: /ÑÒ¯Ñ/i,
    evening: /ÐºÐµÑ/i,
    night: /ÑÒ¯Ð½/i,
  },
};

(match$D.match = {
  ordinalNumber: (0, _index2$2O.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$D,
    parsePattern: parseOrdinalNumberPattern$D,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6r.buildMatchFn)({
    matchPatterns: matchEraPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$D,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6r.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$D,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6r.buildMatchFn)({
    matchPatterns: matchMonthPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$D,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6r.buildMatchFn)({
    matchPatterns: matchDayPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$D,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6r.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$D,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$D,
    defaultParseWidth: "any",
  }),
});

kk.kk = void 0;
var _index$6q = formatDistance$1h;
var _index2$2N = formatLong$D;
var _index3$1p = formatRelative$1h;
var _index4$V = localize$D;
var _index5$M = match$D;

/**
 * @category Locales
 * @summary Kazakh locale.
 * @language Kazakh
 * @iso-639-2 kaz
 * @author Nikita Bayev [@drugoi](https://github.com/drugoi)
 */
(kk.kk = {
  code: "kk",
  formatDistance: _index$6q.formatDistance,
  formatLong: _index2$2N.formatLong,
  formatRelative: _index3$1p.formatRelative,
  localize: _index4$V.localize,
  match: _index5$M.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var km = {};

var formatDistance$1f = {};

formatDistance$1f.formatDistance = void 0;

const formatDistanceLocale$C = {
  lessThanXSeconds: "áá·ááá¶á {{count}} áá·áá¶áá¸",
  xSeconds: "{{count}} áá·áá¶áá¸",
  halfAMinute: "ááááááá¶áá¸",
  lessThanXMinutes: "áá·ááá¶á {{count}} áá¶áá¸",
  xMinutes: "{{count}} áá¶áá¸",
  aboutXHours: "áááá áá {{count}} áááá",
  xHours: "{{count}} áááá",
  xDays: "{{count}} áááá",
  aboutXWeeks: "áááá áá {{count}} ááááá¶á á",
  xWeeks: "{{count}} ááááá¶á á",
  aboutXMonths: "áááá áá {{count}} áá",
  xMonths: "{{count}} áá",
  aboutXYears: "áááá áá {{count}} áááá¶á",
  xYears: "{{count}} áááá¶á",
  overXYears: "áá¶á {{count}} áááá¶á",
  almostXYears: "áá·á {{count}} áááá¶á",
};

const formatDistance$1e = (token, count, options) => {
  const tokenValue = formatDistanceLocale$C[token];

  let result = tokenValue;

  if (typeof count === "number") {
    result = result.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "áááá»ááááááá " + result;
    } else {
      return result + "áá»á";
    }
  }

  return result;
};
formatDistance$1f.formatDistance = formatDistance$1e;

var formatLong$C = {};

formatLong$C.formatLong = void 0;
var _index$6p = buildFormatLongFn$1;

const dateFormats$C = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy",
};

const timeFormats$C = {
  full: "h:mm:ss a",
  long: "h:mm:ss a",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$C = {
  full: "{{date}} 'áááá' {{time}}",
  long: "{{date}} 'áááá' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$C.formatLong = {
  date: (0, _index$6p.buildFormatLongFn)({
    formats: dateFormats$C,
    defaultWidth: "full",
  }),

  time: (0, _index$6p.buildFormatLongFn)({
    formats: timeFormats$C,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6p.buildFormatLongFn)({
    formats: dateTimeFormats$C,
    defaultWidth: "full",
  }),
});

var formatRelative$1f = {};

formatRelative$1f.formatRelative = void 0;

const formatRelativeLocale$C = {
  lastWeek: "'áááá'eeee'áâáááá¶âá áâáá»ááááá' p",
  yesterday: "'áááá·ááá·ááááááá' p",
  today: "'ááááááááááá' p",
  tomorrow: "'ááááááá¢áááááá' p",
  nextWeek: "'áááá'eeee'áâáááá¶âá áâááááááááá' p",
  other: "P",
};

const formatRelative$1e = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$C[token];
formatRelative$1f.formatRelative = formatRelative$1e;

var localize$C = {};

localize$C.localize = void 0;
var _index$6o = buildLocalizeFn$1;

const eraValues$C = {
  narrow: ["á.áá", "áá"],
  abbreviated: ["áá»áá.á", "á.á"],
  wide: ["áá»ááááá·ááááááá¶á", "áááááá·ááááááá¶á"],
};

const quarterValues$C = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["áááá¸áá¶ááá¸ 1", "áááá¸áá¶ááá¸ 2", "áááá¸áá¶ááá¸ 3", "áááá¸áá¶ááá¸ 4"],
};

const monthValues$C = {
  narrow: [
    "á.á",
    "á.á",
    "áá·",
    "á.á",
    "á§.á",
    "á.á",
    "á.á",
    "áá¸",
    "áá",
    "áá»",
    "áá·",
    "á",
  ],

  abbreviated: [
    "áááá¶",
    "áá»áááá",
    "áá¸áá¶",
    "áááá¶",
    "á§ááá¶",
    "áá·áá»áá¶",
    "áááááá¶",
    "áá¸á á¶",
    "ááááá¶",
    "áá»áá¶",
    "áá·áááá·áá¶",
    "áááá¼",
  ],

  wide: [
    "áááá¶",
    "áá»áááá",
    "áá¸áá¶",
    "áááá¶",
    "á§ááá¶",
    "áá·áá»áá¶",
    "áááááá¶",
    "áá¸á á¶",
    "ááááá¶",
    "áá»áá¶",
    "áá·áááá·áá¶",
    "áááá¼",
  ],
};

const dayValues$C = {
  narrow: ["á¢á¶", "á", "á¢", "á", "ááá", "áá»", "á"],
  short: ["á¢á¶", "á", "á¢", "á", "ááá", "áá»", "á"],
  abbreviated: ["á¢á¶", "á", "á¢", "á", "ááá", "áá»", "á"],
  wide: ["á¢á¶áá·ááá", "áááá", "á¢áááá¶á", "áá»á", "áááá ááááá·á", "áá»ááá", "áááá"],
};

const dayPeriodValues$C = {
  narrow: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
  abbreviated: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
  wide: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
};

const formattingDayPeriodValues$u = {
  narrow: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
  abbreviated: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
  wide: {
    am: "áááá¹á",
    pm: "áááá¶á",
    midnight: "âáááááááá¶áá¢áááá¶ááá",
    noon: "áááááááááááá",
    morning: "ááááááá¹á",
    afternoon: "ááááááá",
    evening: "ááááááá¶á",
    night: "áááááá",
  },
};

const ordinalNumber$C = (dirtyNumber, _) => {
  const number = Number(dirtyNumber);
  return number.toString();
};

(localize$C.localize = {
  ordinalNumber: ordinalNumber$C,

  era: (0, _index$6o.buildLocalizeFn)({
    values: eraValues$C,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6o.buildLocalizeFn)({
    values: quarterValues$C,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6o.buildLocalizeFn)({
    values: monthValues$C,
    defaultWidth: "wide",
  }),

  day: (0, _index$6o.buildLocalizeFn)({
    values: dayValues$C,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6o.buildLocalizeFn)({
    values: dayPeriodValues$C,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$u,
    defaultFormattingWidth: "wide",
  }),
});

var match$C = {};

match$C.match = void 0;

var _index$6n = buildMatchFn$1;
var _index2$2M = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$C = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$C = /\d+/i;

const matchEraPatterns$C = {
  narrow: /^(á\.)?áá/i,
  abbreviated: /^(áá»á)?á\.á/i,
  wide: /^(áá»á|áá)áááá·ááááááá¶á/i,
};
const parseEraPatterns$C = {
  any: [/^(á|áá»á)á\.?á/i, /^(áá)?á\.?á/i],
};

const matchQuarterPatterns$C = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^(áááá¸áá¶á)(áá¸)?\s?[1234]/i,
};
const parseQuarterPatterns$C = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$C = {
  narrow: /^(á\.á|á\.á|áá·|á\.á|á§\.á|á\.á|á\.á|áá¸|áá|áá»|áá·|á)/i,
  abbreviated:
    /^(áááá¶|áá»áááá|áá¸áá¶|áááá¶|á§ááá¶|áá·áá»áá¶|áááááá¶|áá¸á á¶|ááááá¶|áá»áá¶|áá·áááá·áá¶|áááá¼)/i,
  wide: /^(áááá¶|áá»áááá|áá¸áá¶|áááá¶|á§ááá¶|áá·áá»áá¶|áááááá¶|áá¸á á¶|ááááá¶|áá»áá¶|áá·áááá·áá¶|áááá¼)/i,
};
const parseMonthPatterns$C = {
  narrow: [
    /^á\.á/i,
    /^á\.á/i,
    /^áá·/i,
    /^á\.á/i,
    /^á§\.á/i,
    /^á\.á/i,
    /^á\.á/i,
    /^áá¸/i,
    /^áá/i,
    /^áá»/i,
    /^áá·/i,
    /^á/i,
  ],

  any: [
    /^áá/i,
    /^áá»/i,
    /^áá¸á/i,
    /^áá/i,
    /^á§á/i,
    /^áá·á/i,
    /^áá/i,
    /^áá¸/i,
    /^áá/i,
    /^áá»/i,
    /^áá·á/i,
    /^á/i,
  ],
};

const matchDayPatterns$C = {
  narrow: /^(á¢á¶|á|á¢|á|ááá|áá»|á)/i,
  short: /^(á¢á¶|á|á¢|á|ááá|áá»|á)/i,
  abbreviated: /^(á¢á¶|á|á¢|á|ááá|áá»|á)/i,
  wide: /^(á¢á¶áá·ááá|áááá|á¢áááá¶á|áá»á|áááá ááááá·á|áá»ááá|áááá)/i,
};
const parseDayPatterns$C = {
  narrow: [/^á¢á¶/i, /^á/i, /^á¢/i, /^á/i, /^ááá/i, /^áá»/i, /^á/i],
  any: [/^á¢á¶/i, /^á/i, /^á¢/i, /^á/i, /^ááá/i, /^áá»/i, /^áá/i],
};

const matchDayPeriodPatterns$C = {
  narrow:
    /^(áááá¹á|áááá¶á|ááááááá¹á|áááááááááááá|ááááááá¶á|ááááááá|áááááá|áááááááá¶áá¢áááá¶ááá)/i,
  any: /^(áááá¹á|áááá¶á|ááááááá¹á|áááááááááááá|ááááááá¶á|ááááááá|áááááá|áááááááá¶áá¢áááá¶ááá)/i,
};

const parseDayPeriodPatterns$C = {
  any: {
    am: /^áááá¹á/i,
    pm: /^áááá¶á/i,
    midnight: /^áááááááá¶áá¢áááá¶ááá/i,
    noon: /^áááááááááááá/i,
    morning: /ááááááá¹á/i,
    afternoon: /ááááááá/i,
    evening: /ááááááá¶á/i,
    night: /áááááá/i,
  },
};

(match$C.match = {
  ordinalNumber: (0, _index2$2M.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$C,
    parsePattern: parseOrdinalNumberPattern$C,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index$6n.buildMatchFn)({
    matchPatterns: matchEraPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$C,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6n.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$C,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6n.buildMatchFn)({
    matchPatterns: matchMonthPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$C,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6n.buildMatchFn)({
    matchPatterns: matchDayPatterns$C,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$C,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6n.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$C,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$C,
    defaultParseWidth: "any",
  }),
});

km.km = void 0;
var _index$6m = formatDistance$1f;
var _index2$2L = formatLong$C;
var _index3$1o = formatRelative$1f;
var _index4$U = localize$C;
var _index5$L = match$C;

/**
 * @category Locales
 * @summary Khmer locale (Cambodian).
 * @language Khmer
 * @iso-639-2 khm
 * @author Seanghay Yath [@seanghay](https://github.com/seanghay)
 */
(km.km = {
  code: "km",
  formatDistance: _index$6m.formatDistance,
  formatLong: _index2$2L.formatLong,
  formatRelative: _index3$1o.formatRelative,
  localize: _index4$U.localize,
  match: _index5$L.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var kn = {};

var formatDistance$1d = {};

formatDistance$1d.formatDistance = void 0;

// note: no implementation for weeks

const formatDistanceLocale$B = {
  lessThanXSeconds: {
    one: {
      default: "1 à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      future: "1 à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      past: "1 à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
    },
    other: {
      default: "{{count}} à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      future: "{{count}} à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      past: "{{count}} à²¸à³à²à³à²à²¡à³âà²à²¿à²à²¤ à²à²¡à²¿à²®à³",
    },
  },

  xSeconds: {
    one: {
      default: "1 à²¸à³à²à³à²à²¡à³",
      future: "1 à²¸à³à²à³à²à²¡à³âà²¨à²²à³à²²à²¿",
      past: "1 à²¸à³à²à³à²à²¡à³ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²¸à³à²à³à²à²¡à³à²à²³à³",
      future: "{{count}} à²¸à³à²à³à²à²¡à³âà²à²³à²²à³à²²à²¿",
      past: "{{count}} à²¸à³à²à³à²à²¡à³ à²¹à²¿à²à²¦à³",
    },
  },

  halfAMinute: {
    other: {
      default: "à²à²°à³à²§ à²¨à²¿à²®à²¿à²·",
      future: "à²à²°à³à²§ à²¨à²¿à²®à²¿à²·à²¦à²²à³à²²à²¿",
      past: "à²à²°à³à²§ à²¨à²¿à²®à²¿à²·à²¦ à²¹à²¿à²à²¦à³",
    },
  },

  lessThanXMinutes: {
    one: {
      default: "1 à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      future: "1 à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      past: "1 à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
    },
    other: {
      default: "{{count}} à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      future: "{{count}} à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
      past: "{{count}} à²¨à²¿à²®à²¿à²·à²à³à²à²¿à²à²¤ à²à²¡à²¿à²®à³",
    },
  },

  xMinutes: {
    one: {
      default: "1 à²¨à²¿à²®à²¿à²·",
      future: "1 à²¨à²¿à²®à²¿à²·à²¦à²²à³à²²à²¿",
      past: "1 à²¨à²¿à²®à²¿à²·à²¦ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²¨à²¿à²®à²¿à²·à²à²³à³",
      future: "{{count}} à²¨à²¿à²®à²¿à²·à²à²³à²²à³à²²à²¿",
      past: "{{count}} à²¨à²¿à²®à²¿à²·à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  aboutXHours: {
    one: {
      default: "à²¸à³à²®à²¾à²°à³ 1 à²à²à²à³",
      future: "à²¸à³à²®à²¾à²°à³ 1 à²à²à²à³à²¯à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ 1 à²à²à²à³ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "à²¸à³à²®à²¾à²°à³ {{count}} à²à²à²à³à²à²³à³",
      future: "à²¸à³à²®à²¾à²°à³ {{count}} à²à²à²à³à²à²³à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ {{count}} à²à²à²à³à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  xHours: {
    one: {
      default: "1 à²à²à²à³",
      future: "1 à²à²à²à³à²¯à²²à³à²²à²¿",
      past: "1 à²à²à²à³ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²à²à²à³à²à²³à³",
      future: "{{count}} à²à²à²à³à²à²³à²²à³à²²à²¿",
      past: "{{count}} à²à²à²à³à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  xDays: {
    one: {
      default: "1 à²¦à²¿à²¨",
      future: "1 à²¦à²¿à²¨à²¦à²²à³à²²à²¿",
      past: "1 à²¦à²¿à²¨à²¦ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²¦à²¿à²¨à²à²³à³",
      future: "{{count}} à²¦à²¿à²¨à²à²³à²²à³à²²à²¿",
      past: "{{count}} à²¦à²¿à²¨à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  // TODO
  // aboutXWeeks: {},

  // TODO
  // xWeeks: {},

  aboutXMonths: {
    one: {
      default: "à²¸à³à²®à²¾à²°à³ 1 à²¤à²¿à²à²à²³à³",
      future: "à²¸à³à²®à²¾à²°à³ 1 à²¤à²¿à²à²à²³à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ 1 à²¤à²¿à²à²à²³ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "à²¸à³à²®à²¾à²°à³ {{count}} à²¤à²¿à²à²à²³à³",
      future: "à²¸à³à²®à²¾à²°à³ {{count}} à²¤à²¿à²à²à²³à³à²à²³à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ {{count}} à²¤à²¿à²à²à²³à³à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  xMonths: {
    one: {
      default: "1 à²¤à²¿à²à²à²³à³",
      future: "1 à²¤à²¿à²à²à²³à²²à³à²²à²¿",
      past: "1 à²¤à²¿à²à²à²³ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²¤à²¿à²à²à²³à³",
      future: "{{count}} à²¤à²¿à²à²à²³à³à²à²³à²²à³à²²à²¿",
      past: "{{count}} à²¤à²¿à²à²à²³à³à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  aboutXYears: {
    one: {
      default: "à²¸à³à²®à²¾à²°à³ 1 à²µà²°à³à²·",
      future: "à²¸à³à²®à²¾à²°à³ 1 à²µà²°à³à²·à²¦à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ 1 à²µà²°à³à²·à²¦ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "à²¸à³à²®à²¾à²°à³ {{count}} à²µà²°à³à²·à²à²³à³",
      future: "à²¸à³à²®à²¾à²°à³ {{count}} à²µà²°à³à²·à²à²³à²²à³à²²à²¿",
      past: "à²¸à³à²®à²¾à²°à³ {{count}} à²µà²°à³à²·à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  xYears: {
    one: {
      default: "1 à²µà²°à³à²·",
      future: "1 à²µà²°à³à²·à²¦à²²à³à²²à²¿",
      past: "1 à²µà²°à³à²·à²¦ à²¹à²¿à²à²¦à³",
    },
    other: {
      default: "{{count}} à²µà²°à³à²·à²à²³à³",
      future: "{{count}} à²µà²°à³à²·à²à²³à²²à³à²²à²¿",
      past: "{{count}} à²µà²°à³à²·à²à²³ à²¹à²¿à²à²¦à³",
    },
  },

  overXYears: {
    one: {
      default: "1 à²µà²°à³à²·à²¦ à²®à³à²²à³",
      future: "1 à²µà²°à³à²·à²¦ à²®à³à²²à³",
      past: "1 à²µà²°à³à²·à²¦ à²®à³à²²à³",
    },
    other: {
      default: "{{count}} à²µà²°à³à²·à²à²³ à²®à³à²²à³",
      future: "{{count}} à²µà²°à³à²·à²à²³ à²®à³à²²à³",
      past: "{{count}} à²µà²°à³à²·à²à²³ à²®à³à²²à³",
    },
  },

  almostXYears: {
    one: {
      default: "à²¬à²¹à³à²¤à³à² 1 à²µà²°à³à²·à²¦à²²à³à²²à²¿",
      future: "à²¬à²¹à³à²¤à³à² 1 à²µà²°à³à²·à²¦à²²à³à²²à²¿",
      past: "à²¬à²¹à³à²¤à³à² 1 à²µà²°à³à²·à²¦à²²à³à²²à²¿",
    },
    other: {
      default: "à²¬à²¹à³à²¤à³à² {{count}} à²µà²°à³à²·à²à²³à²²à³à²²à²¿",
      future: "à²¬à²¹à³à²¤à³à² {{count}} à²µà²°à³à²·à²à²³à²²à³à²²à²¿",
      past: "à²¬à²¹à³à²¤à³à² {{count}} à²µà²°à³à²·à²à²³à²²à³à²²à²¿",
    },
  },
};

function getResultByTense(parentToken, options) {
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return parentToken.future;
    } else {
      return parentToken.past;
    }
  }
  return parentToken.default;
}

const formatDistance$1c = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$B[token];

  if (tokenValue.one && count === 1) {
    result = getResultByTense(tokenValue.one, options);
  } else {
    result = getResultByTense(tokenValue.other, options);
  }

  return result.replace("{{count}}", String(count));
};
formatDistance$1d.formatDistance = formatDistance$1c;

var formatLong$B = {};

formatLong$B.formatLong = void 0;
var _index$6l = buildFormatLongFn$1;

// Reference: https://www.unicode.org/cldr/charts/32/summary/kn.html

const dateFormats$B = {
  full: "EEEE, MMMM d, y", // CLDR 1816
  long: "MMMM d, y", // CLDR 1817
  medium: "MMM d, y", // CLDR 1818
  short: "d/M/yy", // CLDR 1819
};

const timeFormats$B = {
  full: "hh:mm:ss a zzzz", // CLDR 1820
  long: "hh:mm:ss a z", // CLDR 1821
  medium: "hh:mm:ss a", // CLDR 1822
  short: "hh:mm a", // CLDR 1823
};

const dateTimeFormats$B = {
  full: "{{date}} {{time}}", // CLDR 1824
  long: "{{date}} {{time}}", // CLDR 1825
  medium: "{{date}} {{time}}", // CLDR 1826
  short: "{{date}} {{time}}", // CLDR 1827
};

(formatLong$B.formatLong = {
  date: (0, _index$6l.buildFormatLongFn)({
    formats: dateFormats$B,
    defaultWidth: "full",
  }),

  time: (0, _index$6l.buildFormatLongFn)({
    formats: timeFormats$B,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6l.buildFormatLongFn)({
    formats: dateTimeFormats$B,
    defaultWidth: "full",
  }),
});

var formatRelative$1d = {};

formatRelative$1d.formatRelative = void 0;

const formatRelativeLocale$B = {
  lastWeek: "'à²à²³à³à²¦' eeee p 'à²à³à²à³'",
  yesterday: "'à²¨à²¿à²¨à³à²¨à³' p 'à²à³à²à³'",
  today: "'à²à²à²¦à³' p 'à²à³à²à³'",
  tomorrow: "'à²¨à²¾à²³à³' p 'à²à³à²à³'",
  nextWeek: "eeee p 'à²à³à²à³'",
  other: "P",
};

const formatRelative$1c = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$B[token];
formatRelative$1d.formatRelative = formatRelative$1c;

var localize$B = {};

localize$B.localize = void 0;
var _index$6k = buildLocalizeFn$1;

// Reference: https://www.unicode.org/cldr/charts/32/summary/kn.html

const eraValues$B = {
  narrow: ["à²à³à²°à²¿.à²ªà³", "à²à³à²°à²¿.à²¶"],
  abbreviated: ["à²à³à²°à²¿.à²ªà³", "à²à³à²°à²¿.à²¶"], // CLDR #1618, #1620
  wide: ["à²à³à²°à²¿à²¸à³à²¤ à²ªà³à²°à³à²µ", "à²à³à²°à²¿à²¸à³à²¤ à²¶à²"], // CLDR #1614, #1616
};

const quarterValues$B = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["à²¤à³à²°à³ 1", "à²¤à³à²°à³ 2", "à²¤à³à²°à³ 3", "à²¤à³à²°à³ 4"], // CLDR #1630 - #1638
  wide: ["1à²¨à³ à²¤à³à²°à³à²®à²¾à²¸à²¿à²", "2à²¨à³ à²¤à³à²°à³à²®à²¾à²¸à²¿à²", "3à²¨à³ à²¤à³à²°à³à²®à²¾à²¸à²¿à²", "4à²¨à³ à²¤à³à²°à³à²®à²¾à²¸à²¿à²"],
  // CLDR #1622 - #1629
};

// CLDR #1646 - #1717
const monthValues$B = {
  narrow: ["à²", "à²«à³", "à²®à²¾", "à²", "à²®à³", "à²à³", "à²à³", "à²", "à²¸à³", "à²", "à²¨", "à²¡à²¿"],

  abbreviated: [
    "à²à²¨",
    "à²«à³à²¬à³à²°",
    "à²®à²¾à²°à³à²à³",
    "à²à²ªà³à²°à²¿",
    "à²®à³",
    "à²à³à²¨à³",
    "à²à³à²²à³",
    "à²à²",
    "à²¸à³à²ªà³à²à³à²",
    "à²à²à³à²à³",
    "à²¨à²µà³à²",
    "à²¡à²¿à²¸à³à²",
  ],

  wide: [
    "à²à²¨à²µà²°à²¿",
    "à²«à³à²¬à³à²°à²µà²°à²¿",
    "à²®à²¾à²°à³à²à³",
    "à²à²ªà³à²°à²¿à²²à³",
    "à²®à³",
    "à²à³à²¨à³",
    "à²à³à²²à³",
    "à²à²à²¸à³à²à³",
    "à²¸à³à²ªà³à²à³à²à²¬à²°à³",
    "à²à²à³à²à³à²¬à²°à³",
    "à²¨à²µà³à²à²¬à²°à³",
    "à²¡à²¿à²¸à³à²à²¬à²°à³",
  ],
};

// CLDR #1718 - #1773
const dayValues$B = {
  narrow: ["à²­à²¾", "à²¸à³", "à²®à²", "à²¬à³", "à²à³", "à²¶à³", "à²¶"],
  short: ["à²­à²¾à²¨à³", "à²¸à³à²®", "à²®à²à²à²³", "à²¬à³à²§", "à²à³à²°à³", "à²¶à³à²à³à²°", "à²¶à²¨à²¿"],
  abbreviated: ["à²­à²¾à²¨à³", "à²¸à³à²®", "à²®à²à²à²³", "à²¬à³à²§", "à²à³à²°à³", "à²¶à³à²à³à²°", "à²¶à²¨à²¿"],
  wide: [
    "à²­à²¾à²¨à³à²µà²¾à²°",
    "à²¸à³à²®à²µà²¾à²°",
    "à²®à²à²à²³à²µà²¾à²°",
    "à²¬à³à²§à²µà²¾à²°",
    "à²à³à²°à³à²µà²¾à²°",
    "à²¶à³à²à³à²°à²µà²¾à²°",
    "à²¶à²¨à²¿à²µà²¾à²°",
  ],
};

// CLDR #1774 - #1815
const dayPeriodValues$B = {
  narrow: {
    am: "à²ªà³à²°à³à²µà²¾à²¹à³à²¨",
    pm: "à²à²ªà²°à²¾à²¹à³à²¨",
    midnight: "à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¹à³à²¨",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¹à³à²¨",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
  abbreviated: {
    am: "à²ªà³à²°à³à²µà²¾à²¹à³à²¨",
    pm: "à²à²ªà²°à²¾à²¹à³à²¨",
    midnight: "à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
  wide: {
    am: "à²ªà³à²°à³à²µà²¾à²¹à³à²¨",
    pm: "à²à²ªà²°à²¾à²¹à³à²¨",
    midnight: "à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
};

const formattingDayPeriodValues$t = {
  narrow: {
    am: "à²ªà³",
    pm: "à²",
    midnight: "à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
  abbreviated: {
    am: "à²ªà³à²°à³à²µà²¾à²¹à³à²¨",
    pm: "à²à²ªà²°à²¾à²¹à³à²¨",
    midnight: "à²®à²§à³à²¯ à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
  wide: {
    am: "à²ªà³à²°à³à²µà²¾à²¹à³à²¨",
    pm: "à²à²ªà²°à²¾à²¹à³à²¨",
    midnight: "à²®à²§à³à²¯ à²°à²¾à²¤à³à²°à²¿",
    noon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    morning: "à²¬à³à²³à²à³à²à³",
    afternoon: "à²®à²§à³à²¯à²¾à²¨à³à²¹",
    evening: "à²¸à²à²à³",
    night: "à²°à²¾à²¤à³à²°à²¿",
  },
};

const ordinalNumber$B = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "à²¨à³";
};

(localize$B.localize = {
  ordinalNumber: ordinalNumber$B,

  era: (0, _index$6k.buildLocalizeFn)({
    values: eraValues$B,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6k.buildLocalizeFn)({
    values: quarterValues$B,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6k.buildLocalizeFn)({
    values: monthValues$B,
    defaultWidth: "wide",
  }),

  day: (0, _index$6k.buildLocalizeFn)({
    values: dayValues$B,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6k.buildLocalizeFn)({
    values: dayPeriodValues$B,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$t,
    defaultFormattingWidth: "wide",
  }),
});

var match$B = {};

match$B.match = void 0;

var _index$6j = buildMatchFn$1;
var _index2$2K = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$B = /^(\d+)(à²¨à³|à²¨à³)?/i;
const parseOrdinalNumberPattern$B = /\d+/i;

const matchEraPatterns$B = {
  narrow: /^(à²à³à²°à²¿.à²ªà³|à²à³à²°à²¿.à²¶)/i,
  abbreviated: /^(à²à³à²°à²¿\.?\s?à²ªà³\.?|à²à³à²°à²¿\.?\s?à²¶\.?|à²ªà³à²°\.?\s?à²¶\.?)/i,
  wide: /^(à²à³à²°à²¿à²¸à³à²¤ à²ªà³à²°à³à²µ|à²à³à²°à²¿à²¸à³à²¤ à²¶à²|à²ªà³à²°à²¸à²à³à²¤ à²¶à²)/i,
};
const parseEraPatterns$B = {
  any: [/^à²ªà³/i, /^(à²¶|à²ªà³à²°)/i],
};

const matchQuarterPatterns$B = {
  narrow: /^[1234]/i,
  abbreviated: /^à²¤à³à²°à³[1234]|à²¤à³à²°à³ [1234]| [1234]à²¤à³à²°à³/i,
  wide: /^[1234](à²¨à³)? à²¤à³à²°à³à²®à²¾à²¸à²¿à²/i,
};
const parseQuarterPatterns$B = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$B = {
  narrow: /^(à²à³|à²à³|à²|à²«à³|à²®à²¾|à²|à²®à³|à²|à²¸à³|à²|à²¨|à²¡à²¿)/i,
  abbreviated:
    /^(à²à²¨|à²«à³à²¬à³à²°|à²®à²¾à²°à³à²à³|à²à²ªà³à²°à²¿|à²®à³|à²à³à²¨à³|à²à³à²²à³|à²à²|à²¸à³à²ªà³à²à³à²|à²à²à³à²à³|à²¨à²µà³à²|à²¡à²¿à²¸à³à²)/i,
  wide: /^(à²à²¨à²µà²°à²¿|à²«à³à²¬à³à²°à²µà²°à²¿|à²®à²¾à²°à³à²à³|à²à²ªà³à²°à²¿à²²à³|à²®à³|à²à³à²¨à³|à²à³à²²à³|à²à²à²¸à³à²à³|à²¸à³à²ªà³à²à³à²à²¬à²°à³|à²à²à³à²à³à²¬à²°à³|à²¨à²µà³à²à²¬à²°à³|à²¡à²¿à²¸à³à²à²¬à²°à³)/i,
};
const parseMonthPatterns$B = {
  narrow: [
    /^à²$/i,
    /^à²«à³/i,
    /^à²®à²¾/i,
    /^à²/i,
    /^à²®à³/i,
    /^à²à³/i,
    /^à²à³$/i,
    /^à²/i,
    /^à²¸à³/i,
    /^à²/i,
    /^à²¨/i,
    /^à²¡à²¿/i,
  ],

  any: [
    /^à²à²¨/i,
    /^à²«à³/i,
    /^à²®à²¾/i,
    /^à²/i,
    /^à²®à³/i,
    /^à²à³à²¨à³/i,
    /^à²à³à²²à³/i,
    /^à²/i,
    /^à²¸à³/i,
    /^à²/i,
    /^à²¨/i,
    /^à²¡à²¿/i,
  ],
};

const matchDayPatterns$B = {
  narrow: /^(à²­à²¾|à²¸à³|à²®|à²¬à³|à²à³|à²¶à³|à²¶)/i,
  short: /^(à²­à²¾à²¨à³|à²¸à³à²®|à²®à²à²à²³|à²¬à³à²§|à²à³à²°à³|à²¶à³à²à³à²°|à²¶à²¨à²¿)/i,
  abbreviated: /^(à²­à²¾à²¨à³|à²¸à³à²®|à²®à²à²à²³|à²¬à³à²§|à²à³à²°à³|à²¶à³à²à³à²°|à²¶à²¨à²¿)/i,
  wide: /^(à²­à²¾à²¨à³à²µà²¾à²°|à²¸à³à²®à²µà²¾à²°|à²®à²à²à²³à²µà²¾à²°|à²¬à³à²§à²µà²¾à²°|à²à³à²°à³à²µà²¾à²°|à²¶à³à²à³à²°à²µà²¾à²°|à²¶à²¨à²¿à²µà²¾à²°)/i,
};
const parseDayPatterns$B = {
  narrow: [/^à²­à²¾/i, /^à²¸à³/i, /^à²®/i, /^à²¬à³/i, /^à²à³/i, /^à²¶à³/i, /^à²¶/i],
  any: [/^à²­à²¾/i, /^à²¸à³/i, /^à²®/i, /^à²¬à³/i, /^à²à³/i, /^à²¶à³/i, /^à²¶/i],
};

const matchDayPeriodPatterns$B = {
  narrow: /^(à²ªà³|à²|à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿|à²®à²§à³à²¯à²¾à²¨à³à²¹|à²¬à³à²³à²à³à²à³|à²¸à²à²à³|à²°à²¾à²¤à³à²°à²¿)/i,
  any: /^(à²ªà³à²°à³à²µà²¾à²¹à³à²¨|à²à²ªà²°à²¾à²¹à³à²¨|à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿|à²®à²§à³à²¯à²¾à²¨à³à²¹|à²¬à³à²³à²à³à²à³|à²¸à²à²à³|à²°à²¾à²¤à³à²°à²¿)/i,
};
const parseDayPeriodPatterns$B = {
  any: {
    am: /^à²ªà³/i,
    pm: /^à²/i,
    midnight: /à²®à²§à³à²¯à²°à²¾à²¤à³à²°à²¿/i,
    noon: /à²®à²§à³à²¯à²¾à²¨à³à²¹/i,
    morning: /à²¬à³à²³à²à³à²à³/i,
    afternoon: /à²®à²§à³à²¯à²¾à²¨à³à²¹/i,
    evening: /à²¸à²à²à³/i,
    night: /à²°à²¾à²¤à³à²°à²¿/i,
  },
};

(match$B.match = {
  ordinalNumber: (0, _index2$2K.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$B,
    parsePattern: parseOrdinalNumberPattern$B,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6j.buildMatchFn)({
    matchPatterns: matchEraPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$B,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6j.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$B,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6j.buildMatchFn)({
    matchPatterns: matchMonthPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$B,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6j.buildMatchFn)({
    matchPatterns: matchDayPatterns$B,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$B,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6j.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$B,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$B,
    defaultParseWidth: "any",
  }),
});

kn.kn = void 0;
var _index$6i = formatDistance$1d;
var _index2$2J = formatLong$B;
var _index3$1n = formatRelative$1d;
var _index4$T = localize$B;
var _index5$K = match$B;

/**
 * @category Locales
 * @summary Kannada locale (India).
 * @language Kannada
 * @iso-639-2 kan
 * @author Manjunatha Gouli [@developergouli](https://github.com/developergouli)
 */
(kn.kn = {
  code: "kn",
  formatDistance: _index$6i.formatDistance,
  formatLong: _index2$2J.formatLong,
  formatRelative: _index3$1n.formatRelative,
  localize: _index4$T.localize,
  match: _index5$K.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var ko = {};

var formatDistance$1b = {};

formatDistance$1b.formatDistance = void 0;

const formatDistanceLocale$A = {
  lessThanXSeconds: {
    one: "1ì´ ë¯¸ë§",
    other: "{{count}}ì´ ë¯¸ë§",
  },

  xSeconds: {
    one: "1ì´",
    other: "{{count}}ì´",
  },

  halfAMinute: "30ì´",

  lessThanXMinutes: {
    one: "1ë¶ ë¯¸ë§",
    other: "{{count}}ë¶ ë¯¸ë§",
  },

  xMinutes: {
    one: "1ë¶",
    other: "{{count}}ë¶",
  },

  aboutXHours: {
    one: "ì½ 1ìê°",
    other: "ì½ {{count}}ìê°",
  },

  xHours: {
    one: "1ìê°",
    other: "{{count}}ìê°",
  },

  xDays: {
    one: "1ì¼",
    other: "{{count}}ì¼",
  },

  aboutXWeeks: {
    one: "ì½ 1ì£¼",
    other: "ì½ {{count}}ì£¼",
  },

  xWeeks: {
    one: "1ì£¼",
    other: "{{count}}ì£¼",
  },

  aboutXMonths: {
    one: "ì½ 1ê°ì",
    other: "ì½ {{count}}ê°ì",
  },

  xMonths: {
    one: "1ê°ì",
    other: "{{count}}ê°ì",
  },

  aboutXYears: {
    one: "ì½ 1ë",
    other: "ì½ {{count}}ë",
  },

  xYears: {
    one: "1ë",
    other: "{{count}}ë",
  },

  overXYears: {
    one: "1ë ì´ì",
    other: "{{count}}ë ì´ì",
  },

  almostXYears: {
    one: "ê±°ì 1ë",
    other: "ê±°ì {{count}}ë",
  },
};

const formatDistance$1a = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$A[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " í";
    } else {
      return result + " ì ";
    }
  }

  return result;
};
formatDistance$1b.formatDistance = formatDistance$1a;

var formatLong$A = {};

formatLong$A.formatLong = void 0;
var _index$6h = buildFormatLongFn$1;

const dateFormats$A = {
  full: "yë Mì dì¼ EEEE",
  long: "yë Mì dì¼",
  medium: "y.MM.dd",
  short: "y.MM.dd",
};

const timeFormats$A = {
  full: "a Hì mmë¶ ssì´ zzzz",
  long: "a H:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$A = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$A.formatLong = {
  date: (0, _index$6h.buildFormatLongFn)({
    formats: dateFormats$A,
    defaultWidth: "full",
  }),

  time: (0, _index$6h.buildFormatLongFn)({
    formats: timeFormats$A,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6h.buildFormatLongFn)({
    formats: dateTimeFormats$A,
    defaultWidth: "full",
  }),
});

var formatRelative$1b = {};

formatRelative$1b.formatRelative = void 0;

const formatRelativeLocale$A = {
  lastWeek: "'ì§ë' eeee p",
  yesterday: "'ì´ì ' p",
  today: "'ì¤ë' p",
  tomorrow: "'ë´ì¼' p",
  nextWeek: "'ë¤ì' eeee p",
  other: "P",
};

const formatRelative$1a = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$A[token];
formatRelative$1b.formatRelative = formatRelative$1a;

var localize$A = {};

localize$A.localize = void 0;
var _index$6g = buildLocalizeFn$1;

const eraValues$A = {
  narrow: ["BC", "AD"],
  abbreviated: ["BC", "AD"],
  wide: ["ê¸°ìì ", "ìê¸°"],
};

const quarterValues$A = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1ë¶ê¸°", "2ë¶ê¸°", "3ë¶ê¸°", "4ë¶ê¸°"],
};

const monthValues$A = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],

  abbreviated: [
    "1ì",
    "2ì",
    "3ì",
    "4ì",
    "5ì",
    "6ì",
    "7ì",
    "8ì",
    "9ì",
    "10ì",
    "11ì",
    "12ì",
  ],

  wide: [
    "1ì",
    "2ì",
    "3ì",
    "4ì",
    "5ì",
    "6ì",
    "7ì",
    "8ì",
    "9ì",
    "10ì",
    "11ì",
    "12ì",
  ],
};

const dayValues$A = {
  narrow: ["ì¼", "ì", "í", "ì", "ëª©", "ê¸", "í "],
  short: ["ì¼", "ì", "í", "ì", "ëª©", "ê¸", "í "],
  abbreviated: ["ì¼", "ì", "í", "ì", "ëª©", "ê¸", "í "],
  wide: ["ì¼ìì¼", "ììì¼", "íìì¼", "ììì¼", "ëª©ìì¼", "ê¸ìì¼", "í ìì¼"],
};

const dayPeriodValues$A = {
  narrow: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
  abbreviated: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
  wide: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
};

const formattingDayPeriodValues$s = {
  narrow: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
  abbreviated: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
  wide: {
    am: "ì¤ì ",
    pm: "ì¤í",
    midnight: "ìì ",
    noon: "ì ì¤",
    morning: "ìì¹¨",
    afternoon: "ì¤í",
    evening: "ì ë",
    night: "ë°¤",
  },
};

const ordinalNumber$A = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = String(options?.unit);

  switch (unit) {
    case "minute":
    case "second":
      return String(number);
    case "date":
      return number + "ì¼";
    default:
      return number + "ë²ì§¸";
  }
};

(localize$A.localize = {
  ordinalNumber: ordinalNumber$A,

  era: (0, _index$6g.buildLocalizeFn)({
    values: eraValues$A,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6g.buildLocalizeFn)({
    values: quarterValues$A,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6g.buildLocalizeFn)({
    values: monthValues$A,
    defaultWidth: "wide",
  }),

  day: (0, _index$6g.buildLocalizeFn)({
    values: dayValues$A,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6g.buildLocalizeFn)({
    values: dayPeriodValues$A,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$s,
    defaultFormattingWidth: "wide",
  }),
});

var match$A = {};

match$A.match = void 0;

var _index$6f = buildMatchFn$1;
var _index2$2I = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$A = /^(\d+)(ì¼|ë²ì§¸)?/i;
const parseOrdinalNumberPattern$A = /\d+/i;

const matchEraPatterns$A = {
  narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(ê¸°ìì |ìê¸°)/i,
};
const parseEraPatterns$A = {
  any: [/^(bc|ê¸°ìì )/i, /^(ad|ìê¸°)/i],
};

const matchQuarterPatterns$A = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]ì¬?ë¶ê¸°/i,
};
const parseQuarterPatterns$A = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$A = {
  narrow: /^(1[012]|[123456789])/,
  abbreviated: /^(1[012]|[123456789])ì/i,
  wide: /^(1[012]|[123456789])ì/i,
};
const parseMonthPatterns$A = {
  any: [
    /^1ì?$/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/,
  ],
};

const matchDayPatterns$A = {
  narrow: /^[ì¼ìíìëª©ê¸í ]/,
  short: /^[ì¼ìíìëª©ê¸í ]/,
  abbreviated: /^[ì¼ìíìëª©ê¸í ]/,
  wide: /^[ì¼ìíìëª©ê¸í ]ìì¼/,
};
const parseDayPatterns$A = {
  any: [/^ì¼/, /^ì/, /^í/, /^ì/, /^ëª©/, /^ê¸/, /^í /],
};

const matchDayPeriodPatterns$A = {
  any: /^(am|pm|ì¤ì |ì¤í|ìì |ì ì¤|ìì¹¨|ì ë|ë°¤)/i,
};
const parseDayPeriodPatterns$A = {
  any: {
    am: /^(am|ì¤ì )/i,
    pm: /^(pm|ì¤í)/i,
    midnight: /^ìì /i,
    noon: /^ì ì¤/i,
    morning: /^ìì¹¨/i,
    afternoon: /^ì¤í/i,
    evening: /^ì ë/i,
    night: /^ë°¤/i,
  },
};

(match$A.match = {
  ordinalNumber: (0, _index2$2I.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$A,
    parsePattern: parseOrdinalNumberPattern$A,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6f.buildMatchFn)({
    matchPatterns: matchEraPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$A,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6f.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$A,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6f.buildMatchFn)({
    matchPatterns: matchMonthPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$A,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6f.buildMatchFn)({
    matchPatterns: matchDayPatterns$A,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$A,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6f.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$A,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$A,
    defaultParseWidth: "any",
  }),
});

ko.ko = void 0;
var _index$6e = formatDistance$1b;
var _index2$2H = formatLong$A;
var _index3$1m = formatRelative$1b;
var _index4$S = localize$A;
var _index5$J = match$A;

/**
 * @category Locales
 * @summary Korean locale.
 * @language Korean
 * @iso-639-2 kor
 * @author Hong Chulju [@angdev](https://github.com/angdev)
 * @author Lee Seoyoen [@iamssen](https://github.com/iamssen)
 * @author Taiki IKeda [@so99ynoodles](https://github.com/so99ynoodles)
 */
(ko.ko = {
  code: "ko",
  formatDistance: _index$6e.formatDistance,
  formatLong: _index2$2H.formatLong,
  formatRelative: _index3$1m.formatRelative,
  localize: _index4$S.localize,
  match: _index5$J.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var lb = {};

var formatDistance$19 = {};

formatDistance$19.formatDistance = void 0;

const formatDistanceLocale$z = {
  lessThanXSeconds: {
    standalone: {
      one: "manner wÃ©i eng Sekonn",
      other: "manner wÃ©i {{count}} Sekonnen",
    },
    withPreposition: {
      one: "manner wÃ©i enger Sekonn",
      other: "manner wÃ©i {{count}} Sekonnen",
    },
  },

  xSeconds: {
    standalone: {
      one: "eng Sekonn",
      other: "{{count}} Sekonnen",
    },
    withPreposition: {
      one: "enger Sekonn",
      other: "{{count}} Sekonnen",
    },
  },

  halfAMinute: {
    standalone: "eng hallef Minutt",
    withPreposition: "enger hallwer Minutt",
  },

  lessThanXMinutes: {
    standalone: {
      one: "manner wÃ©i eng Minutt",
      other: "manner wÃ©i {{count}} Minutten",
    },
    withPreposition: {
      one: "manner wÃ©i enger Minutt",
      other: "manner wÃ©i {{count}} Minutten",
    },
  },

  xMinutes: {
    standalone: {
      one: "eng Minutt",
      other: "{{count}} Minutten",
    },
    withPreposition: {
      one: "enger Minutt",
      other: "{{count}} Minutten",
    },
  },

  aboutXHours: {
    standalone: {
      one: "ongefÃ©ier eng Stonn",
      other: "ongefÃ©ier {{count}} Stonnen",
    },
    withPreposition: {
      one: "ongefÃ©ier enger Stonn",
      other: "ongefÃ©ier {{count}} Stonnen",
    },
  },

  xHours: {
    standalone: {
      one: "eng Stonn",
      other: "{{count}} Stonnen",
    },
    withPreposition: {
      one: "enger Stonn",
      other: "{{count}} Stonnen",
    },
  },

  xDays: {
    standalone: {
      one: "een Dag",
      other: "{{count}} Deeg",
    },
    withPreposition: {
      one: "engem Dag",
      other: "{{count}} Deeg",
    },
  },

  aboutXWeeks: {
    standalone: {
      one: "ongefÃ©ier eng Woch",
      other: "ongefÃ©ier {{count}} Wochen",
    },
    withPreposition: {
      one: "ongefÃ©ier enger Woche",
      other: "ongefÃ©ier {{count}} Wochen",
    },
  },

  xWeeks: {
    standalone: {
      one: "eng Woch",
      other: "{{count}} Wochen",
    },
    withPreposition: {
      one: "enger Woch",
      other: "{{count}} Wochen",
    },
  },

  aboutXMonths: {
    standalone: {
      one: "ongefÃ©ier ee Mount",
      other: "ongefÃ©ier {{count}} MÃ©int",
    },
    withPreposition: {
      one: "ongefÃ©ier engem Mount",
      other: "ongefÃ©ier {{count}} MÃ©int",
    },
  },

  xMonths: {
    standalone: {
      one: "ee Mount",
      other: "{{count}} MÃ©int",
    },
    withPreposition: {
      one: "engem Mount",
      other: "{{count}} MÃ©int",
    },
  },

  aboutXYears: {
    standalone: {
      one: "ongefÃ©ier ee Joer",
      other: "ongefÃ©ier {{count}} Joer",
    },
    withPreposition: {
      one: "ongefÃ©ier engem Joer",
      other: "ongefÃ©ier {{count}} Joer",
    },
  },

  xYears: {
    standalone: {
      one: "ee Joer",
      other: "{{count}} Joer",
    },
    withPreposition: {
      one: "engem Joer",
      other: "{{count}} Joer",
    },
  },

  overXYears: {
    standalone: {
      one: "mÃ©i wÃ©i ee Joer",
      other: "mÃ©i wÃ©i {{count}} Joer",
    },
    withPreposition: {
      one: "mÃ©i wÃ©i engem Joer",
      other: "mÃ©i wÃ©i {{count}} Joer",
    },
  },

  almostXYears: {
    standalone: {
      one: "bal ee Joer",
      other: "bal {{count}} Joer",
    },
    withPreposition: {
      one: "bal engem Joer",
      other: "bal {{count}} Joer",
    },
  },
};

const EXCEPTION_CONSONANTS = ["d", "h", "n", "t", "z"];
const VOWELS = ["a,", "e", "i", "o", "u"];
const DIGITS_SPOKEN_N_NEEDED = [0, 1, 2, 3, 8, 9];
const FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED = [40, 50, 60, 70];

// Eifeler Regel
function isFinalNNeeded(nextWords) {
  const firstLetter = nextWords.charAt(0).toLowerCase();
  if (
    VOWELS.indexOf(firstLetter) != -1 ||
    EXCEPTION_CONSONANTS.indexOf(firstLetter) != -1
  ) {
    return true;
  }

  // Numbers would need to converted into words for checking.
  // Therefore, I have listed the digits that require a preceeding n with a few exceptions.
  const firstWord = nextWords.split(" ")[0];
  const number = parseInt(firstWord);
  if (
    !isNaN(number) &&
    DIGITS_SPOKEN_N_NEEDED.indexOf(number % 10) != -1 &&
    FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED.indexOf(
      parseInt(firstWord.substring(0, 2)),
    ) == -1
  ) {
    return true;
  }

  // Omit other checks as they are not expected here.
  return false;
}

const formatDistance$18 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$z[token];

  const usageGroup = options?.addSuffix
    ? tokenValue.withPreposition
    : tokenValue.standalone;

  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "a" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    } else {
      return "viru" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    }
  }

  return result;
};
formatDistance$19.formatDistance = formatDistance$18;

var formatLong$z = {};

formatLong$z.formatLong = void 0;
var _index$6d = buildFormatLongFn$1;

// DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008

const dateFormats$z = {
  full: "EEEE, do MMMM y", // MÃ©indeg, 7. Januar 2018
  long: "do MMMM y", // 7. Januar 2018
  medium: "do MMM y", // 7. Jan 2018
  short: "dd.MM.yy", // 07.01.18
};

const timeFormats$z = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$z = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$z.formatLong = {
  date: (0, _index$6d.buildFormatLongFn)({
    formats: dateFormats$z,
    defaultWidth: "full",
  }),

  time: (0, _index$6d.buildFormatLongFn)({
    formats: timeFormats$z,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$6d.buildFormatLongFn)({
    formats: dateTimeFormats$z,
    defaultWidth: "full",
  }),
});

var formatRelative$19 = {};

formatRelative$19.formatRelative = void 0;

const formatRelativeLocale$z = {
  lastWeek: (date) => {
    const day = date.getDay();
    let result = "'lÃ¤schte";
    if (day === 2 || day === 4) {
      // Eifeler Regel: Add an n before the consonant d; Here "DÃ«nschdeg" "and Donneschde".
      result += "n";
    }
    result += "' eeee 'um' p";
    return result;
  },
  yesterday: "'gÃ«schter um' p",
  today: "'haut um' p",
  tomorrow: "'moien um' p",
  nextWeek: "eeee 'um' p",
  other: "P",
};

const formatRelative$18 = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$z[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$19.formatRelative = formatRelative$18;

var localize$z = {};

localize$z.localize = void 0;
var _index$6c = buildLocalizeFn$1;

const eraValues$z = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["viru Christus", "no Christus"],
};

const quarterValues$z = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"],
};

const monthValues$z = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "MÃ¤e",
    "Abr",
    "Mee",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez",
  ],

  wide: [
    "Januar",
    "Februar",
    "MÃ¤erz",
    "AbrÃ«ll",
    "Mee",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember",
  ],
};

const dayValues$z = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "MÃ©", "DÃ«", "MÃ«", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "MÃ©.", "DÃ«.", "MÃ«.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonndeg",
    "MÃ©indeg",
    "DÃ«nschdeg",
    "MÃ«ttwoch",
    "Donneschdeg",
    "Freideg",
    "Samschdeg",
  ],
};

const dayPeriodValues$z = {
  narrow: {
    am: "mo.",
    pm: "nomÃ«.",
    midnight: "MÃ«tternuecht",
    noon: "MÃ«tteg",
    morning: "Moien",
    afternoon: "NomÃ«tteg",
    evening: "Owend",
    night: "Nuecht",
  },
  abbreviated: {
    am: "moies",
    pm: "nomÃ«ttes",
    midnight: "MÃ«tternuecht",
    noon: "MÃ«tteg",
    morning: "Moien",
    afternoon: "NomÃ«tteg",
    evening: "Owend",
    night: "Nuecht",
  },
  wide: {
    am: "moies",
    pm: "nomÃ«ttes",
    midnight: "MÃ«tternuecht",
    noon: "MÃ«tteg",
    morning: "Moien",
    afternoon: "NomÃ«tteg",
    evening: "Owend",
    night: "Nuecht",
  },
};

const formattingDayPeriodValues$r = {
  narrow: {
    am: "mo.",
    pm: "nom.",
    midnight: "MÃ«tternuecht",
    noon: "mÃ«ttes",
    morning: "moies",
    afternoon: "nomÃ«ttes",
    evening: "owes",
    night: "nuets",
  },
  abbreviated: {
    am: "moies",
    pm: "nomÃ«ttes",
    midnight: "MÃ«tternuecht",
    noon: "mÃ«ttes",
    morning: "moies",
    afternoon: "nomÃ«ttes",
    evening: "owes",
    night: "nuets",
  },
  wide: {
    am: "moies",
    pm: "nomÃ«ttes",
    midnight: "MÃ«tternuecht",
    noon: "mÃ«ttes",
    morning: "moies",
    afternoon: "nomÃ«ttes",
    evening: "owes",
    night: "nuets",
  },
};

const ordinalNumber$z = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$z.localize = {
  ordinalNumber: ordinalNumber$z,

  era: (0, _index$6c.buildLocalizeFn)({
    values: eraValues$z,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$6c.buildLocalizeFn)({
    values: quarterValues$z,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$6c.buildLocalizeFn)({
    values: monthValues$z,
    defaultWidth: "wide",
  }),

  day: (0, _index$6c.buildLocalizeFn)({
    values: dayValues$z,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$6c.buildLocalizeFn)({
    values: dayPeriodValues$z,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$r,
    defaultFormattingWidth: "wide",
  }),
});

var match$z = {};

match$z.match = void 0;

var _index$6b = buildMatchFn$1;
var _index2$2G = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$z = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$z = /\d+/i;

const matchEraPatterns$z = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(viru Christus|virun eiser ZÃ¤itrechnung|no Christus|eiser ZÃ¤itrechnung)/i,
};
const parseEraPatterns$z = {
  any: [/^v/i, /^n/i],
};

const matchQuarterPatterns$z = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i,
};
const parseQuarterPatterns$z = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$z = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mÃ¤e|abr|mee|jun|jul|aug|sep|okt|nov|dez)/i,
  wide: /^(januar|februar|mÃ¤erz|abrÃ«ll|mee|juni|juli|august|september|oktober|november|dezember)/i,
};
const parseMonthPatterns$z = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mÃ¤/i,
    /^ab/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$z = {
  narrow: /^[smdf]/i,
  short: /^(so|mÃ©|dÃ«|mÃ«|do|fr|sa)/i,
  abbreviated: /^(son?|mÃ©i?|dÃ«n?|mÃ«t?|don?|fre?|sam?)\.?/i,
  wide: /^(sonndeg|mÃ©indeg|dÃ«nschdeg|mÃ«ttwoch|donneschdeg|freideg|samschdeg)/i,
};
const parseDayPatterns$z = {
  any: [/^so/i, /^mÃ©/i, /^dÃ«/i, /^mÃ«/i, /^do/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$z = {
  narrow: /^(mo\.?|nomÃ«\.?|MÃ«tternuecht|mÃ«ttes|moies|nomÃ«ttes|owes|nuets)/i,
  abbreviated:
    /^(moi\.?|nomÃ«t\.?|MÃ«tternuecht|mÃ«ttes|moies|nomÃ«ttes|owes|nuets)/i,
  wide: /^(moies|nomÃ«ttes|MÃ«tternuecht|mÃ«ttes|moies|nomÃ«ttes|owes|nuets)/i,
};
const parseDayPeriodPatterns$z = {
  any: {
    am: /^m/i,
    pm: /^n/i,
    midnight: /^MÃ«tter/i,
    noon: /^mÃ«ttes/i,
    morning: /moies/i,
    afternoon: /nomÃ«ttes/i, // will never be matched. Afternoon is matched by `pm`
    evening: /owes/i,
    night: /nuets/i, // will never be matched. Night is matched by `pm`
  },
};

(match$z.match = {
  ordinalNumber: (0, _index2$2G.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$z,
    parsePattern: parseOrdinalNumberPattern$z,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$6b.buildMatchFn)({
    matchPatterns: matchEraPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$z,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$6b.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$z,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$6b.buildMatchFn)({
    matchPatterns: matchMonthPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$z,
    defaultParseWidth: "any",
  }),

  day: (0, _index$6b.buildMatchFn)({
    matchPatterns: matchDayPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$z,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$6b.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$z,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$z,
    defaultParseWidth: "any",
  }),
});

lb.lb = void 0;
var _index$6a = formatDistance$19;
var _index2$2F = formatLong$z;
var _index3$1l = formatRelative$19;
var _index4$R = localize$z;
var _index5$I = match$z;

/**
 * @category Locales
 * @summary Luxembourgish locale.
 * @language Luxembourgish
 * @iso-639-2 ltz
 * @author Daniel Waxweiler [@dwaxweiler](https://github.com/dwaxweiler)
 */
(lb.lb = {
  code: "lb",
  formatDistance: _index$6a.formatDistance,
  formatLong: _index2$2F.formatLong,
  formatRelative: _index3$1l.formatRelative,
  localize: _index4$R.localize,
  match: _index5$I.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var lt = {};

var formatDistance$17 = {};

formatDistance$17.formatDistance = void 0;

const translations = {
  xseconds_other: "sekundÄ_sekundÅ¾iÅ³_sekundes",
  xminutes_one: "minutÄ_minutÄs_minutÄ",
  xminutes_other: "minutÄs_minuÄiÅ³_minutes",
  xhours_one: "valanda_valandos_valandÄ",
  xhours_other: "valandos_valandÅ³_valandas",
  xdays_one: "diena_dienos_dienÄ",
  xdays_other: "dienos_dienÅ³_dienas",
  xweeks_one: "savaitÄ_savaitÄs_savaitÄ",
  xweeks_other: "savaitÄs_savaiÄiÅ³_savaites",
  xmonths_one: "mÄnuo_mÄnesio_mÄnesÄ¯",
  xmonths_other: "mÄnesiai_mÄnesiÅ³_mÄnesius",
  xyears_one: "metai_metÅ³_metus",
  xyears_other: "metai_metÅ³_metus",
  about: "apie",
  over: "daugiau nei",
  almost: "beveik",
  lessthan: "maÅ¾iau nei",
};

const translateSeconds = (_number, addSuffix, _key, isFuture) => {
  if (!addSuffix) {
    return "kelios sekundÄs";
  } else {
    return isFuture ? "keliÅ³ sekundÅ¾iÅ³" : "kelias sekundes";
  }
};

const translateSingular = (_number, addSuffix, key, isFuture) => {
  return !addSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
};

const translate = (number, addSuffix, key, isFuture) => {
  const result = number + " ";
  if (number === 1) {
    return result + translateSingular(number, addSuffix, key, isFuture);
  } else if (!addSuffix) {
    return result + (special(number) ? forms(key)[1] : forms(key)[0]);
  } else {
    if (isFuture) {
      return result + forms(key)[1];
    } else {
      return result + (special(number) ? forms(key)[1] : forms(key)[2]);
    }
  }
};

function special(number) {
  return number % 10 === 0 || (number > 10 && number < 20);
}

function forms(key) {
  return translations[key].split("_");
}

const formatDistanceLocale$y = {
  lessThanXSeconds: {
    one: translateSeconds,
    other: translate,
  },

  xSeconds: {
    one: translateSeconds,
    other: translate,
  },

  halfAMinute: "pusÄ minutÄs",

  lessThanXMinutes: {
    one: translateSingular,
    other: translate,
  },

  xMinutes: {
    one: translateSingular,
    other: translate,
  },

  aboutXHours: {
    one: translateSingular,
    other: translate,
  },

  xHours: {
    one: translateSingular,
    other: translate,
  },

  xDays: {
    one: translateSingular,
    other: translate,
  },

  aboutXWeeks: {
    one: translateSingular,
    other: translate,
  },

  xWeeks: {
    one: translateSingular,
    other: translate,
  },

  aboutXMonths: {
    one: translateSingular,
    other: translate,
  },

  xMonths: {
    one: translateSingular,
    other: translate,
  },

  aboutXYears: {
    one: translateSingular,
    other: translate,
  },

  xYears: {
    one: translateSingular,
    other: translate,
  },

  overXYears: {
    one: translateSingular,
    other: translate,
  },

  almostXYears: {
    one: translateSingular,
    other: translate,
  },
};

const formatDistance$16 = (token, count, options) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;

  const isFuture = options?.comparison !== undefined && options.comparison > 0;

  let result;

  const tokenValue = formatDistanceLocale$y[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one(
      count,
      options?.addSuffix === true,
      unit.toLowerCase() + "_one",
      isFuture,
    );
  } else {
    result = tokenValue.other(
      count,
      options?.addSuffix === true,
      unit.toLowerCase() + "_other",
      isFuture,
    );
  }

  if (adverb) {
    const key = adverb[0].toLowerCase();
    result = translations[key] + " " + result;
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "po " + result;
    } else {
      return "prieÅ¡ " + result;
    }
  }

  return result;
};
formatDistance$17.formatDistance = formatDistance$16;

var formatLong$y = {};

formatLong$y.formatLong = void 0;
var _index$69 = buildFormatLongFn$1;

const dateFormats$y = {
  full: "y 'm'. MMMM d 'd'., EEEE",
  long: "y 'm'. MMMM d 'd'.",
  medium: "y-MM-dd",
  short: "y-MM-dd",
};

const timeFormats$y = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$y = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$y.formatLong = {
  date: (0, _index$69.buildFormatLongFn)({
    formats: dateFormats$y,
    defaultWidth: "full",
  }),

  time: (0, _index$69.buildFormatLongFn)({
    formats: timeFormats$y,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$69.buildFormatLongFn)({
    formats: dateTimeFormats$y,
    defaultWidth: "full",
  }),
});

var formatRelative$17 = {};

formatRelative$17.formatRelative = void 0;

const formatRelativeLocale$y = {
  lastWeek: "'PraÄjusÄ¯' eeee p",
  yesterday: "'Vakar' p",
  today: "'Å iandien' p",
  tomorrow: "'Rytoj' p",
  nextWeek: "eeee p",
  other: "P",
};

const formatRelative$16 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$y[token];
formatRelative$17.formatRelative = formatRelative$16;

var localize$y = {};

localize$y.localize = void 0;
var _index$68 = buildLocalizeFn$1;

const eraValues$y = {
  narrow: ["pr. Kr.", "po Kr."],
  abbreviated: ["pr. Kr.", "po Kr."],
  wide: ["prieÅ¡ KristÅ³", "po Kristaus"],
};

const quarterValues$y = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I ketv.", "II ketv.", "III ketv.", "IV ketv."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"],
};

const formattingQuarterValues$2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I k.", "II k.", "III k.", "IV k."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"],
};

const monthValues$y = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "birÅ¾.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod.",
  ],

  wide: [
    "sausis",
    "vasaris",
    "kovas",
    "balandis",
    "geguÅ¾Ä",
    "birÅ¾elis",
    "liepa",
    "rugpjÅ«tis",
    "rugsÄjis",
    "spalis",
    "lapkritis",
    "gruodis",
  ],
};

const formattingMonthValues$8 = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "birÅ¾.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod.",
  ],

  wide: [
    "sausio",
    "vasario",
    "kovo",
    "balandÅ¾io",
    "geguÅ¾Äs",
    "birÅ¾elio",
    "liepos",
    "rugpjÅ«Äio",
    "rugsÄjo",
    "spalio",
    "lapkriÄio",
    "gruodÅ¾io",
  ],
};

const dayValues$y = {
  narrow: ["S", "P", "A", "T", "K", "P", "Å "],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "Å t"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "Å¡t"],
  wide: [
    "sekmadienis",
    "pirmadienis",
    "antradienis",
    "treÄiadienis",
    "ketvirtadienis",
    "penktadienis",
    "Å¡eÅ¡tadienis",
  ],
};

const formattingDayValues$2 = {
  narrow: ["S", "P", "A", "T", "K", "P", "Å "],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "Å t"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "Å¡t"],
  wide: [
    "sekmadienÄ¯",
    "pirmadienÄ¯",
    "antradienÄ¯",
    "treÄiadienÄ¯",
    "ketvirtadienÄ¯",
    "penktadienÄ¯",
    "Å¡eÅ¡tadienÄ¯",
  ],
};

const dayPeriodValues$y = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis",
  },
  abbreviated: {
    am: "prieÅ¡piet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis",
  },
  wide: {
    am: "prieÅ¡piet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis",
  },
};

const formattingDayPeriodValues$q = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietÄ",
    evening: "vakaras",
    night: "naktis",
  },
  abbreviated: {
    am: "prieÅ¡piet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietÄ",
    evening: "vakaras",
    night: "naktis",
  },
  wide: {
    am: "prieÅ¡piet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietÄ",
    evening: "vakaras",
    night: "naktis",
  },
};

const ordinalNumber$y = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "-oji";
};

(localize$y.localize = {
  ordinalNumber: ordinalNumber$y,

  era: (0, _index$68.buildLocalizeFn)({
    values: eraValues$y,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$68.buildLocalizeFn)({
    values: quarterValues$y,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues$2,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$68.buildLocalizeFn)({
    values: monthValues$y,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$8,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$68.buildLocalizeFn)({
    values: dayValues$y,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$2,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$68.buildLocalizeFn)({
    values: dayPeriodValues$y,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$q,
    defaultFormattingWidth: "wide",
  }),
});

var match$y = {};

match$y.match = void 0;

var _index$67 = buildMatchFn$1;
var _index2$2E = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$y = /^(\d+)(-oji)?/i;
const parseOrdinalNumberPattern$y = /\d+/i;

const matchEraPatterns$y = {
  narrow: /^p(r|o)\.?\s?(kr\.?|me)/i,
  abbreviated: /^(pr\.\s?(kr\.|m\.\s?e\.)|po\s?kr\.|mÅ«sÅ³ eroje)/i,
  wide: /^(prieÅ¡ KristÅ³|prieÅ¡ mÅ«sÅ³ erÄ|po Kristaus|mÅ«sÅ³ eroje)/i,
};
const parseEraPatterns$y = {
  wide: [/prieÅ¡/i, /(po|mÅ«sÅ³)/i],
  any: [/^pr/i, /^(po|m)/i],
};

const matchQuarterPatterns$y = {
  narrow: /^([1234])/i,
  abbreviated: /^(I|II|III|IV)\s?ketv?\.?/i,
  wide: /^(I|II|III|IV)\s?ketvirtis/i,
};
const parseQuarterPatterns$y = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/I$/i, /II$/i, /III/i, /IV/i],
};

const matchMonthPatterns$y = {
  narrow: /^[svkbglr]/i,
  abbreviated:
    /^(saus\.|vas\.|kov\.|bal\.|geg\.|birÅ¾\.|liep\.|rugp\.|rugs\.|spal\.|lapkr\.|gruod\.)/i,
  wide: /^(sausi(s|o)|vasari(s|o)|kov(a|o)s|balandÅ¾?i(s|o)|geguÅ¾Äs?|birÅ¾eli(s|o)|liep(a|os)|rugpjÅ«(t|Ä)i(s|o)|rugsÄj(is|o)|spali(s|o)|lapkri(t|Ä)i(s|o)|gruodÅ¾?i(s|o))/i,
};
const parseMonthPatterns$y = {
  narrow: [
    /^s/i,
    /^v/i,
    /^k/i,
    /^b/i,
    /^g/i,
    /^b/i,
    /^l/i,
    /^r/i,
    /^r/i,
    /^s/i,
    /^l/i,
    /^g/i,
  ],

  any: [
    /^saus/i,
    /^vas/i,
    /^kov/i,
    /^bal/i,
    /^geg/i,
    /^birÅ¾/i,
    /^liep/i,
    /^rugp/i,
    /^rugs/i,
    /^spal/i,
    /^lapkr/i,
    /^gruod/i,
  ],
};

const matchDayPatterns$y = {
  narrow: /^[spatkÅ¡]/i,
  short: /^(sk|pr|an|tr|kt|pn|Å¡t)/i,
  abbreviated: /^(sk|pr|an|tr|kt|pn|Å¡t)/i,
  wide: /^(sekmadien(is|Ä¯)|pirmadien(is|Ä¯)|antradien(is|Ä¯)|treÄiadien(is|Ä¯)|ketvirtadien(is|Ä¯)|penktadien(is|Ä¯)|Å¡eÅ¡tadien(is|Ä¯))/i,
};
const parseDayPatterns$y = {
  narrow: [/^s/i, /^p/i, /^a/i, /^t/i, /^k/i, /^p/i, /^Å¡/i],
  wide: [/^se/i, /^pi/i, /^an/i, /^tr/i, /^ke/i, /^pe/i, /^Å¡e/i],
  any: [/^sk/i, /^pr/i, /^an/i, /^tr/i, /^kt/i, /^pn/i, /^Å¡t/i],
};

const matchDayPeriodPatterns$y = {
  narrow:
    /^(pr.\s?p.|pop.|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popietÄ)|vakaras|naktis)/i,
  any: /^(prieÅ¡piet|popiet$|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popietÄ)|vakaras|naktis)/i,
};
const parseDayPeriodPatterns$y = {
  narrow: {
    am: /^pr/i,
    pm: /^pop./i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popietÄ)/i,
    evening: /vakaras/i,
    night: /naktis/i,
  },
  any: {
    am: /^pr/i,
    pm: /^popiet$/i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popietÄ)/i,
    evening: /vakaras/i,
    night: /naktis/i,
  },
};

(match$y.match = {
  ordinalNumber: (0, _index2$2E.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$y,
    parsePattern: parseOrdinalNumberPattern$y,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$67.buildMatchFn)({
    matchPatterns: matchEraPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$y,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$67.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$y,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$67.buildMatchFn)({
    matchPatterns: matchMonthPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$y,
    defaultParseWidth: "any",
  }),

  day: (0, _index$67.buildMatchFn)({
    matchPatterns: matchDayPatterns$y,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$y,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$67.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$y,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$y,
    defaultParseWidth: "any",
  }),
});

lt.lt = void 0;
var _index$66 = formatDistance$17;
var _index2$2D = formatLong$y;
var _index3$1k = formatRelative$17;
var _index4$Q = localize$y;
var _index5$H = match$y;

/**
 * @category Locales
 * @summary Lithuanian locale.
 * @language Lithuanian
 * @iso-639-2 lit
 * @author Pavlo Shpak [@pshpak](https://github.com/pshpak)
 * @author Eduardo Pardo [@eduardopsll](https://github.com/eduardopsll)
 */
(lt.lt = {
  code: "lt",
  formatDistance: _index$66.formatDistance,
  formatLong: _index2$2D.formatLong,
  formatRelative: _index3$1k.formatRelative,
  localize: _index4$Q.localize,
  match: _index5$H.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var lv = {};

var formatDistance$15 = {};

formatDistance$15.formatDistance = void 0;

function buildLocalizeTokenFn$2(schema) {
  return (count, options) => {
    if (count === 1) {
      if (options?.addSuffix) {
        return schema.one[0].replace("{{time}}", schema.one[2]);
      } else {
        return schema.one[0].replace("{{time}}", schema.one[1]);
      }
    } else {
      const rem = count % 10 === 1 && count % 100 !== 11;
      if (options?.addSuffix) {
        return schema.other[0]
          .replace("{{time}}", rem ? schema.other[3] : schema.other[4])
          .replace("{{count}}", String(count));
      } else {
        return schema.other[0]
          .replace("{{time}}", rem ? schema.other[1] : schema.other[2])
          .replace("{{count}}", String(count));
      }
    }
  };
}

const formatDistanceLocale$x = {
  lessThanXSeconds: buildLocalizeTokenFn$2({
    one: ["mazÄk par {{time}}", "sekundi", "sekundi"],
    other: [
      "mazÄk nekÄ {{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundÄm",
    ],
  }),

  xSeconds: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "sekunde", "sekundes"],
    other: [
      "{{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundÄm",
    ],
  }),

  halfAMinute: (_count, options) => {
    if (options?.addSuffix) {
      return "pusminÅ«tes";
    } else {
      return "pusminÅ«te";
    }
  },

  lessThanXMinutes: buildLocalizeTokenFn$2({
    one: ["mazÄk par {{time}}", "minÅ«ti", "minÅ«ti"],
    other: [
      "mazÄk nekÄ {{count}} {{time}}",
      "minÅ«te",
      "minÅ«tes",
      "minÅ«tes",
      "minÅ«tÄm",
    ],
  }),

  xMinutes: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "minÅ«te", "minÅ«tes"],
    other: ["{{count}} {{time}}", "minÅ«te", "minÅ«tes", "minÅ«tes", "minÅ«tÄm"],
  }),

  aboutXHours: buildLocalizeTokenFn$2({
    one: ["apmÄram 1 {{time}}", "stunda", "stundas"],
    other: [
      "apmÄram {{count}} {{time}}",
      "stunda",
      "stundas",
      "stundas",
      "stundÄm",
    ],
  }),

  xHours: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "stunda", "stundas"],
    other: ["{{count}} {{time}}", "stunda", "stundas", "stundas", "stundÄm"],
  }),

  xDays: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "diena", "dienas"],
    other: ["{{count}} {{time}}", "diena", "dienas", "dienas", "dienÄm"],
  }),

  aboutXWeeks: buildLocalizeTokenFn$2({
    one: ["apmÄram 1 {{time}}", "nedÄÄ¼a", "nedÄÄ¼as"],
    other: [
      "apmÄram {{count}} {{time}}",
      "nedÄÄ¼a",
      "nedÄÄ¼u",
      "nedÄÄ¼as",
      "nedÄÄ¼Äm",
    ],
  }),

  xWeeks: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "nedÄÄ¼a", "nedÄÄ¼as"],
    other: [
      "{{count}} {{time}}", // TODO
      "nedÄÄ¼a",
      "nedÄÄ¼u",
      "nedÄÄ¼as",
      "nedÄÄ¼Äm",
    ],
  }),

  aboutXMonths: buildLocalizeTokenFn$2({
    one: ["apmÄram 1 {{time}}", "mÄnesis", "mÄneÅ¡a"],
    other: [
      "apmÄram {{count}} {{time}}",
      "mÄnesis",
      "mÄneÅ¡i",
      "mÄneÅ¡a",
      "mÄneÅ¡iem",
    ],
  }),

  xMonths: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "mÄnesis", "mÄneÅ¡a"],
    other: ["{{count}} {{time}}", "mÄnesis", "mÄneÅ¡i", "mÄneÅ¡a", "mÄneÅ¡iem"],
  }),

  aboutXYears: buildLocalizeTokenFn$2({
    one: ["apmÄram 1 {{time}}", "gads", "gada"],
    other: ["apmÄram {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"],
  }),

  xYears: buildLocalizeTokenFn$2({
    one: ["1 {{time}}", "gads", "gada"],
    other: ["{{count}} {{time}}", "gads", "gadi", "gada", "gadiem"],
  }),

  overXYears: buildLocalizeTokenFn$2({
    one: ["ilgÄk par 1 {{time}}", "gadu", "gadu"],
    other: ["vairÄk nekÄ {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"],
  }),

  almostXYears: buildLocalizeTokenFn$2({
    one: ["gandrÄ«z 1 {{time}}", "gads", "gada"],
    other: ["vairÄk nekÄ {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"],
  }),
};

const formatDistance$14 = (token, count, options) => {
  const result = formatDistanceLocale$x[token](count, options);

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "pÄc " + result;
    } else {
      return "pirms " + result;
    }
  }

  return result;
};
formatDistance$15.formatDistance = formatDistance$14;

var formatLong$x = {};

formatLong$x.formatLong = void 0;
var _index$65 = buildFormatLongFn$1;

const dateFormats$x = {
  full: "EEEE, y. 'gada' d. MMMM",
  long: "y. 'gada' d. MMMM",
  medium: "dd.MM.y.",
  short: "dd.MM.y.",
};

const timeFormats$x = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$x = {
  full: "{{date}} 'plkst.' {{time}}",
  long: "{{date}} 'plkst.' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$x.formatLong = {
  date: (0, _index$65.buildFormatLongFn)({
    formats: dateFormats$x,
    defaultWidth: "full",
  }),

  time: (0, _index$65.buildFormatLongFn)({
    formats: timeFormats$x,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$65.buildFormatLongFn)({
    formats: dateTimeFormats$x,
    defaultWidth: "full",
  }),
});

var formatRelative$15 = {};

formatRelative$15.formatRelative = void 0;
var _index$64 = isSameWeek$1;

const weekdays$1 = [
  "svÄtdienÄ",
  "pirmdienÄ",
  "otrdienÄ",
  "treÅ¡dienÄ",
  "ceturtdienÄ",
  "piektdienÄ",
  "sestdienÄ",
];

const formatRelativeLocale$x = {
  lastWeek: (date, baseDate, options) => {
    if ((0, _index$64.isSameWeek)(date, baseDate, options)) {
      return "eeee 'plkst.' p";
    }

    const weekday = weekdays$1[date.getDay()];
    return "'PagÄjuÅ¡Ä " + weekday + " plkst.' p";
  },
  yesterday: "'Vakar plkst.' p",
  today: "'Å odien plkst.' p",
  tomorrow: "'RÄ«t plkst.' p",
  nextWeek: (date, baseDate, options) => {
    if ((0, _index$64.isSameWeek)(date, baseDate, options)) {
      return "eeee 'plkst.' p";
    }

    const weekday = weekdays$1[date.getDay()];
    return "'NÄkamajÄ " + weekday + " plkst.' p";
  },
  other: "P",
};

const formatRelative$14 = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$x[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$15.formatRelative = formatRelative$14;

var localize$x = {};

localize$x.localize = void 0;
var _index$63 = buildLocalizeFn$1;

const eraValues$x = {
  narrow: ["p.m.Ä", "m.Ä"],
  abbreviated: ["p. m. Ä.", "m. Ä."],
  wide: ["pirms mÅ«su Äras", "mÅ«su ÄrÄ"],
};

const quarterValues$x = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmais ceturksnis",
    "otrais ceturksnis",
    "treÅ¡ais ceturksnis",
    "ceturtais ceturksnis",
  ],
};

const formattingQuarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmajÄ ceturksnÄ«",
    "otrajÄ ceturksnÄ«",
    "treÅ¡ajÄ ceturksnÄ«",
    "ceturtajÄ ceturksnÄ«",
  ],
};

const monthValues$x = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "marts",
    "apr.",
    "maijs",
    "jÅ«n.",
    "jÅ«l.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "janvÄris",
    "februÄris",
    "marts",
    "aprÄ«lis",
    "maijs",
    "jÅ«nijs",
    "jÅ«lijs",
    "augusts",
    "septembris",
    "oktobris",
    "novembris",
    "decembris",
  ],
};

const formattingMonthValues$7 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "martÄ",
    "apr.",
    "maijs",
    "jÅ«n.",
    "jÅ«l.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "janvÄrÄ«",
    "februÄrÄ«",
    "martÄ",
    "aprÄ«lÄ«",
    "maijÄ",
    "jÅ«nijÄ",
    "jÅ«lijÄ",
    "augustÄ",
    "septembrÄ«",
    "oktobrÄ«",
    "novembrÄ«",
    "decembrÄ«",
  ],
};

const dayValues$x = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svÄtd.",
    "pirmd.",
    "otrd.",
    "treÅ¡d.",
    "ceturtd.",
    "piektd.",
    "sestd.",
  ],

  wide: [
    "svÄtdiena",
    "pirmdiena",
    "otrdiena",
    "treÅ¡diena",
    "ceturtdiena",
    "piektdiena",
    "sestdiena",
  ],
};

const formattingDayValues$1 = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svÄtd.",
    "pirmd.",
    "otrd.",
    "treÅ¡d.",
    "ceturtd.",
    "piektd.",
    "sestd.",
  ],

  wide: [
    "svÄtdienÄ",
    "pirmdienÄ",
    "otrdienÄ",
    "treÅ¡dienÄ",
    "ceturtdienÄ",
    "piektdienÄ",
    "sestdienÄ",
  ],
};

const dayPeriodValues$x = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rÄ«ts",
    afternoon: "diena",
    evening: "vakars",
    night: "nakts",
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rÄ«ts",
    afternoon: "pÄcpusd.",
    evening: "vakars",
    night: "nakts",
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnakts",
    noon: "pusdienlaiks",
    morning: "rÄ«ts",
    afternoon: "pÄcpusdiena",
    evening: "vakars",
    night: "nakts",
  },
};

const formattingDayPeriodValues$p = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rÄ«tÄ",
    afternoon: "dienÄ",
    evening: "vakarÄ",
    night: "naktÄ«",
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rÄ«tÄ",
    afternoon: "pÄcpusd.",
    evening: "vakarÄ",
    night: "naktÄ«",
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnaktÄ«",
    noon: "pusdienlaikÄ",
    morning: "rÄ«tÄ",
    afternoon: "pÄcpusdienÄ",
    evening: "vakarÄ",
    night: "naktÄ«",
  },
};

const ordinalNumber$x = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$x.localize = {
  ordinalNumber: ordinalNumber$x,

  era: (0, _index$63.buildLocalizeFn)({
    values: eraValues$x,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$63.buildLocalizeFn)({
    values: quarterValues$x,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues$1,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$63.buildLocalizeFn)({
    values: monthValues$x,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$7,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$63.buildLocalizeFn)({
    values: dayValues$x,
    defaultWidth: "wide",
    formattingValues: formattingDayValues$1,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$63.buildLocalizeFn)({
    values: dayPeriodValues$x,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$p,
    defaultFormattingWidth: "wide",
  }),
});

var match$x = {};

match$x.match = void 0;

var _index$62 = buildMatchFn$1;
var _index2$2C = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$x = /^(\d+)\./i;
const parseOrdinalNumberPattern$x = /\d+/i;

const matchEraPatterns$x = {
  narrow: /^(p\.m\.Ä|m\.Ä)/i,
  abbreviated: /^(p\. m\. Ä\.|m\. Ä\.)/i,
  wide: /^(pirms mÅ«su Äras|mÅ«su ÄrÄ)/i,
};
const parseEraPatterns$x = {
  any: [/^p/i, /^m/i],
};

const matchQuarterPatterns$x = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](\. cet\.)/i,
  wide: /^(pirma(is|jÄ)|otra(is|jÄ)|treÅ¡a(is|jÄ)|ceturta(is|jÄ)) ceturksn(is|Ä«)/i,
};
const parseQuarterPatterns$x = {
  narrow: [/^1/i, /^2/i, /^3/i, /^4/i],
  abbreviated: [/^1/i, /^2/i, /^3/i, /^4/i],
  wide: [/^p/i, /^o/i, /^t/i, /^c/i],
};

const matchMonthPatterns$x = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(janv\.|febr\.|marts|apr\.|maijs|jÅ«n\.|jÅ«l\.|aug\.|sept\.|okt\.|nov\.|dec\.)/i,
  wide: /^(janvÄr(is|Ä«)|februÄr(is|Ä«)|mart[sÄ]|aprÄ«l(is|Ä«)|maij[sÄ]|jÅ«nij[sÄ]|jÅ«lij[sÄ]|august[sÄ]|septembr(is|Ä«)|oktobr(is|Ä«)|novembr(is|Ä«)|decembr(is|Ä«))/i,
};
const parseMonthPatterns$x = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jÅ«n/i,
    /^jÅ«l/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$x = {
  narrow: /^[spotc]/i,
  short: /^(sv|pi|o|t|c|pk|s)/i,
  abbreviated: /^(svÄtd\.|pirmd\.|otrd.\|treÅ¡d\.|ceturtd\.|piektd\.|sestd\.)/i,
  wide: /^(svÄtdien(a|Ä)|pirmdien(a|Ä)|otrdien(a|Ä)|treÅ¡dien(a|Ä)|ceturtdien(a|Ä)|piektdien(a|Ä)|sestdien(a|Ä))/i,
};
const parseDayPatterns$x = {
  narrow: [/^s/i, /^p/i, /^o/i, /^t/i, /^c/i, /^p/i, /^s/i],
  any: [/^sv/i, /^pi/i, /^o/i, /^t/i, /^c/i, /^p/i, /^se/i],
};

const matchDayPeriodPatterns$x = {
  narrow: /^(am|pm|pusn\.|pusd\.|rÄ«t(s|Ä)|dien(a|Ä)|vakar(s|Ä)|nakt(s|Ä«))/,
  abbreviated: /^(am|pm|pusn\.|pusd\.|rÄ«t(s|Ä)|pÄcpusd\.|vakar(s|Ä)|nakt(s|Ä«))/,
  wide: /^(am|pm|pusnakt(s|Ä«)|pusdienlaik(s|Ä)|rÄ«t(s|Ä)|pÄcpusdien(a|Ä)|vakar(s|Ä)|nakt(s|Ä«))/i,
};
const parseDayPeriodPatterns$x = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^pusn/i,
    noon: /^pusd/i,
    morning: /^r/i,
    afternoon: /^(d|pÄc)/i,
    evening: /^v/i,
    night: /^n/i,
  },
};

(match$x.match = {
  ordinalNumber: (0, _index2$2C.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$x,
    parsePattern: parseOrdinalNumberPattern$x,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$62.buildMatchFn)({
    matchPatterns: matchEraPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$x,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$62.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$x,
    defaultParseWidth: "wide",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$62.buildMatchFn)({
    matchPatterns: matchMonthPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$x,
    defaultParseWidth: "any",
  }),

  day: (0, _index$62.buildMatchFn)({
    matchPatterns: matchDayPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$x,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$62.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$x,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$x,
    defaultParseWidth: "any",
  }),
});

lv.lv = void 0;
var _index$61 = formatDistance$15;
var _index2$2B = formatLong$x;
var _index3$1j = formatRelative$15;
var _index4$P = localize$x;
var _index5$G = match$x;

/**
 * @category Locales
 * @summary Latvian locale (Latvia).
 * @language Latvian
 * @iso-639-2 lav
 * @author RÅ«dolfs PuÄ·Ä«tis [@prudolfs](https://github.com/prudolfs)
 */
(lv.lv = {
  code: "lv",
  formatDistance: _index$61.formatDistance,
  formatLong: _index2$2B.formatLong,
  formatRelative: _index3$1j.formatRelative,
  localize: _index4$P.localize,
  match: _index5$G.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var mk = {};

var formatDistance$13 = {};

formatDistance$13.formatDistance = void 0;

const formatDistanceLocale$w = {
  lessThanXSeconds: {
    one: "Ð¿Ð¾Ð¼Ð°Ð»ÐºÑ Ð¾Ð´ ÑÐµÐºÑÐ½Ð´Ð°",
    other: "Ð¿Ð¾Ð¼Ð°Ð»ÐºÑ Ð¾Ð´ {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  xSeconds: {
    one: "1 ÑÐµÐºÑÐ½Ð´Ð°",
    other: "{{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  halfAMinute: "Ð¿Ð¾Ð»Ð¾Ð²Ð¸Ð½Ð° Ð¼Ð¸Ð½ÑÑÐ°",

  lessThanXMinutes: {
    one: "Ð¿Ð¾Ð¼Ð°Ð»ÐºÑ Ð¾Ð´ Ð¼Ð¸Ð½ÑÑÐ°",
    other: "Ð¿Ð¾Ð¼Ð°Ð»ÐºÑ Ð¾Ð´ {{count}} Ð¼Ð¸Ð½ÑÑÐ¸",
  },

  xMinutes: {
    one: "1 Ð¼Ð¸Ð½ÑÑÐ°",
    other: "{{count}} Ð¼Ð¸Ð½ÑÑÐ¸",
  },

  aboutXHours: {
    one: "Ð¾ÐºÐ¾Ð»Ñ 1 ÑÐ°Ñ",
    other: "Ð¾ÐºÐ¾Ð»Ñ {{count}} ÑÐ°ÑÐ°",
  },

  xHours: {
    one: "1 ÑÐ°Ñ",
    other: "{{count}} ÑÐ°ÑÐ°",
  },

  xDays: {
    one: "1 Ð´ÐµÐ½",
    other: "{{count}} Ð´ÐµÐ½Ð°",
  },

  aboutXWeeks: {
    one: "Ð¾ÐºÐ¾Ð»Ñ 1 Ð½ÐµÐ´ÐµÐ»Ð°",
    other: "Ð¾ÐºÐ¾Ð»Ñ {{count}} Ð¼ÐµÑÐµÑÐ¸",
  },

  xWeeks: {
    one: "1 Ð½ÐµÐ´ÐµÐ»Ð°",
    other: "{{count}} Ð½ÐµÐ´ÐµÐ»Ð¸",
  },

  aboutXMonths: {
    one: "Ð¾ÐºÐ¾Ð»Ñ 1 Ð¼ÐµÑÐµÑ",
    other: "Ð¾ÐºÐ¾Ð»Ñ {{count}} Ð½ÐµÐ´ÐµÐ»Ð¸",
  },

  xMonths: {
    one: "1 Ð¼ÐµÑÐµÑ",
    other: "{{count}} Ð¼ÐµÑÐµÑÐ¸",
  },

  aboutXYears: {
    one: "Ð¾ÐºÐ¾Ð»Ñ 1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð¾ÐºÐ¾Ð»Ñ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  xYears: {
    one: "1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  overXYears: {
    one: "Ð¿Ð¾Ð²ÐµÑÐµ Ð¾Ð´ 1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð¿Ð¾Ð²ÐµÑÐµ Ð¾Ð´ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },

  almostXYears: {
    one: "Ð±ÐµÐ·Ð¼Ð°Ð»ÐºÑ 1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
    other: "Ð±ÐµÐ·Ð¼Ð°Ð»ÐºÑ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
  },
};

const formatDistance$12 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$w[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ð·Ð° " + result;
    } else {
      return "Ð¿ÑÐµÐ´ " + result;
    }
  }

  return result;
};
formatDistance$13.formatDistance = formatDistance$12;

var formatLong$w = {};

formatLong$w.formatLong = void 0;
var _index$60 = buildFormatLongFn$1;

const dateFormats$w = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$w = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$w = {
  any: "{{date}} {{time}}",
};

(formatLong$w.formatLong = {
  date: (0, _index$60.buildFormatLongFn)({
    formats: dateFormats$w,
    defaultWidth: "full",
  }),

  time: (0, _index$60.buildFormatLongFn)({
    formats: timeFormats$w,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$60.buildFormatLongFn)({
    formats: dateTimeFormats$w,
    defaultWidth: "any",
  }),
});

var formatRelative$13 = {};

formatRelative$13.formatRelative = void 0;
var _index$5$ = isSameWeek$1;

const weekdays = [
  "Ð½ÐµÐ´ÐµÐ»Ð°",
  "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº",
  "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
  "ÑÑÐµÐ´Ð°",
  "ÑÐµÑÐ²ÑÑÐ¾Ðº",
  "Ð¿ÐµÑÐ¾Ðº",
  "ÑÐ°Ð±Ð¾ÑÐ°",
];

function lastWeek$3(day) {
  const weekday = weekdays[day];

  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'Ð¼Ð¸Ð½Ð°ÑÐ°ÑÐ° " + weekday + " Ð²Ð¾' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'Ð¼Ð¸Ð½Ð°ÑÐ¸Ð¾Ñ " + weekday + " Ð²Ð¾' p";
  }
}

function thisWeek$3(day) {
  const weekday = weekdays[day];

  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'Ð¾Ð²Ð° " + weekday + " Ð²o' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'Ð¾Ð²Ð¾Ñ " + weekday + " Ð²o' p";
  }
}

function nextWeek$3(day) {
  const weekday = weekdays[day];

  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'ÑÐ»ÐµÐ´Ð½Ð°ÑÐ° " + weekday + " Ð²o' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'ÑÐ»ÐµÐ´Ð½Ð¸Ð¾Ñ " + weekday + " Ð²o' p";
  }
}

const formatRelativeLocale$w = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$5$.isSameWeek)(date, baseDate, options)) {
      return thisWeek$3(day);
    } else {
      return lastWeek$3(day);
    }
  },
  yesterday: "'Ð²ÑÐµÑÐ° Ð²Ð¾' p",
  today: "'Ð´ÐµÐ½ÐµÑ Ð²Ð¾' p",
  tomorrow: "'ÑÑÑÐµ Ð²Ð¾' p",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$5$.isSameWeek)(date, baseDate, options)) {
      return thisWeek$3(day);
    } else {
      return nextWeek$3(day);
    }
  },
  other: "P",
};

const formatRelative$12 = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$w[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$13.formatRelative = formatRelative$12;

var localize$w = {};

localize$w.localize = void 0;
var _index$5_ = buildLocalizeFn$1;

const eraValues$w = {
  narrow: ["Ð¿Ñ.Ð½.Ðµ.", "Ð½.Ðµ."],
  abbreviated: ["Ð¿ÑÐµÐ´ Ð½. Ðµ.", "Ð½. Ðµ."],
  wide: ["Ð¿ÑÐµÐ´ Ð½Ð°ÑÐ°ÑÐ° ÐµÑÐ°", "Ð½Ð°ÑÐ°ÑÐ° ÐµÑÐ°"],
};

const quarterValues$w = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ð²Ð¸ ÐºÐ².", "2-ÑÐ¸ ÐºÐ².", "3-ÑÐ¸ ÐºÐ².", "4-ÑÐ¸ ÐºÐ²."],
  wide: ["1-Ð²Ð¸ ÐºÐ²Ð°ÑÑÐ°Ð»", "2-ÑÐ¸ ÐºÐ²Ð°ÑÑÐ°Ð»", "3-ÑÐ¸ ÐºÐ²Ð°ÑÑÐ°Ð»", "4-ÑÐ¸ ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$w = {
  abbreviated: [
    "ÑÐ°Ð½",
    "ÑÐµÐ²",
    "Ð¼Ð°Ñ",
    "Ð°Ð¿Ñ",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½",
    "ÑÑÐ»",
    "Ð°Ð²Ð³",
    "ÑÐµÐ¿Ñ",
    "Ð¾ÐºÑ",
    "Ð½Ð¾ÐµÐ¼",
    "Ð´ÐµÐº",
  ],

  wide: [
    "ÑÐ°Ð½ÑÐ°ÑÐ¸",
    "ÑÐµÐ²ÑÑÐ°ÑÐ¸",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐ¸Ð»",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½Ð¸",
    "ÑÑÐ»Ð¸",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸",
    "Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸",
    "Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸",
    "Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸",
  ],
};

const dayValues$w = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½Ðµ", "Ð¿Ð¾", "Ð²Ñ", "ÑÑ", "ÑÐµ", "Ð¿Ðµ", "ÑÐ°"],
  abbreviated: ["Ð½ÐµÐ´", "Ð¿Ð¾Ð½", "Ð²ÑÐ¾", "ÑÑÐµ", "ÑÐµÑ", "Ð¿ÐµÑ", "ÑÐ°Ð±"],
  wide: [
    "Ð½ÐµÐ´ÐµÐ»Ð°",
    "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº",
    "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
    "ÑÑÐµÐ´Ð°",
    "ÑÐµÑÐ²ÑÑÐ¾Ðº",
    "Ð¿ÐµÑÐ¾Ðº",
    "ÑÐ°Ð±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$w = {
  wide: {
    am: "Ð¿ÑÐµÑÐ¿Ð»Ð°Ð´Ð½Ðµ",
    pm: "Ð¿Ð¾Ð¿Ð»Ð°Ð´Ð½Ðµ",
    midnight: "Ð¿Ð¾Ð»Ð½Ð¾Ñ",
    noon: "Ð½Ð°Ð¿Ð»Ð°Ð´Ð½Ðµ",
    morning: "Ð½Ð°ÑÑÑÐ¾",
    afternoon: "Ð¿Ð¾Ð¿Ð»Ð°Ð´Ð½Ðµ",
    evening: "Ð½Ð°Ð²ÐµÑÐµÑ",
    night: "Ð½Ð¾ÑÐµ",
  },
};

const ordinalNumber$w = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "-Ð²Ð¸";
      case 2:
        return number + "-ÑÐ¸";
      case 7:
      case 8:
        return number + "-Ð¼Ð¸";
    }
  }
  return number + "-ÑÐ¸";
};

(localize$w.localize = {
  ordinalNumber: ordinalNumber$w,

  era: (0, _index$5_.buildLocalizeFn)({
    values: eraValues$w,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5_.buildLocalizeFn)({
    values: quarterValues$w,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5_.buildLocalizeFn)({
    values: monthValues$w,
    defaultWidth: "wide",
  }),

  day: (0, _index$5_.buildLocalizeFn)({
    values: dayValues$w,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5_.buildLocalizeFn)({
    values: dayPeriodValues$w,
    defaultWidth: "wide",
  }),
});

var match$w = {};

match$w.match = void 0;

var _index$5Z = buildMatchFn$1;
var _index2$2A = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$w = /^(\d+)(-?[Ð²ÑÐ¼Ñ][Ð¸])?/i;
const parseOrdinalNumberPattern$w = /\d+/i;

const matchEraPatterns$w = {
  narrow: /^((Ð¿Ñ)?Ð½\.?\s?Ðµ\.?)/i,
  abbreviated: /^((Ð¿Ñ)?Ð½\.?\s?Ðµ\.?)/i,
  wide: /^(Ð¿ÑÐµÐ´ Ð½Ð°ÑÐ°ÑÐ° ÐµÑÐ°|Ð½Ð°ÑÐ°ÑÐ° ÐµÑÐ°)/i,
};
const parseEraPatterns$w = {
  any: [/^Ð¿/i, /^Ð½/i],
};

const matchQuarterPatterns$w = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[Ð²ÑÑ]?Ð¸?)? ÐºÐ².?/i,
  wide: /^[1234](-?[Ð²ÑÑ]?Ð¸?)? ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};
const parseQuarterPatterns$w = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchDayPatterns$w = {
  narrow: /^[Ð½Ð¿Ð²ÑÑ]/i,
  short: /^(Ð½Ðµ|Ð¿Ð¾|Ð²Ñ|ÑÑ|ÑÐµ|Ð¿Ðµ|ÑÐ°)/i,
  abbreviated: /^(Ð½ÐµÐ´|Ð¿Ð¾Ð½|Ð²ÑÐ¾|ÑÑÐµ|ÑÐµÑ|Ð¿ÐµÑ|ÑÐ°Ð±)/i,
  wide: /^(Ð½ÐµÐ´ÐµÐ»Ð°|Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº|Ð²ÑÐ¾ÑÐ½Ð¸Ðº|ÑÑÐµÐ´Ð°|ÑÐµÑÐ²ÑÑÐ¾Ðº|Ð¿ÐµÑÐ¾Ðº|ÑÐ°Ð±Ð¾ÑÐ°)/i,
};

const parseDayPatterns$w = {
  narrow: [/^Ð½/i, /^Ð¿/i, /^Ð²/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð½[ÐµÐ´]/i, /^Ð¿[Ð¾Ð½]/i, /^Ð²Ñ/i, /^ÑÑ/i, /^Ñ[ÐµÑ]/i, /^Ð¿[ÐµÑ]/i, /^Ñ[Ð°Ð±]/i],
};

const matchMonthPatterns$w = {
  abbreviated: /^(ÑÐ°Ð½|ÑÐµÐ²|Ð¼Ð°Ñ|Ð°Ð¿Ñ|Ð¼Ð°Ñ|ÑÑÐ½|ÑÑÐ»|Ð°Ð²Ð³|ÑÐµÐ¿|Ð¾ÐºÑ|Ð½Ð¾ÐµÐ¼|Ð´ÐµÐº)/i,
  wide: /^(ÑÐ°Ð½ÑÐ°ÑÐ¸|ÑÐµÐ²ÑÑÐ°ÑÐ¸|Ð¼Ð°ÑÑ|Ð°Ð¿ÑÐ¸Ð»|Ð¼Ð°Ñ|ÑÑÐ½Ð¸|ÑÑÐ»Ð¸|Ð°Ð²Ð³ÑÑÑ|ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸|Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸|Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸|Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸)/i,
};
const parseMonthPatterns$w = {
  any: [
    /^ÑÐ°/i,
    /^Ð¤/i,
    /^Ð¼Ð°Ñ/i,
    /^Ð°Ð¿/i,
    /^Ð¼Ð°Ñ/i,
    /^ÑÑÐ½/i,
    /^ÑÑÐ»/i,
    /^Ð°Ð²/i,
    /^ÑÐµ/i,
    /^Ð¾ÐºÑ/i,
    /^Ð½Ð¾/i,
    /^Ð´Ðµ/i,
  ],
};

const matchDayPeriodPatterns$w = {
  any: /^(Ð¿ÑÐµÑÐ¿|Ð¿Ð¾Ð¿Ð»|Ð¿Ð¾Ð»Ð½Ð¾Ñ|ÑÑÑÐ¾|Ð¿Ð»Ð°Ð´Ð½Ðµ|Ð²ÐµÑÐµÑ|Ð½Ð¾Ñ)/i,
};
const parseDayPeriodPatterns$w = {
  any: {
    am: /Ð¿ÑÐµÑÐ¿Ð»Ð°Ð´Ð½Ðµ/i,
    pm: /Ð¿Ð¾Ð¿Ð»Ð°Ð´Ð½Ðµ/i,
    midnight: /Ð¿Ð¾Ð»Ð½Ð¾Ñ/i,
    noon: /Ð½Ð°Ð¿Ð»Ð°Ð´Ð½Ðµ/i,
    morning: /Ð½Ð°ÑÑÑÐ¾/i,
    afternoon: /Ð¿Ð¾Ð¿Ð»Ð°Ð´Ð½Ðµ/i,
    evening: /Ð½Ð°Ð²ÐµÑÐµÑ/i,
    night: /Ð½Ð¾ÑÐµ/i,
  },
};

(match$w.match = {
  ordinalNumber: (0, _index2$2A.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$w,
    parsePattern: parseOrdinalNumberPattern$w,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5Z.buildMatchFn)({
    matchPatterns: matchEraPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$w,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5Z.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$w,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5Z.buildMatchFn)({
    matchPatterns: matchMonthPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$w,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5Z.buildMatchFn)({
    matchPatterns: matchDayPatterns$w,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$w,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5Z.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$w,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$w,
    defaultParseWidth: "any",
  }),
});

mk.mk = void 0;
var _index$5Y = formatDistance$13;
var _index2$2z = formatLong$w;
var _index3$1i = formatRelative$13;
var _index4$O = localize$w;
var _index5$F = match$w;

/**
 * @category Locales
 * @summary Macedonian locale.
 * @language Macedonian
 * @iso-639-2 mkd
 * @author Petar Vlahu [@vlahupetar](https://github.com/vlahupetar)
 * @author Altrim Beqiri [@altrim](https://github.com/altrim)
 */
(mk.mk = {
  code: "mk",
  formatDistance: _index$5Y.formatDistance,
  formatLong: _index2$2z.formatLong,
  formatRelative: _index3$1i.formatRelative,
  localize: _index4$O.localize,
  match: _index5$F.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var mn = {};

var formatDistance$11 = {};

formatDistance$11.formatDistance = void 0;

const formatDistanceLocale$v = {
  lessThanXSeconds: {
    one: "ÑÐµÐºÑÐ½Ð´ ÑÒ¯ÑÑÑÐ³Ò¯Ð¹",
    other: "{{count}} ÑÐµÐºÑÐ½Ð´ ÑÒ¯ÑÑÑÐ³Ò¯Ð¹",
  },

  xSeconds: {
    one: "1 ÑÐµÐºÑÐ½Ð´",
    other: "{{count}} ÑÐµÐºÑÐ½Ð´",
  },

  halfAMinute: "ÑÐ°Ð³Ð°Ñ Ð¼Ð¸Ð½ÑÑ",

  lessThanXMinutes: {
    one: "Ð¼Ð¸Ð½ÑÑ ÑÒ¯ÑÑÑÐ³Ò¯Ð¹",
    other: "{{count}} Ð¼Ð¸Ð½ÑÑ ÑÒ¯ÑÑÑÐ³Ò¯Ð¹",
  },

  xMinutes: {
    one: "1 Ð¼Ð¸Ð½ÑÑ",
    other: "{{count}} Ð¼Ð¸Ð½ÑÑ",
  },

  aboutXHours: {
    one: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ 1 ÑÐ°Ð³",
    other: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ {{count}} ÑÐ°Ð³",
  },

  xHours: {
    one: "1 ÑÐ°Ð³",
    other: "{{count}} ÑÐ°Ð³",
  },

  xDays: {
    one: "1 Ó©Ð´Ó©Ñ",
    other: "{{count}} Ó©Ð´Ó©Ñ",
  },

  aboutXWeeks: {
    one: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ 1 Ð´Ð¾Ð»Ð¾Ð¾ ÑÐ¾Ð½Ð¾Ð³",
    other: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ {{count}} Ð´Ð¾Ð»Ð¾Ð¾ ÑÐ¾Ð½Ð¾Ð³",
  },

  xWeeks: {
    one: "1 Ð´Ð¾Ð»Ð¾Ð¾ ÑÐ¾Ð½Ð¾Ð³",
    other: "{{count}} Ð´Ð¾Ð»Ð¾Ð¾ ÑÐ¾Ð½Ð¾Ð³",
  },

  aboutXMonths: {
    one: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ 1 ÑÐ°Ñ",
    other: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ {{count}} ÑÐ°Ñ",
  },

  xMonths: {
    one: "1 ÑÐ°Ñ",
    other: "{{count}} ÑÐ°Ñ",
  },

  aboutXYears: {
    one: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ 1 Ð¶Ð¸Ð»",
    other: "Ð¾Ð¹ÑÐ¾Ð»ÑÐ¾Ð¾Ð³Ð¾Ð¾Ñ {{count}} Ð¶Ð¸Ð»",
  },

  xYears: {
    one: "1 Ð¶Ð¸Ð»",
    other: "{{count}} Ð¶Ð¸Ð»",
  },

  overXYears: {
    one: "1 Ð¶Ð¸Ð» Ð³Ð°ÑÐ°Ð½",
    other: "{{count}} Ð¶Ð¸Ð» Ð³Ð°ÑÐ°Ð½",
  },

  almostXYears: {
    one: "Ð±Ð°ÑÐ°Ð³ 1 Ð¶Ð¸Ð»",
    other: "Ð±Ð°ÑÐ°Ð³ {{count}} Ð¶Ð¸Ð»",
  },
};

const formatDistance$10 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$v[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    /**
     * Append genitive case
     */
    const words = result.split(" ");
    const lastword = words.pop();
    result = words.join(" ");
    switch (lastword) {
      case "ÑÐµÐºÑÐ½Ð´":
        result += " ÑÐµÐºÑÐ½Ð´Ð¸Ð¹Ð½";
        break;
      case "Ð¼Ð¸Ð½ÑÑ":
        result += " Ð¼Ð¸Ð½ÑÑÑÐ½";
        break;
      case "ÑÐ°Ð³":
        result += " ÑÐ°Ð³Ð¸Ð¹Ð½";
        break;
      case "Ó©Ð´Ó©Ñ":
        result += " Ó©Ð´ÑÐ¸Ð¹Ð½";
        break;
      case "ÑÐ°Ñ":
        result += " ÑÐ°ÑÑÐ½";
        break;
      case "Ð¶Ð¸Ð»":
        result += " Ð¶Ð¸Ð»Ð¸Ð¹Ð½";
        break;
      case "ÑÐ¾Ð½Ð¾Ð³":
        result += " ÑÐ¾Ð½Ð¾Ð³Ð¸Ð¹Ð½";
        break;
      case "Ð³Ð°ÑÐ°Ð½":
        result += " Ð³Ð°ÑÐ°Ð½Ñ";
        break;
      case "ÑÒ¯ÑÑÑÐ³Ò¯Ð¹":
        result += " ÑÒ¯ÑÑÑÐ³Ò¯Ð¹ ÑÑÐ³Ð°ÑÐ°Ð°Ð½Ñ";
        break;
      default:
        result += lastword + "-Ð½";
    }

    if (options.comparison && options.comparison > 0) {
      return result + " Ð´Ð°ÑÐ°Ð°";
    } else {
      return result + " Ó©Ð¼Ð½Ó©";
    }
  }

  return result;
};
formatDistance$11.formatDistance = formatDistance$10;

var formatLong$v = {};

formatLong$v.formatLong = void 0;
var _index$5X = buildFormatLongFn$1;

const dateFormats$v = {
  full: "y 'Ð¾Ð½Ñ' MMMM'ÑÐ½' d, EEEE 'Ð³Ð°ÑÐ°Ð³'",
  long: "y 'Ð¾Ð½Ñ' MMMM'ÑÐ½' d",
  medium: "y 'Ð¾Ð½Ñ' MMM'ÑÐ½' d",
  short: "y.MM.dd",
};

const timeFormats$v = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$v = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$v.formatLong = {
  date: (0, _index$5X.buildFormatLongFn)({
    formats: dateFormats$v,
    defaultWidth: "full",
  }),

  time: (0, _index$5X.buildFormatLongFn)({
    formats: timeFormats$v,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5X.buildFormatLongFn)({
    formats: dateTimeFormats$v,
    defaultWidth: "full",
  }),
});

var formatRelative$11 = {};

formatRelative$11.formatRelative = void 0;

const formatRelativeLocale$v = {
  lastWeek: "'Ó©Ð½Ð³Ó©ÑÑÓ©Ð½' eeee 'Ð³Ð°ÑÐ°Ð³Ð¸Ð¹Ð½' p 'ÑÐ°Ð³Ñ'",
  yesterday: "'Ó©ÑÐ¸Ð³Ð´Ó©Ñ' p 'ÑÐ°Ð³Ñ'",
  today: "'Ó©Ð½Ó©Ó©Ð´Ó©Ñ' p 'ÑÐ°Ð³Ñ'",
  tomorrow: "'Ð¼Ð°ÑÐ³Ð°Ð°Ñ' p 'ÑÐ°Ð³Ñ'",
  nextWeek: "'Ð¸ÑÑÑ' eeee 'Ð³Ð°ÑÐ°Ð³Ð¸Ð¹Ð½' p 'ÑÐ°Ð³Ñ'",
  other: "P",
};

const formatRelative$10 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$v[token];
formatRelative$11.formatRelative = formatRelative$10;

var localize$v = {};

localize$v.localize = void 0;
var _index$5W = buildLocalizeFn$1;

const eraValues$v = {
  narrow: ["ÐÐ¢Ó¨", "ÐÐ¢"],
  abbreviated: ["ÐÐ¢Ó¨", "ÐÐ¢"],
  wide: ["Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½ Ó©Ð¼Ð½Ó©Ñ", "Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½"],
};

const quarterValues$v = {
  narrow: ["I", "II", "III", "IV"],
  abbreviated: ["I ÑÐ»Ð¸ÑÐ°Ð»", "II ÑÐ»Ð¸ÑÐ°Ð»", "III ÑÐ»Ð¸ÑÐ°Ð»", "IV ÑÐ»Ð¸ÑÐ°Ð»"],
  wide: ["1-Ñ ÑÐ»Ð¸ÑÐ°Ð»", "2-Ñ ÑÐ»Ð¸ÑÐ°Ð»", "3-Ñ ÑÐ»Ð¸ÑÐ°Ð»", "4-Ñ ÑÐ»Ð¸ÑÐ°Ð»"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$v = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII",
  ],

  abbreviated: [
    "1-Ñ ÑÐ°Ñ",
    "2-Ñ ÑÐ°Ñ",
    "3-Ñ ÑÐ°Ñ",
    "4-Ñ ÑÐ°Ñ",
    "5-Ñ ÑÐ°Ñ",
    "6-Ñ ÑÐ°Ñ",
    "7-Ñ ÑÐ°Ñ",
    "8-Ñ ÑÐ°Ñ",
    "9-Ñ ÑÐ°Ñ",
    "10-Ñ ÑÐ°Ñ",
    "11-Ñ ÑÐ°Ñ",
    "12-Ñ ÑÐ°Ñ",
  ],

  wide: [
    "ÐÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "Ð¥Ð¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÑÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÓ©ÑÓ©Ð²Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "Ð¢Ð°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÑÑÐ³Ð°Ð°Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÐ¾Ð»Ð¾Ð¾Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÐ°Ð¹Ð¼Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÑÐ´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "ÐÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐÑÐ²Ð°Ð½Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "ÐÑÐ²Ð°Ð½ ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
  ],
};

const formattingMonthValues$6 = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII",
  ],

  abbreviated: [
    "1-Ñ ÑÐ°Ñ",
    "2-Ñ ÑÐ°Ñ",
    "3-Ñ ÑÐ°Ñ",
    "4-Ñ ÑÐ°Ñ",
    "5-Ñ ÑÐ°Ñ",
    "6-Ñ ÑÐ°Ñ",
    "7-Ñ ÑÐ°Ñ",
    "8-Ñ ÑÐ°Ñ",
    "9-Ñ ÑÐ°Ñ",
    "10-Ñ ÑÐ°Ñ",
    "11-Ñ ÑÐ°Ñ",
    "12-Ñ ÑÐ°Ñ",
  ],

  wide: [
    "Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð³ÑÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð´Ó©ÑÓ©Ð²Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð·ÑÑÐ³Ð°Ð°Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð´Ð¾Ð»Ð¾Ð¾Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð½Ð°Ð¹Ð¼Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "ÐµÑÐ´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "Ð°ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
    "Ð°ÑÐ²Ð°Ð½Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ",
    "Ð°ÑÐ²Ð°Ð½ ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ",
  ],
};

const dayValues$v = {
  narrow: ["Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð"],
  short: ["ÐÑ", "ÐÐ°", "ÐÑ", "ÐÑ", "ÐÒ¯", "ÐÐ°", "ÐÑ"],
  abbreviated: ["ÐÑÐ¼", "ÐÐ°Ð²", "ÐÑÐ³", "ÐÑÐ°", "ÐÒ¯Ñ", "ÐÐ°Ð°", "ÐÑÐ¼"],
  wide: ["ÐÑÐ¼", "ÐÐ°Ð²Ð°Ð°", "ÐÑÐ³Ð¼Ð°Ñ", "ÐÑÐ°Ð³Ð²Ð°", "ÐÒ¯ÑÑÐ²", "ÐÐ°Ð°ÑÐ°Ð½", "ÐÑÐ¼Ð±Ð°"],
};

const formattingDayValues = {
  narrow: ["Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð"],
  short: ["ÐÑ", "ÐÐ°", "ÐÑ", "ÐÑ", "ÐÒ¯", "ÐÐ°", "ÐÑ"],
  abbreviated: ["ÐÑÐ¼", "ÐÐ°Ð²", "ÐÑÐ³", "ÐÑÐ°", "ÐÒ¯Ñ", "ÐÐ°Ð°", "ÐÑÐ¼"],
  wide: ["Ð½ÑÐ¼", "Ð´Ð°Ð²Ð°Ð°", "Ð¼ÑÐ³Ð¼Ð°Ñ", "Ð»ÑÐ°Ð³Ð²Ð°", "Ð¿Ò¯ÑÑÐ²", "Ð±Ð°Ð°ÑÐ°Ð½", "Ð±ÑÐ¼Ð±Ð°"],
};

const dayPeriodValues$v = {
  narrow: {
    am: "Ò¯.Ó©.",
    pm: "Ò¯.Ñ.",
    midnight: "ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´",
    noon: "Ò¯Ð´ Ð´ÑÐ½Ð´",
    morning: "Ó©Ð³Ð»Ó©Ó©",
    afternoon: "Ó©Ð´Ó©Ñ",
    evening: "Ð¾ÑÐ¾Ð¹",
    night: "ÑÓ©Ð½Ó©",
  },
  abbreviated: {
    am: "Ò¯.Ó©.",
    pm: "Ò¯.Ñ.",
    midnight: "ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´",
    noon: "Ò¯Ð´ Ð´ÑÐ½Ð´",
    morning: "Ó©Ð³Ð»Ó©Ó©",
    afternoon: "Ó©Ð´Ó©Ñ",
    evening: "Ð¾ÑÐ¾Ð¹",
    night: "ÑÓ©Ð½Ó©",
  },
  wide: {
    am: "Ò¯.Ó©.",
    pm: "Ò¯.Ñ.",
    midnight: "ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´",
    noon: "Ò¯Ð´ Ð´ÑÐ½Ð´",
    morning: "Ó©Ð³Ð»Ó©Ó©",
    afternoon: "Ó©Ð´Ó©Ñ",
    evening: "Ð¾ÑÐ¾Ð¹",
    night: "ÑÓ©Ð½Ó©",
  },
};

const ordinalNumber$v = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$v.localize = {
  ordinalNumber: ordinalNumber$v,

  era: (0, _index$5W.buildLocalizeFn)({
    values: eraValues$v,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5W.buildLocalizeFn)({
    values: quarterValues$v,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5W.buildLocalizeFn)({
    values: monthValues$v,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$6,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$5W.buildLocalizeFn)({
    values: dayValues$v,
    defaultWidth: "wide",
    formattingValues: formattingDayValues,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$5W.buildLocalizeFn)({
    values: dayPeriodValues$v,
    defaultWidth: "wide",
  }),
});

var match$v = {};

match$v.match = void 0;

var _index$5V = buildMatchFn$1;
var _index2$2y = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$v = /\d+/i;
const parseOrdinalNumberPattern$v = /\d+/i;

const matchEraPatterns$v = {
  narrow: /^(Ð½ÑÓ©|Ð½Ñ)/i,
  abbreviated: /^(Ð½ÑÓ©|Ð½Ñ)/i,
  wide: /^(Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½ Ó©Ð¼Ð½Ó©|Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½)/i,
};
const parseEraPatterns$v = {
  any: [/^(Ð½ÑÓ©|Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½ Ó©Ð¼Ð½Ó©)/i, /^(Ð½Ñ|Ð½Ð¸Ð¹ÑÐ¸Ð¹Ð½ ÑÐ¾Ð¾Ð»Ð»ÑÐ½)/i],
};

const matchQuarterPatterns$v = {
  narrow: /^(iv|iii|ii|i)/i,
  abbreviated: /^(iv|iii|ii|i) ÑÐ»Ð¸ÑÐ°Ð»/i,
  wide: /^[1-4]-Ñ ÑÐ»Ð¸ÑÐ°Ð»/i,
};
const parseQuarterPatterns$v = {
  any: [/^(i(\s|$)|1)/i, /^(ii(\s|$)|2)/i, /^(iii(\s|$)|3)/i, /^(iv(\s|$)|4)/i],
};

const matchMonthPatterns$v = {
  narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,
  abbreviated:
    /^(1-Ñ ÑÐ°Ñ|2-Ñ ÑÐ°Ñ|3-Ñ ÑÐ°Ñ|4-Ñ ÑÐ°Ñ|5-Ñ ÑÐ°Ñ|6-Ñ ÑÐ°Ñ|7-Ñ ÑÐ°Ñ|8-Ñ ÑÐ°Ñ|9-Ñ ÑÐ°Ñ|10-Ñ ÑÐ°Ñ|11-Ñ ÑÐ°Ñ|12-Ñ ÑÐ°Ñ)/i,
  wide: /^(Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ|ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð³ÑÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð´Ó©ÑÓ©Ð²Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ|ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð·ÑÑÐ³Ð°Ð°Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð´Ð¾Ð»Ð¾Ð¾Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð½Ð°Ð¹Ð¼Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|ÐµÑÐ´Ò¯Ð³ÑÑÑ ÑÐ°Ñ|Ð°ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ|Ð°ÑÐ²Ð°Ð½ Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ ÑÐ°Ñ|Ð°ÑÐ²Ð°Ð½ ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ ÑÐ°Ñ)/i,
};
const parseMonthPatterns$v = {
  narrow: [
    /^i$/i,
    /^ii$/i,
    /^iii$/i,
    /^iv$/i,
    /^v$/i,
    /^vi$/i,
    /^vii$/i,
    /^viii$/i,
    /^ix$/i,
    /^x$/i,
    /^xi$/i,
    /^xii$/i,
  ],

  any: [
    /^(1|Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ)/i,
    /^(2|ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ)/i,
    /^(3|Ð³ÑÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(4|Ð´Ó©ÑÓ©Ð²Ð´Ò¯Ð³ÑÑÑ)/i,
    /^(5|ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(6|Ð·ÑÑÐ³Ð°Ð°Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(7|Ð´Ð¾Ð»Ð¾Ð¾Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(8|Ð½Ð°Ð¹Ð¼Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(9|ÐµÑÐ´Ò¯Ð³ÑÑÑ)/i,
    /^(10|Ð°ÑÐ°Ð²Ð´ÑÐ³Ð°Ð°Ñ)/i,
    /^(11|Ð°ÑÐ²Ð°Ð½ Ð½ÑÐ³Ð´Ò¯Ð³ÑÑÑ)/i,
    /^(12|Ð°ÑÐ²Ð°Ð½ ÑÐ¾ÑÑÐ´ÑÐ³Ð°Ð°Ñ)/i,
  ],
};

const matchDayPatterns$v = {
  narrow: /^[Ð½Ð´Ð¼Ð»Ð¿Ð±Ð±]/i,
  short: /^(Ð½Ñ|Ð´Ð°|Ð¼Ñ|Ð»Ñ|Ð¿Ò¯|Ð±Ð°|Ð±Ñ)/i,
  abbreviated: /^(Ð½ÑÐ¼|Ð´Ð°Ð²|Ð¼ÑÐ³|Ð»ÑÐ°|Ð¿Ò¯Ñ|Ð±Ð°Ð°|Ð±ÑÐ¼)/i,
  wide: /^(Ð½ÑÐ¼|Ð´Ð°Ð²Ð°Ð°|Ð¼ÑÐ³Ð¼Ð°Ñ|Ð»ÑÐ°Ð³Ð²Ð°|Ð¿Ò¯ÑÑÐ²|Ð±Ð°Ð°ÑÐ°Ð½|Ð±ÑÐ¼Ð±Ð°)/i,
};
const parseDayPatterns$v = {
  narrow: [/^Ð½/i, /^Ð´/i, /^Ð¼/i, /^Ð»/i, /^Ð¿/i, /^Ð±/i, /^Ð±/i],
  any: [/^Ð½Ñ/i, /^Ð´Ð°/i, /^Ð¼Ñ/i, /^Ð»Ñ/i, /^Ð¿Ò¯/i, /^Ð±Ð°/i, /^Ð±Ñ/i],
};

const matchDayPeriodPatterns$v = {
  narrow: /^(Ò¯\.Ó©\.|Ò¯\.Ñ\.|ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´|Ò¯Ð´ Ð´ÑÐ½Ð´|Ó©Ð³Ð»Ó©Ó©|Ó©Ð´Ó©Ñ|Ð¾ÑÐ¾Ð¹|ÑÓ©Ð½Ó©)/i,
  any: /^(Ò¯\.Ó©\.|Ò¯\.Ñ\.|ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´|Ò¯Ð´ Ð´ÑÐ½Ð´|Ó©Ð³Ð»Ó©Ó©|Ó©Ð´Ó©Ñ|Ð¾ÑÐ¾Ð¹|ÑÓ©Ð½Ó©)/i,
};
const parseDayPeriodPatterns$v = {
  any: {
    am: /^Ò¯\.Ó©\./i,
    pm: /^Ò¯\.Ñ\./i,
    midnight: /^ÑÓ©Ð½Ó© Ð´ÑÐ½Ð´/i,
    noon: /^Ò¯Ð´ Ð´ÑÐ½Ð´/i,
    morning: /Ó©Ð³Ð»Ó©Ó©/i,
    afternoon: /Ó©Ð´Ó©Ñ/i,
    evening: /Ð¾ÑÐ¾Ð¹/i,
    night: /ÑÓ©Ð½Ó©/i,
  },
};

(match$v.match = {
  ordinalNumber: (0, _index2$2y.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$v,
    parsePattern: parseOrdinalNumberPattern$v,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5V.buildMatchFn)({
    matchPatterns: matchEraPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$v,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5V.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$v,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5V.buildMatchFn)({
    matchPatterns: matchMonthPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$v,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5V.buildMatchFn)({
    matchPatterns: matchDayPatterns$v,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$v,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5V.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$v,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$v,
    defaultParseWidth: "any",
  }),
});

mn.mn = void 0;
var _index$5U = formatDistance$11;
var _index2$2x = formatLong$v;
var _index3$1h = formatRelative$11;
var _index4$N = localize$v;
var _index5$E = match$v;

/**
 * @category Locales
 * @summary Mongolian locale.
 * @language Mongolian
 * @iso-639-2 mon
 * @author Bilguun Ochirbat [@bilguun0203](https://github.com/bilguun0203)
 */
(mn.mn = {
  code: "mn",
  formatDistance: _index$5U.formatDistance,
  formatLong: _index2$2x.formatLong,
  formatRelative: _index3$1h.formatRelative,
  localize: _index4$N.localize,
  match: _index5$E.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var ms = {};

var formatDistance$$ = {};

formatDistance$$.formatDistance = void 0;

const formatDistanceLocale$u = {
  lessThanXSeconds: {
    one: "kurang dari 1 saat",
    other: "kurang dari {{count}} saat",
  },

  xSeconds: {
    one: "1 saat",
    other: "{{count}} saat",
  },

  halfAMinute: "setengah minit",

  lessThanXMinutes: {
    one: "kurang dari 1 minit",
    other: "kurang dari {{count}} minit",
  },

  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit",
  },

  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam",
  },

  xHours: {
    one: "1 jam",
    other: "{{count}} jam",
  },

  xDays: {
    one: "1 hari",
    other: "{{count}} hari",
  },

  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu",
  },

  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu",
  },

  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan",
  },

  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan",
  },

  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun",
  },

  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun",
  },

  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun",
  },

  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun",
  },
};

const formatDistance$_ = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$u[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dalam masa " + result;
    } else {
      return result + " yang lalu";
    }
  }

  return result;
};
formatDistance$$.formatDistance = formatDistance$_;

var formatLong$u = {};

formatLong$u.formatLong = void 0;
var _index$5T = buildFormatLongFn$1;

const dateFormats$u = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy",
};

const timeFormats$u = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm",
};

const dateTimeFormats$u = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$u.formatLong = {
  date: (0, _index$5T.buildFormatLongFn)({
    formats: dateFormats$u,
    defaultWidth: "full",
  }),

  time: (0, _index$5T.buildFormatLongFn)({
    formats: timeFormats$u,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5T.buildFormatLongFn)({
    formats: dateTimeFormats$u,
    defaultWidth: "full",
  }),
});

var formatRelative$$ = {};

formatRelative$$.formatRelative = void 0;

const formatRelativeLocale$u = {
  lastWeek: "eeee 'lepas pada jam' p",
  yesterday: "'Semalam pada jam' p",
  today: "'Hari ini pada jam' p",
  tomorrow: "'Esok pada jam' p",
  nextWeek: "eeee 'pada jam' p",
  other: "P",
};

const formatRelative$_ = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$u[token];
formatRelative$$.formatRelative = formatRelative$_;

var localize$u = {};

localize$u.localize = void 0;
var _index$5S = buildLocalizeFn$1;

// Most data for localization are taken from this page
// https://www.unicode.org/cldr/charts/32/summary/ms.html
const eraValues$u = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masihi", "Masihi"],
};

const quarterValues$u = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["S1", "S2", "S3", "S4"],
  wide: ["Suku pertama", "Suku kedua", "Suku ketiga", "Suku keempat"],
};

// Note: in Malay, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$u = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mac",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Ogo",
    "Sep",
    "Okt",
    "Nov",
    "Dis",
  ],

  wide: [
    "Januari",
    "Februari",
    "Mac",
    "April",
    "Mei",
    "Jun",
    "Julai",
    "Ogos",
    "September",
    "Oktober",
    "November",
    "Disember",
  ],
};

const dayValues$u = {
  narrow: ["A", "I", "S", "R", "K", "J", "S"],
  short: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  abbreviated: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  wide: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"],
};

const dayPeriodValues$u = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tgh malam",
    noon: "tgh hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
};

const formattingDayPeriodValues$o = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam",
  },
};

const ordinalNumber$u = (dirtyNumber, _options) => {
  // Can't use "pertama", "kedua" because can't be parsed
  return "ke-" + Number(dirtyNumber);
};

(localize$u.localize = {
  ordinalNumber: ordinalNumber$u,

  era: (0, _index$5S.buildLocalizeFn)({
    values: eraValues$u,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5S.buildLocalizeFn)({
    values: quarterValues$u,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5S.buildLocalizeFn)({
    values: monthValues$u,
    defaultWidth: "wide",
  }),

  day: (0, _index$5S.buildLocalizeFn)({
    values: dayValues$u,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5S.buildLocalizeFn)({
    values: dayPeriodValues$u,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$o,
    defaultFormattingWidth: "wide",
  }),
});

var match$u = {};

match$u.match = void 0;

var _index$5R = buildMatchFn$1;
var _index2$2w = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$u = /^ke-(\d+)?/i;
const parseOrdinalNumberPattern$u = /petama|\d+/i;

const matchEraPatterns$u = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|m\.?)/i,
  wide: /^(sebelum masihi|masihi)/i,
};
const parseEraPatterns$u = {
  any: [/^s/i, /^(m)/i],
};

const matchQuarterPatterns$u = {
  narrow: /^[1234]/i,
  abbreviated: /^S[1234]/i,
  wide: /Suku (pertama|kedua|ketiga|keempat)/i,
};
const parseQuarterPatterns$u = {
  any: [/pertama|1/i, /kedua|2/i, /ketiga|3/i, /keempat|4/i],
};

const matchMonthPatterns$u = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mac|apr|mei|jun|jul|ogo|sep|okt|nov|dis)/i,
  wide: /^(januari|februari|mac|april|mei|jun|julai|ogos|september|oktober|november|disember)/i,
};
const parseMonthPatterns$u = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^og/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$u = {
  narrow: /^[aisrkj]/i,
  short: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  abbreviated: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  wide: /^(ahad|isnin|selasa|rabu|khamis|jumaat|sabtu)/i,
};
const parseDayPatterns$u = {
  narrow: [/^a/i, /^i/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^a/i, /^i/i, /^se/i, /^r/i, /^k/i, /^j/i, /^sa/i],
};

const matchDayPeriodPatterns$u = {
  narrow: /^(am|pm|tengah malam|tengah hari|pagi|petang|malam)/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|pagi|petang|malam)/i,
};
const parseDayPeriodPatterns$u = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pa/i,
    afternoon: /tengah h/i,
    evening: /pe/i,
    night: /m/i,
  },
};

(match$u.match = {
  ordinalNumber: (0, _index2$2w.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$u,
    parsePattern: parseOrdinalNumberPattern$u,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5R.buildMatchFn)({
    matchPatterns: matchEraPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$u,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5R.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$u,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5R.buildMatchFn)({
    matchPatterns: matchMonthPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$u,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5R.buildMatchFn)({
    matchPatterns: matchDayPatterns$u,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$u,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5R.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$u,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$u,
    defaultParseWidth: "any",
  }),
});

ms.ms = void 0;
var _index$5Q = formatDistance$$;
var _index2$2v = formatLong$u;
var _index3$1g = formatRelative$$;
var _index4$M = localize$u;
var _index5$D = match$u;

/**
 * @category Locales
 * @summary Malay locale.
 * @language Malay
 * @iso-639-2 msa
 * @author Ruban Selvarajah [@Zyten](https://github.com/Zyten)
 */
(ms.ms = {
  code: "ms",
  formatDistance: _index$5Q.formatDistance,
  formatLong: _index2$2v.formatLong,
  formatRelative: _index3$1g.formatRelative,
  localize: _index4$M.localize,
  match: _index5$D.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var mt = {};

var formatDistance$Z = {};

formatDistance$Z.formatDistance = void 0;

const formatDistanceLocale$t = {
  lessThanXSeconds: {
    one: "inqas minn sekonda",
    other: "inqas minn {{count}} sekondi",
  },

  xSeconds: {
    one: "sekonda",
    other: "{{count}} sekondi",
  },

  halfAMinute: "nofs minuta",

  lessThanXMinutes: {
    one: "inqas minn minuta",
    other: "inqas minn {{count}} minuti",
  },

  xMinutes: {
    one: "minuta",
    other: "{{count}} minuti",
  },

  aboutXHours: {
    one: "madwar siegÄ§a",
    other: "madwar {{count}} siegÄ§at",
  },

  xHours: {
    one: "siegÄ§a",
    other: "{{count}} siegÄ§at",
  },

  xDays: {
    one: "Ä¡urnata",
    other: "{{count}} Ä¡ranet",
  },

  aboutXWeeks: {
    one: "madwar Ä¡imgÄ§a",
    other: "madwar {{count}} Ä¡imgÄ§at",
  },

  xWeeks: {
    one: "Ä¡imgÄ§a",
    other: "{{count}} Ä¡imgÄ§at",
  },

  aboutXMonths: {
    one: "madwar xahar",
    other: "madwar {{count}} xhur",
  },

  xMonths: {
    one: "xahar",
    other: "{{count}} xhur",
  },

  aboutXYears: {
    one: "madwar sena",
    two: "madwar sentejn",
    other: "madwar {{count}} snin",
  },

  xYears: {
    one: "sena",
    two: "sentejn",
    other: "{{count}} snin",
  },

  overXYears: {
    one: "aktar minn sena",
    two: "aktar minn sentejn",
    other: "aktar minn {{count}} snin",
  },

  almostXYears: {
    one: "kwaÅ¼i sena",
    two: "kwaÅ¼i sentejn",
    other: "kwaÅ¼i {{count}} snin",
  },
};

const formatDistance$Y = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$t[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "f'" + result;
    } else {
      return result + " ilu";
    }
  }

  return result;
};
formatDistance$Z.formatDistance = formatDistance$Y;

var formatLong$t = {};

formatLong$t.formatLong = void 0;
var _index$5P = buildFormatLongFn$1;

const dateFormats$t = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy",
};

const timeFormats$t = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$t = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$t.formatLong = {
  date: (0, _index$5P.buildFormatLongFn)({
    formats: dateFormats$t,
    defaultWidth: "full",
  }),

  time: (0, _index$5P.buildFormatLongFn)({
    formats: timeFormats$t,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5P.buildFormatLongFn)({
    formats: dateTimeFormats$t,
    defaultWidth: "full",
  }),
});

var formatRelative$Z = {};

formatRelative$Z.formatRelative = void 0;

const formatRelativeLocale$t = {
  lastWeek: "eeee 'li gÄ§adda' 'fil-'p",
  yesterday: "'Il-bieraÄ§ fil-'p",
  today: "'Illum fil-'p",
  tomorrow: "'GÄ§ada fil-'p",
  nextWeek: "eeee 'fil-'p",
  other: "P",
};

const formatRelative$Y = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$t[token];
formatRelative$Z.formatRelative = formatRelative$Y;

var localize$t = {};

localize$t.localize = void 0;
var _index$5O = buildLocalizeFn$1;

const eraValues$t = {
  narrow: ["Q", "W"],
  abbreviated: ["QK", "WK"],
  wide: ["qabel Kristu", "wara Kristu"],
};

const quarterValues$t = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kwart", "2. kwart", "3. kwart", "4. kwart"],
};

const monthValues$t = {
  narrow: ["J", "F", "M", "A", "M", "Ä ", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Fra",
    "Mar",
    "Apr",
    "Mej",
    "Ä un",
    "Lul",
    "Aww",
    "Set",
    "Ott",
    "Nov",
    "DiÄ",
  ],

  wide: [
    "Jannar",
    "Frar",
    "Marzu",
    "April",
    "Mejju",
    "Ä unju",
    "Lulju",
    "Awwissu",
    "Settembru",
    "Ottubru",
    "Novembru",
    "DiÄembru",
  ],
};

const dayValues$t = {
  narrow: ["Ä¦", "T", "T", "E", "Ä¦", "Ä ", "S"],
  short: ["Ä¦a", "Tn", "Tl", "Er", "Ä¦a", "Ä i", "Si"],
  abbreviated: ["Ä¦ad", "Tne", "Tli", "Erb", "Ä¦am", "Ä im", "Sib"],
  wide: [
    "Il-Ä¦add",
    "It-Tnejn",
    "It-Tlieta",
    "L-ErbgÄ§a",
    "Il-Ä¦amis",
    "Il-Ä imgÄ§a",
    "Is-Sibt",
  ],
};

const dayPeriodValues$t = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "gÄ§odwa",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "lejl",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "gÄ§odwa",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "lejl",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "gÄ§odwa",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "lejl",
  },
};

const formattingDayPeriodValues$n = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgÄ§odu",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "billejl",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgÄ§odu",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "billejl",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgÄ§odu",
    afternoon: "wara nofsinhar",
    evening: "filgÄ§axija",
    night: "billejl",
  },
};

const ordinalNumber$t = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "Âº";
};

(localize$t.localize = {
  ordinalNumber: ordinalNumber$t,

  era: (0, _index$5O.buildLocalizeFn)({
    values: eraValues$t,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5O.buildLocalizeFn)({
    values: quarterValues$t,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5O.buildLocalizeFn)({
    values: monthValues$t,
    defaultWidth: "wide",
  }),

  day: (0, _index$5O.buildLocalizeFn)({
    values: dayValues$t,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5O.buildLocalizeFn)({
    values: dayPeriodValues$t,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$n,
    defaultFormattingWidth: "wide",
  }),
});

var match$t = {};

match$t.match = void 0;

var _index$5N = buildMatchFn$1;
var _index2$2u = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$t = /^(\d+)(Âº)?/i;
const parseOrdinalNumberPattern$t = /\d+/i;

const matchEraPatterns$t = {
  narrow: /^(q|w)/i,
  abbreviated: /^(q\.?\s?k\.?|b\.?\s?c\.?\s?e\.?|w\.?\s?k\.?)/i,
  wide: /^(qabel kristu|before common era|wara kristu|common era)/i,
};
const parseEraPatterns$t = {
  any: [/^(q|b)/i, /^(w|c)/i],
};

const matchQuarterPatterns$t = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](\.)? kwart/i,
};
const parseQuarterPatterns$t = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$t = {
  narrow: /^[jfmaglsond]/i,
  abbreviated: /^(jan|fra|mar|apr|mej|Ä¡un|lul|aww|set|ott|nov|diÄ)/i,
  wide: /^(jannar|frar|marzu|april|mejju|Ä¡unju|lulju|awwissu|settembru|ottubru|novembru|diÄembru)/i,
};
const parseMonthPatterns$t = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^Ä¡/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mej/i,
    /^Ä¡/i,
    /^l/i,
    /^aw/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$t = {
  narrow: /^[Ä§teÄ¡s]/i,
  short: /^(Ä§a|tn|tl|er|Ä§a|Ä¡i|si)/i,
  abbreviated: /^(Ä§ad|tne|tli|erb|Ä§am|Ä¡im|sib)/i,
  wide: /^(il-Ä§add|it-tnejn|it-tlieta|l-erbgÄ§a|il-Ä§amis|il-Ä¡imgÄ§a|is-sibt)/i,
};
const parseDayPatterns$t = {
  narrow: [/^Ä§/i, /^t/i, /^t/i, /^e/i, /^Ä§/i, /^Ä¡/i, /^s/i],
  any: [
    /^(il-)?Ä§ad/i,
    /^(it-)?tn/i,
    /^(it-)?tl/i,
    /^(l-)?er/i,
    /^(il-)?ham/i,
    /^(il-)?Ä¡i/i,
    /^(is-)?si/i,
  ],
};

const matchDayPeriodPatterns$t = {
  narrow:
    /^(a|p|f'nofsillejl|f'nofsinhar|(ta') (gÄ§odwa|wara nofsinhar|filgÄ§axija|lejl))/i,
  any: /^([ap]\.?\s?m\.?|f'nofsillejl|f'nofsinhar|(ta') (gÄ§odwa|wara nofsinhar|filgÄ§axija|lejl))/i,
};
const parseDayPeriodPatterns$t = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^f'nofsillejl/i,
    noon: /^f'nofsinhar/i,
    morning: /gÄ§odwa/i,
    afternoon: /wara(\s.*)nofsinhar/i,
    evening: /filgÄ§axija/i,
    night: /lejl/i,
  },
};

(match$t.match = {
  ordinalNumber: (0, _index2$2u.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$t,
    parsePattern: parseOrdinalNumberPattern$t,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5N.buildMatchFn)({
    matchPatterns: matchEraPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$t,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5N.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$t,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5N.buildMatchFn)({
    matchPatterns: matchMonthPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$t,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5N.buildMatchFn)({
    matchPatterns: matchDayPatterns$t,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$t,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5N.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$t,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$t,
    defaultParseWidth: "any",
  }),
});

mt.mt = void 0;
var _index$5M = formatDistance$Z;
var _index2$2t = formatLong$t;
var _index3$1f = formatRelative$Z;
var _index4$L = localize$t;
var _index5$C = match$t;

/**
 * @category Locales
 * @summary Maltese locale.
 * @language Maltese
 * @iso-639-2 mlt
 * @author Andras Matzon [@amatzon](@link https://github.com/amatzon)
 * @author Bryan Borg [@bryanMt](@link https://github.com/bryanMt)
 */
(mt.mt = {
  code: "mt",
  formatDistance: _index$5M.formatDistance,
  formatLong: _index2$2t.formatLong,
  formatRelative: _index3$1f.formatRelative,
  localize: _index4$L.localize,
  match: _index5$C.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var nb = {};

var formatDistance$X = {};

formatDistance$X.formatDistance = void 0;

const formatDistanceLocale$s = {
  lessThanXSeconds: {
    one: "mindre enn ett sekund",
    other: "mindre enn {{count}} sekunder",
  },

  xSeconds: {
    one: "ett sekund",
    other: "{{count}} sekunder",
  },

  halfAMinute: "et halvt minutt",

  lessThanXMinutes: {
    one: "mindre enn ett minutt",
    other: "mindre enn {{count}} minutter",
  },

  xMinutes: {
    one: "ett minutt",
    other: "{{count}} minutter",
  },

  aboutXHours: {
    one: "omtrent en time",
    other: "omtrent {{count}} timer",
  },

  xHours: {
    one: "en time",
    other: "{{count}} timer",
  },

  xDays: {
    one: "en dag",
    other: "{{count}} dager",
  },

  aboutXWeeks: {
    one: "omtrent en uke",
    other: "omtrent {{count}} uker",
  },

  xWeeks: {
    one: "en uke",
    other: "{{count}} uker",
  },

  aboutXMonths: {
    one: "omtrent en mÃ¥ned",
    other: "omtrent {{count}} mÃ¥neder",
  },

  xMonths: {
    one: "en mÃ¥ned",
    other: "{{count}} mÃ¥neder",
  },

  aboutXYears: {
    one: "omtrent ett Ã¥r",
    other: "omtrent {{count}} Ã¥r",
  },

  xYears: {
    one: "ett Ã¥r",
    other: "{{count}} Ã¥r",
  },

  overXYears: {
    one: "over ett Ã¥r",
    other: "over {{count}} Ã¥r",
  },

  almostXYears: {
    one: "nesten ett Ã¥r",
    other: "nesten {{count}} Ã¥r",
  },
};

const formatDistance$W = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$s[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }

  return result;
};
formatDistance$X.formatDistance = formatDistance$W;

var formatLong$s = {};

formatLong$s.formatLong = void 0;
var _index$5L = buildFormatLongFn$1;

const dateFormats$s = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y",
};

const timeFormats$s = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$s = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$s.formatLong = {
  date: (0, _index$5L.buildFormatLongFn)({
    formats: dateFormats$s,
    defaultWidth: "full",
  }),

  time: (0, _index$5L.buildFormatLongFn)({
    formats: timeFormats$s,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5L.buildFormatLongFn)({
    formats: dateTimeFormats$s,
    defaultWidth: "full",
  }),
});

var formatRelative$X = {};

formatRelative$X.formatRelative = void 0;

const formatRelativeLocale$s = {
  lastWeek: "'forrige' eeee 'kl.' p",
  yesterday: "'i gÃ¥r kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P",
};

const formatRelative$W = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$s[token];
formatRelative$X.formatRelative = formatRelative$W;

var localize$s = {};

localize$s.localize = void 0;
var _index$5K = buildLocalizeFn$1;

const eraValues$s = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fÃ¸r Kristus", "etter Kristus"],
};

const quarterValues$s = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$s = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des.",
  ],

  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember",
  ],
};

const dayValues$s = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sÃ¸", "ma", "ti", "on", "to", "fr", "lÃ¸"],
  abbreviated: ["sÃ¸n", "man", "tir", "ons", "tor", "fre", "lÃ¸r"],
  wide: [
    "sÃ¸ndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lÃ¸rdag",
  ],
};

const dayPeriodValues$s = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ etterm.",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natten",
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ etterm.",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natten",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morgenen",
    afternoon: "pÃ¥ ettermiddagen",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natten",
  },
};

const ordinalNumber$s = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$s.localize = {
  ordinalNumber: ordinalNumber$s,

  era: (0, _index$5K.buildLocalizeFn)({
    values: eraValues$s,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5K.buildLocalizeFn)({
    values: quarterValues$s,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5K.buildLocalizeFn)({
    values: monthValues$s,
    defaultWidth: "wide",
  }),

  day: (0, _index$5K.buildLocalizeFn)({
    values: dayValues$s,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5K.buildLocalizeFn)({
    values: dayPeriodValues$s,
    defaultWidth: "wide",
  }),
});

var match$s = {};

match$s.match = void 0;

var _index$5J = buildMatchFn$1;
var _index2$2s = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$s = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$s = /\d+/i;

const matchEraPatterns$s = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(fÃ¸r Kristus|fÃ¸r vÃ¥r tid|etter Kristus|vÃ¥r tid)/i,
};
const parseEraPatterns$s = {
  any: [/^f/i, /^e/i],
};

const matchQuarterPatterns$s = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i,
};
const parseQuarterPatterns$s = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$s = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i,
};
const parseMonthPatterns$s = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$s = {
  narrow: /^[smtofl]/i,
  short: /^(sÃ¸|ma|ti|on|to|fr|lÃ¸)/i,
  abbreviated: /^(sÃ¸n|man|tir|ons|tor|fre|lÃ¸r)/i,
  wide: /^(sÃ¸ndag|mandag|tirsdag|onsdag|torsdag|fredag|lÃ¸rdag)/i,
};
const parseDayPatterns$s = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i],
};

const matchDayPeriodPatterns$s = {
  narrow:
    /^(midnatt|middag|(pÃ¥) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(pÃ¥) (morgenen|ettermiddagen|kvelden|natten))/i,
};
const parseDayPeriodPatterns$s = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgen/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i,
  },
};

(match$s.match = {
  ordinalNumber: (0, _index2$2s.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$s,
    parsePattern: parseOrdinalNumberPattern$s,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5J.buildMatchFn)({
    matchPatterns: matchEraPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$s,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5J.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$s,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5J.buildMatchFn)({
    matchPatterns: matchMonthPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$s,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5J.buildMatchFn)({
    matchPatterns: matchDayPatterns$s,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$s,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5J.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$s,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$s,
    defaultParseWidth: "any",
  }),
});

nb.nb = void 0;
var _index$5I = formatDistance$X;
var _index2$2r = formatLong$s;
var _index3$1e = formatRelative$X;
var _index4$K = localize$s;
var _index5$B = match$s;

/**
 * @category Locales
 * @summary Norwegian BokmÃ¥l locale.
 * @language Norwegian BokmÃ¥l
 * @iso-639-2 nob
 * @author Hans-Kristian Koren [@Hanse](https://github.com/Hanse)
 * @author Mikolaj Grzyb [@mikolajgrzyb](https://github.com/mikolajgrzyb)
 * @author Dag Stuan [@dagstuan](https://github.com/dagstuan)
 */
(nb.nb = {
  code: "nb",
  formatDistance: _index$5I.formatDistance,
  formatLong: _index2$2r.formatLong,
  formatRelative: _index3$1e.formatRelative,
  localize: _index4$K.localize,
  match: _index5$B.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var nl = {};

var formatDistance$V = {};

formatDistance$V.formatDistance = void 0;

const formatDistanceLocale$r = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden",
  },

  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden",
  },

  halfAMinute: "een halve minuut",

  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten",
  },

  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten",
  },

  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur",
  },

  xHours: {
    one: "1 uur",
    other: "{{count}} uur",
  },

  xDays: {
    one: "1 dag",
    other: "{{count}} dagen",
  },

  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weken",
  },

  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden",
  },

  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden",
  },

  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar",
  },

  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar",
  },

  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar",
  },

  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar",
  },
};

const formatDistance$U = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$r[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }

  return result;
};
formatDistance$V.formatDistance = formatDistance$U;

var formatLong$r = {};

formatLong$r.formatLong = void 0;
var _index$5H = buildFormatLongFn$1;

const dateFormats$r = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y",
};

const timeFormats$r = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$r = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$r.formatLong = {
  date: (0, _index$5H.buildFormatLongFn)({
    formats: dateFormats$r,
    defaultWidth: "full",
  }),

  time: (0, _index$5H.buildFormatLongFn)({
    formats: timeFormats$r,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5H.buildFormatLongFn)({
    formats: dateTimeFormats$r,
    defaultWidth: "full",
  }),
});

var formatRelative$V = {};

formatRelative$V.formatRelative = void 0;

const formatRelativeLocale$r = {
  lastWeek: "'afgelopen' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P",
};

const formatRelative$U = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$r[token];
formatRelative$V.formatRelative = formatRelative$U;

var localize$r = {};

localize$r.localize = void 0;
var _index$5G = buildLocalizeFn$1;

const eraValues$r = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"],
};

const quarterValues$r = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"],
};

const monthValues$r = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december",
  ],
};

const dayValues$r = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag",
  ],
};

const dayPeriodValues$r = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts",
  },
};

const ordinalNumber$r = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "e";
};

(localize$r.localize = {
  ordinalNumber: ordinalNumber$r,

  era: (0, _index$5G.buildLocalizeFn)({
    values: eraValues$r,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5G.buildLocalizeFn)({
    values: quarterValues$r,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5G.buildLocalizeFn)({
    values: monthValues$r,
    defaultWidth: "wide",
  }),

  day: (0, _index$5G.buildLocalizeFn)({
    values: dayValues$r,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5G.buildLocalizeFn)({
    values: dayPeriodValues$r,
    defaultWidth: "wide",
  }),
});

var match$r = {};

match$r.match = void 0;

var _index$5F = buildMatchFn$1;
var _index2$2q = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$r = /^(\d+)e?/i;
const parseOrdinalNumberPattern$r = /\d+/i;

const matchEraPatterns$r = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/,
};
const parseEraPatterns$r = {
  any: [/^v/, /^n/],
};

const matchQuarterPatterns$r = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i,
};
const parseQuarterPatterns$r = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$r = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i,
};
const parseMonthPatterns$r = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i,
  ],
};

const matchDayPatterns$r = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i,
};
const parseDayPatterns$r = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i],
};

const matchDayPeriodPatterns$r = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i,
};
const parseDayPeriodPatterns$r = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i,
  },
};

(match$r.match = {
  ordinalNumber: (0, _index2$2q.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$r,
    parsePattern: parseOrdinalNumberPattern$r,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5F.buildMatchFn)({
    matchPatterns: matchEraPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$r,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5F.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$r,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5F.buildMatchFn)({
    matchPatterns: matchMonthPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$r,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5F.buildMatchFn)({
    matchPatterns: matchDayPatterns$r,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$r,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5F.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$r,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$r,
    defaultParseWidth: "any",
  }),
});

nl.nl = void 0;
var _index$5E = formatDistance$V;
var _index2$2p = formatLong$r;
var _index3$1d = formatRelative$V;
var _index4$J = localize$r;
var _index5$A = match$r;

/**
 * @category Locales
 * @summary Dutch locale.
 * @language Dutch
 * @iso-639-2 nld
 * @author Jorik Tangelder [@jtangelder](https://github.com/jtangelder)
 * @author Ruben Stolk [@rubenstolk](https://github.com/rubenstolk)
 * @author Lode Vanhove [@bitcrumb](https://github.com/bitcrumb)
 * @author Edo Rivai [@edorivai](https://github.com/edorivai)
 * @author Niels Keurentjes [@curry684](https://github.com/curry684)
 * @author Stefan Vermaas [@stefanvermaas](https://github.com/stefanvermaas)
 */
(nl.nl = {
  code: "nl",
  formatDistance: _index$5E.formatDistance,
  formatLong: _index2$2p.formatLong,
  formatRelative: _index3$1d.formatRelative,
  localize: _index4$J.localize,
  match: _index5$A.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var nlBE = {};

var formatDistance$T = {};

formatDistance$T.formatDistance = void 0;

const formatDistanceLocale$q = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden",
  },

  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden",
  },

  halfAMinute: "een halve minuut",

  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten",
  },

  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten",
  },

  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur",
  },

  xHours: {
    one: "1 uur",
    other: "{{count}} uur",
  },

  xDays: {
    one: "1 dag",
    other: "{{count}} dagen",
  },

  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weken",
  },

  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden",
  },

  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden",
  },

  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar",
  },

  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar",
  },

  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar",
  },

  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar",
  },
};

const formatDistance$S = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$q[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }

  return result;
};
formatDistance$T.formatDistance = formatDistance$S;

var formatLong$q = {};

formatLong$q.formatLong = void 0;
var _index$5D = buildFormatLongFn$1;

const dateFormats$q = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y",
};

const timeFormats$q = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$q = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$q.formatLong = {
  date: (0, _index$5D.buildFormatLongFn)({
    formats: dateFormats$q,
    defaultWidth: "full",
  }),

  time: (0, _index$5D.buildFormatLongFn)({
    formats: timeFormats$q,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5D.buildFormatLongFn)({
    formats: dateTimeFormats$q,
    defaultWidth: "full",
  }),
});

var formatRelative$T = {};

formatRelative$T.formatRelative = void 0;

const formatRelativeLocale$q = {
  lastWeek: "'vorige' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P",
};

const formatRelative$S = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$q[token];
formatRelative$T.formatRelative = formatRelative$S;

var localize$q = {};

localize$q.localize = void 0;
var _index$5C = buildLocalizeFn$1;

const eraValues$q = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"],
};

const quarterValues$q = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"],
};

const monthValues$q = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december",
  ],
};

const dayValues$q = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag",
  ],
};

const dayPeriodValues$q = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts",
  },
};

const ordinalNumber$q = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "e";
};

(localize$q.localize = {
  ordinalNumber: ordinalNumber$q,

  era: (0, _index$5C.buildLocalizeFn)({
    values: eraValues$q,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5C.buildLocalizeFn)({
    values: quarterValues$q,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5C.buildLocalizeFn)({
    values: monthValues$q,
    defaultWidth: "wide",
  }),

  day: (0, _index$5C.buildLocalizeFn)({
    values: dayValues$q,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5C.buildLocalizeFn)({
    values: dayPeriodValues$q,
    defaultWidth: "wide",
  }),
});

var match$q = {};

match$q.match = void 0;

var _index$5B = buildMatchFn$1;
var _index2$2o = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$q = /^(\d+)e?/i;
const parseOrdinalNumberPattern$q = /\d+/i;

const matchEraPatterns$q = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/,
};
const parseEraPatterns$q = {
  any: [/^v/, /^n/],
};

const matchQuarterPatterns$q = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i,
};
const parseQuarterPatterns$q = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$q = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i,
};
const parseMonthPatterns$q = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i,
  ],
};

const matchDayPatterns$q = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i,
};
const parseDayPatterns$q = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i],
};

const matchDayPeriodPatterns$q = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i,
};
const parseDayPeriodPatterns$q = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i,
  },
};

(match$q.match = {
  ordinalNumber: (0, _index2$2o.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$q,
    parsePattern: parseOrdinalNumberPattern$q,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5B.buildMatchFn)({
    matchPatterns: matchEraPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$q,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5B.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$q,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5B.buildMatchFn)({
    matchPatterns: matchMonthPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$q,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5B.buildMatchFn)({
    matchPatterns: matchDayPatterns$q,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$q,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5B.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$q,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$q,
    defaultParseWidth: "any",
  }),
});

nlBE.nlBE = void 0;
var _index$5A = formatDistance$T;
var _index2$2n = formatLong$q;
var _index3$1c = formatRelative$T;
var _index4$I = localize$q;
var _index5$z = match$q;

/**
 * @category Locales
 * @summary Dutch locale.
 * @language Dutch
 * @iso-639-2 nld
 * @author Jorik Tangelder [@jtangelder](https://github.com/jtangelder)
 * @author Ruben Stolk [@rubenstolk](https://github.com/rubenstolk)
 * @author Lode Vanhove [@bitcrumb](https://github.com/bitcrumb)
 * @author Alex Hoeing [@dcbn](https://github.com/dcbn)
 */
(nlBE.nlBE = {
  code: "nl-BE",
  formatDistance: _index$5A.formatDistance,
  formatLong: _index2$2n.formatLong,
  formatRelative: _index3$1c.formatRelative,
  localize: _index4$I.localize,
  match: _index5$z.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var nn = {};

var formatDistance$R = {};

formatDistance$R.formatDistance = void 0;

const formatDistanceLocale$p = {
  lessThanXSeconds: {
    one: "mindre enn eitt sekund",
    other: "mindre enn {{count}} sekund",
  },

  xSeconds: {
    one: "eitt sekund",
    other: "{{count}} sekund",
  },

  halfAMinute: "eit halvt minutt",

  lessThanXMinutes: {
    one: "mindre enn eitt minutt",
    other: "mindre enn {{count}} minutt",
  },

  xMinutes: {
    one: "eitt minutt",
    other: "{{count}} minutt",
  },

  aboutXHours: {
    one: "omtrent ein time",
    other: "omtrent {{count}} timar",
  },

  xHours: {
    one: "ein time",
    other: "{{count}} timar",
  },

  xDays: {
    one: "ein dag",
    other: "{{count}} dagar",
  },

  aboutXWeeks: {
    one: "omtrent ei veke",
    other: "omtrent {{count}} veker",
  },

  xWeeks: {
    one: "ei veke",
    other: "{{count}} veker",
  },

  aboutXMonths: {
    one: "omtrent ein mÃ¥nad",
    other: "omtrent {{count}} mÃ¥nader",
  },

  xMonths: {
    one: "ein mÃ¥nad",
    other: "{{count}} mÃ¥nader",
  },

  aboutXYears: {
    one: "omtrent eitt Ã¥r",
    other: "omtrent {{count}} Ã¥r",
  },

  xYears: {
    one: "eitt Ã¥r",
    other: "{{count}} Ã¥r",
  },

  overXYears: {
    one: "over eitt Ã¥r",
    other: "over {{count}} Ã¥r",
  },

  almostXYears: {
    one: "nesten eitt Ã¥r",
    other: "nesten {{count}} Ã¥r",
  },
};

const wordMapping$1 = [
  "null",
  "ein",
  "to",
  "tre",
  "fire",
  "fem",
  "seks",
  "sju",
  "Ã¥tte",
  "ni",
  "ti",
  "elleve",
  "tolv",
];

const formatDistance$Q = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$p[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping$1[count] : String(count),
    );
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sidan";
    }
  }

  return result;
};
formatDistance$R.formatDistance = formatDistance$Q;

var formatLong$p = {};

formatLong$p.formatLong = void 0;
var _index$5z = buildFormatLongFn$1;

const dateFormats$p = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y",
};

const timeFormats$p = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$p = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$p.formatLong = {
  date: (0, _index$5z.buildFormatLongFn)({
    formats: dateFormats$p,
    defaultWidth: "full",
  }),

  time: (0, _index$5z.buildFormatLongFn)({
    formats: timeFormats$p,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5z.buildFormatLongFn)({
    formats: dateTimeFormats$p,
    defaultWidth: "full",
  }),
});

var formatRelative$R = {};

formatRelative$R.formatRelative = void 0;

const formatRelativeLocale$p = {
  lastWeek: "'fÃ¸rre' eeee 'kl.' p",
  yesterday: "'i gÃ¥r kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P",
};

const formatRelative$Q = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$p[token];
formatRelative$R.formatRelative = formatRelative$Q;

var localize$p = {};

localize$p.localize = void 0;
var _index$5y = buildLocalizeFn$1;

const eraValues$p = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fÃ¸r Kristus", "etter Kristus"],
};

const quarterValues$p = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$p = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des.",
  ],

  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember",
  ],
};

const dayValues$p = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["su", "mÃ¥", "ty", "on", "to", "fr", "lau"],
  abbreviated: ["sun", "mÃ¥n", "tys", "ons", "tor", "fre", "laur"],
  wide: [
    "sundag",
    "mÃ¥ndag",
    "tysdag",
    "onsdag",
    "torsdag",
    "fredag",
    "laurdag",
  ],
};

const dayPeriodValues$p = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ etterm.",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natta",
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ etterm.",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natta",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morgonen",
    afternoon: "pÃ¥ ettermiddagen",
    evening: "pÃ¥ kvelden",
    night: "pÃ¥ natta",
  },
};

const ordinalNumber$p = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$p.localize = {
  ordinalNumber: ordinalNumber$p,

  era: (0, _index$5y.buildLocalizeFn)({
    values: eraValues$p,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5y.buildLocalizeFn)({
    values: quarterValues$p,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5y.buildLocalizeFn)({
    values: monthValues$p,
    defaultWidth: "wide",
  }),

  day: (0, _index$5y.buildLocalizeFn)({
    values: dayValues$p,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5y.buildLocalizeFn)({
    values: dayPeriodValues$p,
    defaultWidth: "wide",
  }),
});

var match$p = {};

match$p.match = void 0;

var _index$5x = buildMatchFn$1;
var _index2$2m = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$p = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$p = /\d+/i;

const matchEraPatterns$p = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(fÃ¸r Kristus|fÃ¸r vÃ¥r tid|etter Kristus|vÃ¥r tid)/i,
};
const parseEraPatterns$p = {
  any: [/^f/i, /^e/i],
};

const matchQuarterPatterns$p = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i,
};
const parseQuarterPatterns$p = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$p = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i,
};
const parseMonthPatterns$p = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$p = {
  narrow: /^[smtofl]/i,
  short: /^(su|mÃ¥|ty|on|to|fr|la)/i,
  abbreviated: /^(sun|mÃ¥n|tys|ons|tor|fre|laur)/i,
  wide: /^(sundag|mÃ¥ndag|tysdag|onsdag|torsdag|fredag|laurdag)/i,
};
const parseDayPatterns$p = {
  any: [/^s/i, /^m/i, /^ty/i, /^o/i, /^to/i, /^f/i, /^l/i],
};

const matchDayPeriodPatterns$p = {
  narrow: /^(midnatt|middag|(pÃ¥) (morgonen|ettermiddagen|kvelden|natta)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(pÃ¥) (morgonen|ettermiddagen|kvelden|natta))/i,
};
const parseDayPeriodPatterns$p = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i,
  },
};

(match$p.match = {
  ordinalNumber: (0, _index2$2m.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$p,
    parsePattern: parseOrdinalNumberPattern$p,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5x.buildMatchFn)({
    matchPatterns: matchEraPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$p,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5x.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$p,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5x.buildMatchFn)({
    matchPatterns: matchMonthPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$p,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5x.buildMatchFn)({
    matchPatterns: matchDayPatterns$p,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$p,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5x.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$p,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$p,
    defaultParseWidth: "any",
  }),
});

nn.nn = void 0;
var _index$5w = formatDistance$R;
var _index2$2l = formatLong$p;
var _index3$1b = formatRelative$R;
var _index4$H = localize$p;
var _index5$y = match$p;

/**
 * @category Locales
 * @summary Norwegian Nynorsk locale.
 * @language Norwegian Nynorsk
 * @iso-639-2 nno
 * @author Mats Byrkjeland [@draperunner](https://github.com/draperunner)
 */
(nn.nn = {
  code: "nn",
  formatDistance: _index$5w.formatDistance,
  formatLong: _index2$2l.formatLong,
  formatRelative: _index3$1b.formatRelative,
  localize: _index4$H.localize,
  match: _index5$y.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var oc = {};

var formatDistance$P = {};

formatDistance$P.formatDistance = void 0;

const formatDistanceLocale$o = {
  lessThanXSeconds: {
    one: "mens dâuna segonda",
    other: "mens de {{count}} segondas",
  },

  xSeconds: {
    one: "1 segonda",
    other: "{{count}} segondas",
  },

  halfAMinute: "30 segondas",

  lessThanXMinutes: {
    one: "mens dâuna minuta",
    other: "mens de {{count}} minutas",
  },

  xMinutes: {
    one: "1 minuta",
    other: "{{count}} minutas",
  },

  aboutXHours: {
    one: "environ 1 ora",
    other: "environ {{count}} oras",
  },

  xHours: {
    one: "1 ora",
    other: "{{count}} oras",
  },

  xDays: {
    one: "1 jorn",
    other: "{{count}} jorns",
  },

  aboutXWeeks: {
    one: "environ 1 setmana",
    other: "environ {{count}} setmanas",
  },

  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanas",
  },

  aboutXMonths: {
    one: "environ 1 mes",
    other: "environ {{count}} meses",
  },

  xMonths: {
    one: "1 mes",
    other: "{{count}} meses",
  },

  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans",
  },

  xYears: {
    one: "1 an",
    other: "{{count}} ans",
  },

  overXYears: {
    one: "mai dâun an",
    other: "mai de {{count}} ans",
  },

  almostXYears: {
    one: "gaireben un an",
    other: "gaireben {{count}} ans",
  },
};

const formatDistance$O = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$o[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dâaquÃ­ " + result;
    } else {
      return "fa " + result;
    }
  }

  return result;
};
formatDistance$P.formatDistance = formatDistance$O;

var formatLong$o = {};

formatLong$o.formatLong = void 0;
var _index$5v = buildFormatLongFn$1;

const dateFormats$o = {
  full: "EEEE d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y",
};

const timeFormats$o = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$o = {
  full: "{{date}} 'a' {{time}}",
  long: "{{date}} 'a' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$o.formatLong = {
  date: (0, _index$5v.buildFormatLongFn)({
    formats: dateFormats$o,
    defaultWidth: "full",
  }),

  time: (0, _index$5v.buildFormatLongFn)({
    formats: timeFormats$o,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5v.buildFormatLongFn)({
    formats: dateTimeFormats$o,
    defaultWidth: "full",
  }),
});

var formatRelative$P = {};

formatRelative$P.formatRelative = void 0;

const formatRelativeLocale$o = {
  lastWeek: "eeee 'passat a' p",
  yesterday: "'iÃ¨r a' p",
  today: "'uÃ¨i a' p",
  tomorrow: "'deman a' p",
  nextWeek: "eeee 'a' p",
  other: "P",
};

const formatRelative$O = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$o[token];
formatRelative$P.formatRelative = formatRelative$O;

var localize$o = {};

localize$o.localize = void 0;
var _index$5u = buildLocalizeFn$1;

const eraValues$o = {
  narrow: ["ab. J.C.", "apr. J.C."],
  abbreviated: ["ab. J.C.", "apr. J.C."],
  wide: ["abans JÃ¨sus-Crist", "aprÃ¨s JÃ¨sus-Crist"],
};

const quarterValues$o = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1Ã¨r trim.", "2nd trim.", "3en trim.", "4en trim."],
  wide: ["1Ã¨r trimÃ¨stre", "2nd trimÃ¨stre", "3en trimÃ¨stre", "4en trimÃ¨stre"],
};

const monthValues$o = {
  narrow: [
    "GN",
    "FB",
    "MÃ",
    "AB",
    "MA",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DC",
  ],

  abbreviated: [
    "gen.",
    "febr.",
    "marÃ§",
    "abr.",
    "mai",
    "junh",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "dec.",
  ],

  wide: [
    "geniÃ¨r",
    "febriÃ¨r",
    "marÃ§",
    "abril",
    "mai",
    "junh",
    "julhet",
    "agost",
    "setembre",
    "octÃ²bre",
    "novembre",
    "decembre",
  ],
};

const dayValues$o = {
  narrow: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  wide: [
    "dimenge",
    "diluns",
    "dimars",
    "dimÃ¨cres",
    "dijÃ²us",
    "divendres",
    "dissabte",
  ],
};

const dayPeriodValues$o = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "matin",
    afternoon: "aprÃ¨p-miÃ¨gjorn",
    evening: "vÃ¨spre",
    night: "nuÃ¨ch",
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "matin",
    afternoon: "aprÃ¨p-miÃ¨gjorn",
    evening: "vÃ¨spre",
    night: "nuÃ¨ch",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "matin",
    afternoon: "aprÃ¨p-miÃ¨gjorn",
    evening: "vÃ¨spre",
    night: "nuÃ¨ch",
  },
};

const formattingDayPeriodValues$m = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "del matin",
    afternoon: "de lâaprÃ¨p-miÃ¨gjorn",
    evening: "del ser",
    night: "de la nuÃ¨ch",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "del matin",
    afternoon: "de lâaprÃ¨p-miÃ¨gjorn",
    evening: "del ser",
    night: "de la nuÃ¨ch",
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "miÃ¨januÃ¨ch",
    noon: "miÃ¨gjorn",
    morning: "del matin",
    afternoon: "de lâaprÃ¨p-miÃ¨gjorn",
    evening: "del ser",
    night: "de la nuÃ¨ch",
  },
};

const ordinalNumber$o = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;
  let ordinal;

  switch (number) {
    case 1:
      ordinal = "Ã¨r";
      break;
    case 2:
      ordinal = "nd";
      break;
    default:
      ordinal = "en";
  }

  // feminine for year, week, hour, minute, second
  if (
    unit === "year" ||
    unit === "week" ||
    unit === "hour" ||
    unit === "minute" ||
    unit === "second"
  ) {
    ordinal += "a";
  }

  return number + ordinal;
};

(localize$o.localize = {
  ordinalNumber: ordinalNumber$o,

  era: (0, _index$5u.buildLocalizeFn)({
    values: eraValues$o,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5u.buildLocalizeFn)({
    values: quarterValues$o,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5u.buildLocalizeFn)({
    values: monthValues$o,
    defaultWidth: "wide",
  }),

  day: (0, _index$5u.buildLocalizeFn)({
    values: dayValues$o,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5u.buildLocalizeFn)({
    values: dayPeriodValues$o,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$m,
    defaultFormattingWidth: "wide",
  }),
});

var match$o = {};

match$o.match = void 0;

var _index$5t = buildMatchFn$1;
var _index2$2k = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$o = /^(\d+)(Ã¨r|nd|en)?[a]?/i;
const parseOrdinalNumberPattern$o = /\d+/i;

const matchEraPatterns$o = {
  narrow: /^(ab\.J\.C|apr\.J\.C|apr\.J\.-C)/i,
  abbreviated: /^(ab\.J\.-C|ab\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(abans JÃ¨sus-Crist|aprÃ¨s JÃ¨sus-Crist)/i,
};
const parseEraPatterns$o = {
  any: [/^ab/i, /^ap/i],
};

const matchQuarterPatterns$o = {
  narrow: /^T[1234]/i,
  abbreviated: /^[1234](Ã¨r|nd|en)? trim\.?/i,
  wide: /^[1234](Ã¨r|nd|en)? trimÃ¨stre/i,
};
const parseQuarterPatterns$o = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$o = {
  narrow: /^(GN|FB|MÃ|AB|MA|JN|JL|AG|ST|OC|NV|DC)/i,
  abbreviated: /^(gen|febr|marÃ§|abr|mai|junh|jul|ag|set|oct|nov|dec)\.?/i,
  wide: /^(geniÃ¨r|febriÃ¨r|marÃ§|abril|mai|junh|julhet|agost|setembre|octÃ²bre|novembre|decembre)/i,
};
const parseMonthPatterns$o = {
  any: [
    /^g/i,
    /^f/i,
    /^ma[r?]|MÃ/i,
    /^ab/i,
    /^ma[i?]/i,
    /^ju[n?]|JN/i,
    /^ju[l?]|JL/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$o = {
  narrow: /^d[glmcjvs]\.?/i,
  short: /^d[glmcjvs]\.?/i,
  abbreviated: /^d[glmcjvs]\.?/i,
  wide: /^(dimenge|diluns|dimars|dimÃ¨cres|dijÃ²us|divendres|dissabte)/i,
};
const parseDayPatterns$o = {
  narrow: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  short: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  abbreviated: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],

  any: [
    /^dg|dime/i,
    /^dl|dil/i,
    /^dm|dima/i,
    /^dc|dimÃ¨/i,
    /^dj|dij/i,
    /^dv|div/i,
    /^ds|dis/i,
  ],
};

const matchDayPeriodPatterns$o = {
  any: /(^(a\.?m|p\.?m))|(ante meridiem|post meridiem)|((del |de la |de lâ)(matin|aprÃ¨p-miÃ¨gjorn|vÃ¨spre|ser|nuÃ¨ch))/i,
};
const parseDayPeriodPatterns$o = {
  any: {
    am: /(^a)|ante meridiem/i,
    pm: /(^p)|post meridiem/i,
    midnight: /^miÃ¨j/i,
    noon: /^miÃ¨g/i,
    morning: /matin/i,
    afternoon: /aprÃ¨p-miÃ¨gjorn/i,
    evening: /vÃ¨spre|ser/i,
    night: /nuÃ¨ch/i,
  },
};

(match$o.match = {
  ordinalNumber: (0, _index2$2k.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$o,
    parsePattern: parseOrdinalNumberPattern$o,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5t.buildMatchFn)({
    matchPatterns: matchEraPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$o,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5t.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$o,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5t.buildMatchFn)({
    matchPatterns: matchMonthPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$o,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5t.buildMatchFn)({
    matchPatterns: matchDayPatterns$o,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$o,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5t.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$o,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$o,
    defaultParseWidth: "any",
  }),
});

oc.oc = void 0;
var _index$5s = formatDistance$P;
var _index2$2j = formatLong$o;
var _index3$1a = formatRelative$P;
var _index4$G = localize$o;
var _index5$x = match$o;

/**
 * @category Locales
 * @summary Occitan locale.
 * @language Occitan
 * @iso-639-2 oci
 * @author Quentin PAGÃS
 */
(oc.oc = {
  code: "oc",
  formatDistance: _index$5s.formatDistance,
  formatLong: _index2$2j.formatLong,
  formatRelative: _index3$1a.formatRelative,
  localize: _index4$G.localize,
  match: _index5$x.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var pl = {};

var formatDistance$N = {};

formatDistance$N.formatDistance = void 0;

const formatDistanceLocale$n = {
  lessThanXSeconds: {
    one: {
      regular: "mniej niÅ¼ sekunda",
      past: "mniej niÅ¼ sekundÄ",
      future: "mniej niÅ¼ sekundÄ",
    },
    twoFour: "mniej niÅ¼ {{count}} sekundy",
    other: "mniej niÅ¼ {{count}} sekund",
  },

  xSeconds: {
    one: {
      regular: "sekunda",
      past: "sekundÄ",
      future: "sekundÄ",
    },
    twoFour: "{{count}} sekundy",
    other: "{{count}} sekund",
  },

  halfAMinute: {
    one: "pÃ³Å minuty",
    twoFour: "pÃ³Å minuty",
    other: "pÃ³Å minuty",
  },

  lessThanXMinutes: {
    one: {
      regular: "mniej niÅ¼ minuta",
      past: "mniej niÅ¼ minutÄ",
      future: "mniej niÅ¼ minutÄ",
    },
    twoFour: "mniej niÅ¼ {{count}} minuty",
    other: "mniej niÅ¼ {{count}} minut",
  },

  xMinutes: {
    one: {
      regular: "minuta",
      past: "minutÄ",
      future: "minutÄ",
    },
    twoFour: "{{count}} minuty",
    other: "{{count}} minut",
  },

  aboutXHours: {
    one: {
      regular: "okoÅo godziny",
      past: "okoÅo godziny",
      future: "okoÅo godzinÄ",
    },
    twoFour: "okoÅo {{count}} godziny",
    other: "okoÅo {{count}} godzin",
  },

  xHours: {
    one: {
      regular: "godzina",
      past: "godzinÄ",
      future: "godzinÄ",
    },
    twoFour: "{{count}} godziny",
    other: "{{count}} godzin",
  },

  xDays: {
    one: {
      regular: "dzieÅ",
      past: "dzieÅ",
      future: "1 dzieÅ",
    },
    twoFour: "{{count}} dni",
    other: "{{count}} dni",
  },

  aboutXWeeks: {
    one: "okoÅo tygodnia",
    twoFour: "okoÅo {{count}} tygodni",
    other: "okoÅo {{count}} tygodni",
  },

  xWeeks: {
    one: "tydzieÅ",
    twoFour: "{{count}} tygodnie",
    other: "{{count}} tygodni",
  },

  aboutXMonths: {
    one: "okoÅo miesiÄc",
    twoFour: "okoÅo {{count}} miesiÄce",
    other: "okoÅo {{count}} miesiÄcy",
  },

  xMonths: {
    one: "miesiÄc",
    twoFour: "{{count}} miesiÄce",
    other: "{{count}} miesiÄcy",
  },

  aboutXYears: {
    one: "okoÅo rok",
    twoFour: "okoÅo {{count}} lata",
    other: "okoÅo {{count}} lat",
  },

  xYears: {
    one: "rok",
    twoFour: "{{count}} lata",
    other: "{{count}} lat",
  },

  overXYears: {
    one: "ponad rok",
    twoFour: "ponad {{count}} lata",
    other: "ponad {{count}} lat",
  },

  almostXYears: {
    one: "prawie rok",
    twoFour: "prawie {{count}} lata",
    other: "prawie {{count}} lat",
  },
};

function declensionGroup$1(scheme, count) {
  if (count === 1) {
    return scheme.one;
  }

  const rem100 = count % 100;

  // ends with 11-20
  if (rem100 <= 20 && rem100 > 10) {
    return scheme.other;
  }

  const rem10 = rem100 % 10;

  // ends with 2, 3, 4
  if (rem10 >= 2 && rem10 <= 4) {
    return scheme.twoFour;
  }

  return scheme.other;
}

function declension$3(scheme, count, time) {
  const group = declensionGroup$1(scheme, count);
  const finalText = typeof group === "string" ? group : group[time];
  return finalText.replace("{{count}}", String(count));
}

const formatDistance$M = (token, count, options) => {
  const scheme = formatDistanceLocale$n[token];
  if (!options?.addSuffix) {
    return declension$3(scheme, count, "regular");
  }

  if (options.comparison && options.comparison > 0) {
    return "za " + declension$3(scheme, count, "future");
  } else {
    return declension$3(scheme, count, "past") + " temu";
  }
};
formatDistance$N.formatDistance = formatDistance$M;

var formatLong$n = {};

formatLong$n.formatLong = void 0;
var _index$5r = buildFormatLongFn$1;

const dateFormats$n = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "dd.MM.y",
};

const timeFormats$n = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$n = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$n.formatLong = {
  date: (0, _index$5r.buildFormatLongFn)({
    formats: dateFormats$n,
    defaultWidth: "full",
  }),

  time: (0, _index$5r.buildFormatLongFn)({
    formats: timeFormats$n,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5r.buildFormatLongFn)({
    formats: dateTimeFormats$n,
    defaultWidth: "full",
  }),
});

var formatRelative$N = {};

formatRelative$N.formatRelative = void 0;
var _index$5q = isSameWeek$1;

const adjectivesLastWeek = {
  masculine: "ostatni",
  feminine: "ostatnia",
};

const adjectivesThisWeek = {
  masculine: "ten",
  feminine: "ta",
};

const adjectivesNextWeek = {
  masculine: "nastÄpny",
  feminine: "nastÄpna",
};

const dayGrammaticalGender = {
  0: "feminine",
  1: "masculine",
  2: "masculine",
  3: "feminine",
  4: "masculine",
  5: "masculine",
  6: "feminine",
};

function dayAndTimeWithAdjective(token, date, baseDate, options) {
  let adjectives;
  if ((0, _index$5q.isSameWeek)(date, baseDate, options)) {
    adjectives = adjectivesThisWeek;
  } else if (token === "lastWeek") {
    adjectives = adjectivesLastWeek;
  } else if (token === "nextWeek") {
    adjectives = adjectivesNextWeek;
  } else {
    throw new Error(`Cannot determine adjectives for token ${token}`);
  }

  const day = date.getDay();
  const grammaticalGender = dayGrammaticalGender[day];

  const adjective = adjectives[grammaticalGender];

  return `'${adjective}' eeee 'o' p`;
}

const formatRelativeLocale$n = {
  lastWeek: dayAndTimeWithAdjective,
  yesterday: "'wczoraj o' p",
  today: "'dzisiaj o' p",
  tomorrow: "'jutro o' p",
  nextWeek: dayAndTimeWithAdjective,
  other: "P",
};

const formatRelative$M = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$n[token];

  if (typeof format === "function") {
    return format(token, date, baseDate, options);
  }

  return format;
};
formatRelative$N.formatRelative = formatRelative$M;

var localize$n = {};

localize$n.localize = void 0;
var _index$5p = buildLocalizeFn$1;

const eraValues$n = {
  narrow: ["p.n.e.", "n.e."],
  abbreviated: ["p.n.e.", "n.e."],
  wide: ["przed naszÄ erÄ", "naszej ery"],
};

const quarterValues$n = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
  wide: ["I kwartaÅ", "II kwartaÅ", "III kwartaÅ", "IV kwartaÅ"],
};

const monthValues$n = {
  narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "paÅº",
    "lis",
    "gru",
  ],

  wide: [
    "styczeÅ",
    "luty",
    "marzec",
    "kwiecieÅ",
    "maj",
    "czerwiec",
    "lipiec",
    "sierpieÅ",
    "wrzesieÅ",
    "paÅºdziernik",
    "listopad",
    "grudzieÅ",
  ],
};
const monthFormattingValues = {
  narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "paÅº",
    "lis",
    "gru",
  ],

  wide: [
    "stycznia",
    "lutego",
    "marca",
    "kwietnia",
    "maja",
    "czerwca",
    "lipca",
    "sierpnia",
    "wrzeÅnia",
    "paÅºdziernika",
    "listopada",
    "grudnia",
  ],
};

const dayValues$n = {
  narrow: ["N", "P", "W", "Å", "C", "P", "S"],
  short: ["nie", "pon", "wto", "Åro", "czw", "piÄ", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "År.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziaÅek",
    "wtorek",
    "Åroda",
    "czwartek",
    "piÄtek",
    "sobota",
  ],
};
const dayFormattingValues = {
  narrow: ["n", "p", "w", "Å", "c", "p", "s"],
  short: ["nie", "pon", "wto", "Åro", "czw", "piÄ", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "År.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziaÅek",
    "wtorek",
    "Åroda",
    "czwartek",
    "piÄtek",
    "sobota",
  ],
};

const dayPeriodValues$n = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "pÃ³Ån.",
    noon: "poÅ",
    morning: "rano",
    afternoon: "popoÅ.",
    evening: "wiecz.",
    night: "noc",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "pÃ³Ånoc",
    noon: "poÅudnie",
    morning: "rano",
    afternoon: "popoÅudnie",
    evening: "wieczÃ³r",
    night: "noc",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "pÃ³Ånoc",
    noon: "poÅudnie",
    morning: "rano",
    afternoon: "popoÅudnie",
    evening: "wieczÃ³r",
    night: "noc",
  },
};

const dayPeriodFormattingValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "o pÃ³Ån.",
    noon: "w poÅ.",
    morning: "rano",
    afternoon: "po poÅ.",
    evening: "wiecz.",
    night: "w nocy",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o pÃ³Ånocy",
    noon: "w poÅudnie",
    morning: "rano",
    afternoon: "po poÅudniu",
    evening: "wieczorem",
    night: "w nocy",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o pÃ³Ånocy",
    noon: "w poÅudnie",
    morning: "rano",
    afternoon: "po poÅudniu",
    evening: "wieczorem",
    night: "w nocy",
  },
};

const ordinalNumber$n = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$n.localize = {
  ordinalNumber: ordinalNumber$n,

  era: (0, _index$5p.buildLocalizeFn)({
    values: eraValues$n,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5p.buildLocalizeFn)({
    values: quarterValues$n,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5p.buildLocalizeFn)({
    values: monthValues$n,
    defaultWidth: "wide",
    formattingValues: monthFormattingValues,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$5p.buildLocalizeFn)({
    values: dayValues$n,
    defaultWidth: "wide",
    formattingValues: dayFormattingValues,
    defaultFormattingWidth: "wide",
  }),

  dayPeriod: (0, _index$5p.buildLocalizeFn)({
    values: dayPeriodValues$n,
    defaultWidth: "wide",
    formattingValues: dayPeriodFormattingValues,
    defaultFormattingWidth: "wide",
  }),
});

var match$n = {};

match$n.match = void 0;

var _index$5o = buildMatchFn$1;
var _index2$2i = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$n = /^(\d+)?/i;
const parseOrdinalNumberPattern$n = /\d+/i;

const matchEraPatterns$n = {
  narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  wide: /^(przed\s*nasz(Ä|a)\s*er(Ä|a)|naszej\s*ery)/i,
};
const parseEraPatterns$n = {
  any: [/^p/i, /^n/i],
};

const matchQuarterPatterns$n = {
  narrow: /^[1234]/i,
  abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
  wide: /^(I|II|III|IV)\s*kwarta(Å|l)/i,
};
const parseQuarterPatterns$n = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i],
};

const matchMonthPatterns$n = {
  narrow: /^[slmkcwpg]/i,
  abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(Åº|z)|lis|gru)/i,
  wide: /^(stycznia|stycze(Å|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(Å|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(Å|n)|wrze(Å|s)nia|wrzesie(Å|n)|pa(Åº|z)dziernika|pa(Åº|z)dziernik|listopada|listopad|grudnia|grudzie(Å|n))/i,
};
const parseMonthPatterns$n = {
  narrow: [
    /^s/i,
    /^l/i,
    /^m/i,
    /^k/i,
    /^m/i,
    /^c/i,
    /^l/i,
    /^s/i,
    /^w/i,
    /^p/i,
    /^l/i,
    /^g/i,
  ],

  any: [
    /^st/i,
    /^lu/i,
    /^mar/i,
    /^k/i,
    /^maj/i,
    /^c/i,
    /^lip/i,
    /^si/i,
    /^w/i,
    /^p/i,
    /^lis/i,
    /^g/i,
  ],
};

const matchDayPatterns$n = {
  narrow: /^[npwÅcs]/i,
  short: /^(nie|pon|wto|(Å|s)ro|czw|pi(Ä|a)|sob)/i,
  abbreviated: /^(niedz|pon|wt|(Å|s)r|czw|pt|sob)\.?/i,
  wide: /^(niedziela|poniedzia(Å|l)ek|wtorek|(Å|s)roda|czwartek|pi(Ä|a)tek|sobota)/i,
};
const parseDayPatterns$n = {
  narrow: [/^n/i, /^p/i, /^w/i, /^Å/i, /^c/i, /^p/i, /^s/i],
  abbreviated: [/^n/i, /^po/i, /^w/i, /^(Å|s)r/i, /^c/i, /^pt/i, /^so/i],

  any: [/^n/i, /^po/i, /^w/i, /^(Å|s)r/i, /^c/i, /^pi/i, /^so/i],
};

const matchDayPeriodPatterns$n = {
  narrow:
    /^(^a$|^p$|pÃ³(Å|l)n\.?|o\s*pÃ³(Å|l)n\.?|po(Å|l)\.?|w\s*po(Å|l)\.?|po\s*po(Å|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
  any: /^(am|pm|pÃ³(Å|l)noc|o\s*pÃ³(Å|l)nocy|po(Å|l)udnie|w\s*po(Å|l)udnie|popo(Å|l)udnie|po\s*po(Å|l)udniu|rano|wieczÃ³r|wieczorem|noc|w\s*nocy)/i,
};
const parseDayPeriodPatterns$n = {
  narrow: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /pÃ³(Å|l)n/i,
    noon: /po(Å|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(Å|l)/i,
    evening: /wiecz/i,
    night: /noc/i,
  },
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /pÃ³(Å|l)n/i,
    noon: /po(Å|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(Å|l)/i,
    evening: /wiecz/i,
    night: /noc/i,
  },
};

(match$n.match = {
  ordinalNumber: (0, _index2$2i.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$n,
    parsePattern: parseOrdinalNumberPattern$n,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5o.buildMatchFn)({
    matchPatterns: matchEraPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$n,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5o.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$n,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5o.buildMatchFn)({
    matchPatterns: matchMonthPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$n,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5o.buildMatchFn)({
    matchPatterns: matchDayPatterns$n,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$n,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5o.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$n,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$n,
    defaultParseWidth: "any",
  }),
});

pl.pl = void 0;
var _index$5n = formatDistance$N;
var _index2$2h = formatLong$n;
var _index3$19 = formatRelative$N;
var _index4$F = localize$n;
var _index5$w = match$n;

/**
 * @category Locales
 * @summary Polish locale.
 * @language Polish
 * @iso-639-2 pol
 * @author Mateusz Derks [@ertrzyiks](https://github.com/ertrzyiks)
 * @author Just RAG [@justrag](https://github.com/justrag)
 * @author Mikolaj Grzyb [@mikolajgrzyb](https://github.com/mikolajgrzyb)
 * @author Mateusz Tokarski [@mutisz](https://github.com/mutisz)
 */
(pl.pl = {
  code: "pl",
  formatDistance: _index$5n.formatDistance,
  formatLong: _index2$2h.formatLong,
  formatRelative: _index3$19.formatRelative,
  localize: _index4$F.localize,
  match: _index5$w.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var pt = {};

var formatDistance$L = {};

formatDistance$L.formatDistance = void 0;

const formatDistanceLocale$m = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos",
  },

  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos",
  },

  halfAMinute: "meio minuto",

  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos",
  },

  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos",
  },

  aboutXHours: {
    one: "aproximadamente 1 hora",
    other: "aproximadamente {{count}} horas",
  },

  xHours: {
    one: "1 hora",
    other: "{{count}} horas",
  },

  xDays: {
    one: "1 dia",
    other: "{{count}} dias",
  },

  aboutXWeeks: {
    one: "aproximadamente 1 semana",
    other: "aproximadamente {{count}} semanas",
  },

  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas",
  },

  aboutXMonths: {
    one: "aproximadamente 1 mÃªs",
    other: "aproximadamente {{count}} meses",
  },

  xMonths: {
    one: "1 mÃªs",
    other: "{{count}} meses",
  },

  aboutXYears: {
    one: "aproximadamente 1 ano",
    other: "aproximadamente {{count}} anos",
  },

  xYears: {
    one: "1 ano",
    other: "{{count}} anos",
  },

  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos",
  },

  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos",
  },
};

const formatDistance$K = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$m[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "daqui a " + result;
    } else {
      return "hÃ¡ " + result;
    }
  }

  return result;
};
formatDistance$L.formatDistance = formatDistance$K;

var formatLong$m = {};

formatLong$m.formatLong = void 0;
var _index$5m = buildFormatLongFn$1;

const dateFormats$m = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d 'de' MMM 'de' y",
  short: "dd/MM/y",
};

const timeFormats$m = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$m = {
  full: "{{date}} 'Ã s' {{time}}",
  long: "{{date}} 'Ã s' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$m.formatLong = {
  date: (0, _index$5m.buildFormatLongFn)({
    formats: dateFormats$m,
    defaultWidth: "full",
  }),

  time: (0, _index$5m.buildFormatLongFn)({
    formats: timeFormats$m,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5m.buildFormatLongFn)({
    formats: dateTimeFormats$m,
    defaultWidth: "full",
  }),
});

var formatRelative$L = {};

formatRelative$L.formatRelative = void 0;

const formatRelativeLocale$m = {
  lastWeek: (date) => {
    const weekday = date.getDay();
    const last = weekday === 0 || weekday === 6 ? "Ãºltimo" : "Ãºltima";
    return "'" + last + "' eeee 'Ã s' p";
  },
  yesterday: "'ontem Ã s' p",
  today: "'hoje Ã s' p",
  tomorrow: "'amanhÃ£ Ã s' p",
  nextWeek: "eeee 'Ã s' p",
  other: "P",
};

const formatRelative$K = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$m[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$L.formatRelative = formatRelative$K;

var localize$m = {};

localize$m.localize = void 0;
var _index$5l = buildLocalizeFn$1;

const eraValues$m = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["antes de Cristo", "depois de Cristo"],
};

const quarterValues$m = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1Âº trimestre", "2Âº trimestre", "3Âº trimestre", "4Âº trimestre"],
};

const monthValues$m = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez",
  ],

  wide: [
    "janeiro",
    "fevereiro",
    "marÃ§o",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro",
  ],
};

const dayValues$m = {
  narrow: ["d", "s", "t", "q", "q", "s", "s"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sÃ¡b"],
  abbreviated: ["dom", "seg", "ter", "qua", "qui", "sex", "sÃ¡b"],
  wide: [
    "domingo",
    "segunda-feira",
    "terÃ§a-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sÃ¡bado",
  ],
};

const dayPeriodValues$m = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada",
  },
};

const formattingDayPeriodValues$l = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada",
  },
};

const ordinalNumber$m = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "Âº";
};

(localize$m.localize = {
  ordinalNumber: ordinalNumber$m,

  era: (0, _index$5l.buildLocalizeFn)({
    values: eraValues$m,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5l.buildLocalizeFn)({
    values: quarterValues$m,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5l.buildLocalizeFn)({
    values: monthValues$m,
    defaultWidth: "wide",
  }),

  day: (0, _index$5l.buildLocalizeFn)({
    values: dayValues$m,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5l.buildLocalizeFn)({
    values: dayPeriodValues$m,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$l,
    defaultFormattingWidth: "wide",
  }),
});

var match$m = {};

match$m.match = void 0;

var _index$5k = buildMatchFn$1;
var _index2$2g = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$m = /^(\d+)(Âº|Âª)?/i;
const parseOrdinalNumberPattern$m = /\d+/i;

const matchEraPatterns$m = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i,
};
const parseEraPatterns$m = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era comum)/i,
    /^(depois de cristo|era comum)/i,
  ],
};

const matchQuarterPatterns$m = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](Âº|Âª)? trimestre/i,
};
const parseQuarterPatterns$m = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$m = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|marÃ§o|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i,
};
const parseMonthPatterns$m = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ab/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$m = {
  narrow: /^[dstq]/i,
  short: /^(dom|seg|ter|qua|qui|sex|s[Ã¡a]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[Ã¡a]b)/i,
  wide: /^(domingo|segunda-?\s?feira|terÃ§a-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[Ã¡a]bado)/i,
};
const parseDayPatterns$m = {
  narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[Ã¡a]/i],
};

const matchDayPeriodPatterns$m = {
  narrow:
    /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[Ã£a]|tarde|noite|madrugada))/i,
  any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[Ã£a]|tarde|noite|madrugada))/i,
};
const parseDayPeriodPatterns$m = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^meia/i,
    noon: /^meio/i,
    morning: /manh[Ã£a]/i,
    afternoon: /tarde/i,
    evening: /noite/i,
    night: /madrugada/i,
  },
};

(match$m.match = {
  ordinalNumber: (0, _index2$2g.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$m,
    parsePattern: parseOrdinalNumberPattern$m,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5k.buildMatchFn)({
    matchPatterns: matchEraPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$m,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5k.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$m,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5k.buildMatchFn)({
    matchPatterns: matchMonthPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$m,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5k.buildMatchFn)({
    matchPatterns: matchDayPatterns$m,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$m,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5k.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$m,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$m,
    defaultParseWidth: "any",
  }),
});

pt.pt = void 0;
var _index$5j = formatDistance$L;
var _index2$2f = formatLong$m;
var _index3$18 = formatRelative$L;
var _index4$E = localize$m;
var _index5$v = match$m;

/**
 * @category Locales
 * @summary Portuguese locale.
 * @language Portuguese
 * @iso-639-2 por
 * @author DÃ¡rio Freire [@dfreire](https://github.com/dfreire)
 * @author AdriÃ¡n de la Rosa [@adrm](https://github.com/adrm)
 */
(pt.pt = {
  code: "pt",
  formatDistance: _index$5j.formatDistance,
  formatLong: _index2$2f.formatLong,
  formatRelative: _index3$18.formatRelative,
  localize: _index4$E.localize,
  match: _index5$v.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var ptBR = {};

var formatDistance$J = {};

formatDistance$J.formatDistance = void 0;

const formatDistanceLocale$l = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos",
  },

  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos",
  },

  halfAMinute: "meio minuto",

  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos",
  },

  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos",
  },

  aboutXHours: {
    one: "cerca de 1 hora",
    other: "cerca de {{count}} horas",
  },

  xHours: {
    one: "1 hora",
    other: "{{count}} horas",
  },

  xDays: {
    one: "1 dia",
    other: "{{count}} dias",
  },

  aboutXWeeks: {
    one: "cerca de 1 semana",
    other: "cerca de {{count}} semanas",
  },

  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas",
  },

  aboutXMonths: {
    one: "cerca de 1 mÃªs",
    other: "cerca de {{count}} meses",
  },

  xMonths: {
    one: "1 mÃªs",
    other: "{{count}} meses",
  },

  aboutXYears: {
    one: "cerca de 1 ano",
    other: "cerca de {{count}} anos",
  },

  xYears: {
    one: "1 ano",
    other: "{{count}} anos",
  },

  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos",
  },

  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos",
  },
};

const formatDistance$I = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$l[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "em " + result;
    } else {
      return "hÃ¡ " + result;
    }
  }

  return result;
};
formatDistance$J.formatDistance = formatDistance$I;

var formatLong$l = {};

formatLong$l.formatLong = void 0;
var _index$5i = buildFormatLongFn$1;

const dateFormats$l = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/yyyy",
};

const timeFormats$l = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$l = {
  full: "{{date}} 'Ã s' {{time}}",
  long: "{{date}} 'Ã s' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$l.formatLong = {
  date: (0, _index$5i.buildFormatLongFn)({
    formats: dateFormats$l,
    defaultWidth: "full",
  }),

  time: (0, _index$5i.buildFormatLongFn)({
    formats: timeFormats$l,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5i.buildFormatLongFn)({
    formats: dateTimeFormats$l,
    defaultWidth: "full",
  }),
});

var formatRelative$J = {};

formatRelative$J.formatRelative = void 0;

const formatRelativeLocale$l = {
  lastWeek: (date) => {
    const weekday = date.getDay();
    const last = weekday === 0 || weekday === 6 ? "Ãºltimo" : "Ãºltima";
    return "'" + last + "' eeee 'Ã s' p";
  },
  yesterday: "'ontem Ã s' p",
  today: "'hoje Ã s' p",
  tomorrow: "'amanhÃ£ Ã s' p",
  nextWeek: "eeee 'Ã s' p",
  other: "P",
};

const formatRelative$I = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$l[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$J.formatRelative = formatRelative$I;

var localize$l = {};

localize$l.localize = void 0;
var _index$5h = buildLocalizeFn$1;

const eraValues$l = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "depois de cristo"],
};

const quarterValues$l = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1Âº trimestre", "2Âº trimestre", "3Âº trimestre", "4Âº trimestre"],
};

const monthValues$l = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez",
  ],

  wide: [
    "janeiro",
    "fevereiro",
    "marÃ§o",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro",
  ],
};

const dayValues$l = {
  narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
  abbreviated: [
    "domingo",
    "segunda",
    "terÃ§a",
    "quarta",
    "quinta",
    "sexta",
    "sÃ¡bado",
  ],

  wide: [
    "domingo",
    "segunda-feira",
    "terÃ§a-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sÃ¡bado",
  ],
};

const dayPeriodValues$l = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhÃ£",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite",
  },
};

const formattingDayPeriodValues$k = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhÃ£",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite",
  },
};

const ordinalNumber$l = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  if (options?.unit === "week") {
    return number + "Âª";
  }
  return number + "Âº";
};

(localize$l.localize = {
  ordinalNumber: ordinalNumber$l,

  era: (0, _index$5h.buildLocalizeFn)({
    values: eraValues$l,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5h.buildLocalizeFn)({
    values: quarterValues$l,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5h.buildLocalizeFn)({
    values: monthValues$l,
    defaultWidth: "wide",
  }),

  day: (0, _index$5h.buildLocalizeFn)({
    values: dayValues$l,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5h.buildLocalizeFn)({
    values: dayPeriodValues$l,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$k,
    defaultFormattingWidth: "wide",
  }),
});

var match$l = {};

match$l.match = void 0;

var _index$5g = buildMatchFn$1;
var _index2$2e = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$l = /^(\d+)[ÂºÂªo]?/i;
const parseOrdinalNumberPattern$l = /\d+/i;

const matchEraPatterns$l = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
  wide: /^(antes de cristo|depois de cristo)/i,
};
const parseEraPatterns$l = {
  any: [/^ac/i, /^dc/i],
  wide: [/^antes de cristo/i, /^depois de cristo/i],
};

const matchQuarterPatterns$l = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](Âº)? trimestre/i,
};
const parseQuarterPatterns$l = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$l = {
  narrow: /^[jfmajsond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|marÃ§o|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i,
};
const parseMonthPatterns$l = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^fev/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dez/i,
  ],
};

const matchDayPatterns$l = {
  narrow: /^(dom|[23456]Âª?|s[aÃ¡]b)/i,
  short: /^(dom|[23456]Âª?|s[aÃ¡]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aÃ¡]b)/i,
  wide: /^(domingo|(segunda|ter[cÃ§]a|quarta|quinta|sexta)([- ]feira)?|s[aÃ¡]bado)/i,
};
const parseDayPatterns$l = {
  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aÃ¡]/i],
  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aÃ¡]/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aÃ¡]b/i],
};

const matchDayPeriodPatterns$l = {
  narrow: /^(a|p|mn|md|(da) (manhÃ£|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manhÃ£|tarde|noite))/i,
};
const parseDayPeriodPatterns$l = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn|^meia[-\s]noite/i,
    noon: /^md|^meio[-\s]dia/i,
    morning: /manhÃ£/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noite/i,
  },
};

(match$l.match = {
  ordinalNumber: (0, _index2$2e.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$l,
    parsePattern: parseOrdinalNumberPattern$l,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5g.buildMatchFn)({
    matchPatterns: matchEraPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$l,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5g.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$l,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5g.buildMatchFn)({
    matchPatterns: matchMonthPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$l,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5g.buildMatchFn)({
    matchPatterns: matchDayPatterns$l,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$l,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5g.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$l,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$l,
    defaultParseWidth: "any",
  }),
});

ptBR.ptBR = void 0;
var _index$5f = formatDistance$J;
var _index2$2d = formatLong$l;
var _index3$17 = formatRelative$J;
var _index4$D = localize$l;
var _index5$u = match$l;

/**
 * @category Locales
 * @summary Portuguese locale (Brazil).
 * @language Portuguese
 * @iso-639-2 por
 * @author Lucas Duailibe [@duailibe](https://github.com/duailibe)
 * @author Yago Carballo [@yagocarballo](https://github.com/YagoCarballo)
 */
(ptBR.ptBR = {
  code: "pt-BR",
  formatDistance: _index$5f.formatDistance,
  formatLong: _index2$2d.formatLong,
  formatRelative: _index3$17.formatRelative,
  localize: _index4$D.localize,
  match: _index5$u.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var ro = {};

var formatDistance$H = {};

formatDistance$H.formatDistance = void 0;

const formatDistanceLocale$k = {
  lessThanXSeconds: {
    one: "mai puÈin de o secundÄ",
    other: "mai puÈin de {{count}} secunde",
  },

  xSeconds: {
    one: "1 secundÄ",
    other: "{{count}} secunde",
  },

  halfAMinute: "jumÄtate de minut",

  lessThanXMinutes: {
    one: "mai puÈin de un minut",
    other: "mai puÈin de {{count}} minute",
  },

  xMinutes: {
    one: "1 minut",
    other: "{{count}} minute",
  },

  aboutXHours: {
    one: "circa 1 orÄ",
    other: "circa {{count}} ore",
  },

  xHours: {
    one: "1 orÄ",
    other: "{{count}} ore",
  },

  xDays: {
    one: "1 zi",
    other: "{{count}} zile",
  },

  aboutXWeeks: {
    one: "circa o sÄptÄmÃ¢nÄ",
    other: "circa {{count}} sÄptÄmÃ¢ni",
  },

  xWeeks: {
    one: "1 sÄptÄmÃ¢nÄ",
    other: "{{count}} sÄptÄmÃ¢ni",
  },

  aboutXMonths: {
    one: "circa 1 lunÄ",
    other: "circa {{count}} luni",
  },

  xMonths: {
    one: "1 lunÄ",
    other: "{{count}} luni",
  },

  aboutXYears: {
    one: "circa 1 an",
    other: "circa {{count}} ani",
  },

  xYears: {
    one: "1 an",
    other: "{{count}} ani",
  },

  overXYears: {
    one: "peste 1 an",
    other: "peste {{count}} ani",
  },

  almostXYears: {
    one: "aproape 1 an",
    other: "aproape {{count}} ani",
  },
};

const formatDistance$G = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$k[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ã®n " + result;
    } else {
      return result + " Ã®n urmÄ";
    }
  }

  return result;
};
formatDistance$H.formatDistance = formatDistance$G;

var formatLong$k = {};

formatLong$k.formatLong = void 0;
var _index$5e = buildFormatLongFn$1;

const dateFormats$k = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd.MM.yyyy",
};

const timeFormats$k = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$k = {
  full: "{{date}} 'la' {{time}}",
  long: "{{date}} 'la' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$k.formatLong = {
  date: (0, _index$5e.buildFormatLongFn)({
    formats: dateFormats$k,
    defaultWidth: "full",
  }),

  time: (0, _index$5e.buildFormatLongFn)({
    formats: timeFormats$k,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5e.buildFormatLongFn)({
    formats: dateTimeFormats$k,
    defaultWidth: "full",
  }),
});

var formatRelative$H = {};

formatRelative$H.formatRelative = void 0;

const formatRelativeLocale$k = {
  lastWeek: "eeee 'trecutÄ la' p",
  yesterday: "'ieri la' p",
  today: "'astÄzi la' p",
  tomorrow: "'mÃ¢ine la' p",
  nextWeek: "eeee 'viitoare la' p",
  other: "P",
};

const formatRelative$G = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$k[token];
formatRelative$H.formatRelative = formatRelative$G;

var localize$k = {};

localize$k.localize = void 0;
var _index$5d = buildLocalizeFn$1;

const eraValues$k = {
  narrow: ["Ã", "D"],
  abbreviated: ["Ã.d.C.", "D.C."],
  wide: ["Ãnainte de Cristos", "DupÄ Cristos"],
};

const quarterValues$k = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: [
    "primul trimestru",
    "al doilea trimestru",
    "al treilea trimestru",
    "al patrulea trimestru",
  ],
};

const monthValues$k = {
  narrow: ["I", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "ian",
    "feb",
    "mar",
    "apr",
    "mai",
    "iun",
    "iul",
    "aug",
    "sep",
    "oct",
    "noi",
    "dec",
  ],

  wide: [
    "ianuarie",
    "februarie",
    "martie",
    "aprilie",
    "mai",
    "iunie",
    "iulie",
    "august",
    "septembrie",
    "octombrie",
    "noiembrie",
    "decembrie",
  ],
};

const dayValues$k = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["du", "lu", "ma", "mi", "jo", "vi", "sÃ¢"],
  abbreviated: ["dum", "lun", "mar", "mie", "joi", "vin", "sÃ¢m"],
  wide: ["duminicÄ", "luni", "marÈi", "miercuri", "joi", "vineri", "sÃ¢mbÄtÄ"],
};

const dayPeriodValues$k = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "ami",
    morning: "dim",
    afternoon: "da",
    evening: "s",
    night: "n",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopÈii",
    noon: "amiazÄ",
    morning: "dimineaÈÄ",
    afternoon: "dupÄ-amiazÄ",
    evening: "searÄ",
    night: "noapte",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopÈii",
    noon: "amiazÄ",
    morning: "dimineaÈÄ",
    afternoon: "dupÄ-amiazÄ",
    evening: "searÄ",
    night: "noapte",
  },
};

const formattingDayPeriodValues$j = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "amiazÄ",
    morning: "dimineaÈÄ",
    afternoon: "dupÄ-amiazÄ",
    evening: "searÄ",
    night: "noapte",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopÈii",
    noon: "amiazÄ",
    morning: "dimineaÈÄ",
    afternoon: "dupÄ-amiazÄ",
    evening: "searÄ",
    night: "noapte",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopÈii",
    noon: "amiazÄ",
    morning: "dimineaÈÄ",
    afternoon: "dupÄ-amiazÄ",
    evening: "searÄ",
    night: "noapte",
  },
};

const ordinalNumber$k = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$k.localize = {
  ordinalNumber: ordinalNumber$k,

  era: (0, _index$5d.buildLocalizeFn)({
    values: eraValues$k,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$5d.buildLocalizeFn)({
    values: quarterValues$k,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$5d.buildLocalizeFn)({
    values: monthValues$k,
    defaultWidth: "wide",
  }),

  day: (0, _index$5d.buildLocalizeFn)({
    values: dayValues$k,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$5d.buildLocalizeFn)({
    values: dayPeriodValues$k,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$j,
    defaultFormattingWidth: "wide",
  }),
});

var match$k = {};

match$k.match = void 0;

var _index$5c = buildMatchFn$1;
var _index2$2c = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$k = /^(\d+)?/i;
const parseOrdinalNumberPattern$k = /\d+/i;

const matchEraPatterns$k = {
  narrow: /^(Ã|D)/i,
  abbreviated:
    /^(Ã\.?\s?d\.?\s?C\.?|Ã\.?\s?e\.?\s?n\.?|D\.?\s?C\.?|e\.?\s?n\.?)/i,
  wide: /^(Ãnainte de Cristos|Ãnaintea erei noastre|DupÄ Cristos|Era noastrÄ)/i,
};
const parseEraPatterns$k = {
  any: [/^ÃC/i, /^DC/i],
  wide: [
    /^(Ãnainte de Cristos|Ãnaintea erei noastre)/i,
    /^(DupÄ Cristos|Era noastrÄ)/i,
  ],
};

const matchQuarterPatterns$k = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^trimestrul [1234]/i,
};
const parseQuarterPatterns$k = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$k = {
  narrow: /^[ifmaasond]/i,
  abbreviated: /^(ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|noi|dec)/i,
  wide: /^(ianuarie|februarie|martie|aprilie|mai|iunie|iulie|august|septembrie|octombrie|noiembrie|decembrie)/i,
};
const parseMonthPatterns$k = {
  narrow: [
    /^i/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ia/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^iun/i,
    /^iul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$k = {
  narrow: /^[dlmjvs]/i,
  short: /^(d|l|ma|mi|j|v|s)/i,
  abbreviated: /^(dum|lun|mar|mie|jo|vi|sÃ¢)/i,
  wide: /^(duminica|luni|marÅ£i|miercuri|joi|vineri|sÃ¢mbÄtÄ)/i,
};
const parseDayPatterns$k = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^mi/i, /^j/i, /^v/i, /^s/i],
};

const matchDayPeriodPatterns$k = {
  narrow: /^(a|p|mn|a|(dimineaÅ£a|dupÄ-amiaza|seara|noaptea))/i,
  any: /^([ap]\.?\s?m\.?|miezul nopÈii|amiaza|(dimineaÅ£a|dupÄ-amiaza|seara|noaptea))/i,
};
const parseDayPeriodPatterns$k = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /amiaza/i,
    morning: /dimineaÅ£a/i,
    afternoon: /dupÄ-amiaza/i,
    evening: /seara/i,
    night: /noaptea/i,
  },
};

(match$k.match = {
  ordinalNumber: (0, _index2$2c.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$k,
    parsePattern: parseOrdinalNumberPattern$k,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$5c.buildMatchFn)({
    matchPatterns: matchEraPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$k,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$5c.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$k,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$5c.buildMatchFn)({
    matchPatterns: matchMonthPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$k,
    defaultParseWidth: "any",
  }),

  day: (0, _index$5c.buildMatchFn)({
    matchPatterns: matchDayPatterns$k,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$k,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$5c.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$k,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$k,
    defaultParseWidth: "any",
  }),
});

ro.ro = void 0;
var _index$5b = formatDistance$H;
var _index2$2b = formatLong$k;
var _index3$16 = formatRelative$H;
var _index4$C = localize$k;
var _index5$t = match$k;

/**
 * @category Locales
 * @summary Romanian locale.
 * @language Romanian
 * @iso-639-2 ron
 * @author Sergiu Munteanu [@jsergiu](https://github.com/jsergiu)
 * @author Adrian Ocneanu [@aocneanu](https://github.com/aocneanu)
 * @author Mihai Ocneanu [@gandesc](https://github.com/gandesc)
 */
(ro.ro = {
  code: "ro",
  formatDistance: _index$5b.formatDistance,
  formatLong: _index2$2b.formatLong,
  formatRelative: _index3$16.formatRelative,
  localize: _index4$C.localize,
  match: _index5$t.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var ru = {};

var formatDistance$F = {};

formatDistance$F.formatDistance = void 0;

function declension$2(scheme, count) {
  // scheme for count=1 exists
  if (scheme.one !== undefined && count === 1) {
    return scheme.one;
  }

  const rem10 = count % 10;
  const rem100 = count % 100;

  // 1, 21, 31, ...
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count));

    // 2, 3, 4, 22, 23, 24, 32 ...
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count));

    // 5, 6, 7, 8, 9, 10, 11, ...
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count));
  }
}

function buildLocalizeTokenFn$1(scheme) {
  return (count, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension$2(scheme.future, count);
        } else {
          return "ÑÐµÑÐµÐ· " + declension$2(scheme.regular, count);
        }
      } else {
        if (scheme.past) {
          return declension$2(scheme.past, count);
        } else {
          return declension$2(scheme.regular, count) + " Ð½Ð°Ð·Ð°Ð´";
        }
      }
    } else {
      return declension$2(scheme.regular, count);
    }
  };
}

const formatDistanceLocale$j = {
  lessThanXSeconds: buildLocalizeTokenFn$1({
    regular: {
      one: "Ð¼ÐµÐ½ÑÑÐµ ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½ÑÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½ÑÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´",
      pluralGenitive: "Ð¼ÐµÐ½ÑÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´",
    },
    future: {
      one: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  xSeconds: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ð°",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
    },
    past: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ Ð½Ð°Ð·Ð°Ð´",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ Ð½Ð°Ð·Ð°Ð´",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ Ð½Ð°Ð·Ð°Ð´",
    },
    future: {
      singularNominative: "ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      pluralGenitive: "ÑÐµÑÐµÐ· {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  halfAMinute: (_count, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "ÑÐµÑÐµÐ· Ð¿Ð¾Ð»Ð¼Ð¸Ð½ÑÑÑ";
      } else {
        return "Ð¿Ð¾Ð»Ð¼Ð¸Ð½ÑÑÑ Ð½Ð°Ð·Ð°Ð´";
      }
    }

    return "Ð¿Ð¾Ð»Ð¼Ð¸Ð½ÑÑÑ";
  },

  lessThanXMinutes: buildLocalizeTokenFn$1({
    regular: {
      one: "Ð¼ÐµÐ½ÑÑÐµ Ð¼Ð¸Ð½ÑÑÑ",
      singularNominative: "Ð¼ÐµÐ½ÑÑÐµ {{count}} Ð¼Ð¸Ð½ÑÑÑ",
      singularGenitive: "Ð¼ÐµÐ½ÑÑÐµ {{count}} Ð¼Ð¸Ð½ÑÑ",
      pluralGenitive: "Ð¼ÐµÐ½ÑÑÐµ {{count}} Ð¼Ð¸Ð½ÑÑ",
    },
    future: {
      one: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· Ð¼Ð¸Ð½ÑÑÑ",
      singularNominative: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑÑ",
      singularGenitive: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑÑ",
      pluralGenitive: "Ð¼ÐµÐ½ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑ",
    },
  }),

  xMinutes: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑÐ°",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑ",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ",
    },
    past: {
      singularNominative: "{{count}} Ð¼Ð¸Ð½ÑÑÑ Ð½Ð°Ð·Ð°Ð´",
      singularGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑÑ Ð½Ð°Ð·Ð°Ð´",
      pluralGenitive: "{{count}} Ð¼Ð¸Ð½ÑÑ Ð½Ð°Ð·Ð°Ð´",
    },
    future: {
      singularNominative: "ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑÑ",
      singularGenitive: "ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑÑ",
      pluralGenitive: "ÑÐµÑÐµÐ· {{count}} Ð¼Ð¸Ð½ÑÑ",
    },
  }),

  aboutXHours: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} ÑÐ°ÑÐ°",
      singularGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} ÑÐ°ÑÐ¾Ð²",
      pluralGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} ÑÐ°ÑÐ¾Ð²",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} ÑÐ°Ñ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} ÑÐ°ÑÐ°",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} ÑÐ°ÑÐ¾Ð²",
    },
  }),

  xHours: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} ÑÐ°Ñ",
      singularGenitive: "{{count}} ÑÐ°ÑÐ°",
      pluralGenitive: "{{count}} ÑÐ°ÑÐ¾Ð²",
    },
  }),

  xDays: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} Ð´ÐµÐ½Ñ",
      singularGenitive: "{{count}} Ð´Ð½Ñ",
      pluralGenitive: "{{count}} Ð´Ð½ÐµÐ¹",
    },
  }),

  aboutXWeeks: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð½ÐµÐ´ÐµÐ»Ð¸",
      singularGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
      pluralGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð½ÐµÐ´ÐµÐ»Ð¸",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
    },
  }),

  xWeeks: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
      singularGenitive: "{{count}} Ð½ÐµÐ´ÐµÐ»Ð¸",
      pluralGenitive: "{{count}} Ð½ÐµÐ´ÐµÐ»Ñ",
    },
  }),

  aboutXMonths: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð¼ÐµÑÑÑÐ°",
      singularGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð¼ÐµÑÑÑÐµÐ²",
      pluralGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð¼ÐµÑÑÑÐµÐ²",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð¼ÐµÑÑÑÐ°",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð¼ÐµÑÑÑÐµÐ²",
    },
  }),

  xMonths: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} Ð¼ÐµÑÑÑ",
      singularGenitive: "{{count}} Ð¼ÐµÑÑÑÐ°",
      pluralGenitive: "{{count}} Ð¼ÐµÑÑÑÐµÐ²",
    },
  }),

  aboutXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð³Ð¾Ð´Ð°",
      singularGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð»ÐµÑ",
      pluralGenitive: "Ð¾ÐºÐ¾Ð»Ð¾ {{count}} Ð»ÐµÑ",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´Ð°",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐµÑÐµÐ· {{count}} Ð»ÐµÑ",
    },
  }),

  xYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "{{count}} Ð³Ð¾Ð´",
      singularGenitive: "{{count}} Ð³Ð¾Ð´Ð°",
      pluralGenitive: "{{count}} Ð»ÐµÑ",
    },
  }),

  overXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð±Ð¾Ð»ÑÑÐµ {{count}} Ð³Ð¾Ð´Ð°",
      singularGenitive: "Ð±Ð¾Ð»ÑÑÐµ {{count}} Ð»ÐµÑ",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑÐµ {{count}} Ð»ÐµÑ",
    },
    future: {
      singularNominative: "Ð±Ð¾Ð»ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð±Ð¾Ð»ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´Ð°",
      pluralGenitive: "Ð±Ð¾Ð»ÑÑÐµ, ÑÐµÐ¼ ÑÐµÑÐµÐ· {{count}} Ð»ÐµÑ",
    },
  }),

  almostXYears: buildLocalizeTokenFn$1({
    regular: {
      singularNominative: "Ð¿Ð¾ÑÑÐ¸ {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð¿Ð¾ÑÑÐ¸ {{count}} Ð³Ð¾Ð´Ð°",
      pluralGenitive: "Ð¿Ð¾ÑÑÐ¸ {{count}} Ð»ÐµÑ",
    },
    future: {
      singularNominative: "Ð¿Ð¾ÑÑÐ¸ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´",
      singularGenitive: "Ð¿Ð¾ÑÑÐ¸ ÑÐµÑÐµÐ· {{count}} Ð³Ð¾Ð´Ð°",
      pluralGenitive: "Ð¿Ð¾ÑÑÐ¸ ÑÐµÑÐµÐ· {{count}} Ð»ÐµÑ",
    },
  }),
};

const formatDistance$E = (token, count, options) => {
  return formatDistanceLocale$j[token](count, options);
};
formatDistance$F.formatDistance = formatDistance$E;

var formatLong$j = {};

formatLong$j.formatLong = void 0;
var _index$5a = buildFormatLongFn$1;

const dateFormats$j = {
  full: "EEEE, d MMMM y 'Ð³.'",
  long: "d MMMM y 'Ð³.'",
  medium: "d MMM y 'Ð³.'",
  short: "dd.MM.y",
};

const timeFormats$j = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$j = {
  any: "{{date}}, {{time}}",
};

(formatLong$j.formatLong = {
  date: (0, _index$5a.buildFormatLongFn)({
    formats: dateFormats$j,
    defaultWidth: "full",
  }),

  time: (0, _index$5a.buildFormatLongFn)({
    formats: timeFormats$j,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$5a.buildFormatLongFn)({
    formats: dateTimeFormats$j,
    defaultWidth: "any",
  }),
});

var formatRelative$F = {};

formatRelative$F.formatRelative = void 0;
var _index$59 = isSameWeek$1;

const accusativeWeekdays$2 = [
  "Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ",
  "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº",
  "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
  "ÑÑÐµÐ´Ñ",
  "ÑÐµÑÐ²ÐµÑÐ³",
  "Ð¿ÑÑÐ½Ð¸ÑÑ",
  "ÑÑÐ±Ð±Ð¾ÑÑ",
];

function lastWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];

  switch (day) {
    case 0:
      return "'Ð² Ð¿ÑÐ¾ÑÐ»Ð¾Ðµ " + weekday + " Ð²' p";
    case 1:
    case 2:
    case 4:
      return "'Ð² Ð¿ÑÐ¾ÑÐ»ÑÐ¹ " + weekday + " Ð²' p";
    case 3:
    case 5:
    case 6:
      return "'Ð² Ð¿ÑÐ¾ÑÐ»ÑÑ " + weekday + " Ð²' p";
  }
}

function thisWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];

  if (day === 2 /* Tue */) {
    return "'Ð²Ð¾ " + weekday + " Ð²' p";
  } else {
    return "'Ð² " + weekday + " Ð²' p";
  }
}

function nextWeek$2(day) {
  const weekday = accusativeWeekdays$2[day];

  switch (day) {
    case 0:
      return "'Ð² ÑÐ»ÐµÐ´ÑÑÑÐµÐµ " + weekday + " Ð²' p";
    case 1:
    case 2:
    case 4:
      return "'Ð² ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¹ " + weekday + " Ð²' p";
    case 3:
    case 5:
    case 6:
      return "'Ð² ÑÐ»ÐµÐ´ÑÑÑÑÑ " + weekday + " Ð²' p";
  }
}

const formatRelativeLocale$j = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$59.isSameWeek)(date, baseDate, options)) {
      return thisWeek$2(day);
    } else {
      return lastWeek$2(day);
    }
  },
  yesterday: "'Ð²ÑÐµÑÐ° Ð²' p",
  today: "'ÑÐµÐ³Ð¾Ð´Ð½Ñ Ð²' p",
  tomorrow: "'Ð·Ð°Ð²ÑÑÐ° Ð²' p",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$59.isSameWeek)(date, baseDate, options)) {
      return thisWeek$2(day);
    } else {
      return nextWeek$2(day);
    }
  },
  other: "P",
};

const formatRelative$E = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$j[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$F.formatRelative = formatRelative$E;

var localize$j = {};

localize$j.localize = void 0;
var _index$58 = buildLocalizeFn$1;

const eraValues$j = {
  narrow: ["Ð´Ð¾ Ð½.Ñ.", "Ð½.Ñ."],
  abbreviated: ["Ð´Ð¾ Ð½. Ñ.", "Ð½. Ñ."],
  wide: ["Ð´Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÑÑ", "Ð½Ð°ÑÐµÐ¹ ÑÑÑ"],
};

const quarterValues$j = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ð¹ ÐºÐ².", "2-Ð¹ ÐºÐ².", "3-Ð¹ ÐºÐ².", "4-Ð¹ ÐºÐ²."],
  wide: ["1-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "2-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "3-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "4-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$j = {
  narrow: ["Ð¯", "Ð¤", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡", "Ð", "Ð", "Ð"],
  abbreviated: [
    "ÑÐ½Ð².",
    "ÑÐµÐ².",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿Ñ.",
    "Ð¼Ð°Ð¹",
    "Ð¸ÑÐ½Ñ",
    "Ð¸ÑÐ»Ñ",
    "Ð°Ð²Ð³.",
    "ÑÐµÐ½Ñ.",
    "Ð¾ÐºÑ.",
    "Ð½Ð¾ÑÐ±.",
    "Ð´ÐµÐº.",
  ],

  wide: [
    "ÑÐ½Ð²Ð°ÑÑ",
    "ÑÐµÐ²ÑÐ°Ð»Ñ",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐµÐ»Ñ",
    "Ð¼Ð°Ð¹",
    "Ð¸ÑÐ½Ñ",
    "Ð¸ÑÐ»Ñ",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ½ÑÑÐ±ÑÑ",
    "Ð¾ÐºÑÑÐ±ÑÑ",
    "Ð½Ð¾ÑÐ±ÑÑ",
    "Ð´ÐµÐºÐ°Ð±ÑÑ",
  ],
};

const formattingMonthValues$5 = {
  narrow: ["Ð¯", "Ð¤", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡", "Ð", "Ð", "Ð"],
  abbreviated: [
    "ÑÐ½Ð².",
    "ÑÐµÐ².",
    "Ð¼Ð°Ñ.",
    "Ð°Ð¿Ñ.",
    "Ð¼Ð°Ñ",
    "Ð¸ÑÐ½.",
    "Ð¸ÑÐ».",
    "Ð°Ð²Ð³.",
    "ÑÐµÐ½Ñ.",
    "Ð¾ÐºÑ.",
    "Ð½Ð¾ÑÐ±.",
    "Ð´ÐµÐº.",
  ],

  wide: [
    "ÑÐ½Ð²Ð°ÑÑ",
    "ÑÐµÐ²ÑÐ°Ð»Ñ",
    "Ð¼Ð°ÑÑÐ°",
    "Ð°Ð¿ÑÐµÐ»Ñ",
    "Ð¼Ð°Ñ",
    "Ð¸ÑÐ½Ñ",
    "Ð¸ÑÐ»Ñ",
    "Ð°Ð²Ð³ÑÑÑÐ°",
    "ÑÐµÐ½ÑÑÐ±ÑÑ",
    "Ð¾ÐºÑÑÐ±ÑÑ",
    "Ð½Ð¾ÑÐ±ÑÑ",
    "Ð´ÐµÐºÐ°Ð±ÑÑ",
  ],
};

const dayValues$j = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð²Ñ", "Ð¿Ð½", "Ð²Ñ", "ÑÑ", "ÑÑ", "Ð¿Ñ", "ÑÐ±"],
  abbreviated: ["Ð²ÑÐº", "Ð¿Ð½Ð´", "Ð²ÑÑ", "ÑÑÐ´", "ÑÑÐ²", "Ð¿ÑÐ½", "ÑÑÐ±"],
  wide: [
    "Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ",
    "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº",
    "Ð²ÑÐ¾ÑÐ½Ð¸Ðº",
    "ÑÑÐµÐ´Ð°",
    "ÑÐµÑÐ²ÐµÑÐ³",
    "Ð¿ÑÑÐ½Ð¸ÑÐ°",
    "ÑÑÐ±Ð±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$j = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½.",
    noon: "Ð¿Ð¾Ð»Ð´.",
    morning: "ÑÑÑÐ¾",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½.",
    noon: "Ð¿Ð¾Ð»Ð´.",
    morning: "ÑÑÑÐ¾",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½Ð¾ÑÑ",
    noon: "Ð¿Ð¾Ð»Ð´ÐµÐ½Ñ",
    morning: "ÑÑÑÐ¾",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑÐµÑ",
    night: "Ð½Ð¾ÑÑ",
  },
};

const formattingDayPeriodValues$i = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½.",
    noon: "Ð¿Ð¾Ð»Ð´.",
    morning: "ÑÑÑÐ°",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÐ¸",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½.",
    noon: "Ð¿Ð¾Ð»Ð´.",
    morning: "ÑÑÑÐ°",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÐ¸",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð»Ð½Ð¾ÑÑ",
    noon: "Ð¿Ð¾Ð»Ð´ÐµÐ½Ñ",
    morning: "ÑÑÑÐ°",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑÐµÑÐ°",
    night: "Ð½Ð¾ÑÐ¸",
  },
};

const ordinalNumber$j = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;

  let suffix;
  if (unit === "date") {
    suffix = "-Ðµ";
  } else if (unit === "week" || unit === "minute" || unit === "second") {
    suffix = "-Ñ";
  } else {
    suffix = "-Ð¹";
  }

  return number + suffix;
};

(localize$j.localize = {
  ordinalNumber: ordinalNumber$j,

  era: (0, _index$58.buildLocalizeFn)({
    values: eraValues$j,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$58.buildLocalizeFn)({
    values: quarterValues$j,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$58.buildLocalizeFn)({
    values: monthValues$j,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$5,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$58.buildLocalizeFn)({
    values: dayValues$j,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$58.buildLocalizeFn)({
    values: dayPeriodValues$j,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$i,
    defaultFormattingWidth: "wide",
  }),
});

var match$j = {};

match$j.match = void 0;

var _index$57 = buildMatchFn$1;
var _index2$2a = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$j = /^(\d+)(-?(Ðµ|Ñ|Ð¹|Ð¾Ðµ|ÑÐµ|Ð°Ñ|ÑÑ|ÑÐ¹|Ð¾Ð¹|Ð¸Ð¹|ÑÐ¹))?/i;
const parseOrdinalNumberPattern$j = /\d+/i;

const matchEraPatterns$j = {
  narrow: /^((Ð´Ð¾ )?Ð½\.?\s?Ñ\.?)/i,
  abbreviated: /^((Ð´Ð¾ )?Ð½\.?\s?Ñ\.?)/i,
  wide: /^(Ð´Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÑÑ|Ð½Ð°ÑÐµÐ¹ ÑÑÑ|Ð½Ð°ÑÐ° ÑÑÐ°)/i,
};
const parseEraPatterns$j = {
  any: [/^Ð´/i, /^Ð½/i],
};

const matchQuarterPatterns$j = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ÑÐ¾Ð¸]?Ð¹?)? ÐºÐ².?/i,
  wide: /^[1234](-?[ÑÐ¾Ð¸]?Ð¹?)? ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};

const parseQuarterPatterns$j = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$j = {
  narrow: /^[ÑÑÐ¼Ð°Ð¸ÑÐ¾Ð½Ð´]/i,
  abbreviated:
    /^(ÑÐ½Ð²|ÑÐµÐ²|Ð¼Ð°ÑÑ?|Ð°Ð¿Ñ|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑÐ½[ÑÑ]?|Ð¸ÑÐ»[ÑÑ]?|Ð°Ð²Ð³|ÑÐµÐ½Ñ?|Ð¾ÐºÑ|Ð½Ð¾ÑÐ±?|Ð´ÐµÐº)\.?/i,
  wide: /^(ÑÐ½Ð²Ð°Ñ[ÑÑ]|ÑÐµÐ²ÑÐ°Ð»[ÑÑ]|Ð¼Ð°ÑÑÐ°?|Ð°Ð¿ÑÐµÐ»[ÑÑ]|Ð¼Ð°[Ð¹Ñ]|Ð¸ÑÐ½[ÑÑ]|Ð¸ÑÐ»[ÑÑ]|Ð°Ð²Ð³ÑÑÑÐ°?|ÑÐµÐ½ÑÑÐ±Ñ[ÑÑ]|Ð¾ÐºÑÑÐ±Ñ[ÑÑ]|Ð¾ÐºÑÑÐ±Ñ[ÑÑ]|Ð½Ð¾ÑÐ±Ñ[ÑÑ]|Ð´ÐµÐºÐ°Ð±Ñ[ÑÑ])/i,
};

const parseMonthPatterns$j = {
  narrow: [
    /^Ñ/i,
    /^Ñ/i,
    /^Ð¼/i,
    /^Ð°/i,
    /^Ð¼/i,
    /^Ð¸/i,
    /^Ð¸/i,
    /^Ð°/i,
    /^Ñ/i,
    /^Ð¾/i,
    /^Ð½/i,
    /^Ñ/i,
  ],

  any: [
    /^Ñ/i,
    /^Ñ/i,
    /^Ð¼Ð°Ñ/i,
    /^Ð°Ð¿/i,
    /^Ð¼Ð°[Ð¹Ñ]/i,
    /^Ð¸ÑÐ½/i,
    /^Ð¸ÑÐ»/i,
    /^Ð°Ð²/i,
    /^Ñ/i,
    /^Ð¾/i,
    /^Ð½/i,
    /^Ð´/i,
  ],
};

const matchDayPatterns$j = {
  narrow: /^[Ð²Ð¿ÑÑ]/i,
  short: /^(Ð²Ñ|Ð²Ð¾|Ð¿Ð½|Ð¿Ð¾|Ð²Ñ|ÑÑ|ÑÑ|ÑÐµ|Ð¿Ñ|Ð¿Ñ|ÑÐ±|ÑÑ)\.?/i,
  abbreviated: /^(Ð²ÑÐº|Ð²Ð¾Ñ|Ð¿Ð½Ð´|Ð¿Ð¾Ð½|Ð²ÑÑ|Ð²ÑÐ¾|ÑÑÐ´|ÑÑÐµ|ÑÑÐ²|ÑÐµÑ|Ð¿ÑÐ½|Ð¿ÑÑ|ÑÑÐ±).?/i,
  wide: /^(Ð²Ð¾ÑÐºÑÐµÑÐµÐ½Ñ[ÐµÑ]|Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸ÐºÐ°?|Ð²ÑÐ¾ÑÐ½Ð¸ÐºÐ°?|ÑÑÐµÐ´[Ð°Ñ]|ÑÐµÑÐ²ÐµÑÐ³Ð°?|Ð¿ÑÑÐ½Ð¸Ñ[Ð°Ñ]|ÑÑÐ±Ð±Ð¾Ñ[Ð°Ñ])/i,
};

const parseDayPatterns$j = {
  narrow: [/^Ð²/i, /^Ð¿/i, /^Ð²/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð²[Ð¾Ñ]/i, /^Ð¿[Ð¾Ð½]/i, /^Ð²/i, /^ÑÑ/i, /^Ñ/i, /^Ð¿[ÑÑ]/i, /^Ñ[ÑÐ±]/i],
};

const matchDayPeriodPatterns$j = {
  narrow: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾Ð»Ð½\.?|Ð¿Ð¾Ð»Ð´\.?|ÑÑÑ[Ð¾Ð°]|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾Ñ[ÑÐ¸])/i,
  abbreviated: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾Ð»Ð½\.?|Ð¿Ð¾Ð»Ð´\.?|ÑÑÑ[Ð¾Ð°]|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½Ð¾Ñ[ÑÐ¸])/i,
  wide: /^([Ð´Ð¿]Ð¿|Ð¿Ð¾Ð»Ð½Ð¾ÑÑ|Ð¿Ð¾Ð»Ð´ÐµÐ½Ñ|ÑÑÑ[Ð¾Ð°]|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑÐµÑÐ°?|Ð½Ð¾Ñ[ÑÐ¸])/i,
};

const parseDayPeriodPatterns$j = {
  any: {
    am: /^Ð´Ð¿/i,
    pm: /^Ð¿Ð¿/i,
    midnight: /^Ð¿Ð¾Ð»Ð½/i,
    noon: /^Ð¿Ð¾Ð»Ð´/i,
    morning: /^Ñ/i,
    afternoon: /^Ð´[ÐµÐ½]/i,
    evening: /^Ð²/i,
    night: /^Ð½/i,
  },
};

(match$j.match = {
  ordinalNumber: (0, _index2$2a.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$j,
    parsePattern: parseOrdinalNumberPattern$j,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$57.buildMatchFn)({
    matchPatterns: matchEraPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$j,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$57.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$j,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$57.buildMatchFn)({
    matchPatterns: matchMonthPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$j,
    defaultParseWidth: "any",
  }),

  day: (0, _index$57.buildMatchFn)({
    matchPatterns: matchDayPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$j,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$57.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$j,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$j,
    defaultParseWidth: "any",
  }),
});

ru.ru = void 0;
var _index$56 = formatDistance$F;
var _index2$29 = formatLong$j;
var _index3$15 = formatRelative$F;
var _index4$B = localize$j;
var _index5$s = match$j;

/**
 * @category Locales
 * @summary Russian locale.
 * @language Russian
 * @iso-639-2 rus
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */
(ru.ru = {
  code: "ru",
  formatDistance: _index$56.formatDistance,
  formatLong: _index2$29.formatLong,
  formatRelative: _index3$15.formatRelative,
  localize: _index4$B.localize,
  match: _index5$s.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var se = {};

var formatDistance$D = {};

formatDistance$D.formatDistance = void 0;

const formatDistanceLocale$i = {
  lessThanXSeconds: {
    one: "unnit go ovtta sekundda",
    other: "unnit go {{count}} sekundda",
  },

  xSeconds: {
    one: "sekundda",
    other: "{{count}} sekundda",
  },

  halfAMinute: "bealle minuhta",

  lessThanXMinutes: {
    one: "unnit go bealle minuhta",
    other: "unnit go {{count}} minuhta",
  },

  xMinutes: {
    one: "minuhta",
    other: "{{count}} minuhta",
  },

  aboutXHours: {
    one: "sullii ovtta diimmu",
    other: "sullii {{count}} diimmu",
  },

  xHours: {
    one: "diimmu",
    other: "{{count}} diimmu",
  },

  xDays: {
    one: "beaivvi",
    other: "{{count}} beaivvi",
  },

  aboutXWeeks: {
    one: "sullii ovtta vahku",
    other: "sullii {{count}} vahku",
  },

  xWeeks: {
    one: "vahku",
    other: "{{count}} vahku",
  },

  aboutXMonths: {
    one: "sullii ovtta mÃ¡nu",
    other: "sullii {{count}} mÃ¡nu",
  },

  xMonths: {
    one: "mÃ¡nu",
    other: "{{count}} mÃ¡nu",
  },

  aboutXYears: {
    one: "sullii ovtta jagi",
    other: "sullii {{count}} jagi",
  },

  xYears: {
    one: "jagi",
    other: "{{count}} jagi",
  },

  overXYears: {
    one: "guhkit go jagi",
    other: "guhkit go {{count}} jagi",
  },

  almostXYears: {
    one: "measta jagi",
    other: "measta {{count}} jagi",
  },
};

const formatDistance$C = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$i[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "geahÄen " + result;
    } else {
      return result + " Ã¡igi";
    }
  }

  return result;
};
formatDistance$D.formatDistance = formatDistance$C;

var formatLong$i = {};

formatLong$i.formatLong = void 0;
var _index$55 = buildFormatLongFn$1;

const dateFormats$i = {
  full: "EEEE MMMM d. 'b.' y",
  long: "MMMM d. 'b.' y",
  medium: "MMM d. 'b.' y",
  short: "dd.MM.y",
};

const timeFormats$i = {
  full: "'dii.' HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$i = {
  full: "{{date}} 'dii.' {{time}}",
  long: "{{date}} 'dii.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$i.formatLong = {
  date: (0, _index$55.buildFormatLongFn)({
    formats: dateFormats$i,
    defaultWidth: "full",
  }),

  time: (0, _index$55.buildFormatLongFn)({
    formats: timeFormats$i,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$55.buildFormatLongFn)({
    formats: dateTimeFormats$i,
    defaultWidth: "full",
  }),
});

var formatRelative$D = {};

formatRelative$D.formatRelative = void 0;

const formatRelativeLocale$i = {
  lastWeek: "'ovddit' eeee 'dii.' p",
  yesterday: "'ikte dii.' p",
  today: "'odne dii.' p",
  tomorrow: "'ihtin dii.' p",
  nextWeek: "EEEE 'dii.' p",
  other: "P",
};

const formatRelative$C = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$i[token];
formatRelative$D.formatRelative = formatRelative$C;

var localize$i = {};

localize$i.localize = void 0;
var _index$54 = buildLocalizeFn$1;

const eraValues$i = {
  narrow: ["o.Kr.", "m.Kr."],
  abbreviated: ["o.Kr.", "m.Kr."],
  wide: ["ovdal Kristusa", "maÅÅel Kristusa"],
};

const quarterValues$i = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartÃ¡la", "2. kvartÃ¡la", "3. kvartÃ¡la", "4. kvartÃ¡la"],
};

const monthValues$i = {
  narrow: ["O", "G", "N", "C", "M", "G", "S", "B", "Ä", "G", "S", "J"],
  abbreviated: [
    "oÄÄa",
    "guov",
    "njuk",
    "cuo",
    "mies",
    "geas",
    "suoi",
    "borg",
    "ÄakÄ",
    "golg",
    "skÃ¡b",
    "juov",
  ],

  wide: [
    "oÄÄajagemÃ¡nnu",
    "guovvamÃ¡nnu",
    "njukÄamÃ¡nnu",
    "cuoÅomÃ¡nnu",
    "miessemÃ¡nnu",
    "geassemÃ¡nnu",
    "suoidnemÃ¡nnu",
    "borgemÃ¡nnu",
    "ÄakÄamÃ¡nnu",
    "golggotmÃ¡nnu",
    "skÃ¡bmamÃ¡nnu",
    "juovlamÃ¡nnu",
  ],
};

const dayValues$i = {
  narrow: ["S", "V", "M", "G", "D", "B", "L"],
  short: ["sotn", "vuos", "maÅ", "gask", "duor", "bear", "lÃ¡v"],
  abbreviated: ["sotn", "vuos", "maÅ", "gask", "duor", "bear", "lÃ¡v"],
  wide: [
    "sotnabeaivi",
    "vuossÃ¡rga",
    "maÅÅebÃ¡rga",
    "gaskavahkku",
    "duorastat",
    "bearjadat",
    "lÃ¡vvardat",
  ],
};

const dayPeriodValues$i = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gaskaidja",
    noon: "gaskabeaivi",
    morning: "iÄÄes",
    afternoon: "maÅÅel gaska.",
    evening: "eahkes",
    night: "ihkku",
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeaivvi",
    morning: "iÄÄes",
    afternoon: "maÅÅel gaskabea.",
    evening: "eahkes",
    night: "ihkku",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeavvi",
    morning: "iÄÄes",
    afternoon: "maÅÅel gaskabeaivvi",
    evening: "eahkes",
    night: "ihkku",
  },
};

const ordinalNumber$i = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$i.localize = {
  ordinalNumber: ordinalNumber$i,

  era: (0, _index$54.buildLocalizeFn)({
    values: eraValues$i,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$54.buildLocalizeFn)({
    values: quarterValues$i,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$54.buildLocalizeFn)({
    values: monthValues$i,
    defaultWidth: "wide",
  }),

  day: (0, _index$54.buildLocalizeFn)({
    values: dayValues$i,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$54.buildLocalizeFn)({
    values: dayPeriodValues$i,
    defaultWidth: "wide",
  }),
});

var match$i = {};

match$i.match = void 0;

var _index$53 = buildMatchFn$1;
var _index2$28 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$i = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$i = /\d+/i;

const matchEraPatterns$i = {
  narrow: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  abbreviated: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  wide: /^(ovdal Kristusa|ovdal min Ã¡iggi|maÅÅel Kristusa|min Ã¡igi)/i,
};
const parseEraPatterns$i = {
  any: [/^o/i, /^m/i],
};

const matchQuarterPatterns$i = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartÃ¡la/i,
};
const parseQuarterPatterns$i = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$i = {
  narrow: /^[ogncmsbÄj]/i,
  abbreviated:
    /^(oÄÄa|guov|njuk|cuo|mies|geas|suoi|borg|ÄakÄ|golg|skÃ¡b|juov)\.?/i,
  wide: /^(oÄÄajagemÃ¡nnu|guovvamÃ¡nnu|njukÄamÃ¡nnu|cuoÅomÃ¡nnu|miessemÃ¡nnu|geassemÃ¡nnu|suoidnemÃ¡nnu|borgemÃ¡nnu|ÄakÄamÃ¡nnu|golggotmÃ¡nnu|skÃ¡bmamÃ¡nnu|juovlamÃ¡nnu)/i,
};
const parseMonthPatterns$i = {
  narrow: [
    /^o/i,
    /^g/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^g/i,
    /^s/i,
    /^b/i,
    /^Ä/i,
    /^g/i,
    /^s/i,
    /^j/i,
  ],

  any: [
    /^o/i,
    /^gu/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^ge/i,
    /^su/i,
    /^b/i,
    /^Ä/i,
    /^go/i,
    /^sk/i,
    /^j/i,
  ],
};

const matchDayPatterns$i = {
  narrow: /^[svmgdbl]/i,
  short: /^(sotn|vuos|maÅ|gask|duor|bear|lÃ¡v)/i,
  abbreviated: /^(sotn|vuos|maÅ|gask|duor|bear|lÃ¡v)/i,
  wide: /^(sotnabeaivi|vuossÃ¡rga|maÅÅebÃ¡rga|gaskavahkku|duorastat|bearjadat|lÃ¡vvardat)/i,
};
const parseDayPatterns$i = {
  any: [/^s/i, /^v/i, /^m/i, /^g/i, /^d/i, /^b/i, /^l/i],
};

const matchDayPeriodPatterns$i = {
  narrow:
    /^(gaskaidja|gaskabeaivvi|(pÃ¥) (iÄÄes|maÅÅel gaskabeaivvi|eahkes|ihkku)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|gaskaidja|gaskabeaivvi|(pÃ¥) (iÄÄes|maÅÅel gaskabeaivvi|eahkes|ihkku))/i,
};
const parseDayPeriodPatterns$i = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^gaskai/i,
    noon: /^gaskab/i,
    morning: /iÄÄes/i,
    afternoon: /maÅÅel gaskabeaivvi/i,
    evening: /eahkes/i,
    night: /ihkku/i,
  },
};

(match$i.match = {
  ordinalNumber: (0, _index2$28.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$i,
    parsePattern: parseOrdinalNumberPattern$i,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$53.buildMatchFn)({
    matchPatterns: matchEraPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$i,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$53.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$i,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$53.buildMatchFn)({
    matchPatterns: matchMonthPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$i,
    defaultParseWidth: "any",
  }),

  day: (0, _index$53.buildMatchFn)({
    matchPatterns: matchDayPatterns$i,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$i,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$53.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$i,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$i,
    defaultParseWidth: "any",
  }),
});

se.se = void 0;
var _index$52 = formatDistance$D;
var _index2$27 = formatLong$i;
var _index3$14 = formatRelative$D;
var _index4$A = localize$i;
var _index5$r = match$i;

/**
 * @category Locales
 * @summary Northern SÃ¡mi locale.
 * @language Northern SÃ¡mi
 * @iso-639-2 sme
 * @author Audun Rundberg [@audunru](https://github.com/audunru)
 */
(se.se = {
  code: "se",
  formatDistance: _index$52.formatDistance,
  formatLong: _index2$27.formatLong,
  formatRelative: _index3$14.formatRelative,
  localize: _index4$A.localize,
  match: _index5$r.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var sk = {};

var formatDistance$B = {};

formatDistance$B.formatDistance = void 0;

function declensionGroup(scheme, count) {
  if (count === 1 && scheme.one) {
    return scheme.one;
  }

  if (count >= 2 && count <= 4 && scheme.twoFour) {
    return scheme.twoFour;
  }

  // if count === null || count === 0 || count >= 5
  return scheme.other;
}

function declension$1(scheme, count, time) {
  const group = declensionGroup(scheme, count);
  const finalText = group[time];
  return finalText.replace("{{count}}", String(count));
}

function extractPreposition(token) {
  const result = ["lessThan", "about", "over", "almost"].filter(
    function (preposition) {
      return !!token.match(new RegExp("^" + preposition));
    },
  );

  return result[0];
}

function prefixPreposition(preposition) {
  let translation = "";

  if (preposition === "almost") {
    translation = "takmer";
  }

  if (preposition === "about") {
    translation = "pribliÅ¾ne";
  }

  return translation.length > 0 ? translation + " " : "";
}

function suffixPreposition(preposition) {
  let translation = "";

  if (preposition === "lessThan") {
    translation = "menej neÅ¾";
  }

  if (preposition === "over") {
    translation = "viac neÅ¾";
  }

  return translation.length > 0 ? translation + " " : "";
}

function lowercaseFirstLetter(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

const formatDistanceLocale$h = {
  xSeconds: {
    one: {
      present: "sekunda",
      past: "sekundou",
      future: "sekundu",
    },
    twoFour: {
      present: "{{count}} sekundy",
      past: "{{count}} sekundami",
      future: "{{count}} sekundy",
    },
    other: {
      present: "{{count}} sekÃºnd",
      past: "{{count}} sekundami",
      future: "{{count}} sekÃºnd",
    },
  },

  halfAMinute: {
    other: {
      present: "pol minÃºty",
      past: "pol minÃºtou",
      future: "pol minÃºty",
    },
  },

  xMinutes: {
    one: {
      present: "minÃºta",
      past: "minÃºtou",
      future: "minÃºtu",
    },
    twoFour: {
      present: "{{count}} minÃºty",
      past: "{{count}} minÃºtami",
      future: "{{count}} minÃºty",
    },
    other: {
      present: "{{count}} minÃºt",
      past: "{{count}} minÃºtami",
      future: "{{count}} minÃºt",
    },
  },

  xHours: {
    one: {
      present: "hodina",
      past: "hodinou",
      future: "hodinu",
    },
    twoFour: {
      present: "{{count}} hodiny",
      past: "{{count}} hodinami",
      future: "{{count}} hodiny",
    },
    other: {
      present: "{{count}} hodÃ­n",
      past: "{{count}} hodinami",
      future: "{{count}} hodÃ­n",
    },
  },

  xDays: {
    one: {
      present: "deÅ",
      past: "dÅom",
      future: "deÅ",
    },
    twoFour: {
      present: "{{count}} dni",
      past: "{{count}} dÅami",
      future: "{{count}} dni",
    },
    other: {
      present: "{{count}} dnÃ­",
      past: "{{count}} dÅami",
      future: "{{count}} dnÃ­",
    },
  },

  xWeeks: {
    one: {
      present: "tÃ½Å¾deÅ",
      past: "tÃ½Å¾dÅom",
      future: "tÃ½Å¾deÅ",
    },
    twoFour: {
      present: "{{count}} tÃ½Å¾dne",
      past: "{{count}} tÃ½Å¾dÅami",
      future: "{{count}} tÃ½Å¾dne",
    },
    other: {
      present: "{{count}} tÃ½Å¾dÅov",
      past: "{{count}} tÃ½Å¾dÅami",
      future: "{{count}} tÃ½Å¾dÅov",
    },
  },

  xMonths: {
    one: {
      present: "mesiac",
      past: "mesiacom",
      future: "mesiac",
    },
    twoFour: {
      present: "{{count}} mesiace",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiace",
    },
    other: {
      present: "{{count}} mesiacov",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiacov",
    },
  },

  xYears: {
    one: {
      present: "rok",
      past: "rokom",
      future: "rok",
    },
    twoFour: {
      present: "{{count}} roky",
      past: "{{count}} rokmi",
      future: "{{count}} roky",
    },
    other: {
      present: "{{count}} rokov",
      past: "{{count}} rokmi",
      future: "{{count}} rokov",
    },
  },
};

const formatDistance$A = (token, count, options) => {
  const preposition = extractPreposition(token) || "";
  const key = lowercaseFirstLetter(token.substring(preposition.length));
  const scheme = formatDistanceLocale$h[key];

  if (!options?.addSuffix) {
    return (
      prefixPreposition(preposition) +
      suffixPreposition(preposition) +
      declension$1(scheme, count, "present")
    );
  }

  if (options.comparison && options.comparison > 0) {
    return (
      prefixPreposition(preposition) +
      "o " +
      suffixPreposition(preposition) +
      declension$1(scheme, count, "future")
    );
  } else {
    return (
      prefixPreposition(preposition) +
      "pred " +
      suffixPreposition(preposition) +
      declension$1(scheme, count, "past")
    );
  }
};
formatDistance$B.formatDistance = formatDistance$A;

var formatLong$h = {};

formatLong$h.formatLong = void 0;
var _index$51 = buildFormatLongFn$1;

// https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#1986
const dateFormats$h = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. M. y",
  short: "d. M. y",
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#2149
const timeFormats$h = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#1994
const dateTimeFormats$h = {
  full: "{{date}}, {{time}}",
  long: "{{date}}, {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$h.formatLong = {
  date: (0, _index$51.buildFormatLongFn)({
    formats: dateFormats$h,
    defaultWidth: "full",
  }),

  time: (0, _index$51.buildFormatLongFn)({
    formats: timeFormats$h,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$51.buildFormatLongFn)({
    formats: dateTimeFormats$h,
    defaultWidth: "full",
  }),
});

var formatRelative$B = {};

formatRelative$B.formatRelative = void 0;
var _index$50 = isSameWeek$1;

// https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#1308
const accusativeWeekdays$1 = [
  "nedeÄ¾u",
  "pondelok",
  "utorok",
  "stredu",
  "Å¡tvrtok",
  "piatok",
  "sobotu",
];

function lastWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];

  switch (day) {
    case 0: /* Sun */
    case 3: /* Wed */
    case 6 /* Sat */:
      return "'minulÃº " + weekday + " o' p";
    default:
      return "'minulÃ½' eeee 'o' p";
  }
}

function thisWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];

  if (day === 4 /* Thu */) {
    return "'vo' eeee 'o' p";
  } else {
    return "'v " + weekday + " o' p";
  }
}

function nextWeek$1(day) {
  const weekday = accusativeWeekdays$1[day];

  switch (day) {
    case 0: /* Sun */
    case 4: /* Wed */
    case 6 /* Sat */:
      return "'budÃºcu " + weekday + " o' p";
    default:
      return "'budÃºci' eeee 'o' p";
  }
}

const formatRelativeLocale$h = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$50.isSameWeek)(date, baseDate, options)) {
      return thisWeek$1(day);
    } else {
      return lastWeek$1(day);
    }
  },
  yesterday: "'vÄera o' p",
  today: "'dnes o' p",
  tomorrow: "'zajtra o' p",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if ((0, _index$50.isSameWeek)(date, baseDate, options)) {
      return thisWeek$1(day);
    } else {
      return nextWeek$1(day);
    }
  },
  other: "P",
};

const formatRelative$A = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$h[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$B.formatRelative = formatRelative$A;

var localize$h = {};

localize$h.localize = void 0;
var _index$4$ = buildLocalizeFn$1;

// https://www.unicode.org/cldr/charts/32/summary/sk.html#1772
const eraValues$h = {
  narrow: ["pred Kr.", "po Kr."],
  abbreviated: ["pred Kr.", "po Kr."],
  wide: ["pred Kristom", "po Kristovi"],
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html#1780
const quarterValues$h = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Å¡tvrÅ¥rok", "2. Å¡tvrÅ¥rok", "3. Å¡tvrÅ¥rok", "4. Å¡tvrÅ¥rok"],
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html#1804
const monthValues$h = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "mÃ¡j",
    "jÃºn",
    "jÃºl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januÃ¡r",
    "februÃ¡r",
    "marec",
    "aprÃ­l",
    "mÃ¡j",
    "jÃºn",
    "jÃºl",
    "august",
    "september",
    "oktÃ³ber",
    "november",
    "december",
  ],
};
const formattingMonthValues$4 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "mÃ¡j",
    "jÃºn",
    "jÃºl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januÃ¡ra",
    "februÃ¡ra",
    "marca",
    "aprÃ­la",
    "mÃ¡ja",
    "jÃºna",
    "jÃºla",
    "augusta",
    "septembra",
    "oktÃ³bra",
    "novembra",
    "decembra",
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html#1876
const dayValues$h = {
  narrow: ["n", "p", "u", "s", "Å¡", "p", "s"],
  short: ["ne", "po", "ut", "st", "Å¡t", "pi", "so"],
  abbreviated: ["ne", "po", "ut", "st", "Å¡t", "pi", "so"],
  wide: [
    "nedeÄ¾a",
    "pondelok",
    "utorok",
    "streda",
    "Å¡tvrtok",
    "piatok",
    "sobota",
  ],
};

// https://www.unicode.org/cldr/charts/32/summary/sk.html#1932
const dayPeriodValues$h = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "rÃ¡no",
    afternoon: "pop.",
    evening: "veÄ.",
    night: "noc",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "rÃ¡no",
    afternoon: "popol.",
    evening: "veÄer",
    night: "noc",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "polnoc",
    noon: "poludnie",
    morning: "rÃ¡no",
    afternoon: "popoludnie",
    evening: "veÄer",
    night: "noc",
  },
};

const formattingDayPeriodValues$h = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "nap.",
    morning: "rÃ¡no",
    afternoon: "pop.",
    evening: "veÄ.",
    night: "v n.",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "napol.",
    morning: "rÃ¡no",
    afternoon: "popol.",
    evening: "veÄer",
    night: "v noci",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o polnoci",
    noon: "napoludnie",
    morning: "rÃ¡no",
    afternoon: "popoludnÃ­",
    evening: "veÄer",
    night: "v noci",
  },
};

const ordinalNumber$h = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$h.localize = {
  ordinalNumber: ordinalNumber$h,

  era: (0, _index$4$.buildLocalizeFn)({
    values: eraValues$h,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4$.buildLocalizeFn)({
    values: quarterValues$h,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4$.buildLocalizeFn)({
    values: monthValues$h,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$4,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$4$.buildLocalizeFn)({
    values: dayValues$h,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4$.buildLocalizeFn)({
    values: dayPeriodValues$h,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$h,
    defaultFormattingWidth: "wide",
  }),
});

var match$h = {};

match$h.match = void 0;

var _index$4_ = buildMatchFn$1;
var _index2$26 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$h = /^(\d+)\.?/i;
const parseOrdinalNumberPattern$h = /\d+/i;

const matchEraPatterns$h = {
  narrow: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(pred Kristom|pred na[Å¡s][Ã­i]m letopo[Äc]tom|po Kristovi|n[Ã¡a][Å¡s]ho letopo[Äc]tu)/i,
};
const parseEraPatterns$h = {
  any: [/^pr/i, /^(po|n)/i],
};

const matchQuarterPatterns$h = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\. [Å¡s]tvr[Å¥t]rok/i,
};
const parseQuarterPatterns$h = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$h = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|m[Ã¡a]j|j[Ãºu]n|j[Ãºu]l|aug|sep|okt|nov|dec)/i,
  wide: /^(janu[Ã¡a]ra?|febru[Ã¡a]ra?|(marec|marca)|apr[Ã­i]la?|m[Ã¡a]ja?|j[Ãºu]na?|j[Ãºu]la?|augusta?|(september|septembra)|(okt[Ã³o]ber|okt[Ã³o]bra)|(november|novembra)|(december|decembra))/i,
};
const parseMonthPatterns$h = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^m[Ã¡a]j/i,
    /^j[Ãºu]n/i,
    /^j[Ãºu]l/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$h = {
  narrow: /^[npusÅ¡p]/i,
  short: /^(ne|po|ut|st|Å¡t|pi|so)/i,
  abbreviated: /^(ne|po|ut|st|Å¡t|pi|so)/i,
  wide: /^(nede[Ä¾l]a|pondelok|utorok|streda|[Å¡s]tvrtok|piatok|sobota])/i,
};
const parseDayPatterns$h = {
  narrow: [/^n/i, /^p/i, /^u/i, /^s/i, /^Å¡/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^u/i, /^st/i, /^(Å¡t|stv)/i, /^pi/i, /^so/i],
};

const matchDayPeriodPatterns$h = {
  narrow:
    /^(am|pm|(o )?poln\.?|(nap\.?|pol\.?)|r[Ã¡a]no|pop\.?|ve[Äc]\.?|(v n\.?|noc))/i,
  abbreviated:
    /^(am|pm|(o )?poln\.?|(napol\.?|pol\.?)|r[Ã¡a]no|pop\.?|ve[Äc]er|(v )?noci?)/i,
  any: /^(am|pm|(o )?polnoci?|(na)?poludnie|r[Ã¡a]no|popoludn(ie|Ã­|i)|ve[Äc]er|(v )?noci?)/i,
};
const parseDayPeriodPatterns$h = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /poln/i,
    noon: /^(nap|(na)?pol(\.|u))/i,
    morning: /^r[Ã¡a]no/i,
    afternoon: /^pop/i,
    evening: /^ve[Äc]/i,
    night: /^(noc|v n\.)/i,
  },
};

(match$h.match = {
  ordinalNumber: (0, _index2$26.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$h,
    parsePattern: parseOrdinalNumberPattern$h,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4_.buildMatchFn)({
    matchPatterns: matchEraPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$h,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4_.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$h,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4_.buildMatchFn)({
    matchPatterns: matchMonthPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$h,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4_.buildMatchFn)({
    matchPatterns: matchDayPatterns$h,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$h,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4_.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$h,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$h,
    defaultParseWidth: "any",
  }),
});

sk.sk = void 0;
var _index$4Z = formatDistance$B;
var _index2$25 = formatLong$h;
var _index3$13 = formatRelative$B;
var _index4$z = localize$h;
var _index5$q = match$h;

/**
 * @category Locales
 * @summary Slovak locale.
 * @language Slovak
 * @iso-639-2 slk
 * @author Marek Suscak [@mareksuscak](https://github.com/mareksuscak)
 */
(sk.sk = {
  code: "sk",
  formatDistance: _index$4Z.formatDistance,
  formatLong: _index2$25.formatLong,
  formatRelative: _index3$13.formatRelative,
  localize: _index4$z.localize,
  match: _index5$q.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var sl = {};

var formatDistance$z = {};

formatDistance$z.formatDistance = void 0;

function isPluralType$1(val) {
  return val.one !== undefined;
}

const formatDistanceLocale$g = {
  lessThanXSeconds: {
    present: {
      one: "manj kot {{count}} sekunda",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund",
    },
    past: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundama",
      few: "manj kot {{count}} sekundami",
      other: "manj kot {{count}} sekundami",
    },
    future: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund",
    },
  },

  xSeconds: {
    present: {
      one: "{{count}} sekunda",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund",
    },
    past: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundama",
      few: "{{count}} sekundami",
      other: "{{count}} sekundami",
    },
    future: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund",
    },
  },

  halfAMinute: "pol minute",

  lessThanXMinutes: {
    present: {
      one: "manj kot {{count}} minuta",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut",
    },
    past: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minutama",
      few: "manj kot {{count}} minutami",
      other: "manj kot {{count}} minutami",
    },
    future: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut",
    },
  },

  xMinutes: {
    present: {
      one: "{{count}} minuta",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut",
    },
    past: {
      one: "{{count}} minuto",
      two: "{{count}} minutama",
      few: "{{count}} minutami",
      other: "{{count}} minutami",
    },
    future: {
      one: "{{count}} minuto",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut",
    },
  },

  aboutXHours: {
    present: {
      one: "pribliÅ¾no {{count}} ura",
      two: "pribliÅ¾no {{count}} uri",
      few: "pribliÅ¾no {{count}} ure",
      other: "pribliÅ¾no {{count}} ur",
    },
    past: {
      one: "pribliÅ¾no {{count}} uro",
      two: "pribliÅ¾no {{count}} urama",
      few: "pribliÅ¾no {{count}} urami",
      other: "pribliÅ¾no {{count}} urami",
    },
    future: {
      one: "pribliÅ¾no {{count}} uro",
      two: "pribliÅ¾no {{count}} uri",
      few: "pribliÅ¾no {{count}} ure",
      other: "pribliÅ¾no {{count}} ur",
    },
  },

  xHours: {
    present: {
      one: "{{count}} ura",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur",
    },
    past: {
      one: "{{count}} uro",
      two: "{{count}} urama",
      few: "{{count}} urami",
      other: "{{count}} urami",
    },
    future: {
      one: "{{count}} uro",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur",
    },
  },

  xDays: {
    present: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni",
    },
    past: {
      one: "{{count}} dnem",
      two: "{{count}} dnevoma",
      few: "{{count}} dnevi",
      other: "{{count}} dnevi",
    },
    future: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni",
    },
  },

  // no tenses for weeks?
  aboutXWeeks: {
    one: "pribliÅ¾no {{count}} teden",
    two: "pribliÅ¾no {{count}} tedna",
    few: "pribliÅ¾no {{count}} tedne",
    other: "pribliÅ¾no {{count}} tednov",
  },

  // no tenses for weeks?
  xWeeks: {
    one: "{{count}} teden",
    two: "{{count}} tedna",
    few: "{{count}} tedne",
    other: "{{count}} tednov",
  },

  aboutXMonths: {
    present: {
      one: "pribliÅ¾no {{count}} mesec",
      two: "pribliÅ¾no {{count}} meseca",
      few: "pribliÅ¾no {{count}} mesece",
      other: "pribliÅ¾no {{count}} mesecev",
    },
    past: {
      one: "pribliÅ¾no {{count}} mesecem",
      two: "pribliÅ¾no {{count}} mesecema",
      few: "pribliÅ¾no {{count}} meseci",
      other: "pribliÅ¾no {{count}} meseci",
    },
    future: {
      one: "pribliÅ¾no {{count}} mesec",
      two: "pribliÅ¾no {{count}} meseca",
      few: "pribliÅ¾no {{count}} mesece",
      other: "pribliÅ¾no {{count}} mesecev",
    },
  },

  xMonths: {
    present: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} meseci",
      other: "{{count}} mesecev",
    },
    past: {
      one: "{{count}} mesecem",
      two: "{{count}} mesecema",
      few: "{{count}} meseci",
      other: "{{count}} meseci",
    },
    future: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} mesece",
      other: "{{count}} mesecev",
    },
  },

  aboutXYears: {
    present: {
      one: "pribliÅ¾no {{count}} leto",
      two: "pribliÅ¾no {{count}} leti",
      few: "pribliÅ¾no {{count}} leta",
      other: "pribliÅ¾no {{count}} let",
    },
    past: {
      one: "pribliÅ¾no {{count}} letom",
      two: "pribliÅ¾no {{count}} letoma",
      few: "pribliÅ¾no {{count}} leti",
      other: "pribliÅ¾no {{count}} leti",
    },
    future: {
      one: "pribliÅ¾no {{count}} leto",
      two: "pribliÅ¾no {{count}} leti",
      few: "pribliÅ¾no {{count}} leta",
      other: "pribliÅ¾no {{count}} let",
    },
  },

  xYears: {
    present: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let",
    },
    past: {
      one: "{{count}} letom",
      two: "{{count}} letoma",
      few: "{{count}} leti",
      other: "{{count}} leti",
    },
    future: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let",
    },
  },

  overXYears: {
    present: {
      one: "veÄ kot {{count}} leto",
      two: "veÄ kot {{count}} leti",
      few: "veÄ kot {{count}} leta",
      other: "veÄ kot {{count}} let",
    },
    past: {
      one: "veÄ kot {{count}} letom",
      two: "veÄ kot {{count}} letoma",
      few: "veÄ kot {{count}} leti",
      other: "veÄ kot {{count}} leti",
    },
    future: {
      one: "veÄ kot {{count}} leto",
      two: "veÄ kot {{count}} leti",
      few: "veÄ kot {{count}} leta",
      other: "veÄ kot {{count}} let",
    },
  },

  almostXYears: {
    present: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let",
    },
    past: {
      one: "skoraj {{count}} letom",
      two: "skoraj {{count}} letoma",
      few: "skoraj {{count}} leti",
      other: "skoraj {{count}} leti",
    },
    future: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let",
    },
  },
};

function getFormFromCount(count) {
  switch (count % 100) {
    case 1:
      return "one";
    case 2:
      return "two";
    case 3:
    case 4:
      return "few";
    default:
      return "other";
  }
}

const formatDistance$y = (token, count, options) => {
  let result = "";
  let tense = "present";

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      tense = "future";
      result = "Äez ";
    } else {
      tense = "past";
      result = "pred ";
    }
  }

  const tokenValue = formatDistanceLocale$g[token];

  if (typeof tokenValue === "string") {
    result += tokenValue;
  } else {
    const form = getFormFromCount(count);
    if (isPluralType$1(tokenValue)) {
      result += tokenValue[form].replace("{{count}}", String(count));
    } else {
      result += tokenValue[tense][form].replace("{{count}}", String(count));
    }
  }

  return result;
};
formatDistance$z.formatDistance = formatDistance$y;

var formatLong$g = {};

formatLong$g.formatLong = void 0;
var _index$4Y = buildFormatLongFn$1;

const dateFormats$g = {
  full: "EEEE, dd. MMMM y",
  long: "dd. MMMM y",
  medium: "d. MMM y",
  short: "d. MM. yy",
};

const timeFormats$g = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$g = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$g.formatLong = {
  date: (0, _index$4Y.buildFormatLongFn)({
    formats: dateFormats$g,
    defaultWidth: "full",
  }),

  time: (0, _index$4Y.buildFormatLongFn)({
    formats: timeFormats$g,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4Y.buildFormatLongFn)({
    formats: dateTimeFormats$g,
    defaultWidth: "full",
  }),
});

var formatRelative$z = {};

formatRelative$z.formatRelative = void 0;

const formatRelativeLocale$g = {
  lastWeek: (date) => {
    const day = date.getDay();

    switch (day) {
      case 0:
        return "'prejÅ¡njo nedeljo ob' p";
      case 3:
        return "'prejÅ¡njo sredo ob' p";
      case 6:
        return "'prejÅ¡njo soboto ob' p";
      default:
        return "'prejÅ¡nji' EEEE 'ob' p";
    }
  },
  yesterday: "'vÄeraj ob' p",
  today: "'danes ob' p",
  tomorrow: "'jutri ob' p",
  nextWeek: (date) => {
    const day = date.getDay();

    switch (day) {
      case 0:
        return "'naslednjo nedeljo ob' p";
      case 3:
        return "'naslednjo sredo ob' p";
      case 6:
        return "'naslednjo soboto ob' p";
      default:
        return "'naslednji' EEEE 'ob' p";
    }
  },
  other: "P",
};

const formatRelative$y = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$g[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$z.formatRelative = formatRelative$y;

var localize$g = {};

localize$g.localize = void 0;
var _index$4X = buildLocalizeFn$1;

const eraValues$g = {
  narrow: ["pr. n. Å¡t.", "po n. Å¡t."],
  abbreviated: ["pr. n. Å¡t.", "po n. Å¡t."],
  wide: ["pred naÅ¡im Å¡tetjem", "po naÅ¡em Å¡tetju"],
};

const quarterValues$g = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. Äet.", "2. Äet.", "3. Äet.", "4. Äet."],
  wide: ["1. Äetrtletje", "2. Äetrtletje", "3. Äetrtletje", "4. Äetrtletje"],
};

const monthValues$g = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "avg.",
    "sep.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januar",
    "februar",
    "marec",
    "april",
    "maj",
    "junij",
    "julij",
    "avgust",
    "september",
    "oktober",
    "november",
    "december",
  ],
};

const dayValues$g = {
  narrow: ["n", "p", "t", "s", "Ä", "p", "s"],
  short: ["ned.", "pon.", "tor.", "sre.", "Äet.", "pet.", "sob."],
  abbreviated: ["ned.", "pon.", "tor.", "sre.", "Äet.", "pet.", "sob."],

  wide: [
    "nedelja",
    "ponedeljek",
    "torek",
    "sreda",
    "Äetrtek",
    "petek",
    "sobota",
  ],
};

const dayPeriodValues$g = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "j",
    afternoon: "p",
    evening: "v",
    night: "n",
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "poln.",
    noon: "pold.",
    morning: "jut.",
    afternoon: "pop.",
    evening: "veÄ.",
    night: "noÄ",
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "polnoÄ",
    noon: "poldne",
    morning: "jutro",
    afternoon: "popoldne",
    evening: "veÄer",
    night: "noÄ",
  },
};

const formattingDayPeriodValues$g = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "zj",
    afternoon: "p",
    evening: "zv",
    night: "po",
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "opoln.",
    noon: "opold.",
    morning: "zjut.",
    afternoon: "pop.",
    evening: "zveÄ.",
    night: "ponoÄi",
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "opolnoÄi",
    noon: "opoldne",
    morning: "zjutraj",
    afternoon: "popoldan",
    evening: "zveÄer",
    night: "ponoÄi",
  },
};

const ordinalNumber$g = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$g.localize = {
  ordinalNumber: ordinalNumber$g,

  era: (0, _index$4X.buildLocalizeFn)({
    values: eraValues$g,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4X.buildLocalizeFn)({
    values: quarterValues$g,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4X.buildLocalizeFn)({
    values: monthValues$g,
    defaultWidth: "wide",
  }),

  day: (0, _index$4X.buildLocalizeFn)({
    values: dayValues$g,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4X.buildLocalizeFn)({
    values: dayPeriodValues$g,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$g,
    defaultFormattingWidth: "wide",
  }),
});

var match$g = {};

match$g.match = void 0;

var _index$4W = buildMatchFn$1;
var _index2$24 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$g = /^(\d+)\./i;
const parseOrdinalNumberPattern$g = /\d+/i;

const matchEraPatterns$g = {
  abbreviated: /^(pr\. n\. Å¡t\.|po n\. Å¡t\.)/i,
  wide: /^(pred Kristusom|pred na[sÅ¡]im [sÅ¡]tetjem|po Kristusu|po na[sÅ¡]em [sÅ¡]tetju|na[sÅ¡]ega [sÅ¡]tetja)/i,
};
const parseEraPatterns$g = {
  any: [/^pr/i, /^(po|na[sÅ¡]em)/i],
};

const matchQuarterPatterns$g = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?[Äc]et\.?/i,
  wide: /^[1234]\. [Äc]etrtletje/i,
};
const parseQuarterPatterns$g = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$g = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(jan\.|feb\.|mar\.|apr\.|maj|jun\.|jul\.|avg\.|sep\.|okt\.|nov\.|dec\.)/i,
  wide: /^(januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)/i,
};
const parseMonthPatterns$g = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  abbreviated: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  wide: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$g = {
  narrow: /^[nptsÄc]/i,
  short: /^(ned\.|pon\.|tor\.|sre\.|[cÄ]et\.|pet\.|sob\.)/i,
  abbreviated: /^(ned\.|pon\.|tor\.|sre\.|[cÄ]et\.|pet\.|sob\.)/i,
  wide: /^(nedelja|ponedeljek|torek|sreda|[cÄ]etrtek|petek|sobota)/i,
};
const parseDayPatterns$g = {
  narrow: [/^n/i, /^p/i, /^t/i, /^s/i, /^[cÄ]/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^t/i, /^sr/i, /^[cÄ]/i, /^pe/i, /^so/i],
};

const matchDayPeriodPatterns$g = {
  narrow: /^(d|po?|z?v|n|z?j|24\.00|12\.00)/i,
  any: /^(dop\.|pop\.|o?poln(\.|o[cÄ]i?)|o?pold(\.|ne)|z?ve[cÄ](\.|er)|(po)?no[cÄ]i?|popold(ne|an)|jut(\.|ro)|zjut(\.|raj))/i,
};
const parseDayPeriodPatterns$g = {
  narrow: {
    am: /^d/i,
    pm: /^p/i,
    midnight: /^24/i,
    noon: /^12/i,
    morning: /^(z?j)/i,
    afternoon: /^p/i,
    evening: /^(z?v)/i,
    night: /^(n|po)/i,
  },
  any: {
    am: /^dop\./i,
    pm: /^pop\./i,
    midnight: /^o?poln/i,
    noon: /^o?pold/i,
    morning: /j/i,
    afternoon: /^pop\./i,
    evening: /^z?ve/i,
    night: /(po)?no/i,
  },
};

(match$g.match = {
  ordinalNumber: (0, _index2$24.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$g,
    parsePattern: parseOrdinalNumberPattern$g,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4W.buildMatchFn)({
    matchPatterns: matchEraPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$g,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4W.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$g,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4W.buildMatchFn)({
    matchPatterns: matchMonthPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$g,
    defaultParseWidth: "wide",
  }),

  day: (0, _index$4W.buildMatchFn)({
    matchPatterns: matchDayPatterns$g,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$g,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4W.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$g,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$g,
    defaultParseWidth: "any",
  }),
});

sl.sl = void 0;
var _index$4V = formatDistance$z;
var _index2$23 = formatLong$g;
var _index3$12 = formatRelative$z;
var _index4$y = localize$g;
var _index5$p = match$g;

/**
 * @category Locales
 * @summary Slovenian locale.
 * @language Slovenian
 * @iso-639-2 slv
 * @author Adam Stradovnik [@Neoglyph](https://github.com/Neoglyph)
 * @author Mato Å½gajner [@mzgajner](https://github.com/mzgajner)
 */
(sl.sl = {
  code: "sl",
  formatDistance: _index$4V.formatDistance,
  formatLong: _index2$23.formatLong,
  formatRelative: _index3$12.formatRelative,
  localize: _index4$y.localize,
  match: _index5$p.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var sq = {};

var formatDistance$x = {};

formatDistance$x.formatDistance = void 0;

const formatDistanceLocale$f = {
  lessThanXSeconds: {
    one: "mÃ« pak se njÃ« sekondÃ«",
    other: "mÃ« pak se {{count}} sekonda",
  },

  xSeconds: {
    one: "1 sekondÃ«",
    other: "{{count}} sekonda",
  },

  halfAMinute: "gjysÃ«m minuti",

  lessThanXMinutes: {
    one: "mÃ« pak se njÃ« minute",
    other: "mÃ« pak se {{count}} minuta",
  },

  xMinutes: {
    one: "1 minutÃ«",
    other: "{{count}} minuta",
  },

  aboutXHours: {
    one: "rreth 1 orÃ«",
    other: "rreth {{count}} orÃ«",
  },

  xHours: {
    one: "1 orÃ«",
    other: "{{count}} orÃ«",
  },

  xDays: {
    one: "1 ditÃ«",
    other: "{{count}} ditÃ«",
  },

  aboutXWeeks: {
    one: "rreth 1 javÃ«",
    other: "rreth {{count}} javÃ«",
  },

  xWeeks: {
    one: "1 javÃ«",
    other: "{{count}} javÃ«",
  },

  aboutXMonths: {
    one: "rreth 1 muaj",
    other: "rreth {{count}} muaj",
  },

  xMonths: {
    one: "1 muaj",
    other: "{{count}} muaj",
  },

  aboutXYears: {
    one: "rreth 1 vit",
    other: "rreth {{count}} vite",
  },

  xYears: {
    one: "1 vit",
    other: "{{count}} vite",
  },

  overXYears: {
    one: "mbi 1 vit",
    other: "mbi {{count}} vite",
  },

  almostXYears: {
    one: "pothuajse 1 vit",
    other: "pothuajse {{count}} vite",
  },
};

const formatDistance$w = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$f[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "nÃ« " + result;
    } else {
      return result + " mÃ« parÃ«";
    }
  }

  return result;
};
formatDistance$x.formatDistance = formatDistance$w;

var formatLong$f = {};

formatLong$f.formatLong = void 0;
var _index$4U = buildFormatLongFn$1;

const dateFormats$f = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$f = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$f = {
  full: "{{date}} 'nÃ«' {{time}}",
  long: "{{date}} 'nÃ«' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$f.formatLong = {
  date: (0, _index$4U.buildFormatLongFn)({
    formats: dateFormats$f,
    defaultWidth: "full",
  }),

  time: (0, _index$4U.buildFormatLongFn)({
    formats: timeFormats$f,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4U.buildFormatLongFn)({
    formats: dateTimeFormats$f,
    defaultWidth: "full",
  }),
});

var formatRelative$x = {};

formatRelative$x.formatRelative = void 0;

const formatRelativeLocale$f = {
  lastWeek: "'tÃ«' eeee 'e shkuar nÃ«' p",
  yesterday: "'dje nÃ«' p",
  today: "'sot nÃ«' p",
  tomorrow: "'nesÃ«r nÃ«' p",
  nextWeek: "eeee 'at' p",
  other: "P",
};

const formatRelative$w = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$f[token];
formatRelative$x.formatRelative = formatRelative$w;

var localize$f = {};

localize$f.localize = void 0;
var _index$4T = buildLocalizeFn$1;

const eraValues$f = {
  narrow: ["P", "M"],
  abbreviated: ["PK", "MK"],
  wide: ["Para Krishtit", "Mbas Krishtit"],
};

const quarterValues$f = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["4-mujori I", "4-mujori II", "4-mujori III", "4-mujori IV"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$f = {
  narrow: ["J", "S", "M", "P", "M", "Q", "K", "G", "S", "T", "N", "D"],
  abbreviated: [
    "Jan",
    "Shk",
    "Mar",
    "Pri",
    "Maj",
    "Qer",
    "Kor",
    "Gus",
    "Sht",
    "Tet",
    "NÃ«n",
    "Dhj",
  ],

  wide: [
    "Janar",
    "Shkurt",
    "Mars",
    "Prill",
    "Maj",
    "Qershor",
    "Korrik",
    "Gusht",
    "Shtator",
    "Tetor",
    "NÃ«ntor",
    "Dhjetor",
  ],
};

const dayValues$f = {
  narrow: ["D", "H", "M", "M", "E", "P", "S"],
  short: ["Di", "HÃ«", "Ma", "MÃ«", "En", "Pr", "Sh"],
  abbreviated: ["Die", "HÃ«n", "Mar", "MÃ«r", "Enj", "Pre", "Sht"],
  wide: ["DielÃ«", "HÃ«nÃ«", "MartÃ«", "MÃ«rkurÃ«", "Enjte", "Premte", "ShtunÃ«"],
};

const dayPeriodValues$f = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "mÃ«ngjes",
    afternoon: "dite",
    evening: "mbrÃ«mje",
    night: "natÃ«",
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnÃ«tÃ«",
    noon: "drek",
    morning: "mÃ«ngjes",
    afternoon: "mbasdite",
    evening: "mbrÃ«mje",
    night: "natÃ«",
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnÃ«tÃ«",
    noon: "drek",
    morning: "mÃ«ngjes",
    afternoon: "mbasdite",
    evening: "mbrÃ«mje",
    night: "natÃ«",
  },
};

const formattingDayPeriodValues$f = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "nÃ« mÃ«ngjes",
    afternoon: "nÃ« mbasdite",
    evening: "nÃ« mbrÃ«mje",
    night: "nÃ« mesnatÃ«",
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnatÃ«",
    noon: "drek",
    morning: "nÃ« mÃ«ngjes",
    afternoon: "nÃ« mbasdite",
    evening: "nÃ« mbrÃ«mje",
    night: "nÃ« mesnatÃ«",
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnatÃ«",
    noon: "drek",
    morning: "nÃ« mÃ«ngjes",
    afternoon: "nÃ« mbasdite",
    evening: "nÃ« mbrÃ«mje",
    night: "nÃ« mesnatÃ«",
  },
};

const ordinalNumber$f = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  if (options?.unit === "hour") return String(number);

  if (number === 1) return number + "-rÃ«";
  if (number === 4) return number + "t";

  return number + "-tÃ«";
};

(localize$f.localize = {
  ordinalNumber: ordinalNumber$f,

  era: (0, _index$4T.buildLocalizeFn)({
    values: eraValues$f,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4T.buildLocalizeFn)({
    values: quarterValues$f,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4T.buildLocalizeFn)({
    values: monthValues$f,
    defaultWidth: "wide",
  }),

  day: (0, _index$4T.buildLocalizeFn)({
    values: dayValues$f,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4T.buildLocalizeFn)({
    values: dayPeriodValues$f,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$f,
    defaultFormattingWidth: "wide",
  }),
});

var match$f = {};

match$f.match = void 0;

var _index$4S = buildMatchFn$1;
var _index2$22 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$f = /^(\d+)(-rÃ«|-tÃ«|t|)?/i;
const parseOrdinalNumberPattern$f = /\d+/i;

const matchEraPatterns$f = {
  narrow: /^(p|m)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(para krishtit|mbas krishtit)/i,
};
const parseEraPatterns$f = {
  any: [/^b/i, /^(p|m)/i],
};

const matchQuarterPatterns$f = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]-mujori (i{1,3}|iv)/i,
};
const parseQuarterPatterns$f = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$f = {
  narrow: /^[jsmpqkftnd]/i,
  abbreviated: /^(jan|shk|mar|pri|maj|qer|kor|gus|sht|tet|nÃ«n|dhj)/i,
  wide: /^(janar|shkurt|mars|prill|maj|qershor|korrik|gusht|shtator|tetor|nÃ«ntor|dhjetor)/i,
};
const parseMonthPatterns$f = {
  narrow: [
    /^j/i,
    /^s/i,
    /^m/i,
    /^p/i,
    /^m/i,
    /^q/i,
    /^k/i,
    /^g/i,
    /^s/i,
    /^t/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^shk/i,
    /^mar/i,
    /^pri/i,
    /^maj/i,
    /^qer/i,
    /^kor/i,
    /^gu/i,
    /^sht/i,
    /^tet/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$f = {
  narrow: /^[dhmeps]/i,
  short: /^(di|hÃ«|ma|mÃ«|en|pr|sh)/i,
  abbreviated: /^(die|hÃ«n|mar|mÃ«r|enj|pre|sht)/i,
  wide: /^(dielÃ«|hÃ«nÃ«|martÃ«|mÃ«rkurÃ«|enjte|premte|shtunÃ«)/i,
};
const parseDayPatterns$f = {
  narrow: [/^d/i, /^h/i, /^m/i, /^m/i, /^e/i, /^p/i, /^s/i],
  any: [/^d/i, /^h/i, /^ma/i, /^mÃ«/i, /^e/i, /^p/i, /^s/i],
};

const matchDayPeriodPatterns$f = {
  narrow: /^(p|m|me|nÃ« (mÃ«ngjes|mbasdite|mbrÃ«mje|mesnatÃ«))/i,
  any: /^([pm]\.?\s?d\.?|drek|nÃ« (mÃ«ngjes|mbasdite|mbrÃ«mje|mesnatÃ«))/i,
};
const parseDayPeriodPatterns$f = {
  any: {
    am: /^p/i,
    pm: /^m/i,
    midnight: /^me/i,
    noon: /^dr/i,
    morning: /mÃ«ngjes/i,
    afternoon: /mbasdite/i,
    evening: /mbrÃ«mje/i,
    night: /natÃ«/i,
  },
};

(match$f.match = {
  ordinalNumber: (0, _index2$22.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$f,
    parsePattern: parseOrdinalNumberPattern$f,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4S.buildMatchFn)({
    matchPatterns: matchEraPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$f,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4S.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$f,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4S.buildMatchFn)({
    matchPatterns: matchMonthPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$f,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4S.buildMatchFn)({
    matchPatterns: matchDayPatterns$f,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$f,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4S.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$f,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$f,
    defaultParseWidth: "any",
  }),
});

sq.sq = void 0;
var _index$4R = formatDistance$x;
var _index2$21 = formatLong$f;
var _index3$11 = formatRelative$x;
var _index4$x = localize$f;
var _index5$o = match$f;

/**
 * @category Locales
 * @summary Albanian locale.
 * @language Shqip
 * @iso-639-2 sqi
 * @author Ardit Dine [@arditdine](https://github.com/arditdine)
 */
(sq.sq = {
  code: "sq",
  formatDistance: _index$4R.formatDistance,
  formatLong: _index2$21.formatLong,
  formatRelative: _index3$11.formatRelative,
  localize: _index4$x.localize,
  match: _index5$o.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var sr = {};

var formatDistance$v = {};

formatDistance$v.formatDistance = void 0;

const formatDistanceLocale$e = {
  lessThanXSeconds: {
    one: {
      standalone: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 ÑÐµÐºÑÐ½Ð´Ðµ",
      withPrepositionAgo: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 ÑÐµÐºÑÐ½Ð´Ðµ",
      withPrepositionIn: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 ÑÐµÐºÑÐ½Ð´Ñ",
    },
    dual: "Ð¼Ð°ÑÐµ Ð¾Ð´ {{count}} ÑÐµÐºÑÐ½Ð´Ðµ",
    other: "Ð¼Ð°ÑÐµ Ð¾Ð´ {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  xSeconds: {
    one: {
      standalone: "1 ÑÐµÐºÑÐ½Ð´Ð°",
      withPrepositionAgo: "1 ÑÐµÐºÑÐ½Ð´Ðµ",
      withPrepositionIn: "1 ÑÐµÐºÑÐ½Ð´Ñ",
    },
    dual: "{{count}} ÑÐµÐºÑÐ½Ð´Ðµ",
    other: "{{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
  },

  halfAMinute: "Ð¿Ð¾Ð»Ð° Ð¼Ð¸Ð½ÑÑÐµ",

  lessThanXMinutes: {
    one: {
      standalone: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 Ð¼Ð¸Ð½ÑÑÐµ",
      withPrepositionAgo: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 Ð¼Ð¸Ð½ÑÑÐµ",
      withPrepositionIn: "Ð¼Ð°ÑÐµ Ð¾Ð´ 1 Ð¼Ð¸Ð½ÑÑÑ",
    },
    dual: "Ð¼Ð°ÑÐµ Ð¾Ð´ {{count}} Ð¼Ð¸Ð½ÑÑÐµ",
    other: "Ð¼Ð°ÑÐµ Ð¾Ð´ {{count}} Ð¼Ð¸Ð½ÑÑÐ°",
  },

  xMinutes: {
    one: {
      standalone: "1 Ð¼Ð¸Ð½ÑÑÐ°",
      withPrepositionAgo: "1 Ð¼Ð¸Ð½ÑÑÐµ",
      withPrepositionIn: "1 Ð¼Ð¸Ð½ÑÑÑ",
    },
    dual: "{{count}} Ð¼Ð¸Ð½ÑÑÐµ",
    other: "{{count}} Ð¼Ð¸Ð½ÑÑÐ°",
  },

  aboutXHours: {
    one: {
      standalone: "Ð¾ÐºÐ¾ 1 ÑÐ°Ñ",
      withPrepositionAgo: "Ð¾ÐºÐ¾ 1 ÑÐ°Ñ",
      withPrepositionIn: "Ð¾ÐºÐ¾ 1 ÑÐ°Ñ",
    },
    dual: "Ð¾ÐºÐ¾ {{count}} ÑÐ°ÑÐ°",
    other: "Ð¾ÐºÐ¾ {{count}} ÑÐ°ÑÐ¸",
  },

  xHours: {
    one: {
      standalone: "1 ÑÐ°Ñ",
      withPrepositionAgo: "1 ÑÐ°Ñ",
      withPrepositionIn: "1 ÑÐ°Ñ",
    },
    dual: "{{count}} ÑÐ°ÑÐ°",
    other: "{{count}} ÑÐ°ÑÐ¸",
  },

  xDays: {
    one: {
      standalone: "1 Ð´Ð°Ð½",
      withPrepositionAgo: "1 Ð´Ð°Ð½",
      withPrepositionIn: "1 Ð´Ð°Ð½",
    },
    dual: "{{count}} Ð´Ð°Ð½Ð°",
    other: "{{count}} Ð´Ð°Ð½Ð°",
  },

  aboutXWeeks: {
    one: {
      standalone: "Ð¾ÐºÐ¾ 1 Ð½ÐµÐ´ÐµÑÑ",
      withPrepositionAgo: "Ð¾ÐºÐ¾ 1 Ð½ÐµÐ´ÐµÑÑ",
      withPrepositionIn: "Ð¾ÐºÐ¾ 1 Ð½ÐµÐ´ÐµÑÑ",
    },
    dual: "Ð¾ÐºÐ¾ {{count}} Ð½ÐµÐ´ÐµÑÐµ",
    other: "Ð¾ÐºÐ¾ {{count}} Ð½ÐµÐ´ÐµÑÐµ",
  },

  xWeeks: {
    one: {
      standalone: "1 Ð½ÐµÐ´ÐµÑÑ",
      withPrepositionAgo: "1 Ð½ÐµÐ´ÐµÑÑ",
      withPrepositionIn: "1 Ð½ÐµÐ´ÐµÑÑ",
    },
    dual: "{{count}} Ð½ÐµÐ´ÐµÑÐµ",
    other: "{{count}} Ð½ÐµÐ´ÐµÑÐµ",
  },

  aboutXMonths: {
    one: {
      standalone: "Ð¾ÐºÐ¾ 1 Ð¼ÐµÑÐµÑ",
      withPrepositionAgo: "Ð¾ÐºÐ¾ 1 Ð¼ÐµÑÐµÑ",
      withPrepositionIn: "Ð¾ÐºÐ¾ 1 Ð¼ÐµÑÐµÑ",
    },
    dual: "Ð¾ÐºÐ¾ {{count}} Ð¼ÐµÑÐµÑÐ°",
    other: "Ð¾ÐºÐ¾ {{count}} Ð¼ÐµÑÐµÑÐ¸",
  },

  xMonths: {
    one: {
      standalone: "1 Ð¼ÐµÑÐµÑ",
      withPrepositionAgo: "1 Ð¼ÐµÑÐµÑ",
      withPrepositionIn: "1 Ð¼ÐµÑÐµÑ",
    },
    dual: "{{count}} Ð¼ÐµÑÐµÑÐ°",
    other: "{{count}} Ð¼ÐµÑÐµÑÐ¸",
  },

  aboutXYears: {
    one: {
      standalone: "Ð¾ÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionAgo: "Ð¾ÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionIn: "Ð¾ÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
    },
    dual: "Ð¾ÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ðµ",
    other: "Ð¾ÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð°",
  },

  xYears: {
    one: {
      standalone: "1 Ð³Ð¾Ð´Ð¸Ð½Ð°",
      withPrepositionAgo: "1 Ð³Ð¾Ð´Ð¸Ð½Ðµ",
      withPrepositionIn: "1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
    },
    dual: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ðµ",
    other: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ð°",
  },

  overXYears: {
    one: {
      standalone: "Ð¿ÑÐµÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionAgo: "Ð¿ÑÐµÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionIn: "Ð¿ÑÐµÐºÐ¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
    },
    dual: "Ð¿ÑÐµÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ðµ",
    other: "Ð¿ÑÐµÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð°",
  },

  almostXYears: {
    one: {
      standalone: "Ð³Ð¾ÑÐ¾Ð²Ð¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionAgo: "Ð³Ð¾ÑÐ¾Ð²Ð¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
      withPrepositionIn: "Ð³Ð¾ÑÐ¾Ð²Ð¾ 1 Ð³Ð¾Ð´Ð¸Ð½Ñ",
    },
    dual: "Ð³Ð¾ÑÐ¾Ð²Ð¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ðµ",
    other: "Ð³Ð¾ÑÐ¾Ð²Ð¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð°",
  },
};

const formatDistance$u = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$e[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (
    count % 10 > 1 &&
    count % 10 < 5 && // if last digit is between 2 and 4
    String(count).substr(-2, 1) !== "1" // unless the 2nd to last digit is "1"
  ) {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ð·Ð° " + result;
    } else {
      return "Ð¿ÑÐµ " + result;
    }
  }

  return result;
};
formatDistance$v.formatDistance = formatDistance$u;

var formatLong$e = {};

formatLong$e.formatLong = void 0;
var _index$4Q = buildFormatLongFn$1;

const dateFormats$e = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy.",
};

const timeFormats$e = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$e = {
  full: "{{date}} 'Ñ' {{time}}",
  long: "{{date}} 'Ñ' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$e.formatLong = {
  date: (0, _index$4Q.buildFormatLongFn)({
    formats: dateFormats$e,
    defaultWidth: "full",
  }),

  time: (0, _index$4Q.buildFormatLongFn)({
    formats: timeFormats$e,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4Q.buildFormatLongFn)({
    formats: dateTimeFormats$e,
    defaultWidth: "full",
  }),
});

var formatRelative$v = {};

formatRelative$v.formatRelative = void 0;

const formatRelativeLocale$e = {
  lastWeek: (date) => {
    const day = date.getDay();

    switch (day) {
      case 0:
        return "'Ð¿ÑÐ¾ÑÐ»Ðµ Ð½ÐµÐ´ÐµÑÐµ Ñ' p";
      case 3:
        return "'Ð¿ÑÐ¾ÑÐ»Ðµ ÑÑÐµÐ´Ðµ Ñ' p";
      case 6:
        return "'Ð¿ÑÐ¾ÑÐ»Ðµ ÑÑÐ±Ð¾ÑÐµ Ñ' p";
      default:
        return "'Ð¿ÑÐ¾ÑÐ»Ð¸' EEEE 'Ñ' p";
    }
  },
  yesterday: "'ÑÑÑÐµ Ñ' p",
  today: "'Ð´Ð°Ð½Ð°Ñ Ñ' p",
  tomorrow: "'ÑÑÑÑÐ° Ñ' p",
  nextWeek: (date) => {
    const day = date.getDay();

    switch (day) {
      case 0:
        return "'ÑÐ»ÐµÐ´ÐµÑÐµ Ð½ÐµÐ´ÐµÑÐµ Ñ' p";
      case 3:
        return "'ÑÐ»ÐµÐ´ÐµÑÑ ÑÑÐµÐ´Ñ Ñ' p";
      case 6:
        return "'ÑÐ»ÐµÐ´ÐµÑÑ ÑÑÐ±Ð¾ÑÑ Ñ' p";
      default:
        return "'ÑÐ»ÐµÐ´ÐµÑÐ¸' EEEE 'Ñ' p";
    }
  },
  other: "P",
};

const formatRelative$u = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$e[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$v.formatRelative = formatRelative$u;

var localize$e = {};

localize$e.localize = void 0;
var _index$4P = buildLocalizeFn$1;

const eraValues$e = {
  narrow: ["Ð¿Ñ.Ð½.Ðµ.", "ÐÐ"],
  abbreviated: ["Ð¿Ñ. Ð¥Ñ.", "Ð¿Ð¾. Ð¥Ñ."],
  wide: ["ÐÑÐµ Ð¥ÑÐ¸ÑÑÐ°", "ÐÐ¾ÑÐ»Ðµ Ð¥ÑÐ¸ÑÑÐ°"],
};

const quarterValues$e = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. ÐºÐ².", "2. ÐºÐ².", "3. ÐºÐ².", "4. ÐºÐ²."],
  wide: ["1. ÐºÐ²Ð°ÑÑÐ°Ð»", "2. ÐºÐ²Ð°ÑÑÐ°Ð»", "3. ÐºÐ²Ð°ÑÑÐ°Ð»", "4. ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$e = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "ÑÐ°Ð½",
    "ÑÐµÐ±",
    "Ð¼Ð°Ñ",
    "Ð°Ð¿Ñ",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½",
    "ÑÑÐ»",
    "Ð°Ð²Ð³",
    "ÑÐµÐ¿",
    "Ð¾ÐºÑ",
    "Ð½Ð¾Ð²",
    "Ð´ÐµÑ",
  ],

  wide: [
    "ÑÐ°Ð½ÑÐ°Ñ",
    "ÑÐµÐ±ÑÑÐ°Ñ",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐ¸Ð»",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½",
    "ÑÑÐ»",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ",
    "Ð¾ÐºÑÐ¾Ð±Ð°Ñ",
    "Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ",
    "Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ",
  ],
};

const formattingMonthValues$3 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "ÑÐ°Ð½",
    "ÑÐµÐ±",
    "Ð¼Ð°Ñ",
    "Ð°Ð¿Ñ",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½",
    "ÑÑÐ»",
    "Ð°Ð²Ð³",
    "ÑÐµÐ¿",
    "Ð¾ÐºÑ",
    "Ð½Ð¾Ð²",
    "Ð´ÐµÑ",
  ],

  wide: [
    "ÑÐ°Ð½ÑÐ°Ñ",
    "ÑÐµÐ±ÑÑÐ°Ñ",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐ¸Ð»",
    "Ð¼Ð°Ñ",
    "ÑÑÐ½",
    "ÑÑÐ»",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ",
    "Ð¾ÐºÑÐ¾Ð±Ð°Ñ",
    "Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ",
    "Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ",
  ],
};

const dayValues$e = {
  narrow: ["Ð", "Ð", "Ð£", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½ÐµÐ´", "Ð¿Ð¾Ð½", "ÑÑÐ¾", "ÑÑÐµ", "ÑÐµÑ", "Ð¿ÐµÑ", "ÑÑÐ±"],
  abbreviated: ["Ð½ÐµÐ´", "Ð¿Ð¾Ð½", "ÑÑÐ¾", "ÑÑÐµ", "ÑÐµÑ", "Ð¿ÐµÑ", "ÑÑÐ±"],
  wide: [
    "Ð½ÐµÐ´ÐµÑÐ°",
    "Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐ°Ðº",
    "ÑÑÐ¾ÑÐ°Ðº",
    "ÑÑÐµÐ´Ð°",
    "ÑÐµÑÐ²ÑÑÐ°Ðº",
    "Ð¿ÐµÑÐ°Ðº",
    "ÑÑÐ±Ð¾ÑÐ°",
  ],
};

const formattingDayPeriodValues$e = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
};

const dayPeriodValues$e = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "Ð¿Ð¾Ð½Ð¾Ñ",
    noon: "Ð¿Ð¾Ð´Ð½Ðµ",
    morning: "ÑÑÑÑÑÑ",
    afternoon: "Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð´Ð½Ðµ",
    evening: "ÑÐ²ÐµÑÐµ",
    night: "Ð½Ð¾ÑÑ",
  },
};

const ordinalNumber$e = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$e.localize = {
  ordinalNumber: ordinalNumber$e,

  era: (0, _index$4P.buildLocalizeFn)({
    values: eraValues$e,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4P.buildLocalizeFn)({
    values: quarterValues$e,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4P.buildLocalizeFn)({
    values: monthValues$e,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$3,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$4P.buildLocalizeFn)({
    values: dayValues$e,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4P.buildLocalizeFn)({
    values: dayPeriodValues$e,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$e,
    defaultFormattingWidth: "wide",
  }),
});

var match$e = {};

match$e.match = void 0;

var _index$4O = buildMatchFn$1;
var _index2$20 = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$e = /^(\d+)\./i;
const parseOrdinalNumberPattern$e = /\d+/i;

const matchEraPatterns$e = {
  narrow: /^(Ð¿Ñ\.Ð½\.Ðµ\.|ÐÐ)/i,
  abbreviated: /^(Ð¿Ñ\.\s?Ð¥Ñ\.|Ð¿Ð¾\.\s?Ð¥Ñ\.)/i,
  wide: /^(ÐÑÐµ Ð¥ÑÐ¸ÑÑÐ°|Ð¿ÑÐµ Ð½Ð¾Ð²Ðµ ÐµÑÐµ|ÐÐ¾ÑÐ»Ðµ Ð¥ÑÐ¸ÑÑÐ°|Ð½Ð¾Ð²Ð° ÐµÑÐ°)/i,
};
const parseEraPatterns$e = {
  any: [/^Ð¿Ñ/i, /^(Ð¿Ð¾|Ð½Ð¾Ð²Ð°)/i],
};

const matchQuarterPatterns$e = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?ÐºÐ²\.?/i,
  wide: /^[1234]\. ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};
const parseQuarterPatterns$e = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$e = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(ÑÐ°Ð½|ÑÐµÐ±|Ð¼Ð°Ñ|Ð°Ð¿Ñ|Ð¼Ð°Ñ|ÑÑÐ½|ÑÑÐ»|Ð°Ð²Ð³|ÑÐµÐ¿|Ð¾ÐºÑ|Ð½Ð¾Ð²|Ð´ÐµÑ)/i,
  wide: /^((ÑÐ°Ð½ÑÐ°Ñ|ÑÐ°Ð½ÑÐ°ÑÐ°)|(ÑÐµÐ±ÑÑÐ°Ñ|ÑÐµÐ±ÑÑÐ°ÑÐ°)|(Ð¼Ð°ÑÑ|Ð¼Ð°ÑÑÐ°)|(Ð°Ð¿ÑÐ¸Ð»|Ð°Ð¿ÑÐ¸Ð»Ð°)|(Ð¼ÑÐ°|Ð¼Ð°ÑÐ°)|(ÑÑÐ½|ÑÑÐ½Ð°)|(ÑÑÐ»|ÑÑÐ»Ð°)|(Ð°Ð²Ð³ÑÑÑ|Ð°Ð²Ð³ÑÑÑÐ°)|(ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ|ÑÐµÐ¿ÑÐµÐ¼Ð±ÑÐ°)|(Ð¾ÐºÑÐ¾Ð±Ð°Ñ|Ð¾ÐºÑÐ¾Ð±ÑÐ°)|(Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ|Ð½Ð¾Ð²ÐµÐ¼Ð±ÑÐ°)|(Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ|Ð´ÐµÑÐµÐ¼Ð±ÑÐ°))/i,
};
const parseMonthPatterns$e = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i,
  ],

  any: [
    /^ÑÐ°/i,
    /^Ñ/i,
    /^Ð¼Ð°Ñ/i,
    /^Ð°Ð¿/i,
    /^Ð¼Ð°Ñ/i,
    /^ÑÑÐ½/i,
    /^ÑÑÐ»/i,
    /^Ð°Ð²Ð³/i,
    /^Ñ/i,
    /^Ð¾/i,
    /^Ð½/i,
    /^Ð´/i,
  ],
};

const matchDayPatterns$e = {
  narrow: /^[Ð¿ÑÑÑÐ½]/i,
  short: /^(Ð½ÐµÐ´|Ð¿Ð¾Ð½|ÑÑÐ¾|ÑÑÐµ|ÑÐµÑ|Ð¿ÐµÑ|ÑÑÐ±)/i,
  abbreviated: /^(Ð½ÐµÐ´|Ð¿Ð¾Ð½|ÑÑÐ¾|ÑÑÐµ|ÑÐµÑ|Ð¿ÐµÑ|ÑÑÐ±)/i,
  wide: /^(Ð½ÐµÐ´ÐµÑÐ°|Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐ°Ðº|ÑÑÐ¾ÑÐ°Ðº|ÑÑÐµÐ´Ð°|ÑÐµÑÐ²ÑÑÐ°Ðº|Ð¿ÐµÑÐ°Ðº|ÑÑÐ±Ð¾ÑÐ°)/i,
};
const parseDayPatterns$e = {
  narrow: [/^Ð¿/i, /^Ñ/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i, /^Ð½/i],
  any: [/^Ð½ÐµÐ´/i, /^Ð¿Ð¾Ð½/i, /^ÑÑÐ¾/i, /^ÑÑÐµ/i, /^ÑÐµÑ/i, /^Ð¿ÐµÑ/i, /^ÑÑÐ±/i],
};

const matchDayPeriodPatterns$e = {
  any: /^(Ð°Ð¼|Ð¿Ð¼|Ð¿Ð¾Ð½Ð¾Ñ|(Ð¿Ð¾)?Ð¿Ð¾Ð´Ð½Ðµ|ÑÐ²ÐµÑÐµ|Ð½Ð¾ÑÑ|Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð´Ð½Ðµ|ÑÑÑÑÑÑ)/i,
};
const parseDayPeriodPatterns$e = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^Ð¿Ð¾Ð½Ð¾/i,
    noon: /^Ð¿Ð¾Ð´/i,
    morning: /ÑÑÑÑÑÑ/i,
    afternoon: /(Ð¿Ð¾ÑÐ»Ðµ\s|Ð¿Ð¾)+Ð¿Ð¾Ð´Ð½Ðµ/i,
    evening: /(ÑÐ²ÐµÑÐµ)/i,
    night: /(Ð½Ð¾ÑÑ)/i,
  },
};

(match$e.match = {
  ordinalNumber: (0, _index2$20.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$e,
    parsePattern: parseOrdinalNumberPattern$e,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4O.buildMatchFn)({
    matchPatterns: matchEraPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$e,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4O.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$e,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4O.buildMatchFn)({
    matchPatterns: matchMonthPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$e,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4O.buildMatchFn)({
    matchPatterns: matchDayPatterns$e,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$e,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4O.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$e,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$e,
    defaultParseWidth: "any",
  }),
});

sr.sr = void 0;
var _index$4N = formatDistance$v;
var _index2$1$ = formatLong$e;
var _index3$10 = formatRelative$v;
var _index4$w = localize$e;
var _index5$n = match$e;

/**
 * @category Locales
 * @summary Serbian cyrillic locale.
 * @language Serbian
 * @iso-639-2 srp
 * @author Igor RadivojeviÄ [@rogyvoje](https://github.com/rogyvoje)
 */
(sr.sr = {
  code: "sr",
  formatDistance: _index$4N.formatDistance,
  formatLong: _index2$1$.formatLong,
  formatRelative: _index3$10.formatRelative,
  localize: _index4$w.localize,
  match: _index5$n.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var srLatn = {};

var formatDistance$t = {};

formatDistance$t.formatDistance = void 0;

const formatDistanceLocale$d = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu",
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi",
  },

  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu",
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi",
  },

  halfAMinute: "pola minute",

  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu",
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta",
  },

  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu",
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta",
  },

  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat",
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati",
  },

  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat",
    },
    dual: "{{count}} sata",
    other: "{{count}} sati",
  },

  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan",
    },
    dual: "{{count}} dana",
    other: "{{count}} dana",
  },

  aboutXWeeks: {
    one: {
      standalone: "oko 1 nedelju",
      withPrepositionAgo: "oko 1 nedelju",
      withPrepositionIn: "oko 1 nedelju",
    },
    dual: "oko {{count}} nedelje",
    other: "oko {{count}} nedelje",
  },

  xWeeks: {
    one: {
      standalone: "1 nedelju",
      withPrepositionAgo: "1 nedelju",
      withPrepositionIn: "1 nedelju",
    },
    dual: "{{count}} nedelje",
    other: "{{count}} nedelje",
  },

  aboutXMonths: {
    one: {
      standalone: "oko 1 mesec",
      withPrepositionAgo: "oko 1 mesec",
      withPrepositionIn: "oko 1 mesec",
    },
    dual: "oko {{count}} meseca",
    other: "oko {{count}} meseci",
  },

  xMonths: {
    one: {
      standalone: "1 mesec",
      withPrepositionAgo: "1 mesec",
      withPrepositionIn: "1 mesec",
    },
    dual: "{{count}} meseca",
    other: "{{count}} meseci",
  },

  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu",
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina",
  },

  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu",
    },
    dual: "{{count}} godine",
    other: "{{count}} godina",
  },

  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu",
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina",
  },

  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu",
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina",
  },
};

const formatDistance$s = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$d[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (
    count % 10 > 1 &&
    count % 10 < 5 && // if last digit is between 2 and 4
    String(count).substr(-2, 1) !== "1" // unless the 2nd to last digit is "1"
  ) {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "za " + result;
    } else {
      return "pre " + result;
    }
  }

  return result;
};
formatDistance$t.formatDistance = formatDistance$s;

var formatLong$d = {};

formatLong$d.formatLong = void 0;
var _index$4M = buildFormatLongFn$1;

const dateFormats$d = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy.",
};

const timeFormats$d = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$d = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$d.formatLong = {
  date: (0, _index$4M.buildFormatLongFn)({
    formats: dateFormats$d,
    defaultWidth: "full",
  }),

  time: (0, _index$4M.buildFormatLongFn)({
    formats: timeFormats$d,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4M.buildFormatLongFn)({
    formats: dateTimeFormats$d,
    defaultWidth: "full",
  }),
});

var formatRelative$t = {};

formatRelative$t.formatRelative = void 0;

const formatRelativeLocale$d = {
  lastWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'proÅ¡le nedelje u' p";
      case 3:
        return "'proÅ¡le srede u' p";
      case 6:
        return "'proÅ¡le subote u' p";
      default:
        return "'proÅ¡li' EEEE 'u' p";
    }
  },
  yesterday: "'juÄe u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date) => {
    switch (date.getDay()) {
      case 0:
        return "'sledeÄe nedelje u' p";
      case 3:
        return "'sledeÄu sredu u' p";
      case 6:
        return "'sledeÄu subotu u' p";
      default:
        return "'sledeÄi' EEEE 'u' p";
    }
  },
  other: "P",
};

const formatRelative$s = (token, date, _baseDate, _options) => {
  const format = formatRelativeLocale$d[token];

  if (typeof format === "function") {
    return format(date);
  }

  return format;
};
formatRelative$t.formatRelative = formatRelative$s;

var localize$d = {};

localize$d.localize = void 0;
var _index$4L = buildLocalizeFn$1;

const eraValues$d = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Pre Hrista", "Posle Hrista"],
};

const quarterValues$d = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"],
};

const monthValues$d = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar",
  ],
};

const formattingMonthValues$2 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12.",
  ],

  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec",
  ],

  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar",
  ],
};

const dayValues$d = {
  narrow: ["N", "P", "U", "S", "Ä", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "Äet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "Äet", "pet", "sub"],
  wide: [
    "nedelja",
    "ponedeljak",
    "utorak",
    "sreda",
    "Äetvrtak",
    "petak",
    "subota",
  ],
};

const formattingDayPeriodValues$d = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uveÄe",
    night: "noÄu",
  },
};

const dayPeriodValues$d = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveÄe",
    night: "noÄu",
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoÄ",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uveÄe",
    night: "noÄu",
  },
};

const ordinalNumber$d = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$d.localize = {
  ordinalNumber: ordinalNumber$d,

  era: (0, _index$4L.buildLocalizeFn)({
    values: eraValues$d,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4L.buildLocalizeFn)({
    values: quarterValues$d,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4L.buildLocalizeFn)({
    values: monthValues$d,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$2,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$4L.buildLocalizeFn)({
    values: dayValues$d,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4L.buildLocalizeFn)({
    values: dayPeriodValues$d,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$d,
    defaultFormattingWidth: "wide",
  }),
});

var match$d = {};

match$d.match = void 0;

var _index$4K = buildMatchFn$1;
var _index2$1_ = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$d = /^(\d+)\./i;
const parseOrdinalNumberPattern$d = /\d+/i;

const matchEraPatterns$d = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Pre Hrista|pre nove ere|Posle Hrista|nova era)/i,
};
const parseEraPatterns$d = {
  any: [/^pr/i, /^(po|nova)/i],
};

const matchQuarterPatterns$d = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i,
};
const parseQuarterPatterns$d = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$d = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(jun|juna)|(jul|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i,
};
const parseMonthPatterns$d = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$d = {
  narrow: /^[npusÄc]/i,
  short: /^(ned|pon|uto|sre|(Äet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(Äet|cet)|pet|sub)/i,
  wide: /^(nedelja|ponedeljak|utorak|sreda|(Äetvrtak|cetvrtak)|petak|subota)/i,
};
const parseDayPatterns$d = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns$d = {
  any: /^(am|pm|ponoc|ponoÄ|(po)?podne|uvece|uveÄe|noÄu|posle podne|ujutru)/i,
};
const parseDayPeriodPatterns$d = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(posle\s|po)+podne/i,
    evening: /(uvece|uveÄe)/i,
    night: /(nocu|noÄu)/i,
  },
};

(match$d.match = {
  ordinalNumber: (0, _index2$1_.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$d,
    parsePattern: parseOrdinalNumberPattern$d,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4K.buildMatchFn)({
    matchPatterns: matchEraPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$d,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4K.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$d,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4K.buildMatchFn)({
    matchPatterns: matchMonthPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$d,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4K.buildMatchFn)({
    matchPatterns: matchDayPatterns$d,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$d,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4K.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$d,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$d,
    defaultParseWidth: "any",
  }),
});

srLatn.srLatn = void 0;
var _index$4J = formatDistance$t;
var _index2$1Z = formatLong$d;
var _index3$$ = formatRelative$t;
var _index4$v = localize$d;
var _index5$m = match$d;

/**
 * @category Locales
 * @summary Serbian latin locale.
 * @language Serbian
 * @iso-639-2 srp
 * @author Igor RadivojeviÄ [@rogyvoje](https://github.com/rogyvoje)
 */
(srLatn.srLatn = {
  code: "sr-Latn",
  formatDistance: _index$4J.formatDistance,
  formatLong: _index2$1Z.formatLong,
  formatRelative: _index3$$.formatRelative,
  localize: _index4$v.localize,
  match: _index5$m.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var sv = {};

var formatDistance$r = {};

formatDistance$r.formatDistance = void 0;

const formatDistanceLocale$c = {
  lessThanXSeconds: {
    one: "mindre Ã¤n en sekund",
    other: "mindre Ã¤n {{count}} sekunder",
  },

  xSeconds: {
    one: "en sekund",
    other: "{{count}} sekunder",
  },

  halfAMinute: "en halv minut",

  lessThanXMinutes: {
    one: "mindre Ã¤n en minut",
    other: "mindre Ã¤n {{count}} minuter",
  },

  xMinutes: {
    one: "en minut",
    other: "{{count}} minuter",
  },

  aboutXHours: {
    one: "ungefÃ¤r en timme",
    other: "ungefÃ¤r {{count}} timmar",
  },

  xHours: {
    one: "en timme",
    other: "{{count}} timmar",
  },

  xDays: {
    one: "en dag",
    other: "{{count}} dagar",
  },

  aboutXWeeks: {
    one: "ungefÃ¤r en vecka",
    other: "ungefÃ¤r {{count}} veckor",
  },

  xWeeks: {
    one: "en vecka",
    other: "{{count}} veckor",
  },

  aboutXMonths: {
    one: "ungefÃ¤r en mÃ¥nad",
    other: "ungefÃ¤r {{count}} mÃ¥nader",
  },

  xMonths: {
    one: "en mÃ¥nad",
    other: "{{count}} mÃ¥nader",
  },

  aboutXYears: {
    one: "ungefÃ¤r ett Ã¥r",
    other: "ungefÃ¤r {{count}} Ã¥r",
  },

  xYears: {
    one: "ett Ã¥r",
    other: "{{count}} Ã¥r",
  },

  overXYears: {
    one: "Ã¶ver ett Ã¥r",
    other: "Ã¶ver {{count}} Ã¥r",
  },

  almostXYears: {
    one: "nÃ¤stan ett Ã¥r",
    other: "nÃ¤stan {{count}} Ã¥r",
  },
};

const wordMapping = [
  "noll",
  "en",
  "tvÃ¥",
  "tre",
  "fyra",
  "fem",
  "sex",
  "sju",
  "Ã¥tta",
  "nio",
  "tio",
  "elva",
  "tolv",
];

const formatDistance$q = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$c[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping[count] : String(count),
    );
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sedan";
    }
  }

  return result;
};
formatDistance$r.formatDistance = formatDistance$q;

var formatLong$c = {};

formatLong$c.formatLong = void 0;
var _index$4I = buildFormatLongFn$1;

const dateFormats$c = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "y-MM-dd",
};

const timeFormats$c = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$c = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$c.formatLong = {
  date: (0, _index$4I.buildFormatLongFn)({
    formats: dateFormats$c,
    defaultWidth: "full",
  }),

  time: (0, _index$4I.buildFormatLongFn)({
    formats: timeFormats$c,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4I.buildFormatLongFn)({
    formats: dateTimeFormats$c,
    defaultWidth: "full",
  }),
});

var formatRelative$r = {};

formatRelative$r.formatRelative = void 0;

const formatRelativeLocale$c = {
  lastWeek: "'i' EEEE's kl.' p",
  yesterday: "'igÃ¥r kl.' p",
  today: "'idag kl.' p",
  tomorrow: "'imorgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P",
};

const formatRelative$q = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$c[token];
formatRelative$r.formatRelative = formatRelative$q;

var localize$c = {};

localize$c.localize = void 0;
var _index$4H = buildLocalizeFn$1;

const eraValues$c = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fÃ¶re Kristus", "efter Kristus"],
};

const quarterValues$c = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1:a kvartalet", "2:a kvartalet", "3:e kvartalet", "4:e kvartalet"],
};

const monthValues$c = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "maj",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec.",
  ],

  wide: [
    "januari",
    "februari",
    "mars",
    "april",
    "maj",
    "juni",
    "juli",
    "augusti",
    "september",
    "oktober",
    "november",
    "december",
  ],
};

const dayValues$c = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sÃ¶", "mÃ¥", "ti", "on", "to", "fr", "lÃ¶"],
  abbreviated: ["sÃ¶n", "mÃ¥n", "tis", "ons", "tors", "fre", "lÃ¶r"],
  wide: ["sÃ¶ndag", "mÃ¥ndag", "tisdag", "onsdag", "torsdag", "fredag", "lÃ¶rdag"],
};

// https://www.unicode.org/cldr/charts/32/summary/sv.html#1888
const dayPeriodValues$c = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "morg.",
    afternoon: "efterm.",
    evening: "kvÃ¤ll",
    night: "natt",
  },
  abbreviated: {
    am: "f.m.",
    pm: "e.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "efterm.",
    evening: "kvÃ¤ll",
    night: "natt",
  },
  wide: {
    am: "fÃ¶rmiddag",
    pm: "eftermiddag",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "eftermiddag",
    evening: "kvÃ¤ll",
    night: "natt",
  },
};

const formattingDayPeriodValues$c = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ efterm.",
    evening: "pÃ¥ kvÃ¤llen",
    night: "pÃ¥ natten",
  },
  abbreviated: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morg.",
    afternoon: "pÃ¥ efterm.",
    evening: "pÃ¥ kvÃ¤llen",
    night: "pÃ¥ natten",
  },
  wide: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "pÃ¥ morgonen",
    afternoon: "pÃ¥ eftermiddagen",
    evening: "pÃ¥ kvÃ¤llen",
    night: "pÃ¥ natten",
  },
};

const ordinalNumber$c = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
      case 2:
        return number + ":a";
    }
  }
  return number + ":e";
};

(localize$c.localize = {
  ordinalNumber: ordinalNumber$c,

  era: (0, _index$4H.buildLocalizeFn)({
    values: eraValues$c,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4H.buildLocalizeFn)({
    values: quarterValues$c,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4H.buildLocalizeFn)({
    values: monthValues$c,
    defaultWidth: "wide",
  }),

  day: (0, _index$4H.buildLocalizeFn)({
    values: dayValues$c,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4H.buildLocalizeFn)({
    values: dayPeriodValues$c,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$c,
    defaultFormattingWidth: "wide",
  }),
});

var match$c = {};

match$c.match = void 0;

var _index$4G = buildMatchFn$1;
var _index2$1Y = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$c = /^(\d+)(:a|:e)?/i;
const parseOrdinalNumberPattern$c = /\d+/i;

const matchEraPatterns$c = {
  narrow: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  wide: /^(fÃ¶re Kristus|fÃ¶re vÃ¥r tid|efter Kristus|vÃ¥r tid)/i,
};
const parseEraPatterns$c = {
  any: [/^f/i, /^[ev]/i],
};

const matchQuarterPatterns$c = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](:a|:e)? kvartalet/i,
};
const parseQuarterPatterns$c = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$c = {
  narrow: /^[jfmasond]/i,
  abbreviated:
    /^(jan|feb|mar[s]?|apr|maj|jun[i]?|jul[i]?|aug|sep|okt|nov|dec)\.?/i,
  wide: /^(januari|februari|mars|april|maj|juni|juli|augusti|september|oktober|november|december)/i,
};
const parseMonthPatterns$c = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$c = {
  narrow: /^[smtofl]/i,
  short: /^(sÃ¶|mÃ¥|ti|on|to|fr|lÃ¶)/i,
  abbreviated: /^(sÃ¶n|mÃ¥n|tis|ons|tors|fre|lÃ¶r)/i,
  wide: /^(sÃ¶ndag|mÃ¥ndag|tisdag|onsdag|torsdag|fredag|lÃ¶rdag)/i,
};
const parseDayPatterns$c = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i],
};

const matchDayPeriodPatterns$c = {
  any: /^([fe]\.?\s?m\.?|midn(att)?|midd(ag)?|(pÃ¥) (morgonen|eftermiddagen|kvÃ¤llen|natten))/i,
};
const parseDayPeriodPatterns$c = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /eftermiddag/i,
    evening: /kvÃ¤ll/i,
    night: /natt/i,
  },
};

(match$c.match = {
  ordinalNumber: (0, _index2$1Y.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$c,
    parsePattern: parseOrdinalNumberPattern$c,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4G.buildMatchFn)({
    matchPatterns: matchEraPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$c,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4G.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$c,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4G.buildMatchFn)({
    matchPatterns: matchMonthPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$c,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4G.buildMatchFn)({
    matchPatterns: matchDayPatterns$c,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$c,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4G.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$c,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$c,
    defaultParseWidth: "any",
  }),
});

sv.sv = void 0;
var _index$4F = formatDistance$r;
var _index2$1X = formatLong$c;
var _index3$_ = formatRelative$r;
var _index4$u = localize$c;
var _index5$l = match$c;

/**
 * @category Locales
 * @summary Swedish locale.
 * @language Swedish
 * @iso-639-2 swe
 * @author Johannes UlÃ©n [@ejulen](https://github.com/ejulen)
 * @author Alexander Nanberg [@alexandernanberg](https://github.com/alexandernanberg)
 * @author Henrik Andersson [@limelights](https://github.com/limelights)
 */
(sv.sv = {
  code: "sv",
  formatDistance: _index$4F.formatDistance,
  formatLong: _index2$1X.formatLong,
  formatRelative: _index3$_.formatRelative,
  localize: _index4$u.localize,
  match: _index5$l.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var ta = {};

var formatDistance$p = {};

formatDistance$p.formatDistance = void 0;

function isPluralType(val) {
  return val.one !== undefined;
}

const formatDistanceLocale$b = {
  lessThanXSeconds: {
    one: {
      default: "à®à®°à¯ à®µà®¿à®©à®¾à®à®¿à®à¯à®à¯ à®à¯à®±à¯à®µà®¾à®",
      in: "à®à®°à¯ à®µà®¿à®©à®¾à®à®¿à®à¯à®à¯à®³à¯",
      ago: "à®à®°à¯ à®µà®¿à®©à®¾à®à®¿à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®µà®¿à®©à®¾à®à®¿à®à®³à¯à®à¯à®à¯ à®à¯à®±à¯à®µà®¾à®",
      in: "{{count}} à®µà®¿à®©à®¾à®à®¿à®à®³à¯à®à¯à®à¯à®³à¯",
      ago: "{{count}} à®µà®¿à®©à®¾à®à®¿à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xSeconds: {
    one: {
      default: "1 à®µà®¿à®©à®¾à®à®¿",
      in: "1 à®µà®¿à®©à®¾à®à®¿à®¯à®¿à®²à¯",
      ago: "1 à®µà®¿à®©à®¾à®à®¿ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®µà®¿à®¨à®¾à®à®¿à®à®³à¯",
      in: "{{count}} à®µà®¿à®©à®¾à®à®¿à®à®³à®¿à®²à¯",
      ago: "{{count}} à®µà®¿à®¨à®¾à®à®¿à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  halfAMinute: {
    default: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯",
    in: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®¤à¯à®¤à®¿à®²à¯",
    ago: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
  },

  lessThanXMinutes: {
    one: {
      default: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®¤à¯à®¤à®¿à®±à¯à®à¯à®®à¯ à®à¯à®±à¯à®µà®¾à®",
      in: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®¤à¯à®¤à®¿à®±à¯à®à¯à®³à¯",
      ago: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯à®à¯à®à¯à®®à¯ à®à¯à®±à¯à®µà®¾à®",
      in: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯à®à¯à®à¯à®³à¯",
      ago: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xMinutes: {
    one: {
      default: "1 à®¨à®¿à®®à®¿à®à®®à¯",
      in: "1 à®¨à®¿à®®à®¿à®à®¤à¯à®¤à®¿à®²à¯",
      ago: "1 à®¨à®¿à®®à®¿à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯",
      in: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  aboutXHours: {
    one: {
      default: "à®à¯à®®à®¾à®°à¯ 1 à®®à®£à®¿ à®¨à¯à®°à®®à¯",
      in: "à®à¯à®®à®¾à®°à¯ 1 à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ 1 à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®£à®¿ à®¨à¯à®°à®®à¯",
      in: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
      ago: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®²à¯",
    },
  },

  xHours: {
    one: {
      default: "1 à®®à®£à®¿ à®¨à¯à®°à®®à¯",
      in: "1 à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®²à¯",
      ago: "1 à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®®à®£à®¿ à®¨à¯à®°à®®à¯",
      in: "{{count}} à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®²à¯",
      ago: "{{count}} à®®à®£à®¿ à®¨à¯à®°à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xDays: {
    one: {
      default: "1 à®¨à®¾à®³à¯",
      in: "1 à®¨à®¾à®³à®¿à®²à¯",
      ago: "1 à®¨à®¾à®³à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®¨à®¾à®à¯à®à®³à¯",
      in: "{{count}} à®¨à®¾à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®¨à®¾à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  aboutXWeeks: {
    one: {
      default: "à®à¯à®®à®¾à®°à¯ 1 à®µà®¾à®°à®®à¯",
      in: "à®à¯à®®à®¾à®°à¯ 1 à®µà®¾à®°à®¤à¯à®¤à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ 1 à®µà®¾à®°à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "à®à¯à®®à®¾à®°à¯ {{count}} à®µà®¾à®°à®à¯à®à®³à¯",
      in: "à®à¯à®®à®¾à®°à¯ {{count}} à®µà®¾à®°à®à¯à®à®³à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ {{count}} à®µà®¾à®°à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xWeeks: {
    one: {
      default: "1 à®µà®¾à®°à®®à¯",
      in: "1 à®µà®¾à®°à®¤à¯à®¤à®¿à®²à¯",
      ago: "1 à®µà®¾à®°à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®µà®¾à®°à®à¯à®à®³à¯",
      in: "{{count}} à®µà®¾à®°à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®µà®¾à®°à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  aboutXMonths: {
    one: {
      default: "à®à¯à®®à®¾à®°à¯ 1 à®®à®¾à®¤à®®à¯",
      in: "à®à¯à®®à®¾à®°à¯ 1 à®®à®¾à®¤à®¤à¯à®¤à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ 1 à®®à®¾à®¤à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®¾à®¤à®à¯à®à®³à¯",
      in: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®¾à®¤à®à¯à®à®³à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ {{count}} à®®à®¾à®¤à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xMonths: {
    one: {
      default: "1 à®®à®¾à®¤à®®à¯",
      in: "1 à®®à®¾à®¤à®¤à¯à®¤à®¿à®²à¯",
      ago: "1 à®®à®¾à®¤à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®®à®¾à®¤à®à¯à®à®³à¯",
      in: "{{count}} à®®à®¾à®¤à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®®à®¾à®¤à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  aboutXYears: {
    one: {
      default: "à®à¯à®®à®¾à®°à¯ 1 à®µà®°à¯à®à®®à¯",
      in: "à®à¯à®®à®¾à®°à¯ 1 à®à®£à¯à®à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ 1 à®µà®°à¯à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "à®à¯à®®à®¾à®°à¯ {{count}} à®à®£à¯à®à¯à®à®³à¯",
      in: "à®à¯à®®à®¾à®°à¯ {{count}} à®à®£à¯à®à¯à®à®³à®¿à®²à¯",
      ago: "à®à¯à®®à®¾à®°à¯ {{count}} à®à®£à¯à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  xYears: {
    one: {
      default: "1 à®µà®°à¯à®à®®à¯",
      in: "1 à®à®£à¯à®à®¿à®²à¯",
      ago: "1 à®µà®°à¯à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®à®£à¯à®à¯à®à®³à¯",
      in: "{{count}} à®à®£à¯à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®à®£à¯à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  overXYears: {
    one: {
      default: "1 à®µà®°à¯à®à®¤à¯à®¤à®¿à®±à¯à®à¯ à®®à¯à®²à¯",
      in: "1 à®µà®°à¯à®à®¤à¯à®¤à®¿à®±à¯à®à¯à®®à¯ à®®à¯à®²à®¾à®",
      ago: "1 à®µà®°à¯à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "{{count}} à®à®£à¯à®à¯à®à®³à¯à®à¯à®à¯à®®à¯ à®®à¯à®²à®¾à®",
      in: "{{count}} à®à®£à¯à®à¯à®à®³à®¿à®²à¯",
      ago: "{{count}} à®à®£à¯à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },

  almostXYears: {
    one: {
      default: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® 1 à®µà®°à¯à®à®®à¯",
      in: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® 1 à®à®£à¯à®à®¿à®²à¯",
      ago: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® 1 à®µà®°à¯à®à®®à¯ à®®à¯à®©à¯à®ªà¯",
    },
    other: {
      default: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® {{count}} à®à®£à¯à®à¯à®à®³à¯",
      in: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® {{count}} à®à®£à¯à®à¯à®à®³à®¿à®²à¯",
      ago: "à®à®¿à®à¯à®à®¤à¯à®¤à®à¯à® {{count}} à®à®£à¯à®à¯à®à®³à¯à®à¯à®à¯ à®®à¯à®©à¯à®ªà¯",
    },
  },
};

const formatDistance$o = (token, count, options) => {
  const tense = options?.addSuffix
    ? options.comparison && options.comparison > 0
      ? "in"
      : "ago"
    : "default";

  const tokenValue = formatDistanceLocale$b[token];

  if (!isPluralType(tokenValue)) return tokenValue[tense];

  if (count === 1) {
    return tokenValue.one[tense];
  } else {
    return tokenValue.other[tense].replace("{{count}}", String(count));
  }
};
formatDistance$p.formatDistance = formatDistance$o;

var formatLong$b = {};

formatLong$b.formatLong = void 0;
var _index$4E = buildFormatLongFn$1;

// Ref: https://www.unicode.org/cldr/charts/32/summary/ta.html

// CLDR #1846 - #1849
const dateFormats$b = {
  full: "EEEE, d MMMM, y",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "d/M/yy",
};

// CLDR #1850 - #1853
const timeFormats$b = {
  full: "a h:mm:ss zzzz",
  long: "a h:mm:ss z",
  medium: "a h:mm:ss",
  short: "a h:mm",
};

const dateTimeFormats$b = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$b.formatLong = {
  date: (0, _index$4E.buildFormatLongFn)({
    formats: dateFormats$b,
    defaultWidth: "full",
  }),

  time: (0, _index$4E.buildFormatLongFn)({
    formats: timeFormats$b,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4E.buildFormatLongFn)({
    formats: dateTimeFormats$b,
    defaultWidth: "full",
  }),
});

var formatRelative$p = {};

formatRelative$p.formatRelative = void 0;

const formatRelativeLocale$b = {
  lastWeek: "'à®à®à®¨à¯à®¤' eeee p 'à®®à®£à®¿à®à¯à®à¯'",
  yesterday: "'à®¨à¯à®±à¯à®±à¯ ' p 'à®®à®£à®¿à®à¯à®à¯'",
  today: "'à®à®©à¯à®±à¯ ' p 'à®®à®£à®¿à®à¯à®à¯'",
  tomorrow: "'à®¨à®¾à®³à¯ ' p 'à®®à®£à®¿à®à¯à®à¯'",
  nextWeek: "eeee p 'à®®à®£à®¿à®à¯à®à¯'",
  other: "P",
};

const formatRelative$o = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$b[token];
formatRelative$p.formatRelative = formatRelative$o;

var localize$b = {};

localize$b.localize = void 0;
var _index$4D = buildLocalizeFn$1;

// Ref: https://www.unicode.org/cldr/charts/32/summary/ta.html

const eraValues$b = {
  narrow: ["à®à®¿.à®®à¯.", "à®à®¿.à®ªà®¿."],
  abbreviated: ["à®à®¿.à®®à¯.", "à®à®¿.à®ªà®¿."], // CLDR #1624, #1626
  wide: ["à®à®¿à®±à®¿à®¸à¯à®¤à¯à®µà¯à®à¯à®à¯ à®®à¯à®©à¯", "à®à®©à¯à®©à¯ à®à¯à®®à®¿à®©à®¿"], // CLDR #1620, #1622
};

const quarterValues$b = {
  // CLDR #1644 - #1647
  narrow: ["1", "2", "3", "4"],
  // CLDR #1636 - #1639
  abbreviated: ["à®à®¾à®²à®¾.1", "à®à®¾à®²à®¾.2", "à®à®¾à®²à®¾.3", "à®à®¾à®²à®¾.4"],
  // CLDR #1628 - #1631
  wide: [
    "à®à®©à¯à®±à®¾à®®à¯ à®à®¾à®²à®¾à®£à¯à®à¯",
    "à®à®°à®£à¯à®à®¾à®®à¯ à®à®¾à®²à®¾à®£à¯à®à¯",
    "à®®à¯à®©à¯à®±à®¾à®®à¯ à®à®¾à®²à®¾à®£à¯à®à¯",
    "à®¨à®¾à®©à¯à®à®¾à®®à¯ à®à®¾à®²à®¾à®£à¯à®à¯",
  ],
};

const monthValues$b = {
  // CLDR #700 - #711
  narrow: ["à®", "à®ªà®¿", "à®®à®¾", "à®", "à®®à¯", "à®à¯", "à®à¯", "à®", "à®à¯", "à®", "à®¨", "à®à®¿"],

  // CLDR #1676 - #1687
  abbreviated: [
    "à®à®©.",
    "à®ªà®¿à®ªà¯.",
    "à®®à®¾à®°à¯.",
    "à®à®ªà¯.",
    "à®®à¯",
    "à®à¯à®©à¯",
    "à®à¯à®²à¯",
    "à®à®.",
    "à®à¯à®ªà¯.",
    "à®à®à¯.",
    "à®¨à®µ.",
    "à®à®¿à®.",
  ],

  // CLDR #1652 - #1663
  wide: [
    "à®à®©à®µà®°à®¿", // January
    "à®ªà®¿à®ªà¯à®°à®µà®°à®¿", // February
    "à®®à®¾à®°à¯à®à¯", // March
    "à®à®ªà¯à®°à®²à¯", // April
    "à®®à¯", // May
    "à®à¯à®©à¯", // June
    "à®à¯à®²à¯", // July
    "à®à®à®¸à¯à®à¯", // August
    "à®à¯à®ªà¯à®à®®à¯à®ªà®°à¯", // September
    "à®à®à¯à®à¯à®ªà®°à¯", // October
    "à®¨à®µà®®à¯à®ªà®°à¯", // November
    "à®à®¿à®à®®à¯à®ªà®°à¯", // December
  ],
};

const dayValues$b = {
  // CLDR #1766 - #1772
  narrow: ["à®à®¾", "à®¤à®¿", "à®à¯", "à®ªà¯", "à®µà®¿", "à®µà¯", "à®"],
  // CLDR #1752 - #1758
  short: ["à®à®¾", "à®¤à®¿", "à®à¯", "à®ªà¯", "à®µà®¿", "à®µà¯", "à®"],
  // CLDR #1738 - #1744
  abbreviated: ["à®à®¾à®¯à®¿.", "à®¤à®¿à®à¯.", "à®à¯à®µà¯.", "à®ªà¯à®¤.", "à®µà®¿à®¯à®¾.", "à®µà¯à®³à¯.", "à®à®©à®¿"],

  // CLDR #1724 - #1730
  wide: [
    "à®à®¾à®¯à®¿à®±à¯", // Sunday
    "à®¤à®¿à®à¯à®à®³à¯", // Monday
    "à®à¯à®µà¯à®µà®¾à®¯à¯", // Tuesday
    "à®ªà¯à®¤à®©à¯", // Wednesday
    "à®µà®¿à®¯à®¾à®´à®©à¯", // Thursday
    "à®µà¯à®³à¯à®³à®¿", // Friday
    "à®à®©à®¿", // Saturday
  ],
};

// CLDR #1780 - #1845
const dayPeriodValues$b = {
  narrow: {
    am: "à®®à¯.à®ª",
    pm: "à®ªà®¿.à®ª",
    midnight: "à®¨à®³à¯.",
    noon: "à®¨à®£à¯.",
    morning: "à®à®¾.",
    afternoon: "à®®à®¤à®¿.",
    evening: "à®®à®¾.",
    night: "à®à®°.",
  },
  abbreviated: {
    am: "à®®à¯à®±à¯à®ªà®à®²à¯",
    pm: "à®ªà®¿à®±à¯à®ªà®à®²à¯",
    midnight: "à®¨à®³à¯à®³à®¿à®°à®µà¯",
    noon: "à®¨à®£à¯à®ªà®à®²à¯",
    morning: "à®à®¾à®²à¯",
    afternoon: "à®®à®¤à®¿à®¯à®®à¯",
    evening: "à®®à®¾à®²à¯",
    night: "à®à®°à®µà¯",
  },
  wide: {
    am: "à®®à¯à®±à¯à®ªà®à®²à¯",
    pm: "à®ªà®¿à®±à¯à®ªà®à®²à¯",
    midnight: "à®¨à®³à¯à®³à®¿à®°à®µà¯",
    noon: "à®¨à®£à¯à®ªà®à®²à¯",
    morning: "à®à®¾à®²à¯",
    afternoon: "à®®à®¤à®¿à®¯à®®à¯",
    evening: "à®®à®¾à®²à¯",
    night: "à®à®°à®µà¯",
  },
};

// CLDR #1780 - #1845
const formattingDayPeriodValues$b = {
  narrow: {
    am: "à®®à¯.à®ª",
    pm: "à®ªà®¿.à®ª",
    midnight: "à®¨à®³à¯.",
    noon: "à®¨à®£à¯.",
    morning: "à®à®¾.",
    afternoon: "à®®à®¤à®¿.",
    evening: "à®®à®¾.",
    night: "à®à®°.",
  },
  abbreviated: {
    am: "à®®à¯à®±à¯à®ªà®à®²à¯",
    pm: "à®ªà®¿à®±à¯à®ªà®à®²à¯",
    midnight: "à®¨à®³à¯à®³à®¿à®°à®µà¯",
    noon: "à®¨à®£à¯à®ªà®à®²à¯",
    morning: "à®à®¾à®²à¯",
    afternoon: "à®®à®¤à®¿à®¯à®®à¯",
    evening: "à®®à®¾à®²à¯",
    night: "à®à®°à®µà¯",
  },
  wide: {
    am: "à®®à¯à®±à¯à®ªà®à®²à¯",
    pm: "à®ªà®¿à®±à¯à®ªà®à®²à¯",
    midnight: "à®¨à®³à¯à®³à®¿à®°à®µà¯",
    noon: "à®¨à®£à¯à®ªà®à®²à¯",
    morning: "à®à®¾à®²à¯",
    afternoon: "à®®à®¤à®¿à®¯à®®à¯",
    evening: "à®®à®¾à®²à¯",
    night: "à®à®°à®µà¯",
  },
};

const ordinalNumber$b = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$b.localize = {
  ordinalNumber: ordinalNumber$b,

  era: (0, _index$4D.buildLocalizeFn)({
    values: eraValues$b,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4D.buildLocalizeFn)({
    values: quarterValues$b,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4D.buildLocalizeFn)({
    values: monthValues$b,
    defaultWidth: "wide",
  }),

  day: (0, _index$4D.buildLocalizeFn)({
    values: dayValues$b,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4D.buildLocalizeFn)({
    values: dayPeriodValues$b,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$b,
    defaultFormattingWidth: "wide",
  }),
});

var match$b = {};

match$b.match = void 0;

var _index$4C = buildMatchFn$1;
var _index2$1W = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$b = /^(\d+)(à®µà®¤à¯)?/i;
const parseOrdinalNumberPattern$b = /\d+/i;

const matchEraPatterns$b = {
  narrow: /^(à®à®¿.à®®à¯.|à®à®¿.à®ªà®¿.)/i,
  abbreviated: /^(à®à®¿\.?\s?à®®à¯\.?|à®à®¿\.?\s?à®ªà®¿\.?)/,
  wide: /^(à®à®¿à®±à®¿à®¸à¯à®¤à¯à®µà¯à®à¯à®à¯\sà®®à¯à®©à¯|à®à®©à¯à®©à¯\sà®à¯à®®à®¿à®©à®¿)/i,
};
const parseEraPatterns$b = {
  any: [/à®à®¿\.?\s?à®®à¯\.?/, /à®à®¿\.?\s?à®ªà®¿\.?/],
};

const matchQuarterPatterns$b = {
  narrow: /^[1234]/i,
  abbreviated: /^à®à®¾à®²à®¾.[1234]/i,
  wide: /^(à®à®©à¯à®±à®¾à®®à¯|à®à®°à®£à¯à®à®¾à®®à¯|à®®à¯à®©à¯à®±à®¾à®®à¯|à®¨à®¾à®©à¯à®à®¾à®®à¯) à®à®¾à®²à®¾à®£à¯à®à¯/i,
};
const parseQuarterPatterns$b = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [
    /(1|à®à®¾à®²à®¾.1|à®à®©à¯à®±à®¾à®®à¯)/i,
    /(2|à®à®¾à®²à®¾.2|à®à®°à®£à¯à®à®¾à®®à¯)/i,
    /(3|à®à®¾à®²à®¾.3|à®®à¯à®©à¯à®±à®¾à®®à¯)/i,
    /(4|à®à®¾à®²à®¾.4|à®¨à®¾à®©à¯à®à®¾à®®à¯)/i,
  ],
};

const matchMonthPatterns$b = {
  narrow: /^(à®|à®ªà®¿|à®®à®¾|à®|à®®à¯|à®à¯|à®|à®à¯|à®|à®¨|à®à®¿)$/i,
  abbreviated: /^(à®à®©.|à®ªà®¿à®ªà¯.|à®®à®¾à®°à¯.|à®à®ªà¯.|à®®à¯|à®à¯à®©à¯|à®à¯à®²à¯|à®à®.|à®à¯à®ªà¯.|à®à®à¯.|à®¨à®µ.|à®à®¿à®.)/i,
  wide: /^(à®à®©à®µà®°à®¿|à®ªà®¿à®ªà¯à®°à®µà®°à®¿|à®®à®¾à®°à¯à®à¯|à®à®ªà¯à®°à®²à¯|à®®à¯|à®à¯à®©à¯|à®à¯à®²à¯|à®à®à®¸à¯à®à¯|à®à¯à®ªà¯à®à®®à¯à®ªà®°à¯|à®à®à¯à®à¯à®ªà®°à¯|à®¨à®µà®®à¯à®ªà®°à¯|à®à®¿à®à®®à¯à®ªà®°à¯)/i,
};
const parseMonthPatterns$b = {
  narrow: [
    /^à®$/i,
    /^à®ªà®¿/i,
    /^à®®à®¾/i,
    /^à®/i,
    /^à®®à¯/i,
    /^à®à¯/i,
    /^à®à¯/i,
    /^à®/i,
    /^à®à¯/i,
    /^à®/i,
    /^à®¨/i,
    /^à®à®¿/i,
  ],

  any: [
    /^à®à®©/i,
    /^à®ªà®¿/i,
    /^à®®à®¾/i,
    /^à®/i,
    /^à®®à¯/i,
    /^à®à¯à®©à¯/i,
    /^à®à¯à®²à¯/i,
    /^à®/i,
    /^à®à¯/i,
    /^à®/i,
    /^à®¨/i,
    /^à®à®¿/i,
  ],
};

const matchDayPatterns$b = {
  narrow: /^(à®à®¾|à®¤à®¿|à®à¯|à®ªà¯|à®µà®¿|à®µà¯|à®)/i,
  short: /^(à®à®¾|à®¤à®¿|à®à¯|à®ªà¯|à®µà®¿|à®µà¯|à®)/i,
  abbreviated: /^(à®à®¾à®¯à®¿.|à®¤à®¿à®à¯.|à®à¯à®µà¯.|à®ªà¯à®¤.|à®µà®¿à®¯à®¾.|à®µà¯à®³à¯.|à®à®©à®¿)/i,
  wide: /^(à®à®¾à®¯à®¿à®±à¯|à®¤à®¿à®à¯à®à®³à¯|à®à¯à®µà¯à®µà®¾à®¯à¯|à®ªà¯à®¤à®©à¯|à®µà®¿à®¯à®¾à®´à®©à¯|à®µà¯à®³à¯à®³à®¿|à®à®©à®¿)/i,
};
const parseDayPatterns$b = {
  narrow: [/^à®à®¾/i, /^à®¤à®¿/i, /^à®à¯/i, /^à®ªà¯/i, /^à®µà®¿/i, /^à®µà¯/i, /^à®/i],
  any: [/^à®à®¾/i, /^à®¤à®¿/i, /^à®à¯/i, /^à®ªà¯/i, /^à®µà®¿/i, /^à®µà¯/i, /^à®/i],
};

const matchDayPeriodPatterns$b = {
  narrow: /^(à®®à¯.à®ª|à®ªà®¿.à®ª|à®¨à®³à¯|à®¨à®£à¯|à®à®¾à®²à¯|à®®à®¤à®¿à®¯à®®à¯|à®®à®¾à®²à¯|à®à®°à®µà¯)/i,
  any: /^(à®®à¯.à®ª|à®ªà®¿.à®ª|à®®à¯à®±à¯à®ªà®à®²à¯|à®ªà®¿à®±à¯à®ªà®à®²à¯|à®¨à®³à¯à®³à®¿à®°à®µà¯|à®¨à®£à¯à®ªà®à®²à¯|à®à®¾à®²à¯|à®®à®¤à®¿à®¯à®®à¯|à®®à®¾à®²à¯|à®à®°à®µà¯)/i,
};
const parseDayPeriodPatterns$b = {
  any: {
    am: /^à®®à¯/i,
    pm: /^à®ªà®¿/i,
    midnight: /^à®¨à®³à¯/i,
    noon: /^à®¨à®£à¯/i,
    morning: /à®à®¾à®²à¯/i,
    afternoon: /à®®à®¤à®¿à®¯à®®à¯/i,
    evening: /à®®à®¾à®²à¯/i,
    night: /à®à®°à®µà¯/i,
  },
};

(match$b.match = {
  ordinalNumber: (0, _index2$1W.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$b,
    parsePattern: parseOrdinalNumberPattern$b,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4C.buildMatchFn)({
    matchPatterns: matchEraPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$b,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4C.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$b,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4C.buildMatchFn)({
    matchPatterns: matchMonthPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$b,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4C.buildMatchFn)({
    matchPatterns: matchDayPatterns$b,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$b,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4C.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$b,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$b,
    defaultParseWidth: "any",
  }),
});

ta.ta = void 0;
var _index$4B = formatDistance$p;
var _index2$1V = formatLong$b;
var _index3$Z = formatRelative$p;
var _index4$t = localize$b;
var _index5$k = match$b;

/**
 * @category Locales
 * @summary Tamil locale (India).
 * @language Tamil
 * @iso-639-2 tam
 * @author Sibiraj [@sibiraj-s](https://github.com/sibiraj-s)
 */
(ta.ta = {
  code: "ta",
  formatDistance: _index$4B.formatDistance,
  formatLong: _index2$1V.formatLong,
  formatRelative: _index3$Z.formatRelative,
  localize: _index4$t.localize,
  match: _index5$k.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var te = {};

var formatDistance$n = {};

formatDistance$n.formatDistance = void 0;

// Source: https://www.unicode.org/cldr/charts/32/summary/te.html

const formatDistanceLocale$a = {
  lessThanXSeconds: {
    standalone: {
      one: "à°¸à±à°à°¨à± à°à°¨à±à°¨à°¾ à°¤à°à±à°à±à°µ",
      other: "{{count}} à°¸à±à°à°¨à±à°² à°à°¨à±à°¨à°¾ à°¤à°à±à°à±à°µ",
    },
    withPreposition: {
      one: "à°¸à±à°à°¨à±",
      other: "{{count}} à°¸à±à°à°¨à±à°²",
    },
  },

  xSeconds: {
    standalone: {
      one: "à°à° à°¸à±à°à°¨à±", // CLDR #1314
      other: "{{count}} à°¸à±à°à°¨à±à°²",
    },
    withPreposition: {
      one: "à°à° à°¸à±à°à°¨à±",
      other: "{{count}} à°¸à±à°à°¨à±à°²",
    },
  },

  halfAMinute: {
    standalone: "à°à°° à°¨à°¿à°®à°¿à°·à°",
    withPreposition: "à°à°° à°¨à°¿à°®à°¿à°·à°",
  },

  lessThanXMinutes: {
    standalone: {
      one: "à°à° à°¨à°¿à°®à°¿à°·à° à°à°¨à±à°¨à°¾ à°¤à°à±à°à±à°µ",
      other: "{{count}} à°¨à°¿à°®à°¿à°·à°¾à°² à°à°¨à±à°¨à°¾ à°¤à°à±à°à±à°µ",
    },
    withPreposition: {
      one: "à°à° à°¨à°¿à°®à°¿à°·à°",
      other: "{{count}} à°¨à°¿à°®à°¿à°·à°¾à°²",
    },
  },

  xMinutes: {
    standalone: {
      one: "à°à° à°¨à°¿à°®à°¿à°·à°", // CLDR #1311
      other: "{{count}} à°¨à°¿à°®à°¿à°·à°¾à°²à±",
    },
    withPreposition: {
      one: "à°à° à°¨à°¿à°®à°¿à°·à°", // CLDR #1311
      other: "{{count}} à°¨à°¿à°®à°¿à°·à°¾à°²",
    },
  },

  aboutXHours: {
    standalone: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°à°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°à°à°à°²à±",
    },
    withPreposition: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°à°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°à°à°à°²",
    },
  },

  xHours: {
    standalone: {
      one: "à°à° à°à°à°", // CLDR #1308
      other: "{{count}} à°à°à°à°²à±",
    },
    withPreposition: {
      one: "à°à° à°à°à°",
      other: "{{count}} à°à°à°à°²",
    },
  },

  xDays: {
    standalone: {
      one: "à°à° à°°à±à°à±", // CLDR #1292
      other: "{{count}} à°°à±à°à±à°²à±",
    },
    withPreposition: {
      one: "à°à° à°°à±à°à±",
      other: "{{count}} à°°à±à°à±à°²",
    },
  },

  aboutXWeeks: {
    standalone: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°µà°¾à°°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°µà°¾à°°à°¾à°²à±",
    },
    withPreposition: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°µà°¾à°°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°µà°¾à°°à°¾à°²à°²",
    },
  },

  xWeeks: {
    standalone: {
      one: "à°à° à°µà°¾à°°à°",
      other: "{{count}} à°µà°¾à°°à°¾à°²à±",
    },
    withPreposition: {
      one: "à°à° à°µà°¾à°°à°",
      other: "{{count}} à°µà°¾à°°à°¾à°²à°²",
    },
  },

  aboutXMonths: {
    standalone: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°¨à±à°²",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°¨à±à°²à°²à±",
    },
    withPreposition: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°¨à±à°²",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°¨à±à°²à°²",
    },
  },

  xMonths: {
    standalone: {
      one: "à°à° à°¨à±à°²", // CLDR #1281
      other: "{{count}} à°¨à±à°²à°²à±",
    },
    withPreposition: {
      one: "à°à° à°¨à±à°²",
      other: "{{count}} à°¨à±à°²à°²",
    },
  },

  aboutXYears: {
    standalone: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±",
    },
    withPreposition: {
      one: "à°¸à±à°®à°¾à°°à± à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "à°¸à±à°®à°¾à°°à± {{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²",
    },
  },

  xYears: {
    standalone: {
      one: "à°à° à°¸à°à°µà°¤à±à°¸à°°à°", // CLDR #1275
      other: "{{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±",
    },
    withPreposition: {
      one: "à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "{{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²",
    },
  },

  overXYears: {
    standalone: {
      one: "à°à° à°¸à°à°µà°¤à±à°¸à°°à° à°ªà±à°à°¾",
      other: "{{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à°à± à°ªà±à°à°¾",
    },
    withPreposition: {
      one: "à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "{{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²",
    },
  },

  almostXYears: {
    standalone: {
      one: "à°¦à°¾à°¦à°¾à°ªà± à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "à°¦à°¾à°¦à°¾à°ªà± {{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²à±",
    },
    withPreposition: {
      one: "à°¦à°¾à°¦à°¾à°ªà± à°à° à°¸à°à°µà°¤à±à°¸à°°à°",
      other: "à°¦à°¾à°¦à°¾à°ªà± {{count}} à°¸à°à°µà°¤à±à°¸à°°à°¾à°²",
    },
  },
};

const formatDistance$m = (token, count, options) => {
  let result;

  const tokenValue = options?.addSuffix
    ? formatDistanceLocale$a[token].withPreposition
    : formatDistanceLocale$a[token].standalone;

  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "à°²à±";
    } else {
      return result + " à°à±à°°à°¿à°¤à°";
    }
  }

  return result;
};
formatDistance$n.formatDistance = formatDistance$m;

var formatLong$a = {};

formatLong$a.formatLong = void 0;
var _index$4A = buildFormatLongFn$1;

// Source: https://www.unicode.org/cldr/charts/32/summary/te.html

// CLDR #1807 - #1811
const dateFormats$a = {
  full: "d, MMMM y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd-MM-yy",
};

// CLDR #1807 - #1811
const timeFormats$a = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

// CLDR #1815 - #1818
const dateTimeFormats$a = {
  full: "{{date}} {{time}}'à°à°¿'",
  long: "{{date}} {{time}}'à°à°¿'",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$a.formatLong = {
  date: (0, _index$4A.buildFormatLongFn)({
    formats: dateFormats$a,
    defaultWidth: "full",
  }),

  time: (0, _index$4A.buildFormatLongFn)({
    formats: timeFormats$a,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4A.buildFormatLongFn)({
    formats: dateTimeFormats$a,
    defaultWidth: "full",
  }),
});

var formatRelative$n = {};

formatRelative$n.formatRelative = void 0;

// Source: https://www.unicode.org/cldr/charts/32/summary/te.html

const formatRelativeLocale$a = {
  lastWeek: "'à°à°¤' eeee p", // CLDR #1384
  yesterday: "'à°¨à°¿à°¨à±à°¨' p", // CLDR #1393
  today: "'à° à°°à±à°à±' p", // CLDR #1394
  tomorrow: "'à°°à±à°ªà±' p", // CLDR #1395
  nextWeek: "'à°¤à°¦à±à°ªà°°à°¿' eeee p", // CLDR #1386
  other: "P",
};

const formatRelative$m = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$a[token];
formatRelative$n.formatRelative = formatRelative$m;

var localize$a = {};

localize$a.localize = void 0;
var _index$4z = buildLocalizeFn$1;

// Source: https://www.unicode.org/cldr/charts/32/summary/te.html
// Source: https://dsal.uchicago.edu/dictionaries/brown/

// CLDR #1605 - #1608
const eraValues$a = {
  narrow: ["à°à±à°°à±.à°ªà±.", "à°à±à°°à±.à°¶."],
  abbreviated: ["à°à±à°°à±.à°ªà±.", "à°à±à°°à±.à°¶."],
  wide: ["à°à±à°°à±à°¸à±à°¤à± à°ªà±à°°à±à°µà°", "à°à±à°°à±à°¸à±à°¤à±à°¶à°à°"],
};

// CLDR #1613 - #1628
const quarterValues$a = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["à°¤à±à°°à±1", "à°¤à±à°°à±2", "à°¤à±à°°à±3", "à°¤à±à°°à±4"],
  wide: ["1à°µ à°¤à±à°°à±à°®à°¾à°¸à°¿à°à°", "2à°µ à°¤à±à°°à±à°®à°¾à°¸à°¿à°à°", "3à°µ à°¤à±à°°à±à°®à°¾à°¸à°¿à°à°", "4à°µ à°¤à±à°°à±à°®à°¾à°¸à°¿à°à°"],
};

// CLDR #1637 - #1708
const monthValues$a = {
  narrow: ["à°", "à°«à°¿", "à°®à°¾", "à°", "à°®à±", "à°à±", "à°à±", "à°", "à°¸à±", "à°", "à°¨", "à°¡à°¿"],

  abbreviated: [
    "à°à°¨",
    "à°«à°¿à°¬à±à°°",
    "à°®à°¾à°°à±à°à°¿",
    "à°à°ªà±à°°à°¿",
    "à°®à±",
    "à°à±à°¨à±",
    "à°à±à°²à±",
    "à°à°",
    "à°¸à±à°ªà±à°à±à°",
    "à°à°à±à°à±",
    "à°¨à°µà°",
    "à°¡à°¿à°¸à±à°",
  ],

  wide: [
    "à°à°¨à°µà°°à°¿",
    "à°«à°¿à°¬à±à°°à°µà°°à°¿",
    "à°®à°¾à°°à±à°à°¿",
    "à°à°ªà±à°°à°¿à°²à±",
    "à°®à±",
    "à°à±à°¨à±",
    "à°à±à°²à±",
    "à°à°à°¸à±à°à±",
    "à°¸à±à°ªà±à°à±à°à°¬à°°à±",
    "à°à°à±à°à±à°¬à°°à±",
    "à°¨à°µà°à°¬à°°à±",
    "à°¡à°¿à°¸à±à°à°¬à°°à±",
  ],
};

// CLDR #1709 - #1764
const dayValues$a = {
  narrow: ["à°", "à°¸à±", "à°®", "à°¬à±", "à°à±", "à°¶à±", "à°¶"],
  short: ["à°à°¦à°¿", "à°¸à±à°®", "à°®à°à°à°³", "à°¬à±à°§", "à°à±à°°à±", "à°¶à±à°à±à°°", "à°¶à°¨à°¿"],
  abbreviated: ["à°à°¦à°¿", "à°¸à±à°®", "à°®à°à°à°³", "à°¬à±à°§", "à°à±à°°à±", "à°¶à±à°à±à°°", "à°¶à°¨à°¿"],
  wide: [
    "à°à°¦à°¿à°µà°¾à°°à°",
    "à°¸à±à°®à°µà°¾à°°à°",
    "à°®à°à°à°³à°µà°¾à°°à°",
    "à°¬à±à°§à°µà°¾à°°à°",
    "à°à±à°°à±à°µà°¾à°°à°",
    "à°¶à±à°à±à°°à°µà°¾à°°à°",
    "à°¶à°¨à°¿à°µà°¾à°°à°",
  ],
};

// CLDR #1767 - #1806
const dayPeriodValues$a = {
  narrow: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
  abbreviated: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
  wide: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
};

const formattingDayPeriodValues$a = {
  narrow: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
  abbreviated: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
  wide: {
    am: "à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°",
    pm: "à°à°ªà°°à°¾à°¹à±à°¨à°",
    midnight: "à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿",
    noon: "à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    morning: "à°à°¦à°¯à°",
    afternoon: "à°®à°§à±à°¯à°¾à°¹à±à°¨à°",
    evening: "à°¸à°¾à°¯à°à°¤à±à°°à°",
    night: "à°°à°¾à°¤à±à°°à°¿",
  },
};

const ordinalNumber$a = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + "à°µ";
};

(localize$a.localize = {
  ordinalNumber: ordinalNumber$a,

  era: (0, _index$4z.buildLocalizeFn)({
    values: eraValues$a,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4z.buildLocalizeFn)({
    values: quarterValues$a,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4z.buildLocalizeFn)({
    values: monthValues$a,
    defaultWidth: "wide",
  }),

  day: (0, _index$4z.buildLocalizeFn)({
    values: dayValues$a,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4z.buildLocalizeFn)({
    values: dayPeriodValues$a,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$a,
    defaultFormattingWidth: "wide",
  }),
});

var match$a = {};

match$a.match = void 0;

var _index$4y = buildMatchFn$1;
var _index2$1U = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$a = /^(\d+)(à°µ)?/i;
const parseOrdinalNumberPattern$a = /\d+/i;

const matchEraPatterns$a = {
  narrow: /^(à°à±à°°à±\.à°ªà±\.|à°à±à°°à±\.à°¶\.)/i,
  abbreviated:
    /^(à°à±à°°à±\.?\s?à°ªà±\.?|à°ªà±à°°\.?\s?à°¶\.?\s?à°ªà±\.?|à°à±à°°à±\.?\s?à°¶\.?|à°¸à°¾\.?\s?à°¶\.?)/i,
  wide: /^(à°à±à°°à±à°¸à±à°¤à± à°ªà±à°°à±à°µà°|à°ªà±à°°à°¸à±à°¤à±à°¤ à°¶à°à°¾à°¨à°¿à°à°¿ à°ªà±à°°à±à°µà°|à°à±à°°à±à°¸à±à°¤à± à°¶à°à°|à°ªà±à°°à°¸à±à°¤à±à°¤ à°¶à°à°)/i,
};
const parseEraPatterns$a = {
  any: [/^(à°ªà±|à°¶)/i, /^à°¸à°¾/i],
};

const matchQuarterPatterns$a = {
  narrow: /^[1234]/i,
  abbreviated: /^à°¤à±à°°à±[1234]/i,
  wide: /^[1234](à°µ)? à°¤à±à°°à±à°®à°¾à°¸à°¿à°à°/i,
};
const parseQuarterPatterns$a = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$a = {
  narrow: /^(à°à±|à°à±|à°|à°«à°¿|à°®à°¾|à°|à°®à±|à°|à°¸à±|à°|à°¨|à°¡à°¿)/i,
  abbreviated: /^(à°à°¨|à°«à°¿à°¬à±à°°|à°®à°¾à°°à±à°à°¿|à°à°ªà±à°°à°¿|à°®à±|à°à±à°¨à±|à°à±à°²à±|à°à°|à°¸à±à°ªà±|à°à°à±à°à±|à°¨à°µ|à°¡à°¿à°¸à±)/i,
  wide: /^(à°à°¨à°µà°°à°¿|à°«à°¿à°¬à±à°°à°µà°°à°¿|à°®à°¾à°°à±à°à°¿|à°à°ªà±à°°à°¿à°²à±|à°®à±|à°à±à°¨à±|à°à±à°²à±|à°à°à°¸à±à°à±|à°¸à±à°ªà±à°à±à°à°¬à°°à±|à°à°à±à°à±à°¬à°°à±|à°¨à°µà°à°¬à°°à±|à°¡à°¿à°¸à±à°à°¬à°°à±)/i,
};
const parseMonthPatterns$a = {
  narrow: [
    /^à°/i,
    /^à°«à°¿/i,
    /^à°®à°¾/i,
    /^à°/i,
    /^à°®à±/i,
    /^à°à±/i,
    /^à°à±/i,
    /^à°/i,
    /^à°¸à±/i,
    /^à°/i,
    /^à°¨/i,
    /^à°¡à°¿/i,
  ],

  any: [
    /^à°à°¨/i,
    /^à°«à°¿/i,
    /^à°®à°¾/i,
    /^à°/i,
    /^à°®à±/i,
    /^à°à±à°¨à±/i,
    /^à°à±à°²à±/i,
    /^à°à°/i,
    /^à°¸à±/i,
    /^à°/i,
    /^à°¨/i,
    /^à°¡à°¿/i,
  ],
};

const matchDayPatterns$a = {
  narrow: /^(à°|à°¸à±|à°®|à°¬à±|à°à±|à°¶à±|à°¶)/i,
  short: /^(à°à°¦à°¿|à°¸à±à°®|à°®à°|à°¬à±à°§|à°à±à°°à±|à°¶à±à°à±à°°|à°¶à°¨à°¿)/i,
  abbreviated: /^(à°à°¦à°¿|à°¸à±à°®|à°®à°|à°¬à±à°§|à°à±à°°à±|à°¶à±à°à±à°°|à°¶à°¨à°¿)/i,
  wide: /^(à°à°¦à°¿à°µà°¾à°°à°|à°¸à±à°®à°µà°¾à°°à°|à°®à°à°à°³à°µà°¾à°°à°|à°¬à±à°§à°µà°¾à°°à°|à°à±à°°à±à°µà°¾à°°à°|à°¶à±à°à±à°°à°µà°¾à°°à°|à°¶à°¨à°¿à°µà°¾à°°à°)/i,
};
const parseDayPatterns$a = {
  narrow: [/^à°/i, /^à°¸à±/i, /^à°®/i, /^à°¬à±/i, /^à°à±/i, /^à°¶à±/i, /^à°¶/i],
  any: [/^à°à°¦à°¿/i, /^à°¸à±à°®/i, /^à°®à°/i, /^à°¬à±à°§/i, /^à°à±à°°à±/i, /^à°¶à±à°à±à°°/i, /^à°¶à°¨à°¿/i],
};

const matchDayPeriodPatterns$a = {
  narrow:
    /^(à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°|à°à°ªà°°à°¾à°¹à±à°¨à°|à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿|à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°|à°à°¦à°¯à°|à°®à°§à±à°¯à°¾à°¹à±à°¨à°|à°¸à°¾à°¯à°à°¤à±à°°à°|à°°à°¾à°¤à±à°°à°¿)/i,
  any: /^(à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°|à°à°ªà°°à°¾à°¹à±à°¨à°|à°à°°à±à°§à°°à°¾à°¤à±à°°à°¿|à°®à°¿à°à±à°à°®à°§à±à°¯à°¾à°¹à±à°¨à°|à°à°¦à°¯à°|à°®à°§à±à°¯à°¾à°¹à±à°¨à°|à°¸à°¾à°¯à°à°¤à±à°°à°|à°°à°¾à°¤à±à°°à°¿)/i,
};
const parseDayPeriodPatterns$a = {
  any: {
    am: /^à°ªà±à°°à±à°µà°¾à°¹à±à°¨à°/i,
    pm: /^à°à°ªà°°à°¾à°¹à±à°¨à°/i,
    midnight: /^à°à°°à±à°§/i,
    noon: /^à°®à°¿à°à±à°/i,
    morning: /à°à°¦à°¯à°/i,
    afternoon: /à°®à°§à±à°¯à°¾à°¹à±à°¨à°/i,
    evening: /à°¸à°¾à°¯à°à°¤à±à°°à°/i,
    night: /à°°à°¾à°¤à±à°°à°¿/i,
  },
};

(match$a.match = {
  ordinalNumber: (0, _index2$1U.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$a,
    parsePattern: parseOrdinalNumberPattern$a,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4y.buildMatchFn)({
    matchPatterns: matchEraPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$a,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4y.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$a,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4y.buildMatchFn)({
    matchPatterns: matchMonthPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$a,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4y.buildMatchFn)({
    matchPatterns: matchDayPatterns$a,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$a,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4y.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$a,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$a,
    defaultParseWidth: "any",
  }),
});

te.te = void 0;
var _index$4x = formatDistance$n;
var _index2$1T = formatLong$a;
var _index3$Y = formatRelative$n;
var _index4$s = localize$a;
var _index5$j = match$a;

/**
 * @category Locales
 * @summary Telugu locale
 * @language Telugu
 * @iso-639-2 tel
 * @author Kranthi Lakum [@kranthilakum](https://github.com/kranthilakum)
 */
(te.te = {
  code: "te",
  formatDistance: _index$4x.formatDistance,
  formatLong: _index2$1T.formatLong,
  formatRelative: _index3$Y.formatRelative,
  localize: _index4$s.localize,
  match: _index5$j.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var th = {};

var formatDistance$l = {};

formatDistance$l.formatDistance = void 0;

const formatDistanceLocale$9 = {
  lessThanXSeconds: {
    one: "à¸à¹à¸­à¸¢à¸à¸§à¹à¸² 1 à¸§à¸´à¸à¸²à¸à¸µ",
    other: "à¸à¹à¸­à¸¢à¸à¸§à¹à¸² {{count}} à¸§à¸´à¸à¸²à¸à¸µ",
  },

  xSeconds: {
    one: "1 à¸§à¸´à¸à¸²à¸à¸µ",
    other: "{{count}} à¸§à¸´à¸à¸²à¸à¸µ",
  },

  halfAMinute: "à¸à¸£à¸¶à¹à¸à¸à¸²à¸à¸µ",

  lessThanXMinutes: {
    one: "à¸à¹à¸­à¸¢à¸à¸§à¹à¸² 1 à¸à¸²à¸à¸µ",
    other: "à¸à¹à¸­à¸¢à¸à¸§à¹à¸² {{count}} à¸à¸²à¸à¸µ",
  },

  xMinutes: {
    one: "1 à¸à¸²à¸à¸µ",
    other: "{{count}} à¸à¸²à¸à¸µ",
  },

  aboutXHours: {
    one: "à¸à¸£à¸°à¸¡à¸²à¸ 1 à¸à¸±à¹à¸§à¹à¸¡à¸",
    other: "à¸à¸£à¸°à¸¡à¸²à¸ {{count}} à¸à¸±à¹à¸§à¹à¸¡à¸",
  },

  xHours: {
    one: "1 à¸à¸±à¹à¸§à¹à¸¡à¸",
    other: "{{count}} à¸à¸±à¹à¸§à¹à¸¡à¸",
  },

  xDays: {
    one: "1 à¸§à¸±à¸",
    other: "{{count}} à¸§à¸±à¸",
  },

  aboutXWeeks: {
    one: "à¸à¸£à¸°à¸¡à¸²à¸ 1 à¸ªà¸±à¸à¸à¸²à¸«à¹",
    other: "à¸à¸£à¸°à¸¡à¸²à¸ {{count}} à¸ªà¸±à¸à¸à¸²à¸«à¹",
  },

  xWeeks: {
    one: "1 à¸ªà¸±à¸à¸à¸²à¸«à¹",
    other: "{{count}} à¸ªà¸±à¸à¸à¸²à¸«à¹",
  },

  aboutXMonths: {
    one: "à¸à¸£à¸°à¸¡à¸²à¸ 1 à¹à¸à¸·à¸­à¸",
    other: "à¸à¸£à¸°à¸¡à¸²à¸ {{count}} à¹à¸à¸·à¸­à¸",
  },

  xMonths: {
    one: "1 à¹à¸à¸·à¸­à¸",
    other: "{{count}} à¹à¸à¸·à¸­à¸",
  },

  aboutXYears: {
    one: "à¸à¸£à¸°à¸¡à¸²à¸ 1 à¸à¸µ",
    other: "à¸à¸£à¸°à¸¡à¸²à¸ {{count}} à¸à¸µ",
  },

  xYears: {
    one: "1 à¸à¸µ",
    other: "{{count}} à¸à¸µ",
  },

  overXYears: {
    one: "à¸¡à¸²à¸à¸à¸§à¹à¸² 1 à¸à¸µ",
    other: "à¸¡à¸²à¸à¸à¸§à¹à¸² {{count}} à¸à¸µ",
  },

  almostXYears: {
    one: "à¹à¸à¸·à¸­à¸ 1 à¸à¸µ",
    other: "à¹à¸à¸·à¸­à¸ {{count}} à¸à¸µ",
  },
};

const formatDistance$k = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$9[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      if (token === "halfAMinute") {
        return "à¹à¸" + result;
      } else {
        return "à¹à¸ " + result;
      }
    } else {
      return result + "à¸à¸µà¹à¸à¹à¸²à¸à¸¡à¸²";
    }
  }

  return result;
};
formatDistance$l.formatDistance = formatDistance$k;

var formatLong$9 = {};

formatLong$9.formatLong = void 0;
var _index$4w = buildFormatLongFn$1;

const dateFormats$9 = {
  full: "à¸§à¸±à¸EEEEà¸à¸µà¹ do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy",
};

const timeFormats$9 = {
  full: "H:mm:ss à¸. zzzz",
  long: "H:mm:ss à¸. z",
  medium: "H:mm:ss à¸.",
  short: "H:mm à¸.",
};

const dateTimeFormats$9 = {
  full: "{{date}} 'à¹à¸§à¸¥à¸²' {{time}}",
  long: "{{date}} 'à¹à¸§à¸¥à¸²' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$9.formatLong = {
  date: (0, _index$4w.buildFormatLongFn)({
    formats: dateFormats$9,
    defaultWidth: "full",
  }),

  time: (0, _index$4w.buildFormatLongFn)({
    formats: timeFormats$9,
    defaultWidth: "medium",
  }),

  dateTime: (0, _index$4w.buildFormatLongFn)({
    formats: dateTimeFormats$9,
    defaultWidth: "full",
  }),
});

var formatRelative$l = {};

formatRelative$l.formatRelative = void 0;

const formatRelativeLocale$9 = {
  lastWeek: "eeee'à¸à¸µà¹à¹à¸¥à¹à¸§à¹à¸§à¸¥à¸²' p",
  yesterday: "'à¹à¸¡à¸·à¹à¸­à¸§à¸²à¸à¸à¸µà¹à¹à¸§à¸¥à¸²' p",
  today: "'à¸§à¸±à¸à¸à¸µà¹à¹à¸§à¸¥à¸²' p",
  tomorrow: "'à¸à¸£à¸¸à¹à¸à¸à¸µà¹à¹à¸§à¸¥à¸²' p",
  nextWeek: "eeee 'à¹à¸§à¸¥à¸²' p",
  other: "P",
};

const formatRelative$k = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$9[token];
formatRelative$l.formatRelative = formatRelative$k;

var localize$9 = {};

localize$9.localize = void 0;
var _index$4v = buildLocalizeFn$1;

const eraValues$9 = {
  narrow: ["B", "à¸à¸¨"],
  abbreviated: ["BC", "à¸.à¸¨."],
  wide: ["à¸à¸µà¸à¹à¸­à¸à¸à¸£à¸´à¸ªà¸à¸à¸²à¸¥", "à¸à¸£à¸´à¸ªà¸à¹à¸¨à¸±à¸à¸£à¸²à¸"],
};

const quarterValues$9 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["à¹à¸à¸£à¸¡à¸²à¸ªà¹à¸£à¸", "à¹à¸à¸£à¸¡à¸²à¸ªà¸à¸µà¹à¸ªà¸­à¸", "à¹à¸à¸£à¸¡à¸²à¸ªà¸à¸µà¹à¸ªà¸²à¸¡", "à¹à¸à¸£à¸¡à¸²à¸ªà¸à¸µà¹à¸ªà¸µà¹"],
};

const dayValues$9 = {
  narrow: ["à¸­à¸².", "à¸.", "à¸­.", "à¸.", "à¸à¸¤.", "à¸¨.", "à¸ª."],
  short: ["à¸­à¸².", "à¸.", "à¸­.", "à¸.", "à¸à¸¤.", "à¸¨.", "à¸ª."],
  abbreviated: ["à¸­à¸².", "à¸.", "à¸­.", "à¸.", "à¸à¸¤.", "à¸¨.", "à¸ª."],
  wide: ["à¸­à¸²à¸à¸´à¸à¸¢à¹", "à¸à¸±à¸à¸à¸£à¹", "à¸­à¸±à¸à¸à¸²à¸£", "à¸à¸¸à¸", "à¸à¸¤à¸«à¸±à¸ªà¸à¸à¸µ", "à¸¨à¸¸à¸à¸£à¹", "à¹à¸ªà¸²à¸£à¹"],
};

const monthValues$9 = {
  narrow: [
    "à¸¡.à¸.",
    "à¸.à¸.",
    "à¸¡à¸µ.à¸.",
    "à¹à¸¡.à¸¢.",
    "à¸.à¸.",
    "à¸¡à¸´.à¸¢.",
    "à¸.à¸.",
    "à¸ª.à¸.",
    "à¸.à¸¢.",
    "à¸.à¸.",
    "à¸.à¸¢.",
    "à¸.à¸.",
  ],

  abbreviated: [
    "à¸¡.à¸.",
    "à¸.à¸.",
    "à¸¡à¸µ.à¸.",
    "à¹à¸¡.à¸¢.",
    "à¸.à¸.",
    "à¸¡à¸´.à¸¢.",
    "à¸.à¸.",
    "à¸ª.à¸.",
    "à¸.à¸¢.",
    "à¸.à¸.",
    "à¸.à¸¢.",
    "à¸.à¸.",
  ],

  wide: [
    "à¸¡à¸à¸£à¸²à¸à¸¡",
    "à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹",
    "à¸¡à¸µà¸à¸²à¸à¸¡",
    "à¹à¸¡à¸©à¸²à¸¢à¸",
    "à¸à¸¤à¸©à¸ à¸²à¸à¸¡",
    "à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸",
    "à¸à¸£à¸à¸à¸²à¸à¸¡",
    "à¸ªà¸´à¸à¸«à¸²à¸à¸¡",
    "à¸à¸±à¸à¸¢à¸²à¸¢à¸",
    "à¸à¸¸à¸¥à¸²à¸à¸¡",
    "à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸",
    "à¸à¸±à¸à¸§à¸²à¸à¸¡",
  ],
};

const dayPeriodValues$9 = {
  narrow: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¹à¸à¹à¸²",
    afternoon: "à¸à¹à¸²à¸¢",
    evening: "à¹à¸¢à¹à¸",
    night: "à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
  abbreviated: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¹à¸à¹à¸²",
    afternoon: "à¸à¹à¸²à¸¢",
    evening: "à¹à¸¢à¹à¸",
    night: "à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
  wide: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¹à¸à¹à¸²",
    afternoon: "à¸à¹à¸²à¸¢",
    evening: "à¹à¸¢à¹à¸",
    night: "à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
};

const formattingDayPeriodValues$9 = {
  narrow: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¸à¸­à¸à¹à¸à¹à¸²",
    afternoon: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸§à¸±à¸",
    evening: "à¸à¸­à¸à¹à¸¢à¹à¸",
    night: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
  abbreviated: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¸à¸­à¸à¹à¸à¹à¸²",
    afternoon: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸§à¸±à¸",
    evening: "à¸à¸­à¸à¹à¸¢à¹à¸",
    night: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
  wide: {
    am: "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸",
    pm: "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸",
    midnight: "à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸",
    noon: "à¹à¸à¸µà¹à¸¢à¸",
    morning: "à¸à¸­à¸à¹à¸à¹à¸²",
    afternoon: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸§à¸±à¸",
    evening: "à¸à¸­à¸à¹à¸¢à¹à¸",
    night: "à¸à¸­à¸à¸à¸¥à¸²à¸à¸à¸·à¸",
  },
};

const ordinalNumber$9 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$9.localize = {
  ordinalNumber: ordinalNumber$9,

  era: (0, _index$4v.buildLocalizeFn)({
    values: eraValues$9,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4v.buildLocalizeFn)({
    values: quarterValues$9,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4v.buildLocalizeFn)({
    values: monthValues$9,
    defaultWidth: "wide",
  }),

  day: (0, _index$4v.buildLocalizeFn)({
    values: dayValues$9,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4v.buildLocalizeFn)({
    values: dayPeriodValues$9,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$9,
    defaultFormattingWidth: "wide",
  }),
});

var match$9 = {};

match$9.match = void 0;

var _index$4u = buildMatchFn$1;
var _index2$1S = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$9 = /^\d+/i;
const parseOrdinalNumberPattern$9 = /\d+/i;

const matchEraPatterns$9 = {
  narrow: /^([bB]|[aA]|à¸à¸¨)/i,
  abbreviated:
    /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|à¸\.?à¸¨\.?)/i,
  wide: /^(à¸à¹à¸­à¸à¸à¸£à¸´à¸ªà¸à¸à¸²à¸¥|à¸à¸£à¸´à¸ªà¸à¹à¸¨à¸±à¸à¸£à¸²à¸|à¸à¸£à¸´à¸ªà¸à¸à¸²à¸¥)/i,
};
const parseEraPatterns$9 = {
  any: [/^[bB]/i, /^(^[aA]|à¸\.?à¸¨\.?|à¸à¸£à¸´à¸ªà¸à¸à¸²à¸¥|à¸à¸£à¸´à¸ªà¸à¹à¸¨à¸±à¸à¸£à¸²à¸|)/i],
};

const matchQuarterPatterns$9 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^à¹à¸à¸£à¸¡à¸²à¸ª(à¸à¸µà¹)? ?[1234]/i,
};
const parseQuarterPatterns$9 = {
  any: [/(1|à¹à¸£à¸|à¸«à¸à¸¶à¹à¸)/i, /(2|à¸ªà¸­à¸)/i, /(3|à¸ªà¸²à¸¡)/i, /(4|à¸ªà¸µà¹)/i],
};

const matchMonthPatterns$9 = {
  narrow:
    /^(à¸¡\.?à¸\.?|à¸\.?à¸\.?|à¸¡à¸µ\.?à¸\.?|à¹à¸¡\.?à¸¢\.?|à¸\.?à¸\.?|à¸¡à¸´\.?à¸¢\.?|à¸\.?à¸\.?|à¸ª\.?à¸\.?|à¸\.?à¸¢\.?|à¸\.?à¸\.?|à¸\.?à¸¢\.?|à¸\.?à¸\.?)/i,
  abbreviated:
    /^(à¸¡\.?à¸\.?|à¸\.?à¸\.?|à¸¡à¸µ\.?à¸\.?|à¹à¸¡\.?à¸¢\.?|à¸\.?à¸\.?|à¸¡à¸´\.?à¸¢\.?|à¸\.?à¸\.?|à¸ª\.?à¸\.?|à¸\.?à¸¢\.?|à¸\.?à¸\.?|à¸\.?à¸¢\.?|à¸\.?à¸\.?')/i,
  wide: /^(à¸¡à¸à¸£à¸²à¸à¸¡|à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹|à¸¡à¸µà¸à¸²à¸à¸¡|à¹à¸¡à¸©à¸²à¸¢à¸|à¸à¸¤à¸©à¸ à¸²à¸à¸¡|à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸|à¸à¸£à¸à¸à¸²à¸à¸¡|à¸ªà¸´à¸à¸«à¸²à¸à¸¡|à¸à¸±à¸à¸¢à¸²à¸¢à¸|à¸à¸¸à¸¥à¸²à¸à¸¡|à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸|à¸à¸±à¸à¸§à¸²à¸à¸¡)/i,
};
const parseMonthPatterns$9 = {
  wide: [
    /^à¸¡à¸/i,
    /^à¸à¸¸à¸¡/i,
    /^à¸¡à¸µ/i,
    /^à¹à¸¡/i,
    /^à¸à¸¤à¸©/i,
    /^à¸¡à¸´/i,
    /^à¸à¸£à¸/i,
    /^à¸ª/i,
    /^à¸à¸±à¸/i,
    /^à¸/i,
    /^à¸à¸¤à¸¨/i,
    /^à¸/i,
  ],

  any: [
    /^à¸¡\.?à¸\.?/i,
    /^à¸\.?à¸\.?/i,
    /^à¸¡à¸µ\.?à¸\.?/i,
    /^à¹à¸¡\.?à¸¢\.?/i,
    /^à¸\.?à¸\.?/i,
    /^à¸¡à¸´\.?à¸¢\.?/i,
    /^à¸\.?à¸\.?/i,
    /^à¸ª\.?à¸\.?/i,
    /^à¸\.?à¸¢\.?/i,
    /^à¸\.?à¸\.?/i,
    /^à¸\.?à¸¢\.?/i,
    /^à¸\.?à¸\.?/i,
  ],
};

const matchDayPatterns$9 = {
  narrow: /^(à¸­à¸²\.?|à¸\.?|à¸­\.?|à¸à¸¤\.?|à¸\.?|à¸¨\.?|à¸ª\.?)/i,
  short: /^(à¸­à¸²\.?|à¸\.?|à¸­\.?|à¸à¸¤\.?|à¸\.?|à¸¨\.?|à¸ª\.?)/i,
  abbreviated: /^(à¸­à¸²\.?|à¸\.?|à¸­\.?|à¸à¸¤\.?|à¸\.?|à¸¨\.?|à¸ª\.?)/i,
  wide: /^(à¸­à¸²à¸à¸´à¸à¸¢à¹|à¸à¸±à¸à¸à¸£à¹|à¸­à¸±à¸à¸à¸²à¸£|à¸à¸¸à¸|à¸à¸¤à¸«à¸±à¸ªà¸à¸à¸µ|à¸¨à¸¸à¸à¸£à¹|à¹à¸ªà¸²à¸£à¹)/i,
};
const parseDayPatterns$9 = {
  wide: [/^à¸­à¸²/i, /^à¸à¸±/i, /^à¸­à¸±/i, /^à¸à¸¸à¸/i, /^à¸à¸¤/i, /^à¸¨/i, /^à¹à¸ª/i],
  any: [/^à¸­à¸²/i, /^à¸/i, /^à¸­/i, /^à¸(?!à¸¤)/i, /^à¸à¸¤/i, /^à¸¨/i, /^à¸ª/i],
};

const matchDayPeriodPatterns$9 = {
  any: /^(à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸|à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸|à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸|à¹à¸à¸µà¹à¸¢à¸|(à¸à¸­à¸.*?)?.*(à¹à¸à¸µà¹à¸¢à¸|à¹à¸à¹à¸²|à¸à¹à¸²à¸¢|à¹à¸¢à¹à¸|à¸à¸¥à¸²à¸à¸à¸·à¸))/i,
};
const parseDayPeriodPatterns$9 = {
  any: {
    am: /^à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸/i,
    pm: /^à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸/i,
    midnight: /^à¹à¸à¸µà¹à¸¢à¸à¸à¸·à¸/i,
    noon: /^à¹à¸à¸µà¹à¸¢à¸/i,
    morning: /à¹à¸à¹à¸²/i,
    afternoon: /à¸à¹à¸²à¸¢/i,
    evening: /à¹à¸¢à¹à¸/i,
    night: /à¸à¸¥à¸²à¸à¸à¸·à¸/i,
  },
};

(match$9.match = {
  ordinalNumber: (0, _index2$1S.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$9,
    parsePattern: parseOrdinalNumberPattern$9,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4u.buildMatchFn)({
    matchPatterns: matchEraPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$9,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4u.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$9,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4u.buildMatchFn)({
    matchPatterns: matchMonthPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$9,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4u.buildMatchFn)({
    matchPatterns: matchDayPatterns$9,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$9,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4u.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$9,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$9,
    defaultParseWidth: "any",
  }),
});

th.th = void 0;
var _index$4t = formatDistance$l;
var _index2$1R = formatLong$9;
var _index3$X = formatRelative$l;
var _index4$r = localize$9;
var _index5$i = match$9;

/**
 * @category Locales
 * @summary Thai locale.
 * @language Thai
 * @iso-639-2 tha
 * @author Athiwat Hirunworawongkun [@athivvat](https://github.com/athivvat)
 * @author [@hawkup](https://github.com/hawkup)
 * @author  Jirawat I. [@nodtem66](https://github.com/nodtem66)
 */
(th.th = {
  code: "th",
  formatDistance: _index$4t.formatDistance,
  formatLong: _index2$1R.formatLong,
  formatRelative: _index3$X.formatRelative,
  localize: _index4$r.localize,
  match: _index5$i.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var tr = {};

var formatDistance$j = {};

formatDistance$j.formatDistance = void 0;

const formatDistanceLocale$8 = {
  lessThanXSeconds: {
    one: "bir saniyeden az",
    other: "{{count}} saniyeden az",
  },

  xSeconds: {
    one: "1 saniye",
    other: "{{count}} saniye",
  },

  halfAMinute: "yarÄ±m dakika",

  lessThanXMinutes: {
    one: "bir dakikadan az",
    other: "{{count}} dakikadan az",
  },

  xMinutes: {
    one: "1 dakika",
    other: "{{count}} dakika",
  },

  aboutXHours: {
    one: "yaklaÅÄ±k 1 saat",
    other: "yaklaÅÄ±k {{count}} saat",
  },

  xHours: {
    one: "1 saat",
    other: "{{count}} saat",
  },

  xDays: {
    one: "1 gÃ¼n",
    other: "{{count}} gÃ¼n",
  },

  aboutXWeeks: {
    one: "yaklaÅÄ±k 1 hafta",
    other: "yaklaÅÄ±k {{count}} hafta",
  },

  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta",
  },

  aboutXMonths: {
    one: "yaklaÅÄ±k 1 ay",
    other: "yaklaÅÄ±k {{count}} ay",
  },

  xMonths: {
    one: "1 ay",
    other: "{{count}} ay",
  },

  aboutXYears: {
    one: "yaklaÅÄ±k 1 yÄ±l",
    other: "yaklaÅÄ±k {{count}} yÄ±l",
  },

  xYears: {
    one: "1 yÄ±l",
    other: "{{count}} yÄ±l",
  },

  overXYears: {
    one: "1 yÄ±ldan fazla",
    other: "{{count}} yÄ±ldan fazla",
  },

  almostXYears: {
    one: "neredeyse 1 yÄ±l",
    other: "neredeyse {{count}} yÄ±l",
  },
};

const formatDistance$i = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$8[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " Ã¶nce";
    }
  }

  return result;
};
formatDistance$j.formatDistance = formatDistance$i;

var formatLong$8 = {};

formatLong$8.formatLong = void 0;
var _index$4s = buildFormatLongFn$1;

const dateFormats$8 = {
  full: "d MMMM y EEEE",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.yyyy",
};

const timeFormats$8 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$8 = {
  full: "{{date}} 'saat' {{time}}",
  long: "{{date}} 'saat' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$8.formatLong = {
  date: (0, _index$4s.buildFormatLongFn)({
    formats: dateFormats$8,
    defaultWidth: "full",
  }),

  time: (0, _index$4s.buildFormatLongFn)({
    formats: timeFormats$8,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4s.buildFormatLongFn)({
    formats: dateTimeFormats$8,
    defaultWidth: "full",
  }),
});

var formatRelative$j = {};

formatRelative$j.formatRelative = void 0;

const formatRelativeLocale$8 = {
  lastWeek: "'geÃ§en hafta' eeee 'saat' p",
  yesterday: "'dÃ¼n saat' p",
  today: "'bugÃ¼n saat' p",
  tomorrow: "'yarÄ±n saat' p",
  nextWeek: "eeee 'saat' p",
  other: "P",
};

const formatRelative$i = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$8[token];
formatRelative$j.formatRelative = formatRelative$i;

var localize$8 = {};

localize$8.localize = void 0;

var _index$4r = buildLocalizeFn$1;

const eraValues$8 = {
  narrow: ["MÃ", "MS"],
  abbreviated: ["MÃ", "MS"],
  wide: ["Milattan Ãnce", "Milattan Sonra"],
};

const quarterValues$8 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1Ã", "2Ã", "3Ã", "4Ã"],
  wide: ["Ä°lk Ã§eyrek", "Ä°kinci Ãeyrek", "ÃÃ§Ã¼ncÃ¼ Ã§eyrek", "Son Ã§eyrek"],
};

const monthValues$8 = {
  narrow: ["O", "Å", "M", "N", "M", "H", "T", "A", "E", "E", "K", "A"],
  abbreviated: [
    "Oca",
    "Åub",
    "Mar",
    "Nis",
    "May",
    "Haz",
    "Tem",
    "AÄu",
    "Eyl",
    "Eki",
    "Kas",
    "Ara",
  ],

  wide: [
    "Ocak",
    "Åubat",
    "Mart",
    "Nisan",
    "MayÄ±s",
    "Haziran",
    "Temmuz",
    "AÄustos",
    "EylÃ¼l",
    "Ekim",
    "KasÄ±m",
    "AralÄ±k",
  ],
};

const dayValues$8 = {
  narrow: ["P", "P", "S", "Ã", "P", "C", "C"],
  short: ["Pz", "Pt", "Sa", "Ãa", "Pe", "Cu", "Ct"],
  abbreviated: ["Paz", "Pzt", "Sal", "Ãar", "Per", "Cum", "Cts"],
  wide: [
    "Pazar",
    "Pazartesi",
    "SalÄ±",
    "ÃarÅamba",
    "PerÅembe",
    "Cuma",
    "Cumartesi",
  ],
};

const dayPeriodValues$8 = {
  narrow: {
    am: "Ã¶Ã¶",
    pm: "Ã¶s",
    midnight: "gy",
    noon: "Ã¶",
    morning: "sa",
    afternoon: "Ã¶s",
    evening: "ak",
    night: "ge",
  },
  abbreviated: {
    am: "ÃÃ",
    pm: "ÃS",
    midnight: "gece yarÄ±sÄ±",
    noon: "Ã¶Äle",
    morning: "sabah",
    afternoon: "Ã¶Äleden sonra",
    evening: "akÅam",
    night: "gece",
  },
  wide: {
    am: "Ã.Ã.",
    pm: "Ã.S.",
    midnight: "gece yarÄ±sÄ±",
    noon: "Ã¶Äle",
    morning: "sabah",
    afternoon: "Ã¶Äleden sonra",
    evening: "akÅam",
    night: "gece",
  },
};

const formattingDayPeriodValues$8 = {
  narrow: {
    am: "Ã¶Ã¶",
    pm: "Ã¶s",
    midnight: "gy",
    noon: "Ã¶",
    morning: "sa",
    afternoon: "Ã¶s",
    evening: "ak",
    night: "ge",
  },
  abbreviated: {
    am: "ÃÃ",
    pm: "ÃS",
    midnight: "gece yarÄ±sÄ±",
    noon: "Ã¶Älen",
    morning: "sabahleyin",
    afternoon: "Ã¶Äleden sonra",
    evening: "akÅamleyin",
    night: "geceleyin",
  },
  wide: {
    am: "Ã¶.Ã¶.",
    pm: "Ã¶.s.",
    midnight: "gece yarÄ±sÄ±",
    noon: "Ã¶Älen",
    morning: "sabahleyin",
    afternoon: "Ã¶Äleden sonra",
    evening: "akÅamleyin",
    night: "geceleyin",
  },
};

const ordinalNumber$8 = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  return number + ".";
};

(localize$8.localize = {
  ordinalNumber: ordinalNumber$8,

  era: (0, _index$4r.buildLocalizeFn)({
    values: eraValues$8,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4r.buildLocalizeFn)({
    values: quarterValues$8,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1,
  }),

  month: (0, _index$4r.buildLocalizeFn)({
    values: monthValues$8,
    defaultWidth: "wide",
  }),

  day: (0, _index$4r.buildLocalizeFn)({
    values: dayValues$8,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4r.buildLocalizeFn)({
    values: dayPeriodValues$8,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$8,
    defaultFormattingWidth: "wide",
  }),
});

var match$8 = {};

match$8.match = void 0;

var _index$4q = buildMatchFn$1;
var _index2$1Q = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$8 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$8 = /\d+/i;

const matchEraPatterns$8 = {
  narrow: /^(mÃ¶|ms)/i,
  abbreviated: /^(mÃ¶|ms)/i,
  wide: /^(milattan Ã¶nce|milattan sonra)/i,
};
const parseEraPatterns$8 = {
  any: [/(^mÃ¶|^milattan Ã¶nce)/i, /(^ms|^milattan sonra)/i],
};

const matchQuarterPatterns$8 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]Ã§/i,
  wide: /^((i|Ä°)lk|(i|Ä°)kinci|Ã¼Ã§Ã¼ncÃ¼|son) Ã§eyrek/i,
};
const parseQuarterPatterns$8 = {
  any: [/1/i, /2/i, /3/i, /4/i],
  abbreviated: [/1Ã§/i, /2Ã§/i, /3Ã§/i, /4Ã§/i],
  wide: [
    /^(i|Ä°)lk Ã§eyrek/i,
    /(i|Ä°)kinci Ã§eyrek/i,
    /Ã¼Ã§Ã¼ncÃ¼ Ã§eyrek/i,
    /son Ã§eyrek/i,
  ],
};

const matchMonthPatterns$8 = {
  narrow: /^[oÅmnhtaek]/i,
  abbreviated: /^(oca|Åub|mar|nis|may|haz|tem|aÄu|eyl|eki|kas|ara)/i,
  wide: /^(ocak|Åubat|mart|nisan|mayÄ±s|haziran|temmuz|aÄustos|eylÃ¼l|ekim|kasÄ±m|aralÄ±k)/i,
};
const parseMonthPatterns$8 = {
  narrow: [
    /^o/i,
    /^Å/i,
    /^m/i,
    /^n/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^a/i,
    /^e/i,
    /^e/i,
    /^k/i,
    /^a/i,
  ],

  any: [
    /^o/i,
    /^Å/i,
    /^mar/i,
    /^n/i,
    /^may/i,
    /^h/i,
    /^t/i,
    /^aÄ/i,
    /^ey/i,
    /^ek/i,
    /^k/i,
    /^ar/i,
  ],
};

const matchDayPatterns$8 = {
  narrow: /^[psÃ§c]/i,
  short: /^(pz|pt|sa|Ã§a|pe|cu|ct)/i,
  abbreviated: /^(paz|pzt|sal|Ã§ar|per|cum|cts)/i,
  wide: /^(pazar(?!tesi)|pazartesi|salÄ±|Ã§arÅamba|perÅembe|cuma(?!rtesi)|cumartesi)/i,
};
const parseDayPatterns$8 = {
  narrow: [/^p/i, /^p/i, /^s/i, /^Ã§/i, /^p/i, /^c/i, /^c/i],
  any: [/^pz/i, /^pt/i, /^sa/i, /^Ã§a/i, /^pe/i, /^cu/i, /^ct/i],
  wide: [
    /^pazar(?!tesi)/i,
    /^pazartesi/i,
    /^salÄ±/i,
    /^Ã§arÅamba/i,
    /^perÅembe/i,
    /^cuma(?!rtesi)/i,
    /^cumartesi/i,
  ],
};

const matchDayPeriodPatterns$8 = {
  narrow: /^(Ã¶Ã¶|Ã¶s|gy|Ã¶|sa|Ã¶s|ak|ge)/i,
  any: /^(Ã¶\.?\s?[Ã¶s]\.?|Ã¶Äleden sonra|gece yarÄ±sÄ±|Ã¶Äle|(sabah|Ã¶Ä|akÅam|gece)(leyin))/i,
};
const parseDayPeriodPatterns$8 = {
  any: {
    am: /^Ã¶\.?Ã¶\.?/i,
    pm: /^Ã¶\.?s\.?/i,
    midnight: /^(gy|gece yarÄ±sÄ±)/i,
    noon: /^Ã¶Ä/i,
    morning: /^sa/i,
    afternoon: /^Ã¶Äleden sonra/i,
    evening: /^ak/i,
    night: /^ge/i,
  },
};

(match$8.match = {
  ordinalNumber: (0, _index2$1Q.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$8,
    parsePattern: parseOrdinalNumberPattern$8,
    valueCallback: function (value) {
      return parseInt(value, 10);
    },
  }),

  era: (0, _index$4q.buildMatchFn)({
    matchPatterns: matchEraPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$8,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4q.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$8,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4q.buildMatchFn)({
    matchPatterns: matchMonthPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$8,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4q.buildMatchFn)({
    matchPatterns: matchDayPatterns$8,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$8,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4q.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$8,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$8,
    defaultParseWidth: "any",
  }),
});

tr.tr = void 0;
var _index$4p = formatDistance$j;
var _index2$1P = formatLong$8;
var _index3$W = formatRelative$j;
var _index4$q = localize$8;
var _index5$h = match$8;

/**
 * @category Locales
 * @summary Turkish locale.
 * @language Turkish
 * @iso-639-2 tur
 * @author Alpcan AydÄ±n [@alpcanaydin](https://github.com/alpcanaydin)
 * @author Berkay SargÄ±n [@berkaey](https://github.com/berkaey)
 * @author Fatih Bulut [@bulutfatih](https://github.com/bulutfatih)
 * @author Ismail Demirbilek [@dbtek](https://github.com/dbtek)
 * @author Ä°smail Kayar [@ikayar](https://github.com/ikayar)
 *
 *
 */
(tr.tr = {
  code: "tr",
  formatDistance: _index$4p.formatDistance,
  formatLong: _index2$1P.formatLong,
  formatRelative: _index3$W.formatRelative,
  localize: _index4$q.localize,
  match: _index5$h.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var ug = {};

var formatDistance$h = {};

formatDistance$h.formatDistance = void 0;

const formatDistanceLocale$7 = {
  lessThanXSeconds: {
    one: "Ø¨ÙØ± Ø³ÙÙÛÙØª Ø¦ÙÚÙØ¯Û",
    other: "Ø³ÙÙÛÙØª Ø¦ÙÚÙØ¯Û {{count}}",
  },

  xSeconds: {
    one: "Ø¨ÙØ± Ø³ÙÙÛÙØª",
    other: "Ø³ÙÙÛÙØª {{count}}",
  },

  halfAMinute: "ÙÙØ±ÙÙ ÙÙÙÛØª",

  lessThanXMinutes: {
    one: "Ø¨ÙØ± ÙÙÙÛØª Ø¦ÙÚÙØ¯Û",
    other: "ÙÙÙÛØª Ø¦ÙÚÙØ¯Û {{count}}",
  },

  xMinutes: {
    one: "Ø¨ÙØ± ÙÙÙÛØª",
    other: "ÙÙÙÛØª {{count}}",
  },

  aboutXHours: {
    one: "ØªÛØ®ÙÙÙÛÙ Ø¨ÙØ± Ø³Ø§Ø¦ÛØª",
    other: "Ø³Ø§Ø¦ÛØª {{count}} ØªÛØ®ÙÙÙÛÙ",
  },

  xHours: {
    one: "Ø¨ÙØ± Ø³Ø§Ø¦ÛØª",
    other: "Ø³Ø§Ø¦ÛØª {{count}}",
  },

  xDays: {
    one: "Ø¨ÙØ± ÙÛÙ",
    other: "ÙÛÙ {{count}}",
  },

  aboutXWeeks: {
    one: "ØªÛØ®ÙÙÙÛÙ Ø¨ÙØ±Ú¾ÛÙ¾ØªÛ",
    other: "Ú¾ÛÙ¾ØªÛ {{count}} ØªÛØ®ÙÙÙÛÙ",
  },

  xWeeks: {
    one: "Ø¨ÙØ±Ú¾ÛÙ¾ØªÛ",
    other: "Ú¾ÛÙ¾ØªÛ {{count}}",
  },

  aboutXMonths: {
    one: "ØªÛØ®ÙÙÙÛÙ Ø¨ÙØ± Ø¦Ø§Ù",
    other: "Ø¦Ø§Ù {{count}} ØªÛØ®ÙÙÙÛÙ",
  },

  xMonths: {
    one: "Ø¨ÙØ± Ø¦Ø§Ù",
    other: "Ø¦Ø§Ù {{count}}",
  },

  aboutXYears: {
    one: "ØªÛØ®ÙÙÙÛÙ Ø¨ÙØ± ÙÙÙ",
    other: "ÙÙÙ {{count}} ØªÛØ®ÙÙÙÛÙ",
  },

  xYears: {
    one: "Ø¨ÙØ± ÙÙÙ",
    other: "ÙÙÙ {{count}}",
  },

  overXYears: {
    one: "Ø¨ÙØ± ÙÙÙØ¯ÙÙ Ø¦Ø§Ø±ØªÛÙ",
    other: "ÙÙÙØ¯ÙÙ Ø¦Ø§Ø±ØªÛÙ {{count}}",
  },

  almostXYears: {
    one: "Ø¦Ø§Ø³Ø§Ø³ÛÙ Ø¨ÙØ± ÙÙÙ",
    other: "ÙÙÙ {{count}} Ø¦Ø§Ø³Ø§Ø³ÛÙ",
  },
};

const formatDistance$g = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$7[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result;
    } else {
      return result + " Ø¨ÙÙØ¯Ù";
    }
  }

  return result;
};
formatDistance$h.formatDistance = formatDistance$g;

var formatLong$7 = {};

formatLong$7.formatLong = void 0;
var _index$4o = buildFormatLongFn$1;

const dateFormats$7 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats$7 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats$7 = {
  full: "{{date}} 'Ø¯Û' {{time}}",
  long: "{{date}} 'Ø¯Û' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$7.formatLong = {
  date: (0, _index$4o.buildFormatLongFn)({
    formats: dateFormats$7,
    defaultWidth: "full",
  }),

  time: (0, _index$4o.buildFormatLongFn)({
    formats: timeFormats$7,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4o.buildFormatLongFn)({
    formats: dateTimeFormats$7,
    defaultWidth: "full",
  }),
});

var formatRelative$h = {};

formatRelative$h.formatRelative = void 0;

const formatRelativeLocale$7 = {
  lastWeek: "'Ø¦âÛØªÙÛÙ' eeee 'Ø¯Û' p",
  yesterday: "'ØªÛÙÛÚ¯ÛÙ Ø¯Û' p",
  today: "'Ø¨ÛÚ¯ÛÙ Ø¯Û' p",
  tomorrow: "'Ø¦ÛØªÛ Ø¯Û' p",
  nextWeek: "eeee 'Ø¯Û' p",
  other: "P",
};

const formatRelative$g = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$7[token];
formatRelative$h.formatRelative = formatRelative$g;

var localize$7 = {};

localize$7.localize = void 0;
var _index$4n = buildLocalizeFn$1;

const eraValues$7 = {
  narrow: ["Ø¨", "Ù"],
  abbreviated: ["Ø¨", "Ù"],
  wide: ["ÙÙÙÙØ§Ø¯ÙØ¯ÙÙ Ø¨ÛØ±ÛÙ", "ÙÙÙÙØ§Ø¯ÙØ¯ÙÙ ÙÙÙÙÙ"],
};

const quarterValues$7 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["Ø¨ÙØ±ÙÙØ¬Ù ÚØ§Ø±ÛÙ", "Ø¦ÙÙÙÙÙØ¬Ù ÚØ§Ø±ÛÙ", "Ø¦ÛÚÙÙØ¬Ù ÚØ§Ø±ÛÙ", "ØªÛØªÙÙØ¬Ù ÚØ§Ø±ÛÙ"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$7 = {
  narrow: ["Ù", "Ù", "Ù", "Ø§", "Ù", "Ù", "Ù", "Ø§", "Ø³", "Û", "Ù", "Ø¯"],
  abbreviated: [
    "ÙØ§ÙÛØ§Ø±",
    "ÙÛÛÙØ±Ø§Ù",
    "ÙØ§Ø±Øª",
    "Ø¦Ø§Ù¾Ø±ÙÙ",
    "ÙØ§Ù",
    "Ø¦ÙÙÛÙ",
    "Ø¦ÙÙÙÙ",
    "Ø¦Ø§ÛØºÛØ³Øª",
    "Ø³ÙÙØªÛØ¨ÙØ±",
    "Ø¦ÛÙØªÛØ¨ÙØ±",
    "ÙÙÙØ§Ø¨ÙØ±",
    "Ø¯ÙÙØ§Ø¨ÙØ±",
  ],

  wide: [
    "ÙØ§ÙÛØ§Ø±",
    "ÙÛÛÙØ±Ø§Ù",
    "ÙØ§Ø±Øª",
    "Ø¦Ø§Ù¾Ø±ÙÙ",
    "ÙØ§Ù",
    "Ø¦ÙÙÛÙ",
    "Ø¦ÙÙÙÙ",
    "Ø¦Ø§ÛØºÛØ³Øª",
    "Ø³ÙÙØªÛØ¨ÙØ±",
    "Ø¦ÛÙØªÛØ¨ÙØ±",
    "ÙÙÙØ§Ø¨ÙØ±",
    "Ø¯ÙÙØ§Ø¨ÙØ±",
  ],
};

const dayValues$7 = {
  narrow: ["Ù", "Ø¯", "Ø³", "Ú", "Ù¾", "Ø¬", "Ø´"],
  short: ["Ù", "Ø¯", "Ø³", "Ú", "Ù¾", "Ø¬", "Ø´"],
  abbreviated: [
    "ÙÛÙØ´ÛÙØ¨Û",
    "Ø¯ÛØ´ÛÙØ¨Û",
    "Ø³ÛÙØ´ÛÙØ¨Û",
    "ÚØ§Ø±Ø´ÛÙØ¨Û",
    "Ù¾ÛÙØ´ÛÙØ¨Û",
    "Ø¬ÛÙÛ",
    "Ø´ÛÙØ¨Û",
  ],

  wide: [
    "ÙÛÙØ´ÛÙØ¨Û",
    "Ø¯ÛØ´ÛÙØ¨Û",
    "Ø³ÛÙØ´ÛÙØ¨Û",
    "ÚØ§Ø±Ø´ÛÙØ¨Û",
    "Ù¾ÛÙØ´ÛÙØ¨Û",
    "Ø¬ÛÙÛ",
    "Ø´ÛÙØ¨Û",
  ],
};

const dayPeriodValues$7 = {
  narrow: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙ",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´ÙÙ",
    night: "ÙÙÚÛ",
  },
  abbreviated: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙ",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´ÙÙ",
    night: "ÙÙÚÛ",
  },
  wide: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙ",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´ÙÙ",
    night: "ÙÙÚÛ",
  },
};

const formattingDayPeriodValues$7 = {
  narrow: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙØ¯Û",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´Ø§ÙØ¯Ø§",
    night: "ÙÙÚÙØ¯Û",
  },
  abbreviated: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙØ¯Û",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´Ø§ÙØ¯Ø§",
    night: "ÙÙÚÙØ¯Û",
  },
  wide: {
    am: "Ø¦Û",
    pm: "Ú",
    midnight: "Ù",
    noon: "Ú",
    morning: "Ø¦ÛØªÙÚ¯ÛÙØ¯Û",
    afternoon: "ÚÛØ´ØªÙÙ ÙÙÙÙÙ",
    evening: "Ø¦Ø§Ø®Ø´Ø§ÙØ¯Ø§",
    night: "ÙÙÚÙØ¯Û",
  },
};

const ordinalNumber$7 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$7.localize = {
  ordinalNumber: ordinalNumber$7,

  era: (0, _index$4n.buildLocalizeFn)({
    values: eraValues$7,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4n.buildLocalizeFn)({
    values: quarterValues$7,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4n.buildLocalizeFn)({
    values: monthValues$7,
    defaultWidth: "wide",
  }),

  day: (0, _index$4n.buildLocalizeFn)({
    values: dayValues$7,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4n.buildLocalizeFn)({
    values: dayPeriodValues$7,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$7,
    defaultFormattingWidth: "wide",
  }),
});

var match$7 = {};

match$7.match = void 0;

var _index$4m = buildMatchFn$1;
var _index2$1O = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$7 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$7 = /\d+/i;

const matchEraPatterns$7 = {
  narrow: /^(Ø¨|Ù)/i,
  wide: /^(ÙÙÙÙØ§Ø¯ÙØ¯ÙÙ Ø¨ÛØ±ÛÙ|ÙÙÙÙØ§Ø¯ÙØ¯ÙÙ ÙÙÙÙÙ)/i,
};
const parseEraPatterns$7 = {
  any: [/^Ø¨ÛØ±ÛÙ/i, /^ÙÙÙÙÙ/i],
};

const matchQuarterPatterns$7 = {
  narrow: /^[1234]/i,
  abbreviated: /^Ú[1234]/i,
  wide: /^ÚØ§Ø±ÛÙ [1234]/i,
};
const parseQuarterPatterns$7 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$7 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[ÙÙÙØ¦Ø§ÙØ¦âØ¦Ø§Ø³ÛÙØ¯]/i,
  abbreviated:
    /^(ÙØ§ÙÛØ§Ø±|ÙÛÛÙØ±Ø§Ù|ÙØ§Ø±Øª|Ø¦Ø§Ù¾Ø±ÙÙ|ÙØ§Ù|Ø¦ÙÙÛÙ|Ø¦ÙÙÙÙ|Ø¦Ø§ÛØºÛØ³Øª|Ø³ÙÙØªÛØ¨ÙØ±|Ø¦ÛÙØªÛØ¨ÙØ±|ÙÙÙØ§Ø¨ÙØ±|Ø¯ÙÙØ§Ø¨ÙØ±)/i,
  wide: /^(ÙØ§ÙÛØ§Ø±|ÙÛÛÙØ±Ø§Ù|ÙØ§Ø±Øª|Ø¦Ø§Ù¾Ø±ÙÙ|ÙØ§Ù|Ø¦ÙÙÛÙ|Ø¦ÙÙÙÙ|Ø¦Ø§ÛØºÛØ³Øª|Ø³ÙÙØªÛØ¨ÙØ±|Ø¦ÛÙØªÛØ¨ÙØ±|ÙÙÙØ§Ø¨ÙØ±|Ø¯ÙÙØ§Ø¨ÙØ±)/i,
};
const parseMonthPatterns$7 = {
  narrow: [
    /^Ù/i,
    /^Ù/i,
    /^Ù/i,
    /^Ø§/i,
    /^Ù/i,
    /^Ùâ/i,
    /^Ùâ/i,
    /^Ø§â/i,
    /^Ø³/i,
    /^Û/i,
    /^Ù/i,
    /^Ø¯/i,
  ],

  any: [
    /^ÙØ§Ù/i,
    /^ÙÛÛ/i,
    /^ÙØ§Ø±/i,
    /^Ø¦Ø§Ù¾/i,
    /^ÙØ§Ù/i,
    /^Ø¦ÙÙÛÙ/i,
    /^Ø¦ÙÙÙÙ/i,
    /^Ø¦Ø§Û/i,
    /^Ø³ÙÙ/i,
    /^Ø¦ÛÙ/i,
    /^ÙÙÙ/i,
    /^Ø¯ÙÙ/i,
  ],
};

const matchDayPatterns$7 = {
  narrow: /^[Ø¯Ø³ÚÙ¾Ø¬Ø´Ù]/i,
  short: /^(ÙÛ|Ø¯Û|Ø³Û|ÚØ§|Ù¾Û|Ø¬Û|Ø´Û)/i,
  abbreviated: /^(ÙÛ|Ø¯Û|Ø³Û|ÚØ§|Ù¾Û|Ø¬Û|Ø´Û)/i,
  wide: /^(ÙÛÙØ´ÛÙØ¨Û|Ø¯ÛØ´ÛÙØ¨Û|Ø³ÛÙØ´ÛÙØ¨Û|ÚØ§Ø±Ø´ÛÙØ¨Û|Ù¾ÛÙØ´ÛÙØ¨Û|Ø¬ÛÙÛ|Ø´ÛÙØ¨Û)/i,
};
const parseDayPatterns$7 = {
  narrow: [/^Ù/i, /^Ø¯/i, /^Ø³/i, /^Ú/i, /^Ù¾/i, /^Ø¬/i, /^Ø´/i],
  any: [/^Ù/i, /^Ø¯/i, /^Ø³/i, /^Ú/i, /^Ù¾/i, /^Ø¬/i, /^Ø´/i],
};

const matchDayPeriodPatterns$7 = {
  narrow: /^(Ø¦Û|Ú|Ù|Ú|(Ø¯Û|Ø¦ÛØªÙÚ¯ÛÙ) ( Ø¦Ûâ|ÚÛØ´ØªÙÙ ÙÙÙÙÙ|Ø¦Ø§Ø®Ø´ÙÙ|ÙÙÚÛ))/i,
  any: /^(Ø¦Û|Ú|Ù|Ú|(Ø¯Û|Ø¦ÛØªÙÚ¯ÛÙ) ( Ø¦Ûâ|ÚÛØ´ØªÙÙ ÙÙÙÙÙ|Ø¦Ø§Ø®Ø´ÙÙ|ÙÙÚÛ))/i,
};
const parseDayPeriodPatterns$7 = {
  any: {
    am: /^Ø¦Û/i,
    pm: /^Ú/i,
    midnight: /^Ù/i,
    noon: /^Ú/i,
    morning: /Ø¦ÛØªÙÚ¯ÛÙ/i,
    afternoon: /ÚÛØ´ØªÙÙ ÙÙÙÙÙ/i,
    evening: /Ø¦Ø§Ø®Ø´ÙÙ/i,
    night: /ÙÙÚÛ/i,
  },
};

(match$7.match = {
  ordinalNumber: (0, _index2$1O.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$7,
    parsePattern: parseOrdinalNumberPattern$7,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4m.buildMatchFn)({
    matchPatterns: matchEraPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$7,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4m.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$7,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4m.buildMatchFn)({
    matchPatterns: matchMonthPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$7,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4m.buildMatchFn)({
    matchPatterns: matchDayPatterns$7,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$7,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4m.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$7,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$7,
    defaultParseWidth: "any",
  }),
});

ug.ug = void 0;
var _index$4l = formatDistance$h;
var _index2$1N = formatLong$7;
var _index3$V = formatRelative$h;
var _index4$p = localize$7;
var _index5$g = match$7;

/**
 * @category Locales
 * @summary Uighur locale
 * @language Uighur
 * @iso-639-2 uig
 * @author Abduwaly M. [@abduwaly](https://github.com/abduwaly)
 */
(ug.ug = {
  code: "ug",
  formatDistance: _index$4l.formatDistance,
  formatLong: _index2$1N.formatLong,
  formatRelative: _index3$V.formatRelative,
  localize: _index4$p.localize,
  match: _index5$g.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var uk = {};

var formatDistance$f = {};

formatDistance$f.formatDistance = void 0;

function declension(scheme, count) {
  // scheme for count=1 exists
  if (scheme.one !== undefined && count === 1) {
    return scheme.one;
  }

  const rem10 = count % 10;
  const rem100 = count % 100;

  // 1, 21, 31, ...
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count));

    // 2, 3, 4, 22, 23, 24, 32 ...
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count));

    // 5, 6, 7, 8, 9, 10, 11, ...
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count));
  }
}

function buildLocalizeTokenFn(scheme) {
  return (count, options) => {
    if (options && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension(scheme.future, count);
        } else {
          return "Ð·Ð° " + declension(scheme.regular, count);
        }
      } else {
        if (scheme.past) {
          return declension(scheme.past, count);
        } else {
          return declension(scheme.regular, count) + " ÑÐ¾Ð¼Ñ";
        }
      }
    } else {
      return declension(scheme.regular, count);
    }
  };
}

const halfAtMinute = (_, options) => {
  if (options && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "Ð·Ð° Ð¿ÑÐ²ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸";
    } else {
      return "Ð¿ÑÐ²ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸ ÑÐ¾Ð¼Ñ";
    }
  }

  return "Ð¿ÑÐ²ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸";
};

const formatDistanceLocale$6 = {
  lessThanXSeconds: buildLocalizeTokenFn({
    regular: {
      one: "Ð¼ÐµÐ½ÑÐµ ÑÐµÐºÑÐ½Ð´Ð¸",
      singularNominative: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
      singularGenitive: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´",
      pluralGenitive: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐµÐºÑÐ½Ð´",
    },
    future: {
      one: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° ÑÐµÐºÑÐ½Ð´Ñ",
      singularNominative: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
      pluralGenitive: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  xSeconds: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ð°",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´",
    },
    past: {
      singularNominative: "{{count}} ÑÐµÐºÑÐ½Ð´Ñ ÑÐ¾Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´Ð¸ ÑÐ¾Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐµÐºÑÐ½Ð´ ÑÐ¾Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ñ",
      singularGenitive: "Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´Ð¸",
      pluralGenitive: "Ð·Ð° {{count}} ÑÐµÐºÑÐ½Ð´",
    },
  }),

  halfAMinute: halfAtMinute,

  lessThanXMinutes: buildLocalizeTokenFn({
    regular: {
      one: "Ð¼ÐµÐ½ÑÐµ ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸",
      singularNominative: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸",
      singularGenitive: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½",
      pluralGenitive: "Ð¼ÐµÐ½ÑÐµ {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½",
    },
    future: {
      one: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° ÑÐ²Ð¸Ð»Ð¸Ð½Ñ",
      singularNominative: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ñ",
      singularGenitive: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸",
      pluralGenitive: "Ð¼ÐµÐ½ÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½",
    },
  }),

  xMinutes: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð°",
      singularGenitive: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸",
      pluralGenitive: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½",
    },
    past: {
      singularNominative: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ñ ÑÐ¾Ð¼Ñ",
      singularGenitive: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸ ÑÐ¾Ð¼Ñ",
      pluralGenitive: "{{count}} ÑÐ²Ð¸Ð»Ð¸Ð½ ÑÐ¾Ð¼Ñ",
    },
    future: {
      singularNominative: "Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ñ",
      singularGenitive: "Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸",
      pluralGenitive: "Ð·Ð° {{count}} ÑÐ²Ð¸Ð»Ð¸Ð½",
    },
  }),

  aboutXHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
      singularGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½",
      pluralGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð³Ð¾Ð´Ð¸Ð½",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð³Ð¾Ð´Ð¸Ð½Ñ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð³Ð¾Ð´Ð¸Ð½",
    },
  }),

  xHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ñ",
      singularGenitive: "{{count}} Ð³Ð¾Ð´Ð¸Ð½Ð¸",
      pluralGenitive: "{{count}} Ð³Ð¾Ð´Ð¸Ð½",
    },
  }),

  xDays: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} Ð´ÐµÐ½Ñ",
      singularGenitive: "{{count}} Ð´Ð½i",
      pluralGenitive: "{{count}} Ð´Ð½ÑÐ²",
    },
  }),

  aboutXWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¸Ð¶Ð½Ñ",
      singularGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¸Ð¶Ð½ÑÐ²",
      pluralGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¸Ð¶Ð½ÑÐ²",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÐ¸Ð¶Ð´ÐµÐ½Ñ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÐ¸Ð¶Ð½Ñ",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÐ¸Ð¶Ð½ÑÐ²",
    },
  }),

  xWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ÑÐ¸Ð¶Ð´ÐµÐ½Ñ",
      singularGenitive: "{{count}} ÑÐ¸Ð¶Ð½Ñ",
      pluralGenitive: "{{count}} ÑÐ¸Ð¶Ð½ÑÐ²",
    },
  }),

  aboutXMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð¼ÑÑÑÑÑ",
      singularGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð¼ÑÑÑÑÑÐ²",
      pluralGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} Ð¼ÑÑÑÑÑÐ²",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð¼ÑÑÑÑÑ",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð¼ÑÑÑÑÑ",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} Ð¼ÑÑÑÑÑÐ²",
    },
  }),

  xMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} Ð¼ÑÑÑÑÑ",
      singularGenitive: "{{count}} Ð¼ÑÑÑÑÑ",
      pluralGenitive: "{{count}} Ð¼ÑÑÑÑÑÐ²",
    },
  }),

  aboutXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¾ÐºÑ",
      singularGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¾ÐºÑÐ²",
      pluralGenitive: "Ð±Ð»Ð¸Ð·ÑÐºÐ¾ {{count}} ÑÐ¾ÐºÑÐ²",
    },
    future: {
      singularNominative: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÑÐº",
      singularGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÐ¾ÐºÐ¸",
      pluralGenitive: "Ð¿ÑÐ¸Ð±Ð»Ð¸Ð·Ð½Ð¾ Ð·Ð° {{count}} ÑÐ¾ÐºÑÐ²",
    },
  }),

  xYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} ÑÑÐº",
      singularGenitive: "{{count}} ÑÐ¾ÐºÐ¸",
      pluralGenitive: "{{count}} ÑÐ¾ÐºÑÐ²",
    },
  }),

  overXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð±ÑÐ»ÑÑÐµ {{count}} ÑÐ¾ÐºÑ",
      singularGenitive: "Ð±ÑÐ»ÑÑÐµ {{count}} ÑÐ¾ÐºÑÐ²",
      pluralGenitive: "Ð±ÑÐ»ÑÑÐµ {{count}} ÑÐ¾ÐºÑÐ²",
    },
    future: {
      singularNominative: "Ð±ÑÐ»ÑÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÑÐº",
      singularGenitive: "Ð±ÑÐ»ÑÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐ¾ÐºÐ¸",
      pluralGenitive: "Ð±ÑÐ»ÑÑÐµ, Ð½ÑÐ¶ Ð·Ð° {{count}} ÑÐ¾ÐºÑÐ²",
    },
  }),

  almostXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "Ð¼Ð°Ð¹Ð¶Ðµ {{count}} ÑÑÐº",
      singularGenitive: "Ð¼Ð°Ð¹Ð¶Ðµ {{count}} ÑÐ¾ÐºÐ¸",
      pluralGenitive: "Ð¼Ð°Ð¹Ð¶Ðµ {{count}} ÑÐ¾ÐºÑÐ²",
    },
    future: {
      singularNominative: "Ð¼Ð°Ð¹Ð¶Ðµ Ð·Ð° {{count}} ÑÑÐº",
      singularGenitive: "Ð¼Ð°Ð¹Ð¶Ðµ Ð·Ð° {{count}} ÑÐ¾ÐºÐ¸",
      pluralGenitive: "Ð¼Ð°Ð¹Ð¶Ðµ Ð·Ð° {{count}} ÑÐ¾ÐºÑÐ²",
    },
  }),
};

const formatDistance$e = (token, count, options) => {
  options = options || {};

  return formatDistanceLocale$6[token](count, options);
};
formatDistance$f.formatDistance = formatDistance$e;

var formatLong$6 = {};

formatLong$6.formatLong = void 0;
var _index$4k = buildFormatLongFn$1;

const dateFormats$6 = {
  full: "EEEE, do MMMM y 'Ñ.'",
  long: "do MMMM y 'Ñ.'",
  medium: "d MMM y 'Ñ.'",
  short: "dd.MM.y",
};

const timeFormats$6 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$6 = {
  full: "{{date}} 'Ð¾' {{time}}",
  long: "{{date}} 'Ð¾' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

(formatLong$6.formatLong = {
  date: (0, _index$4k.buildFormatLongFn)({
    formats: dateFormats$6,
    defaultWidth: "full",
  }),

  time: (0, _index$4k.buildFormatLongFn)({
    formats: timeFormats$6,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4k.buildFormatLongFn)({
    formats: dateTimeFormats$6,
    defaultWidth: "full",
  }),
});

var formatRelative$f = {};

formatRelative$f.formatRelative = void 0;
var _index$4j = isSameWeek$1;
var _index2$1M = toDate$1;

const accusativeWeekdays = [
  "Ð½ÐµÐ´ÑÐ»Ñ",
  "Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº",
  "Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº",
  "ÑÐµÑÐµÐ´Ñ",
  "ÑÐµÑÐ²ÐµÑ",
  "Ð¿âÑÑÐ½Ð¸ÑÑ",
  "ÑÑÐ±Ð¾ÑÑ",
];

function lastWeek(day) {
  const weekday = accusativeWeekdays[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð¼Ð¸Ð½ÑÐ»Ñ " + weekday + " Ð¾' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð¼Ð¸Ð½ÑÐ»Ð¸Ð¹ " + weekday + " Ð¾' p";
  }
}

function thisWeek(day) {
  const weekday = accusativeWeekdays[day];

  return "'Ñ " + weekday + " Ð¾' p";
}

function nextWeek(day) {
  const weekday = accusativeWeekdays[day];

  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ñ " + weekday + " Ð¾' p";
    case 1:
    case 2:
    case 4:
      return "'Ñ Ð½Ð°ÑÑÑÐ¿Ð½Ð¸Ð¹ " + weekday + " Ð¾' p";
  }
}

const lastWeekFormat = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$1M.toDate)(dirtyDate);
  const day = date.getDay();

  if ((0, _index$4j.isSameWeek)(date, baseDate, options)) {
    return thisWeek(day);
  } else {
    return lastWeek(day);
  }
};

const nextWeekFormat = (dirtyDate, baseDate, options) => {
  const date = (0, _index2$1M.toDate)(dirtyDate);
  const day = date.getDay();
  if ((0, _index$4j.isSameWeek)(date, baseDate, options)) {
    return thisWeek(day);
  } else {
    return nextWeek(day);
  }
};

const formatRelativeLocale$6 = {
  lastWeek: lastWeekFormat,
  yesterday: "'Ð²ÑÐ¾ÑÐ° Ð¾' p",
  today: "'ÑÑÐ¾Ð³Ð¾Ð´Ð½Ñ Ð¾' p",
  tomorrow: "'Ð·Ð°Ð²ÑÑÐ° Ð¾' p",
  nextWeek: nextWeekFormat,
  other: "P",
};

const formatRelative$e = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$6[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$f.formatRelative = formatRelative$e;

var localize$6 = {};

localize$6.localize = void 0;
var _index$4i = buildLocalizeFn$1;

const eraValues$6 = {
  narrow: ["Ð´Ð¾ Ð½.Ðµ.", "Ð½.Ðµ."],
  abbreviated: ["Ð´Ð¾ Ð½. Ðµ.", "Ð½. Ðµ."],
  wide: ["Ð´Ð¾ Ð½Ð°ÑÐ¾Ñ ÐµÑÐ¸", "Ð½Ð°ÑÐ¾Ñ ÐµÑÐ¸"],
};

const quarterValues$6 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-Ð¹ ÐºÐ².", "2-Ð¹ ÐºÐ².", "3-Ð¹ ÐºÐ².", "4-Ð¹ ÐºÐ²."],
  wide: ["1-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "2-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "3-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»", "4-Ð¹ ÐºÐ²Ð°ÑÑÐ°Ð»"],
};

const monthValues$6 = {
  // ÐÐ¡Ð¢Ð£ 3582:2013
  narrow: ["Ð¡", "Ð", "Ð", "Ð", "Ð¢", "Ð§", "Ð", "Ð¡", "Ð", "Ð", "Ð", "Ð"],
  abbreviated: [
    "ÑÑÑ.",
    "Ð»ÑÑ.",
    "Ð±ÐµÑÐµÐ·.",
    "ÐºÐ²ÑÑ.",
    "ÑÑÐ°Ð².",
    "ÑÐµÑÐ².",
    "Ð»Ð¸Ð¿.",
    "ÑÐµÑÐ¿.",
    "Ð²ÐµÑÐµÑ.",
    "Ð¶Ð¾Ð²Ñ.",
    "Ð»Ð¸ÑÑÐ¾Ð¿.",
    "Ð³ÑÑÐ´.",
  ],

  wide: [
    "ÑÑÑÐµÐ½Ñ",
    "Ð»ÑÑÐ¸Ð¹",
    "Ð±ÐµÑÐµÐ·ÐµÐ½Ñ",
    "ÐºÐ²ÑÑÐµÐ½Ñ",
    "ÑÑÐ°Ð²ÐµÐ½Ñ",
    "ÑÐµÑÐ²ÐµÐ½Ñ",
    "Ð»Ð¸Ð¿ÐµÐ½Ñ",
    "ÑÐµÑÐ¿ÐµÐ½Ñ",
    "Ð²ÐµÑÐµÑÐµÐ½Ñ",
    "Ð¶Ð¾Ð²ÑÐµÐ½Ñ",
    "Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´",
    "Ð³ÑÑÐ´ÐµÐ½Ñ",
  ],
};

const formattingMonthValues$1 = {
  narrow: ["Ð¡", "Ð", "Ð", "Ð", "Ð¢", "Ð§", "Ð", "Ð¡", "Ð", "Ð", "Ð", "Ð"],
  abbreviated: [
    "ÑÑÑ.",
    "Ð»ÑÑ.",
    "Ð±ÐµÑÐµÐ·.",
    "ÐºÐ²ÑÑ.",
    "ÑÑÐ°Ð².",
    "ÑÐµÑÐ².",
    "Ð»Ð¸Ð¿.",
    "ÑÐµÑÐ¿.",
    "Ð²ÐµÑÐµÑ.",
    "Ð¶Ð¾Ð²Ñ.",
    "Ð»Ð¸ÑÑÐ¾Ð¿.",
    "Ð³ÑÑÐ´.",
  ],

  wide: [
    "ÑÑÑÐ½Ñ",
    "Ð»ÑÑÐ¾Ð³Ð¾",
    "Ð±ÐµÑÐµÐ·Ð½Ñ",
    "ÐºÐ²ÑÑÐ½Ñ",
    "ÑÑÐ°Ð²Ð½Ñ",
    "ÑÐµÑÐ²Ð½Ñ",
    "Ð»Ð¸Ð¿Ð½Ñ",
    "ÑÐµÑÐ¿Ð½Ñ",
    "Ð²ÐµÑÐµÑÐ½Ñ",
    "Ð¶Ð¾Ð²ÑÐ½Ñ",
    "Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´Ð°",
    "Ð³ÑÑÐ´Ð½Ñ",
  ],
};

const dayValues$6 = {
  narrow: ["Ð", "Ð", "Ð", "Ð¡", "Ð§", "Ð", "Ð¡"],
  short: ["Ð½Ð´", "Ð¿Ð½", "Ð²Ñ", "ÑÑ", "ÑÑ", "Ð¿Ñ", "ÑÐ±"],
  abbreviated: ["Ð½ÐµÐ´", "Ð¿Ð¾Ð½", "Ð²ÑÐ²", "ÑÐµÑ", "ÑÑÐ²", "Ð¿ÑÐ½", "ÑÑÐ±"],
  wide: [
    "Ð½ÐµÐ´ÑÐ»Ñ",
    "Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº",
    "Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº",
    "ÑÐµÑÐµÐ´Ð°",
    "ÑÐµÑÐ²ÐµÑ",
    "Ð¿âÑÑÐ½Ð¸ÑÑ",
    "ÑÑÐ±Ð¾ÑÐ°",
  ],
};

const dayPeriodValues$6 = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½.",
    noon: "Ð¿Ð¾Ð».",
    morning: "ÑÐ°Ð½Ð¾Ðº",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½.",
    noon: "Ð¿Ð¾Ð».",
    morning: "ÑÐ°Ð½Ð¾Ðº",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½ÑÑ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½ÑÑ",
    noon: "Ð¿Ð¾Ð»ÑÐ´ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½Ð¾Ðº",
    afternoon: "Ð´ÐµÐ½Ñ",
    evening: "Ð²ÐµÑÑÑ",
    night: "Ð½ÑÑ",
  },
};

const formattingDayPeriodValues$6 = {
  narrow: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½.",
    noon: "Ð¿Ð¾Ð».",
    morning: "ÑÐ°Ð½ÐºÑ",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  abbreviated: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½.",
    noon: "Ð¿Ð¾Ð».",
    morning: "ÑÐ°Ð½ÐºÑ",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
  wide: {
    am: "ÐÐ",
    pm: "ÐÐ",
    midnight: "Ð¿ÑÐ²Ð½ÑÑ",
    noon: "Ð¿Ð¾Ð»ÑÐ´ÐµÐ½Ñ",
    morning: "ÑÐ°Ð½ÐºÑ",
    afternoon: "Ð´Ð½Ñ",
    evening: "Ð²ÐµÑ.",
    night: "Ð½Ð¾ÑÑ",
  },
};

const ordinalNumber$6 = (dirtyNumber, options) => {
  const unit = String(options?.unit);
  const number = Number(dirtyNumber);
  let suffix;

  if (unit === "date") {
    if (number === 3 || number === 23) {
      suffix = "-Ñ";
    } else {
      suffix = "-Ðµ";
    }
  } else if (unit === "minute" || unit === "second" || unit === "hour") {
    suffix = "-Ð°";
  } else {
    suffix = "-Ð¹";
  }

  return number + suffix;
};

(localize$6.localize = {
  ordinalNumber: ordinalNumber$6,

  era: (0, _index$4i.buildLocalizeFn)({
    values: eraValues$6,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4i.buildLocalizeFn)({
    values: quarterValues$6,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4i.buildLocalizeFn)({
    values: monthValues$6,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues$1,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$4i.buildLocalizeFn)({
    values: dayValues$6,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4i.buildLocalizeFn)({
    values: dayPeriodValues$6,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$6,
    defaultFormattingWidth: "wide",
  }),
});

var match$6 = {};

match$6.match = void 0;

var _index$4h = buildMatchFn$1;
var _index2$1L = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$6 = /^(\d+)(-?(Ðµ|Ð¹|Ñ|Ð°|Ñ))?/i;
const parseOrdinalNumberPattern$6 = /\d+/i;

const matchEraPatterns$6 = {
  narrow: /^((Ð´Ð¾ )?Ð½\.?\s?Ðµ\.?)/i,
  abbreviated: /^((Ð´Ð¾ )?Ð½\.?\s?Ðµ\.?)/i,
  wide: /^(Ð´Ð¾ Ð½Ð°ÑÐ¾Ñ ÐµÑÐ¸|Ð½Ð°ÑÐ¾Ñ ÐµÑÐ¸|Ð½Ð°ÑÐ° ÐµÑÐ°)/i,
};

const parseEraPatterns$6 = {
  any: [/^Ð´/i, /^Ð½/i],
};

const matchQuarterPatterns$6 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[Ð¸Ñ]?Ð¹?)? ÐºÐ².?/i,
  wide: /^[1234](-?[Ð¸Ñ]?Ð¹?)? ÐºÐ²Ð°ÑÑÐ°Ð»/i,
};

const parseQuarterPatterns$6 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$6 = {
  narrow: /^[ÑÐ»Ð±ÐºÑÑÐ²Ð¶Ð³]/i,
  abbreviated:
    /^(ÑÑÑ|Ð»ÑÑ|Ð±ÐµÑ(ÐµÐ·)?|ÐºÐ²ÑÑ|ÑÑÐ°Ð²|ÑÐµÑÐ²|Ð»Ð¸Ð¿|ÑÐµÑÐ¿|Ð²ÐµÑ(ÐµÑ)?|Ð¶Ð¾Ð²Ñ|Ð»Ð¸Ñ(ÑÐ¾Ð¿)?|Ð³ÑÑÐ´)\.?/i,
  wide: /^(ÑÑÑÐµÐ½Ñ|ÑÑÑÐ½Ñ|Ð»ÑÑÐ¸Ð¹|Ð»ÑÑÐ¾Ð³Ð¾|Ð±ÐµÑÐµÐ·ÐµÐ½Ñ|Ð±ÐµÑÐµÐ·Ð½Ñ|ÐºÐ²ÑÑÐµÐ½Ñ|ÐºÐ²ÑÑÐ½Ñ|ÑÑÐ°Ð²ÐµÐ½Ñ|ÑÑÐ°Ð²Ð½Ñ|ÑÐµÑÐ²Ð½Ñ|ÑÐµÑÐ²ÐµÐ½Ñ|Ð»Ð¸Ð¿ÐµÐ½Ñ|Ð»Ð¸Ð¿Ð½Ñ|ÑÐµÑÐ¿ÐµÐ½Ñ|ÑÐµÑÐ¿Ð½Ñ|Ð²ÐµÑÐµÑÐµÐ½Ñ|Ð²ÐµÑÐµÑÐ½Ñ|Ð¶Ð¾Ð²ÑÐµÐ½Ñ|Ð¶Ð¾Ð²ÑÐ½Ñ|Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´[Ð°]?|Ð³ÑÑÐ´ÐµÐ½Ñ|Ð³ÑÑÐ´Ð½Ñ)/i,
};

const parseMonthPatterns$6 = {
  narrow: [
    /^Ñ/i,
    /^Ð»/i,
    /^Ð±/i,
    /^Ðº/i,
    /^Ñ/i,
    /^Ñ/i,
    /^Ð»/i,
    /^Ñ/i,
    /^Ð²/i,
    /^Ð¶/i,
    /^Ð»/i,
    /^Ð³/i,
  ],

  any: [
    /^ÑÑ/i,
    /^Ð»Ñ/i,
    /^Ð±/i,
    /^Ðº/i,
    /^Ñ/i,
    /^Ñ/i,
    /^Ð»Ð¸Ð¿/i,
    /^ÑÐµ/i,
    /^Ð²/i,
    /^Ð¶/i,
    /^Ð»Ð¸Ñ/i,
    /^Ð³/i,
  ],
};

const matchDayPatterns$6 = {
  narrow: /^[Ð½Ð¿Ð²ÑÑ]/i,
  short: /^(Ð½Ð´|Ð¿Ð½|Ð²Ñ|ÑÑ|ÑÑ|Ð¿Ñ|ÑÐ±)\.?/i,
  abbreviated: /^(Ð½ÐµÐ´|Ð¿Ð¾Ð½|Ð²ÑÐ²|ÑÐµÑ|ÑÐµ?ÑÐ²|Ð¿ÑÐ½?|ÑÑÐ±)\.?/i,
  wide: /^(Ð½ÐµÐ´ÑÐ»[ÑÑ]|Ð¿Ð¾Ð½ÐµÐ´ÑÐ»[Ð¾Ðº][ÐºÐ°]|Ð²ÑÐ²ÑÐ¾Ñ[Ð¾Ðº][ÐºÐ°]|ÑÐµÑÐµÐ´[Ð°Ð¸]|ÑÐµÑÐ²ÐµÑ(Ð³Ð°)?|Ð¿\W*?ÑÑÐ½Ð¸Ñ[ÑÑ]|ÑÑÐ±Ð¾Ñ[Ð°Ð¸])/i,
};

const parseDayPatterns$6 = {
  narrow: [/^Ð½/i, /^Ð¿/i, /^Ð²/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ñ/i],
  any: [/^Ð½/i, /^Ð¿[Ð¾Ð½]/i, /^Ð²/i, /^Ñ[ÐµÑ]/i, /^Ñ/i, /^Ð¿\W*?[ÑÑ]/i, /^Ñ[ÑÐ±]/i],
};

const matchDayPeriodPatterns$6 = {
  narrow: /^([Ð´Ð¿]Ð¿|Ð¿ÑÐ²Ð½\.?|Ð¿Ð¾Ð»\.?|ÑÐ°Ð½Ð¾Ðº|ÑÐ°Ð½ÐºÑ|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½ÑÑ|Ð½Ð¾ÑÑ)/i,
  abbreviated: /^([Ð´Ð¿]Ð¿|Ð¿ÑÐ²Ð½\.?|Ð¿Ð¾Ð»\.?|ÑÐ°Ð½Ð¾Ðº|ÑÐ°Ð½ÐºÑ|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑ\.?|Ð½ÑÑ|Ð½Ð¾ÑÑ)/i,
  wide: /^([Ð´Ð¿]Ð¿|Ð¿ÑÐ²Ð½ÑÑ|Ð¿Ð¾Ð»ÑÐ´ÐµÐ½Ñ|ÑÐ°Ð½Ð¾Ðº|ÑÐ°Ð½ÐºÑ|Ð´ÐµÐ½Ñ|Ð´Ð½Ñ|Ð²ÐµÑÑÑ|Ð²ÐµÑÐ¾ÑÐ°|Ð½ÑÑ|Ð½Ð¾ÑÑ)/i,
};

const parseDayPeriodPatterns$6 = {
  any: {
    am: /^Ð´Ð¿/i,
    pm: /^Ð¿Ð¿/i,
    midnight: /^Ð¿ÑÐ²Ð½/i,
    noon: /^Ð¿Ð¾Ð»/i,
    morning: /^Ñ/i,
    afternoon: /^Ð´[ÐµÐ½]/i,
    evening: /^Ð²/i,
    night: /^Ð½/i,
  },
};

(match$6.match = {
  ordinalNumber: (0, _index2$1L.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$6,
    parsePattern: parseOrdinalNumberPattern$6,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4h.buildMatchFn)({
    matchPatterns: matchEraPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$6,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4h.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$6,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4h.buildMatchFn)({
    matchPatterns: matchMonthPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$6,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4h.buildMatchFn)({
    matchPatterns: matchDayPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$6,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4h.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$6,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$6,
    defaultParseWidth: "any",
  }),
});

uk.uk = void 0;
var _index$4g = formatDistance$f;
var _index2$1K = formatLong$6;
var _index3$U = formatRelative$f;
var _index4$o = localize$6;
var _index5$f = match$6;

/**
 * @category Locales
 * @summary Ukrainian locale.
 * @language Ukrainian
 * @iso-639-2 ukr
 * @author Andrii Korzh [@korzhyk](https://github.com/korzhyk)
 * @author Andriy Shcherbyak [@shcherbyakdev](https://github.com/shcherbyakdev)
 */
(uk.uk = {
  code: "uk",
  formatDistance: _index$4g.formatDistance,
  formatLong: _index2$1K.formatLong,
  formatRelative: _index3$U.formatRelative,
  localize: _index4$o.localize,
  match: _index5$f.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var uz = {};

var formatDistance$d = {};

formatDistance$d.formatDistance = void 0;

const formatDistanceLocale$5 = {
  lessThanXSeconds: {
    one: "sekunddan kam",
    other: "{{count}} sekunddan kam",
  },

  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekund",
  },

  halfAMinute: "yarim minut",

  lessThanXMinutes: {
    one: "bir minutdan kam",
    other: "{{count}} minutdan kam",
  },

  xMinutes: {
    one: "1 minut",
    other: "{{count}} minut",
  },

  aboutXHours: {
    one: "tahminan 1 soat",
    other: "tahminan {{count}} soat",
  },

  xHours: {
    one: "1 soat",
    other: "{{count}} soat",
  },

  xDays: {
    one: "1 kun",
    other: "{{count}} kun",
  },

  aboutXWeeks: {
    one: "tahminan 1 hafta",
    other: "tahminan {{count}} hafta",
  },

  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta",
  },

  aboutXMonths: {
    one: "tahminan 1 oy",
    other: "tahminan {{count}} oy",
  },

  xMonths: {
    one: "1 oy",
    other: "{{count}} oy",
  },

  aboutXYears: {
    one: "tahminan 1 yil",
    other: "tahminan {{count}} yil",
  },

  xYears: {
    one: "1 yil",
    other: "{{count}} yil",
  },

  overXYears: {
    one: "1 yildan ko'p",
    other: "{{count}} yildan ko'p",
  },

  almostXYears: {
    one: "deyarli 1 yil",
    other: "deyarli {{count}} yil",
  },
};

const formatDistance$c = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$5[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " dan keyin";
    } else {
      return result + " oldin";
    }
  }

  return result;
};
formatDistance$d.formatDistance = formatDistance$c;

var formatLong$5 = {};

formatLong$5.formatLong = void 0;
var _index$4f = buildFormatLongFn$1;

const dateFormats$5 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy",
};

const timeFormats$5 = {
  full: "h:mm:ss zzzz",
  long: "h:mm:ss z",
  medium: "h:mm:ss",
  short: "h:mm",
};

const dateTimeFormats$5 = {
  any: "{{date}}, {{time}}",
};

(formatLong$5.formatLong = {
  date: (0, _index$4f.buildFormatLongFn)({
    formats: dateFormats$5,
    defaultWidth: "full",
  }),

  time: (0, _index$4f.buildFormatLongFn)({
    formats: timeFormats$5,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4f.buildFormatLongFn)({
    formats: dateTimeFormats$5,
    defaultWidth: "any",
  }),
});

var formatRelative$d = {};

formatRelative$d.formatRelative = void 0;

const formatRelativeLocale$5 = {
  lastWeek: "'oldingi' eeee p 'da'",
  yesterday: "'kecha' p 'da'",
  today: "'bugun' p 'da'",
  tomorrow: "'ertaga' p 'da'",
  nextWeek: "eeee p 'da'",
  other: "P",
};

const formatRelative$c = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$5[token];
formatRelative$d.formatRelative = formatRelative$c;

var localize$5 = {};

localize$5.localize = void 0;
var _index$4e = buildLocalizeFn$1;

const eraValues$5 = {
  narrow: ["M.A", "M."],
  abbreviated: ["M.A", "M."],
  wide: ["Miloddan Avvalgi", "Milodiy"],
};

const quarterValues$5 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["CH.1", "CH.2", "CH.3", "CH.4"],
  wide: ["1-chi chorak", "2-chi chorak", "3-chi chorak", "4-chi chorak"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$5 = {
  narrow: ["Y", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "Iyun",
    "Iyul",
    "Avg",
    "Sen",
    "Okt",
    "Noy",
    "Dek",
  ],

  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "Iyun",
    "Iyul",
    "Avgust",
    "Sentabr",
    "Oktabr",
    "Noyabr",
    "Dekabr",
  ],
};

const dayValues$5 = {
  narrow: ["Y", "D", "S", "CH", "P", "J", "SH"],
  short: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
  abbreviated: ["Yak", "Dush", "Sesh", "Chor", "Pay", "Jum", "Shan"],
  wide: [
    "Yakshanba",
    "Dushanba",
    "Seshanba",
    "Chorshanba",
    "Payshanba",
    "Juma",
    "Shanba",
  ],
};

const dayPeriodValues$5 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
};

const formattingDayPeriodValues$5 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun",
  },
};

const ordinalNumber$5 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$5.localize = {
  ordinalNumber: ordinalNumber$5,

  era: (0, _index$4e.buildLocalizeFn)({
    values: eraValues$5,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4e.buildLocalizeFn)({
    values: quarterValues$5,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4e.buildLocalizeFn)({
    values: monthValues$5,
    defaultWidth: "wide",
  }),

  day: (0, _index$4e.buildLocalizeFn)({
    values: dayValues$5,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4e.buildLocalizeFn)({
    values: dayPeriodValues$5,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$5,
    defaultFormattingWidth: "wide",
  }),
});

var match$5 = {};

match$5.match = void 0;

var _index$4d = buildMatchFn$1;
var _index2$1J = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$5 = /^(\d+)(chi)?/i;
const parseOrdinalNumberPattern$5 = /\d+/i;

const matchEraPatterns$5 = {
  narrow: /^(m\.a|m\.)/i,
  abbreviated: /^(m\.a\.?\s?m\.?)/i,
  wide: /^(miloddan avval|miloddan keyin)/i,
};
const parseEraPatterns$5 = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns$5 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](chi)? chorak/i,
};
const parseQuarterPatterns$5 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$5 = {
  narrow: /^[yfmasond]/i,
  abbreviated: /^(yan|fev|mar|apr|may|iyun|iyul|avg|sen|okt|noy|dek)/i,
  wide: /^(yanvar|fevral|mart|aprel|may|iyun|iyul|avgust|sentabr|oktabr|noyabr|dekabr)/i,
};
const parseMonthPatterns$5 = {
  narrow: [
    /^y/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ya/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^iyun/i,
    /^iyul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns$5 = {
  narrow: /^[ydschj]/i,
  short: /^(ya|du|se|cho|pa|ju|sha)/i,
  abbreviated: /^(yak|dush|sesh|chor|pay|jum|shan)/i,
  wide: /^(yakshanba|dushanba|seshanba|chorshanba|payshanba|juma|shanba)/i,
};
const parseDayPatterns$5 = {
  narrow: [/^y/i, /^d/i, /^s/i, /^ch/i, /^p/i, /^j/i, /^sh/i],
  any: [/^ya/i, /^d/i, /^se/i, /^ch/i, /^p/i, /^j/i, /^sh/i],
};

const matchDayPeriodPatterns$5 = {
  narrow: /^(a|p|y\.t|p| (ertalab|tushdan keyin|kechqurun|tun))/i,
  any: /^([ap]\.?\s?m\.?|yarim tun|peshin| (ertalab|tushdan keyin|kechqurun|tun))/i,
};
const parseDayPeriodPatterns$5 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^y\.t/i,
    noon: /^pe/i,
    morning: /ertalab/i,
    afternoon: /tushdan keyin/i,
    evening: /kechqurun/i,
    night: /tun/i,
  },
};

(match$5.match = {
  ordinalNumber: (0, _index2$1J.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$5,
    parsePattern: parseOrdinalNumberPattern$5,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$4d.buildMatchFn)({
    matchPatterns: matchEraPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$5,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$4d.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$5,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$4d.buildMatchFn)({
    matchPatterns: matchMonthPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$5,
    defaultParseWidth: "any",
  }),

  day: (0, _index$4d.buildMatchFn)({
    matchPatterns: matchDayPatterns$5,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$5,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$4d.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$5,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$5,
    defaultParseWidth: "any",
  }),
});

uz.uz = void 0;
var _index$4c = formatDistance$d;
var _index2$1I = formatLong$5;
var _index3$T = formatRelative$d;
var _index4$n = localize$5;
var _index5$e = match$5;

/**
 * @category Locales
 * @summary Uzbek locale.
 * @language Uzbek
 * @iso-639-2 uzb
 * @author Mukhammadali [@mukhammadali](https://github.com/Mukhammadali)
 */
(uz.uz = {
  code: "uz",
  formatDistance: _index$4c.formatDistance,
  formatLong: _index2$1I.formatLong,
  formatRelative: _index3$T.formatRelative,
  localize: _index4$n.localize,
  match: _index5$e.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var uzCyrl = {};

var formatDistance$b = {};

formatDistance$b.formatDistance = void 0;

const formatDistanceLocale$4 = {
  lessThanXSeconds: {
    one: "1 ÑÐ¾Ð½Ð¸ÑÐ´Ð°Ð½ ÐºÐ°Ð¼",
    other: "{{count}} ÑÐ¾Ð½Ð¸ÑÐ´Ð°Ð½ ÐºÐ°Ð¼",
  },

  xSeconds: {
    one: "1 ÑÐ¾Ð½Ð¸Ñ",
    other: "{{count}} ÑÐ¾Ð½Ð¸Ñ",
  },

  halfAMinute: "ÑÑÐ¸Ð¼ Ð´Ð°ÒÐ¸ÒÐ°",

  lessThanXMinutes: {
    one: "1 Ð´Ð°ÒÐ¸ÒÐ°Ð´Ð°Ð½ ÐºÐ°Ð¼",
    other: "{{count}} Ð´Ð°ÒÐ¸ÒÐ°Ð´Ð°Ð½ ÐºÐ°Ð¼",
  },

  xMinutes: {
    one: "1 Ð´Ð°ÒÐ¸ÒÐ°",
    other: "{{count}} Ð´Ð°ÒÐ¸ÒÐ°",
  },

  aboutXHours: {
    one: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ 1 ÑÐ¾Ð°Ñ",
    other: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ {{count}} ÑÐ¾Ð°Ñ",
  },

  xHours: {
    one: "1 ÑÐ¾Ð°Ñ",
    other: "{{count}} ÑÐ¾Ð°Ñ",
  },

  xDays: {
    one: "1 ÐºÑÐ½",
    other: "{{count}} ÐºÑÐ½",
  },

  aboutXWeeks: {
    one: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ 1 ÑÐ°ÑÑÐ°",
    other: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ {{count}} ÑÐ°ÑÑÐ°",
  },

  xWeeks: {
    one: "1 ÑÐ°ÑÑÐ°",
    other: "{{count}} ÑÐ°ÑÑÐ°",
  },

  aboutXMonths: {
    one: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ 1 Ð¾Ð¹",
    other: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ {{count}} Ð¾Ð¹",
  },

  xMonths: {
    one: "1 Ð¾Ð¹",
    other: "{{count}} Ð¾Ð¹",
  },

  aboutXYears: {
    one: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ 1 Ð¹Ð¸Ð»",
    other: "ÑÐ°ÑÐ¼Ð¸Ð½Ð°Ð½ {{count}} Ð¹Ð¸Ð»",
  },

  xYears: {
    one: "1 Ð¹Ð¸Ð»",
    other: "{{count}} Ð¹Ð¸Ð»",
  },

  overXYears: {
    one: "1 Ð¹Ð¸Ð»Ð´Ð°Ð½ ÐºÑÐ¿",
    other: "{{count}} Ð¹Ð¸Ð»Ð´Ð°Ð½ ÐºÑÐ¿",
  },

  almostXYears: {
    one: "Ð´ÐµÑÑÐ»Ð¸ 1 Ð¹Ð¸Ð»",
    other: "Ð´ÐµÑÑÐ»Ð¸ {{count}} Ð¹Ð¸Ð»",
  },
};

const formatDistance$a = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$4[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½";
    } else {
      return result + " Ð¾Ð»Ð´Ð¸Ð½";
    }
  }

  return result;
};
formatDistance$b.formatDistance = formatDistance$a;

var formatLong$4 = {};

formatLong$4.formatLong = void 0;
var _index$4b = buildFormatLongFn$1;

const dateFormats$4 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy",
};

const timeFormats$4 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm",
};

const dateTimeFormats$4 = {
  any: "{{date}}, {{time}}",
};

(formatLong$4.formatLong = {
  date: (0, _index$4b.buildFormatLongFn)({
    formats: dateFormats$4,
    defaultWidth: "full",
  }),

  time: (0, _index$4b.buildFormatLongFn)({
    formats: timeFormats$4,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$4b.buildFormatLongFn)({
    formats: dateTimeFormats$4,
    defaultWidth: "any",
  }),
});

var formatRelative$b = {};

formatRelative$b.formatRelative = void 0;

const formatRelativeLocale$4 = {
  lastWeek: "'ÑÑÐ³Ð°Ð½' eeee p 'Ð´Ð°'",
  yesterday: "'ÐºÐµÑÐ°' p 'Ð´Ð°'",
  today: "'Ð±ÑÐ³ÑÐ½' p 'Ð´Ð°'",
  tomorrow: "'ÑÑÑÐ°Ð³Ð°' p 'Ð´Ð°'",
  nextWeek: "eeee p 'Ð´Ð°'",
  other: "P",
};

const formatRelative$a = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$4[token];
formatRelative$b.formatRelative = formatRelative$a;

var localize$4 = {};

localize$4.localize = void 0;
var _index$4a = buildLocalizeFn$1;

const eraValues$4 = {
  narrow: ["Ð.Ð", "Ð"],
  abbreviated: ["Ð.Ð", "Ð"],
  wide: ["ÐÐ¸Ð»Ð¾Ð´Ð´Ð°Ð½ ÐÐ²Ð²Ð°Ð»Ð³Ð¸", "ÐÐ¸Ð»Ð¾Ð´Ð¸Ð¹"],
};

const quarterValues$4 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ÑÐ¾Ñ.", "2-ÑÐ¾Ñ.", "3-ÑÐ¾Ñ.", "4-ÑÐ¾Ñ."],
  wide: ["1-ÑÐ¾ÑÐ°Ðº", "2-ÑÐ¾ÑÐ°Ðº", "3-ÑÐ¾ÑÐ°Ðº", "4-ÑÐ¾ÑÐ°Ðº"],
};

const monthValues$4 = {
  narrow: ["Ð¯", "Ð¤", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð¡", "Ð", "Ð", "Ð"],
  abbreviated: [
    "ÑÐ½Ð²",
    "ÑÐµÐ²",
    "Ð¼Ð°Ñ",
    "Ð°Ð¿Ñ",
    "Ð¼Ð°Ð¹",
    "Ð¸ÑÐ½",
    "Ð¸ÑÐ»",
    "Ð°Ð²Ð³",
    "ÑÐµÐ½",
    "Ð¾ÐºÑ",
    "Ð½Ð¾Ñ",
    "Ð´ÐµÐº",
  ],

  wide: [
    "ÑÐ½Ð²Ð°Ñ",
    "ÑÐµÐ²ÑÐ°Ð»",
    "Ð¼Ð°ÑÑ",
    "Ð°Ð¿ÑÐµÐ»",
    "Ð¼Ð°Ð¹",
    "Ð¸ÑÐ½",
    "Ð¸ÑÐ»",
    "Ð°Ð²Ð³ÑÑÑ",
    "ÑÐµÐ½ÑÐ°Ð±Ñ",
    "Ð¾ÐºÑÐ°Ð±Ñ",
    "Ð½Ð¾ÑÐ±Ñ",
    "Ð´ÐµÐºÐ°Ð±Ñ",
  ],
};

const dayValues$4 = {
  narrow: ["Ð¯", "Ð", "Ð¡", "Ð§", "Ð", "Ð", "Ð¨"],
  short: ["ÑÐº", "Ð´Ñ", "ÑÐµ", "ÑÐ¾", "Ð¿Ð°", "Ð¶Ñ", "ÑÐ°"],
  abbreviated: ["ÑÐºÑ", "Ð´ÑÑ", "ÑÐµÑ", "ÑÐ¾Ñ", "Ð¿Ð°Ð¹", "Ð¶ÑÐ¼", "ÑÐ°Ð½"],
  wide: [
    "ÑÐºÑÐ°Ð½Ð±Ð°",
    "Ð´ÑÑÐ°Ð½Ð±Ð°",
    "ÑÐµÑÐ°Ð½Ð±Ð°",
    "ÑÐ¾ÑÑÐ°Ð½Ð±Ð°",
    "Ð¿Ð°Ð¹ÑÐ°Ð½Ð±Ð°",
    "Ð¶ÑÐ¼Ð°",
    "ÑÐ°Ð½Ð±Ð°",
  ],
};

const dayPeriodValues$4 = {
  any: {
    am: "Ð.Ð.",
    pm: "Ð.Ð.",
    midnight: "ÑÑÐ¸Ð¼ ÑÑÐ½",
    noon: "Ð¿ÐµÑÐ¸Ð½",
    morning: "ÑÑÑÐ°Ð»Ð°Ð±",
    afternoon: "Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½",
    evening: "ÐºÐµÑÐ°ÑÐ¸",
    night: "ÑÑÐ½",
  },
};

const formattingDayPeriodValues$4 = {
  any: {
    am: "Ð.Ð.",
    pm: "Ð.Ð.",
    midnight: "ÑÑÐ¸Ð¼ ÑÑÐ½",
    noon: "Ð¿ÐµÑÐ¸Ð½",
    morning: "ÑÑÑÐ°Ð»Ð°Ð±",
    afternoon: "Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½",
    evening: "ÐºÐµÑÐ°ÑÐ¸",
    night: "ÑÑÐ½",
  },
};

const ordinalNumber$4 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};

(localize$4.localize = {
  ordinalNumber: ordinalNumber$4,

  era: (0, _index$4a.buildLocalizeFn)({
    values: eraValues$4,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$4a.buildLocalizeFn)({
    values: quarterValues$4,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$4a.buildLocalizeFn)({
    values: monthValues$4,
    defaultWidth: "wide",
  }),

  day: (0, _index$4a.buildLocalizeFn)({
    values: dayValues$4,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$4a.buildLocalizeFn)({
    values: dayPeriodValues$4,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$4,
    defaultFormattingWidth: "any",
  }),
});

var match$4 = {};

match$4.match = void 0;

var _index$49 = buildMatchFn$1;
var _index2$1H = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$4 = /^(\d+)(ÑÐ¸)?/i;
const parseOrdinalNumberPattern$4 = /\d+/i;

const matchEraPatterns$4 = {
  narrow: /^(Ð¼\.Ð°|Ð¼\.)/i,
  abbreviated: /^(Ð¼\.Ð°|Ð¼\.)/i,
  wide: /^(Ð¼Ð¸Ð»Ð¾Ð´Ð´Ð°Ð½ Ð°Ð²Ð²Ð°Ð»|Ð¼Ð¸Ð»Ð¾Ð´Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½)/i,
};
const parseEraPatterns$4 = {
  any: [/^Ð¼/i, /^Ð°/i],
};

const matchQuarterPatterns$4 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-ÑÐ¾Ñ./i,
  wide: /^[1234]-ÑÐ¾ÑÐ°Ðº/i,
};
const parseQuarterPatterns$4 = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns$4 = {
  narrow: /^[ÑÑÐ¼Ð°Ð¼Ð¸Ð¸Ð°ÑÐ¾Ð½Ð´]/i,
  abbreviated: /^(ÑÐ½Ð²|ÑÐµÐ²|Ð¼Ð°Ñ|Ð°Ð¿Ñ|Ð¼Ð°Ð¹|Ð¸ÑÐ½|Ð¸ÑÐ»|Ð°Ð²Ð³|ÑÐµÐ½|Ð¾ÐºÑ|Ð½Ð¾Ñ|Ð´ÐµÐº)/i,
  wide: /^(ÑÐ½Ð²Ð°Ñ|ÑÐµÐ²ÑÐ°Ð»|Ð¼Ð°ÑÑ|Ð°Ð¿ÑÐµÐ»|Ð¼Ð°Ð¹|Ð¸ÑÐ½|Ð¸ÑÐ»|Ð°Ð²Ð³ÑÑÑ|ÑÐµÐ½ÑÐ°Ð±Ñ|Ð¾ÐºÑÐ°Ð±Ñ|Ð½Ð¾ÑÐ±Ñ|Ð´ÐµÐºÐ°Ð±Ñ)/i,
};
const parseMonthPatterns$4 = {
  narrow: [
    /^Ñ/i,
    /^Ñ/i,
    /^Ð¼/i,
    /^Ð°/i,
    /^Ð¼/i,
    /^Ð¸/i,
    /^Ð¸/i,
    /^Ð°/i,
    /^Ñ/i,
    /^Ð¾/i,
    /^Ð½/i,
    /^Ð´/i,
  ],

  any: [
    /^Ñ/i,
    /^Ñ/i,
    /^Ð¼Ð°Ñ/i,
    /^Ð°Ð¿/i,
    /^Ð¼Ð°Ð¹/i,
    /^Ð¸ÑÐ½/i,
    /^Ð¸ÑÐ»/i,
    /^Ð°Ð²/i,
    /^Ñ/i,
    /^Ð¾/i,
    /^Ð½/i,
    /^Ð´/i,
  ],
};

const matchDayPatterns$4 = {
  narrow: /^[ÑÐ´ÑÑÐ¿Ð¶Ñ]/i,
  short: /^(ÑÐº|Ð´Ñ|ÑÐµ|ÑÐ¾|Ð¿Ð°|Ð¶Ñ|ÑÐ°)/i,
  abbreviated: /^(ÑÐºÑ|Ð´ÑÑ|ÑÐµÑ|ÑÐ¾Ñ|Ð¿Ð°Ð¹|Ð¶ÑÐ¼|ÑÐ°Ð½)/i,
  wide: /^(ÑÐºÑÐ°Ð½Ð±Ð°|Ð´ÑÑÐ°Ð½Ð±Ð°|ÑÐµÑÐ°Ð½Ð±Ð°|ÑÐ¾ÑÑÐ°Ð½Ð±Ð°|Ð¿Ð°Ð¹ÑÐ°Ð½Ð±Ð°|Ð¶ÑÐ¼Ð°|ÑÐ°Ð½Ð±Ð°)/i,
};
const parseDayPatterns$4 = {
  narrow: [/^Ñ/i, /^Ð´/i, /^Ñ/i, /^Ñ/i, /^Ð¿/i, /^Ð¶/i, /^Ñ/i],
  any: [/^ÑÐº/i, /^Ð´Ñ/i, /^ÑÐµ/i, /^ÑÐ¾Ñ/i, /^Ð¿Ð°Ð¹/i, /^Ð¶Ñ/i, /^ÑÐ°Ð½/i],
};

const matchDayPeriodPatterns$4 = {
  any: /^(Ð¿\.Ð¾\.|Ð¿\.Ðº\.|ÑÑÐ¸Ð¼ ÑÑÐ½|Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½|(ÑÑÑÐ°Ð»Ð°Ð±|Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½|ÐºÐµÑÐ°ÑÐ¸|ÑÑÐ½))/i,
};
const parseDayPeriodPatterns$4 = {
  any: {
    am: /^Ð¿\.Ð¾\./i,
    pm: /^Ð¿\.Ðº\./i,
    midnight: /^ÑÑÐ¸Ð¼ ÑÑÐ½/i,
    noon: /^Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½/i,
    morning: /ÑÑÑÐ°Ð»Ð°Ð±/i,
    afternoon: /Ð¿ÐµÑÐ¸Ð½Ð´Ð°Ð½ ÐºÐµÐ¹Ð¸Ð½/i,
    evening: /ÐºÐµÑÐ°ÑÐ¸/i,
    night: /ÑÑÐ½/i,
  },
};

(match$4.match = {
  ordinalNumber: (0, _index2$1H.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$4,
    parsePattern: parseOrdinalNumberPattern$4,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$49.buildMatchFn)({
    matchPatterns: matchEraPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$4,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$49.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$4,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$49.buildMatchFn)({
    matchPatterns: matchMonthPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$4,
    defaultParseWidth: "any",
  }),

  day: (0, _index$49.buildMatchFn)({
    matchPatterns: matchDayPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$4,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$49.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$4,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$4,
    defaultParseWidth: "any",
  }),
});

uzCyrl.uzCyrl = void 0;
var _index$48 = formatDistance$b;
var _index2$1G = formatLong$4;
var _index3$S = formatRelative$b;
var _index4$m = localize$4;
var _index5$d = match$4;

/**
 * @category Locales
 * @summary Uzbek Cyrillic locale.
 * @language Uzbek
 * @iso-639-2 uzb
 * @author Kamronbek Shodmonov [@kamronbek28](https://github.com/kamronbek28)
 */
(uzCyrl.uzCyrl = {
  code: "uz-Cyrl",
  formatDistance: _index$48.formatDistance,
  formatLong: _index2$1G.formatLong,
  formatRelative: _index3$S.formatRelative,
  localize: _index4$m.localize,
  match: _index5$d.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1,
  },
});

var vi = {};

var formatDistance$9 = {};

formatDistance$9.formatDistance = void 0;

const formatDistanceLocale$3 = {
  lessThanXSeconds: {
    one: "dÆ°á»i 1 giÃ¢y",
    other: "dÆ°á»i {{count}} giÃ¢y",
  },

  xSeconds: {
    one: "1 giÃ¢y",
    other: "{{count}} giÃ¢y",
  },

  halfAMinute: "ná»­a phÃºt",

  lessThanXMinutes: {
    one: "dÆ°á»i 1 phÃºt",
    other: "dÆ°á»i {{count}} phÃºt",
  },

  xMinutes: {
    one: "1 phÃºt",
    other: "{{count}} phÃºt",
  },

  aboutXHours: {
    one: "khoáº£ng 1 giá»",
    other: "khoáº£ng {{count}} giá»",
  },

  xHours: {
    one: "1 giá»",
    other: "{{count}} giá»",
  },

  xDays: {
    one: "1 ngÃ y",
    other: "{{count}} ngÃ y",
  },

  aboutXWeeks: {
    one: "khoáº£ng 1 tuáº§n",
    other: "khoáº£ng {{count}} tuáº§n",
  },

  xWeeks: {
    one: "1 tuáº§n",
    other: "{{count}} tuáº§n",
  },

  aboutXMonths: {
    one: "khoáº£ng 1 thÃ¡ng",
    other: "khoáº£ng {{count}} thÃ¡ng",
  },

  xMonths: {
    one: "1 thÃ¡ng",
    other: "{{count}} thÃ¡ng",
  },

  aboutXYears: {
    one: "khoáº£ng 1 nÄm",
    other: "khoáº£ng {{count}} nÄm",
  },

  xYears: {
    one: "1 nÄm",
    other: "{{count}} nÄm",
  },

  overXYears: {
    one: "hÆ¡n 1 nÄm",
    other: "hÆ¡n {{count}} nÄm",
  },

  almostXYears: {
    one: "gáº§n 1 nÄm",
    other: "gáº§n {{count}} nÄm",
  },
};

const formatDistance$8 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$3[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + " ná»¯a";
    } else {
      return result + " trÆ°á»c";
    }
  }

  return result;
};
formatDistance$9.formatDistance = formatDistance$8;

var formatLong$3 = {};

formatLong$3.formatLong = void 0;
var _index$47 = buildFormatLongFn$1;

const dateFormats$3 = {
  // thá»© SÃ¡u, ngÃ y 25 thÃ¡ng 08 nÄm 2017
  full: "EEEE, 'ngÃ y' d MMMM 'nÄm' y",
  // ngÃ y 25 thÃ¡ng 08 nÄm 2017
  long: "'ngÃ y' d MMMM 'nÄm' y",
  // 25 thg 08 nÄm 2017
  medium: "d MMM 'nÄm' y",
  // 25/08/2017
  short: "dd/MM/y",
};

const timeFormats$3 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm",
};

const dateTimeFormats$3 = {
  // thá»© SÃ¡u, ngÃ y 25 thÃ¡ng 08 nÄm 2017 23:25:59
  full: "{{date}} {{time}}",
  // ngÃ y 25 thÃ¡ng 08 nÄm 2017 23:25
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$3.formatLong = {
  date: (0, _index$47.buildFormatLongFn)({
    formats: dateFormats$3,
    defaultWidth: "full",
  }),

  time: (0, _index$47.buildFormatLongFn)({
    formats: timeFormats$3,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$47.buildFormatLongFn)({
    formats: dateTimeFormats$3,
    defaultWidth: "full",
  }),
});

var formatRelative$9 = {};

formatRelative$9.formatRelative = void 0;

const formatRelativeLocale$3 = {
  lastWeek: "eeee 'tuáº§n trÆ°á»c vÃ o lÃºc' p",
  yesterday: "'hÃ´m qua vÃ o lÃºc' p",
  today: "'hÃ´m nay vÃ o lÃºc' p",
  tomorrow: "'ngÃ y mai vÃ o lÃºc' p",
  nextWeek: "eeee 'tá»i vÃ o lÃºc' p",
  other: "P",
};

const formatRelative$8 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$3[token];
formatRelative$9.formatRelative = formatRelative$8;

var localize$3 = {};

localize$3.localize = void 0;
var _index$46 = buildLocalizeFn$1;

// Vietnamese locale reference: http://www.localeplanet.com/icu/vi-VN/index.html
// Capitalization reference: http://hcmup.edu.vn/index.php?option=com_content&view=article&id=4106%3Avit-hoa-trong-vn-bn-hanh-chinh&catid=2345%3Atham-kho&Itemid=4103&lang=vi&site=134

const eraValues$3 = {
  narrow: ["TCN", "SCN"],
  abbreviated: ["trÆ°á»c CN", "sau CN"],
  wide: ["trÆ°á»c CÃ´ng NguyÃªn", "sau CÃ´ng NguyÃªn"],
};

const quarterValues$3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["QuÃ½ 1", "QuÃ½ 2", "QuÃ½ 3", "QuÃ½ 4"],
};

const formattingQuarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  // I notice many news outlet use this "quÃ½ II/2018"
  wide: ["quÃ½ I", "quÃ½ II", "quÃ½ III", "quÃ½ IV"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues$3 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],

  abbreviated: [
    "Thg 1",
    "Thg 2",
    "Thg 3",
    "Thg 4",
    "Thg 5",
    "Thg 6",
    "Thg 7",
    "Thg 8",
    "Thg 9",
    "Thg 10",
    "Thg 11",
    "Thg 12",
  ],

  wide: [
    "ThÃ¡ng Má»t",
    "ThÃ¡ng Hai",
    "ThÃ¡ng Ba",
    "ThÃ¡ng TÆ°",
    "ThÃ¡ng NÄm",
    "ThÃ¡ng SÃ¡u",
    "ThÃ¡ng Báº£y",
    "ThÃ¡ng TÃ¡m",
    "ThÃ¡ng ChÃ­n",
    "ThÃ¡ng MÆ°á»i",
    "ThÃ¡ng MÆ°á»i Má»t",
    "ThÃ¡ng MÆ°á»i Hai",
  ],
};
// In Vietnamese date formatting, month number less than 10 expected to have leading zero
const formattingMonthValues = {
  narrow: [
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12",
  ],

  abbreviated: [
    "thg 1",
    "thg 2",
    "thg 3",
    "thg 4",
    "thg 5",
    "thg 6",
    "thg 7",
    "thg 8",
    "thg 9",
    "thg 10",
    "thg 11",
    "thg 12",
  ],

  wide: [
    "thÃ¡ng 01",
    "thÃ¡ng 02",
    "thÃ¡ng 03",
    "thÃ¡ng 04",
    "thÃ¡ng 05",
    "thÃ¡ng 06",
    "thÃ¡ng 07",
    "thÃ¡ng 08",
    "thÃ¡ng 09",
    "thÃ¡ng 10",
    "thÃ¡ng 11",
    "thÃ¡ng 12",
  ],
};

const dayValues$3 = {
  narrow: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
  short: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
  abbreviated: ["CN", "Thá»© 2", "Thá»© 3", "Thá»© 4", "Thá»© 5", "Thá»© 6", "Thá»© 7"],

  wide: [
    "Chá»§ Nháº­t",
    "Thá»© Hai",
    "Thá»© Ba",
    "Thá»© TÆ°",
    "Thá»© NÄm",
    "Thá»© SÃ¡u",
    "Thá»© Báº£y",
  ],
};

// Vietnamese are used to AM/PM borrowing from English, hence `narrow` and
// `abbreviated` are just like English but I'm leaving the `wide`
// format being localized with abbreviations found in some systems (SÃng / CHiá»u);
// however, personally, I don't think `Chiá»u` sounds appropriate for `PM`
const dayPeriodValues$3 = {
  // narrow date period is extremely rare in Vietnamese
  // I used abbreviated form for noon, morning and afternoon
  // which are regconizable by Vietnamese, others cannot be any shorter
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "ná»­a ÄÃªm",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "tá»i",
    night: "ÄÃªm",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ná»­a ÄÃªm",
    noon: "trÆ°a",
    morning: "sÃ¡ng",
    afternoon: "chiá»u",
    evening: "tá»i",
    night: "ÄÃªm",
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "ná»­a ÄÃªm",
    noon: "trÆ°a",
    morning: "sÃ¡ng",
    afternoon: "chiá»u",
    evening: "tá»i",
    night: "ÄÃªm",
  },
};

const formattingDayPeriodValues$3 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "ná»­a ÄÃªm",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "tá»i",
    night: "ÄÃªm",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ná»­a ÄÃªm",
    noon: "trÆ°a",
    morning: "sÃ¡ng",
    afternoon: "chiá»u",
    evening: "tá»i",
    night: "ÄÃªm",
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "ná»­a ÄÃªm",
    noon: "giá»¯a trÆ°a",
    morning: "vÃ o buá»i sÃ¡ng",
    afternoon: "vÃ o buá»i chiá»u",
    evening: "vÃ o buá»i tá»i",
    night: "vÃ o ban ÄÃªm",
  },
};

const ordinalNumber$3 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = options?.unit;

  if (unit === "quarter") {
    // many news outlets use "quÃ½ I"...
    switch (number) {
      case 1:
        return "I";
      case 2:
        return "II";
      case 3:
        return "III";
      case 4:
        return "IV";
    }
  } else if (unit === "day") {
    // day of week in Vietnamese has ordinal number meaning,
    // so we should use them, else it'll sound weird
    switch (number) {
      case 1:
        return "thá»© 2"; // meaning 2nd day but it's the first day of the week :D
      case 2:
        return "thá»© 3"; // meaning 3rd day
      case 3:
        return "thá»© 4"; // meaning 4th day and so on
      case 4:
        return "thá»© 5";
      case 5:
        return "thá»© 6";
      case 6:
        return "thá»© 7";
      case 7:
        return "chá»§ nháº­t"; // meaning Sunday, there's no 8th day :D
    }
  } else if (unit === "week") {
    if (number === 1) {
      return "thá»© nháº¥t";
    } else {
      return "thá»© " + number;
    }
  } else if (unit === "dayOfYear") {
    if (number === 1) {
      return "Äáº§u tiÃªn";
    } else {
      return "thá»© " + number;
    }
  }

  // there are no different forms of ordinal numbers in Vietnamese
  return String(number);
};

(localize$3.localize = {
  ordinalNumber: ordinalNumber$3,

  era: (0, _index$46.buildLocalizeFn)({
    values: eraValues$3,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$46.buildLocalizeFn)({
    values: quarterValues$3,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$46.buildLocalizeFn)({
    values: monthValues$3,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues,
    defaultFormattingWidth: "wide",
  }),

  day: (0, _index$46.buildLocalizeFn)({
    values: dayValues$3,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$46.buildLocalizeFn)({
    values: dayPeriodValues$3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$3,
    defaultFormattingWidth: "wide",
  }),
});

var match$3 = {};

match$3.match = void 0;

var _index$45 = buildMatchFn$1;
var _index2$1F = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$3 = /^(\d+)/i;
const parseOrdinalNumberPattern$3 = /\d+/i;

const matchEraPatterns$3 = {
  narrow: /^(tcn|scn)/i,
  abbreviated: /^(trÆ°á»c CN|sau CN)/i,
  wide: /^(trÆ°á»c CÃ´ng NguyÃªn|sau CÃ´ng NguyÃªn)/i,
};
const parseEraPatterns$3 = {
  any: [/^t/i, /^s/i],
};

const matchQuarterPatterns$3 = {
  narrow: /^([1234]|i{1,3}v?)/i,
  abbreviated: /^q([1234]|i{1,3}v?)/i,
  wide: /^quÃ½ ([1234]|i{1,3}v?)/i,
};
const parseQuarterPatterns$3 = {
  any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i],
};

const matchMonthPatterns$3 = {
  // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
  // note the order of '1' since it is a sub-string of '10', so must be lower priority
  narrow: /^(0?[2-9]|10|11|12|0?1)/i,
  // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
  abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
  // note the order of 'MÆ°á»i' since it is sub-string of MÆ°á»i Má»t, so must be lower priority
  wide: /^thÃ¡ng ?(Má»t|Hai|Ba|TÆ°|NÄm|SÃ¡u|Báº£y|TÃ¡m|ChÃ­n|MÆ°á»i|MÆ°á»i ?Má»t|MÆ°á»i ?Hai|0?[1-9](?!\d)|10|11|12)/i,
};
const parseMonthPatterns$3 = {
  narrow: [
    /0?1$/i,
    /0?2/i,
    /3/,
    /4/,
    /5/,
    /6/,
    /7/,
    /8/,
    /9/,
    /10/,
    /11/,
    /12/,
  ],

  abbreviated: [
    /^thg[ _]?0?1(?!\d)/i,
    /^thg[ _]?0?2/i,
    /^thg[ _]?0?3/i,
    /^thg[ _]?0?4/i,
    /^thg[ _]?0?5/i,
    /^thg[ _]?0?6/i,
    /^thg[ _]?0?7/i,
    /^thg[ _]?0?8/i,
    /^thg[ _]?0?9/i,
    /^thg[ _]?10/i,
    /^thg[ _]?11/i,
    /^thg[ _]?12/i,
  ],

  wide: [
    /^thÃ¡ng ?(Má»t|0?1(?!\d))/i,
    /^thÃ¡ng ?(Hai|0?2)/i,
    /^thÃ¡ng ?(Ba|0?3)/i,
    /^thÃ¡ng ?(TÆ°|0?4)/i,
    /^thÃ¡ng ?(NÄm|0?5)/i,
    /^thÃ¡ng ?(SÃ¡u|0?6)/i,
    /^thÃ¡ng ?(Báº£y|0?7)/i,
    /^thÃ¡ng ?(TÃ¡m|0?8)/i,
    /^thÃ¡ng ?(ChÃ­n|0?9)/i,
    /^thÃ¡ng ?(MÆ°á»i|10)/i,
    /^thÃ¡ng ?(MÆ°á»i ?Má»t|11)/i,
    /^thÃ¡ng ?(MÆ°á»i ?Hai|12)/i,
  ],
};

const matchDayPatterns$3 = {
  narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
  short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  wide: /^(Chá»§ ?Nháº­t|ChÃºa ?Nháº­t|thá»© ?Hai|thá»© ?Ba|thá»© ?TÆ°|thá»© ?NÄm|thá»© ?SÃ¡u|thá»© ?Báº£y)/i,
};
const parseDayPatterns$3 = {
  narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  wide: [/(Chá»§|ChÃºa) ?Nháº­t/i, /Hai/i, /Ba/i, /TÆ°/i, /NÄm/i, /SÃ¡u/i, /Báº£y/i],
};

const matchDayPeriodPatterns$3 = {
  narrow: /^(a|p|ná»­a ÄÃªm|trÆ°a|(giá») (sÃ¡ng|chiá»u|tá»i|ÄÃªm))/i,
  abbreviated: /^(am|pm|ná»­a ÄÃªm|trÆ°a|(giá») (sÃ¡ng|chiá»u|tá»i|ÄÃªm))/i,
  wide: /^(ch[^i]*|sa|ná»­a ÄÃªm|trÆ°a|(giá») (sÃ¡ng|chiá»u|tá»i|ÄÃªm))/i,
};
const parseDayPeriodPatterns$3 = {
  any: {
    am: /^(a|sa)/i,
    pm: /^(p|ch[^i]*)/i,
    midnight: /ná»­a ÄÃªm/i,
    noon: /trÆ°a/i,
    morning: /sÃ¡ng/i,
    afternoon: /chiá»u/i,
    evening: /tá»i/i,
    night: /^ÄÃªm/i,
  },
};

(match$3.match = {
  ordinalNumber: (0, _index2$1F.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$3,
    parsePattern: parseOrdinalNumberPattern$3,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$45.buildMatchFn)({
    matchPatterns: matchEraPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$3,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$45.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$3,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$45.buildMatchFn)({
    matchPatterns: matchMonthPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$3,
    defaultParseWidth: "wide",
  }),

  day: (0, _index$45.buildMatchFn)({
    matchPatterns: matchDayPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$3,
    defaultParseWidth: "wide",
  }),

  dayPeriod: (0, _index$45.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$3,
    defaultParseWidth: "any",
  }),
});

vi.vi = void 0;
var _index$44 = formatDistance$9;
var _index2$1E = formatLong$3;
var _index3$R = formatRelative$9;
var _index4$l = localize$3;
var _index5$c = match$3;

/**
 * @category Locales
 * @summary Vietnamese locale (Vietnam).
 * @language Vietnamese
 * @iso-639-2 vie
 * @author Thanh Tran [@trongthanh](https://github.com/trongthanh)
 * @author Leroy Hopson [@lihop](https://github.com/lihop)
 */
(vi.vi = {
  code: "vi",
  formatDistance: _index$44.formatDistance,
  formatLong: _index2$1E.formatLong,
  formatRelative: _index3$R.formatRelative,
  localize: _index4$l.localize,
  match: _index5$c.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 1 /* First week of new year contains Jan 1st  */,
  },
});

var zhCN = {};

var formatDistance$7 = {};

formatDistance$7.formatDistance = void 0;

const formatDistanceLocale$2 = {
  lessThanXSeconds: {
    one: "ä¸å° 1 ç§",
    other: "ä¸å° {{count}} ç§",
  },

  xSeconds: {
    one: "1 ç§",
    other: "{{count}} ç§",
  },

  halfAMinute: "ååé",

  lessThanXMinutes: {
    one: "ä¸å° 1 åé",
    other: "ä¸å° {{count}} åé",
  },

  xMinutes: {
    one: "1 åé",
    other: "{{count}} åé",
  },

  xHours: {
    one: "1 å°æ¶",
    other: "{{count}} å°æ¶",
  },

  aboutXHours: {
    one: "å¤§çº¦ 1 å°æ¶",
    other: "å¤§çº¦ {{count}} å°æ¶",
  },

  xDays: {
    one: "1 å¤©",
    other: "{{count}} å¤©",
  },

  aboutXWeeks: {
    one: "å¤§çº¦ 1 ä¸ªææ",
    other: "å¤§çº¦ {{count}} ä¸ªææ",
  },

  xWeeks: {
    one: "1 ä¸ªææ",
    other: "{{count}} ä¸ªææ",
  },

  aboutXMonths: {
    one: "å¤§çº¦ 1 ä¸ªæ",
    other: "å¤§çº¦ {{count}} ä¸ªæ",
  },

  xMonths: {
    one: "1 ä¸ªæ",
    other: "{{count}} ä¸ªæ",
  },

  aboutXYears: {
    one: "å¤§çº¦ 1 å¹´",
    other: "å¤§çº¦ {{count}} å¹´",
  },

  xYears: {
    one: "1 å¹´",
    other: "{{count}} å¹´",
  },

  overXYears: {
    one: "è¶è¿ 1 å¹´",
    other: "è¶è¿ {{count}} å¹´",
  },

  almostXYears: {
    one: "å°è¿ 1 å¹´",
    other: "å°è¿ {{count}} å¹´",
  },
};

const formatDistance$6 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "å";
    } else {
      return result + "å";
    }
  }

  return result;
};
formatDistance$7.formatDistance = formatDistance$6;

var formatLong$2 = {};

formatLong$2.formatLong = void 0;
var _index$43 = buildFormatLongFn$1;

const dateFormats$2 = {
  full: "y'å¹´'M'æ'd'æ¥' EEEE",
  long: "y'å¹´'M'æ'd'æ¥'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd",
};

const timeFormats$2 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm",
};

const dateTimeFormats$2 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$2.formatLong = {
  date: (0, _index$43.buildFormatLongFn)({
    formats: dateFormats$2,
    defaultWidth: "full",
  }),

  time: (0, _index$43.buildFormatLongFn)({
    formats: timeFormats$2,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$43.buildFormatLongFn)({
    formats: dateTimeFormats$2,
    defaultWidth: "full",
  }),
});

var formatRelative$7 = {};

formatRelative$7.formatRelative = void 0;
var _index$42 = isSameWeek$1;

function checkWeek(date, baseDate, options) {
  const baseFormat = "eeee p";

  if ((0, _index$42.isSameWeek)(date, baseDate, options)) {
    return baseFormat; // in same week
  } else if (date.getTime() > baseDate.getTime()) {
    return "'ä¸ä¸ª'" + baseFormat; // in next week
  }
  return "'ä¸ä¸ª'" + baseFormat; // in last week
}

const formatRelativeLocale$2 = {
  lastWeek: checkWeek, // days before yesterday, maybe in this week or last week
  yesterday: "'æ¨å¤©' p",
  today: "'ä»å¤©' p",
  tomorrow: "'æå¤©' p",
  nextWeek: checkWeek, // days after tomorrow, maybe in this week or next week
  other: "PP p",
};

const formatRelative$6 = (token, date, baseDate, options) => {
  const format = formatRelativeLocale$2[token];

  if (typeof format === "function") {
    return format(date, baseDate, options);
  }

  return format;
};
formatRelative$7.formatRelative = formatRelative$6;

var localize$2 = {};

localize$2.localize = void 0;
var _index$41 = buildLocalizeFn$1;

const eraValues$2 = {
  narrow: ["å", "å¬å"],
  abbreviated: ["å", "å¬å"],
  wide: ["å¬åå", "å¬å"],
};

const quarterValues$2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ç¬¬ä¸å­£", "ç¬¬äºå­£", "ç¬¬ä¸å­£", "ç¬¬åå­£"],
  wide: ["ç¬¬ä¸å­£åº¦", "ç¬¬äºå­£åº¦", "ç¬¬ä¸å­£åº¦", "ç¬¬åå­£åº¦"],
};

const monthValues$2 = {
  narrow: [
    "ä¸",
    "äº",
    "ä¸",
    "å",
    "äº",
    "å­",
    "ä¸",
    "å«",
    "ä¹",
    "å",
    "åä¸",
    "åäº",
  ],

  abbreviated: [
    "1æ",
    "2æ",
    "3æ",
    "4æ",
    "5æ",
    "6æ",
    "7æ",
    "8æ",
    "9æ",
    "10æ",
    "11æ",
    "12æ",
  ],

  wide: [
    "ä¸æ",
    "äºæ",
    "ä¸æ",
    "åæ",
    "äºæ",
    "å­æ",
    "ä¸æ",
    "å«æ",
    "ä¹æ",
    "åæ",
    "åä¸æ",
    "åäºæ",
  ],
};

const dayValues$2 = {
  narrow: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  short: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  abbreviated: ["å¨æ¥", "å¨ä¸", "å¨äº", "å¨ä¸", "å¨å", "å¨äº", "å¨å­"],

  wide: ["æææ¥", "ææä¸", "ææäº", "ææä¸", "ææå", "ææäº", "ææå­"],
};

const dayPeriodValues$2 = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åæ¨",
    noon: "å",
    morning: "æ©",
    afternoon: "ä¸å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é´",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é´",
  },
};

const formattingDayPeriodValues$2 = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åæ¨",
    noon: "å",
    morning: "æ©",
    afternoon: "ä¸å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é´",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é´",
  },
};

const ordinalNumber$2 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  switch (options?.unit) {
    case "date":
      return number.toString() + "æ¥";
    case "hour":
      return number.toString() + "æ¶";
    case "minute":
      return number.toString() + "å";
    case "second":
      return number.toString() + "ç§";
    default:
      return "ç¬¬ " + number.toString();
  }
};

(localize$2.localize = {
  ordinalNumber: ordinalNumber$2,

  era: (0, _index$41.buildLocalizeFn)({
    values: eraValues$2,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$41.buildLocalizeFn)({
    values: quarterValues$2,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$41.buildLocalizeFn)({
    values: monthValues$2,
    defaultWidth: "wide",
  }),

  day: (0, _index$41.buildLocalizeFn)({
    values: dayValues$2,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$41.buildLocalizeFn)({
    values: dayPeriodValues$2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$2,
    defaultFormattingWidth: "wide",
  }),
});

var match$2 = {};

match$2.match = void 0;

var _index$40 = buildMatchFn$1;
var _index2$1D = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$2 = /^(ç¬¬\s*)?\d+(æ¥|æ¶|å|ç§)?/i;
const parseOrdinalNumberPattern$2 = /\d+/i;

const matchEraPatterns$2 = {
  narrow: /^(å)/i,
  abbreviated: /^(å)/i,
  wide: /^(å¬åå|å¬å)/i,
};
const parseEraPatterns$2 = {
  any: [/^(å)/i, /^(å¬å)/i],
};

const matchQuarterPatterns$2 = {
  narrow: /^[1234]/i,
  abbreviated: /^ç¬¬[ä¸äºä¸å]å»/i,
  wide: /^ç¬¬[ä¸äºä¸å]å»é/i,
};
const parseQuarterPatterns$2 = {
  any: [/(1|ä¸)/i, /(2|äº)/i, /(3|ä¸)/i, /(4|å)/i],
};

const matchMonthPatterns$2 = {
  narrow: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])/i,
  abbreviated: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸]|\d|1[12])æ/i,
  wide: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])æ/i,
};
const parseMonthPatterns$2 = {
  narrow: [
    /^ä¸/i,
    /^äº/i,
    /^ä¸/i,
    /^å/i,
    /^äº/i,
    /^å­/i,
    /^ä¸/i,
    /^å«/i,
    /^ä¹/i,
    /^å(?!(ä¸|äº))/i,
    /^åä¸/i,
    /^åäº/i,
  ],

  any: [
    /^ä¸|1/i,
    /^äº|2/i,
    /^ä¸|3/i,
    /^å|4/i,
    /^äº|5/i,
    /^å­|6/i,
    /^ä¸|7/i,
    /^å«|8/i,
    /^ä¹|9/i,
    /^å(?!(ä¸|äº))|10/i,
    /^åä¸|11/i,
    /^åäº|12/i,
  ],
};

const matchDayPatterns$2 = {
  narrow: /^[ä¸äºä¸åäºå­æ¥]/i,
  short: /^[ä¸äºä¸åäºå­æ¥]/i,
  abbreviated: /^å¨[ä¸äºä¸åäºå­æ¥]/i,
  wide: /^ææ[ä¸äºä¸åäºå­æ¥]/i,
};
const parseDayPatterns$2 = {
  any: [/æ¥/i, /ä¸/i, /äº/i, /ä¸/i, /å/i, /äº/i, /å­/i],
};

const matchDayPeriodPatterns$2 = {
  any: /^(ä¸å?|ä¸å?|åå¤|[ä¸­æ­£]å|æ©ä¸?|ä¸å|æä¸?|åæ¨|)/i,
};
const parseDayPeriodPatterns$2 = {
  any: {
    am: /^ä¸å?/i,
    pm: /^ä¸å?/i,
    midnight: /^åå¤/i,
    noon: /^[ä¸­æ­£]å/i,
    morning: /^æ©ä¸/i,
    afternoon: /^ä¸å/i,
    evening: /^æä¸?/i,
    night: /^åæ¨/i,
  },
};

(match$2.match = {
  ordinalNumber: (0, _index2$1D.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$2,
    parsePattern: parseOrdinalNumberPattern$2,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$40.buildMatchFn)({
    matchPatterns: matchEraPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$2,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$40.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$2,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$40.buildMatchFn)({
    matchPatterns: matchMonthPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$2,
    defaultParseWidth: "any",
  }),

  day: (0, _index$40.buildMatchFn)({
    matchPatterns: matchDayPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$2,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$40.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$2,
    defaultParseWidth: "any",
  }),
});

zhCN.zhCN = void 0;
var _index$3$ = formatDistance$7;
var _index2$1C = formatLong$2;
var _index3$Q = formatRelative$7;
var _index4$k = localize$2;
var _index5$b = match$2;

/**
 * @category Locales
 * @summary Chinese Simplified locale.
 * @language Chinese Simplified
 * @iso-639-2 zho
 * @author Changyu Geng [@KingMario](https://github.com/KingMario)
 * @author Song Shuoyun [@fnlctrl](https://github.com/fnlctrl)
 * @author sabrinaM [@sabrinamiao](https://github.com/sabrinamiao)
 * @author Carney Wu [@cubicwork](https://github.com/cubicwork)
 * @author Terrence Lam [@skyuplam](https://github.com/skyuplam)
 */
(zhCN.zhCN = {
  code: "zh-CN",
  formatDistance: _index$3$.formatDistance,
  formatLong: _index2$1C.formatLong,
  formatRelative: _index3$Q.formatRelative,
  localize: _index4$k.localize,
  match: _index5$b.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

var zhHK = {};

var formatDistance$5 = {};

formatDistance$5.formatDistance = void 0;

const formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: "å°æ¼ 1 ç§",
    other: "å°æ¼ {{count}} ç§",
  },

  xSeconds: {
    one: "1 ç§",
    other: "{{count}} ç§",
  },

  halfAMinute: "ååé",

  lessThanXMinutes: {
    one: "å°æ¼ 1 åé",
    other: "å°æ¼ {{count}} åé",
  },

  xMinutes: {
    one: "1 åé",
    other: "{{count}} åé",
  },

  xHours: {
    one: "1 å°æ",
    other: "{{count}} å°æ",
  },

  aboutXHours: {
    one: "å¤§ç´ 1 å°æ",
    other: "å¤§ç´ {{count}} å°æ",
  },

  xDays: {
    one: "1 å¤©",
    other: "{{count}} å¤©",
  },

  aboutXWeeks: {
    one: "å¤§ç´ 1 åææ",
    other: "å¤§ç´ {{count}} åææ",
  },

  xWeeks: {
    one: "1 åææ",
    other: "{{count}} åææ",
  },

  aboutXMonths: {
    one: "å¤§ç´ 1 åæ",
    other: "å¤§ç´ {{count}} åæ",
  },

  xMonths: {
    one: "1 åæ",
    other: "{{count}} åæ",
  },

  aboutXYears: {
    one: "å¤§ç´ 1 å¹´",
    other: "å¤§ç´ {{count}} å¹´",
  },

  xYears: {
    one: "1 å¹´",
    other: "{{count}} å¹´",
  },

  overXYears: {
    one: "è¶é 1 å¹´",
    other: "è¶é {{count}} å¹´",
  },

  almostXYears: {
    one: "å°è¿ 1 å¹´",
    other: "å°è¿ {{count}} å¹´",
  },
};

const formatDistance$4 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale$1[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "å§";
    } else {
      return result + "å";
    }
  }

  return result;
};
formatDistance$5.formatDistance = formatDistance$4;

var formatLong$1 = {};

formatLong$1.formatLong = void 0;
var _index$3_ = buildFormatLongFn$1;

const dateFormats$1 = {
  full: "y'å¹´'M'æ'd'æ¥' EEEE",
  long: "y'å¹´'M'æ'd'æ¥'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd",
};

const timeFormats$1 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm",
};

const dateTimeFormats$1 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong$1.formatLong = {
  date: (0, _index$3_.buildFormatLongFn)({
    formats: dateFormats$1,
    defaultWidth: "full",
  }),

  time: (0, _index$3_.buildFormatLongFn)({
    formats: timeFormats$1,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$3_.buildFormatLongFn)({
    formats: dateTimeFormats$1,
    defaultWidth: "full",
  }),
});

var formatRelative$5 = {};

formatRelative$5.formatRelative = void 0;

const formatRelativeLocale$1 = {
  lastWeek: "'ä¸å'eeee p",
  yesterday: "'æ¨å¤©' p",
  today: "'ä»å¤©' p",
  tomorrow: "'æå¤©' p",
  nextWeek: "'ä¸å'eeee p",
  other: "P",
};

const formatRelative$4 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale$1[token];
formatRelative$5.formatRelative = formatRelative$4;

var localize$1 = {};

localize$1.localize = void 0;
var _index$3Z = buildLocalizeFn$1;

const eraValues$1 = {
  narrow: ["å", "å¬å"],
  abbreviated: ["å", "å¬å"],
  wide: ["å¬åå", "å¬å"],
};

const quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ç¬¬ä¸å­£", "ç¬¬äºå­£", "ç¬¬ä¸å­£", "ç¬¬åå­£"],
  wide: ["ç¬¬ä¸å­£åº¦", "ç¬¬äºå­£åº¦", "ç¬¬ä¸å­£åº¦", "ç¬¬åå­£åº¦"],
};

const monthValues$1 = {
  narrow: [
    "ä¸",
    "äº",
    "ä¸",
    "å",
    "äº",
    "å­",
    "ä¸",
    "å«",
    "ä¹",
    "å",
    "åä¸",
    "åäº",
  ],

  abbreviated: [
    "1æ",
    "2æ",
    "3æ",
    "4æ",
    "5æ",
    "6æ",
    "7æ",
    "8æ",
    "9æ",
    "10æ",
    "11æ",
    "12æ",
  ],

  wide: [
    "ä¸æ",
    "äºæ",
    "ä¸æ",
    "åæ",
    "äºæ",
    "å­æ",
    "ä¸æ",
    "å«æ",
    "ä¹æ",
    "åæ",
    "åä¸æ",
    "åäºæ",
  ],
};

const dayValues$1 = {
  narrow: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  short: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  abbreviated: ["é±æ¥", "é±ä¸", "é±äº", "é±ä¸", "é±å", "é±äº", "é±å­"],

  wide: ["æææ¥", "ææä¸", "ææäº", "ææä¸", "ææå", "ææäº", "ææå­"],
};

const dayPeriodValues$1 = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åå¤",
    noon: "æ",
    morning: "æ©",
    afternoon: "å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åå¤",
    noon: "ä¸­å",
    morning: "ä¸å",
    afternoon: "ä¸å",
    evening: "æä¸",
    night: "å¤æ",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åå¤",
    noon: "ä¸­å",
    morning: "ä¸å",
    afternoon: "ä¸å",
    evening: "æä¸",
    night: "å¤æ",
  },
};

const formattingDayPeriodValues$1 = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åå¤",
    noon: "æ",
    morning: "æ©",
    afternoon: "å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åå¤",
    noon: "ä¸­å",
    morning: "ä¸å",
    afternoon: "ä¸å",
    evening: "æä¸",
    night: "å¤æ",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åå¤",
    noon: "ä¸­å",
    morning: "ä¸å",
    afternoon: "ä¸å",
    evening: "æä¸",
    night: "å¤æ",
  },
};

const ordinalNumber$1 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  switch (options?.unit) {
    case "date":
      return number + "æ¥";
    case "hour":
      return number + "æ";
    case "minute":
      return number + "å";
    case "second":
      return number + "ç§";
    default:
      return "ç¬¬ " + number;
  }
};

(localize$1.localize = {
  ordinalNumber: ordinalNumber$1,

  era: (0, _index$3Z.buildLocalizeFn)({
    values: eraValues$1,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$3Z.buildLocalizeFn)({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$3Z.buildLocalizeFn)({
    values: monthValues$1,
    defaultWidth: "wide",
  }),

  day: (0, _index$3Z.buildLocalizeFn)({
    values: dayValues$1,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$3Z.buildLocalizeFn)({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide",
  }),
});

var match$1 = {};

match$1.match = void 0;

var _index$3Y = buildMatchFn$1;
var _index2$1B = buildMatchPatternFn$1;

const matchOrdinalNumberPattern$1 = /^(ç¬¬\s*)?\d+(æ¥|æ|å|ç§)?/i;
const parseOrdinalNumberPattern$1 = /\d+/i;

const matchEraPatterns$1 = {
  narrow: /^(å)/i,
  abbreviated: /^(å)/i,
  wide: /^(å¬åå|å¬å)/i,
};
const parseEraPatterns$1 = {
  any: [/^(å)/i, /^(å¬å)/i],
};

const matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^ç¬¬[ä¸äºä¸å]å­£/i,
  wide: /^ç¬¬[ä¸äºä¸å]å­£åº¦/i,
};
const parseQuarterPatterns$1 = {
  any: [/(1|ä¸)/i, /(2|äº)/i, /(3|ä¸)/i, /(4|å)/i],
};

const matchMonthPatterns$1 = {
  narrow: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])/i,
  abbreviated: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸]|\d|1[12])æ/i,
  wide: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])æ/i,
};
const parseMonthPatterns$1 = {
  narrow: [
    /^ä¸/i,
    /^äº/i,
    /^ä¸/i,
    /^å/i,
    /^äº/i,
    /^å­/i,
    /^ä¸/i,
    /^å«/i,
    /^ä¹/i,
    /^å(?!(ä¸|äº))/i,
    /^åä¸/i,
    /^åäº/i,
  ],

  any: [
    /^ä¸|1/i,
    /^äº|2/i,
    /^ä¸|3/i,
    /^å|4/i,
    /^äº|5/i,
    /^å­|6/i,
    /^ä¸|7/i,
    /^å«|8/i,
    /^ä¹|9/i,
    /^å(?!(ä¸|äº))|10/i,
    /^åä¸|11/i,
    /^åäº|12/i,
  ],
};

const matchDayPatterns$1 = {
  narrow: /^[ä¸äºä¸åäºå­æ¥]/i,
  short: /^[ä¸äºä¸åäºå­æ¥]/i,
  abbreviated: /^é±[ä¸äºä¸åäºå­æ¥]/i,
  wide: /^ææ[ä¸äºä¸åäºå­æ¥]/i,
};
const parseDayPatterns$1 = {
  any: [/æ¥/i, /ä¸/i, /äº/i, /ä¸/i, /å/i, /äº/i, /å­/i],
};

const matchDayPeriodPatterns$1 = {
  any: /^(ä¸å?|ä¸å?|åå¤|[ä¸­æ­£]å|æ©ä¸?|ä¸å|æä¸?|åæ¨)/i,
};
const parseDayPeriodPatterns$1 = {
  any: {
    am: /^ä¸å?/i,
    pm: /^ä¸å?/i,
    midnight: /^åå¤/i,
    noon: /^[ä¸­æ­£]å/i,
    morning: /^æ©ä¸/i,
    afternoon: /^ä¸å/i,
    evening: /^æä¸?/i,
    night: /^åæ¨/i,
  },
};

(match$1.match = {
  ordinalNumber: (0, _index2$1B.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$3Y.buildMatchFn)({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$3Y.buildMatchFn)({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$3Y.buildMatchFn)({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any",
  }),

  day: (0, _index$3Y.buildMatchFn)({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$3Y.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any",
  }),
});

zhHK.zhHK = void 0;
var _index$3X = formatDistance$5;
var _index2$1A = formatLong$1;
var _index3$P = formatRelative$5;
var _index4$j = localize$1;
var _index5$a = match$1;

/**
 * @category Locales
 * @summary Chinese Traditional locale.
 * @language Chinese Traditional
 * @iso-639-2 zho
 * @author Gary Ip [@gaplo](https://github.com/gaplo)
 */
(zhHK.zhHK = {
  code: "zh-HK",
  formatDistance: _index$3X.formatDistance,
  formatLong: _index2$1A.formatLong,
  formatRelative: _index3$P.formatRelative,
  localize: _index4$j.localize,
  match: _index5$a.match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
});

var zhTW = {};

var formatDistance$3 = {};

formatDistance$3.formatDistance = void 0;

const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "å°æ¼ 1 ç§",
    other: "å°æ¼ {{count}} ç§",
  },

  xSeconds: {
    one: "1 ç§",
    other: "{{count}} ç§",
  },

  halfAMinute: "ååé",

  lessThanXMinutes: {
    one: "å°æ¼ 1 åé",
    other: "å°æ¼ {{count}} åé",
  },

  xMinutes: {
    one: "1 åé",
    other: "{{count}} åé",
  },

  xHours: {
    one: "1 å°æ",
    other: "{{count}} å°æ",
  },

  aboutXHours: {
    one: "å¤§ç´ 1 å°æ",
    other: "å¤§ç´ {{count}} å°æ",
  },

  xDays: {
    one: "1 å¤©",
    other: "{{count}} å¤©",
  },

  aboutXWeeks: {
    one: "å¤§ç´ 1 åææ",
    other: "å¤§ç´ {{count}} åææ",
  },

  xWeeks: {
    one: "1 åææ",
    other: "{{count}} åææ",
  },

  aboutXMonths: {
    one: "å¤§ç´ 1 åæ",
    other: "å¤§ç´ {{count}} åæ",
  },

  xMonths: {
    one: "1 åæ",
    other: "{{count}} åæ",
  },

  aboutXYears: {
    one: "å¤§ç´ 1 å¹´",
    other: "å¤§ç´ {{count}} å¹´",
  },

  xYears: {
    one: "1 å¹´",
    other: "{{count}} å¹´",
  },

  overXYears: {
    one: "è¶é 1 å¹´",
    other: "è¶é {{count}} å¹´",
  },

  almostXYears: {
    one: "å°è¿ 1 å¹´",
    other: "å°è¿ {{count}} å¹´",
  },
};

const formatDistance$2 = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "å§";
    } else {
      return result + "å";
    }
  }

  return result;
};
formatDistance$3.formatDistance = formatDistance$2;

var formatLong = {};

formatLong.formatLong = void 0;
var _index$3W = buildFormatLongFn$1;

const dateFormats = {
  full: "y'å¹´'M'æ'd'æ¥' EEEE",
  long: "y'å¹´'M'æ'd'æ¥'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd",
};

const timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm",
};

const dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}",
};

(formatLong.formatLong = {
  date: (0, _index$3W.buildFormatLongFn)({
    formats: dateFormats,
    defaultWidth: "full",
  }),

  time: (0, _index$3W.buildFormatLongFn)({
    formats: timeFormats,
    defaultWidth: "full",
  }),

  dateTime: (0, _index$3W.buildFormatLongFn)({
    formats: dateTimeFormats,
    defaultWidth: "full",
  }),
});

var formatRelative$3 = {};

formatRelative$3.formatRelative = void 0;

const formatRelativeLocale = {
  lastWeek: "'ä¸å'eeee p",
  yesterday: "'æ¨å¤©' p",
  today: "'ä»å¤©' p",
  tomorrow: "'æå¤©' p",
  nextWeek: "'ä¸å'eeee p",
  other: "P",
};

const formatRelative$2 = (token, _date, _baseDate, _options) =>
  formatRelativeLocale[token];
formatRelative$3.formatRelative = formatRelative$2;

var localize = {};

localize.localize = void 0;
var _index$3V = buildLocalizeFn$1;

const eraValues = {
  narrow: ["å", "å¬å"],
  abbreviated: ["å", "å¬å"],
  wide: ["å¬åå", "å¬å"],
};

const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ç¬¬ä¸å»", "ç¬¬äºå»", "ç¬¬ä¸å»", "ç¬¬åå»"],
  wide: ["ç¬¬ä¸å»é", "ç¬¬äºå»é", "ç¬¬ä¸å»é", "ç¬¬åå»é"],
};

const monthValues = {
  narrow: [
    "ä¸",
    "äº",
    "ä¸",
    "å",
    "äº",
    "å­",
    "ä¸",
    "å«",
    "ä¹",
    "å",
    "åä¸",
    "åäº",
  ],

  abbreviated: [
    "1æ",
    "2æ",
    "3æ",
    "4æ",
    "5æ",
    "6æ",
    "7æ",
    "8æ",
    "9æ",
    "10æ",
    "11æ",
    "12æ",
  ],

  wide: [
    "ä¸æ",
    "äºæ",
    "ä¸æ",
    "åæ",
    "äºæ",
    "å­æ",
    "ä¸æ",
    "å«æ",
    "ä¹æ",
    "åæ",
    "åä¸æ",
    "åäºæ",
  ],
};

const dayValues = {
  narrow: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  short: ["æ¥", "ä¸", "äº", "ä¸", "å", "äº", "å­"],
  abbreviated: ["é±æ¥", "é±ä¸", "é±äº", "é±ä¸", "é±å", "é±äº", "é±å­"],

  wide: ["æææ¥", "ææä¸", "ææäº", "ææä¸", "ææå", "ææäº", "ææå­"],
};

const dayPeriodValues = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åæ¨",
    noon: "å",
    morning: "æ©",
    afternoon: "ä¸å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é",
  },
};

const formattingDayPeriodValues = {
  narrow: {
    am: "ä¸",
    pm: "ä¸",
    midnight: "åæ¨",
    noon: "å",
    morning: "æ©",
    afternoon: "ä¸å",
    evening: "æ",
    night: "å¤",
  },
  abbreviated: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é",
  },
  wide: {
    am: "ä¸å",
    pm: "ä¸å",
    midnight: "åæ¨",
    noon: "ä¸­å",
    morning: "æ©æ¨",
    afternoon: "ä¸­å",
    evening: "æä¸",
    night: "å¤é",
  },
};

const ordinalNumber = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);

  switch (options?.unit) {
    case "date":
      return number + "æ¥";
    case "hour":
      return number + "æ";
    case "minute":
      return number + "å";
    case "second":
      return number + "ç§";
    default:
      return "ç¬¬ " + number;
  }
};

(localize.localize = {
  ordinalNumber,

  era: (0, _index$3V.buildLocalizeFn)({
    values: eraValues,
    defaultWidth: "wide",
  }),

  quarter: (0, _index$3V.buildLocalizeFn)({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: (0, _index$3V.buildLocalizeFn)({
    values: monthValues,
    defaultWidth: "wide",
  }),

  day: (0, _index$3V.buildLocalizeFn)({
    values: dayValues,
    defaultWidth: "wide",
  }),

  dayPeriod: (0, _index$3V.buildLocalizeFn)({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide",
  }),
});

var match = {};

match.match = void 0;

var _index$3U = buildMatchFn$1;
var _index2$1z = buildMatchPatternFn$1;

const matchOrdinalNumberPattern = /^(ç¬¬\s*)?\d+(æ¥|æ|å|ç§)?/i;
const parseOrdinalNumberPattern = /\d+/i;

const matchEraPatterns = {
  narrow: /^(å)/i,
  abbreviated: /^(å)/i,
  wide: /^(å¬åå|å¬å)/i,
};
const parseEraPatterns = {
  any: [/^(å)/i, /^(å¬å)/i],
};

const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^ç¬¬[ä¸äºä¸å]å»/i,
  wide: /^ç¬¬[ä¸äºä¸å]å»é/i,
};
const parseQuarterPatterns = {
  any: [/(1|ä¸)/i, /(2|äº)/i, /(3|ä¸)/i, /(4|å)/i],
};

const matchMonthPatterns = {
  narrow: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])/i,
  abbreviated: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸]|\d|1[12])æ/i,
  wide: /^(ä¸|äº|ä¸|å|äº|å­|ä¸|å«|ä¹|å[äºä¸])æ/i,
};
const parseMonthPatterns = {
  narrow: [
    /^ä¸/i,
    /^äº/i,
    /^ä¸/i,
    /^å/i,
    /^äº/i,
    /^å­/i,
    /^ä¸/i,
    /^å«/i,
    /^ä¹/i,
    /^å(?!(ä¸|äº))/i,
    /^åä¸/i,
    /^åäº/i,
  ],

  any: [
    /^ä¸|1/i,
    /^äº|2/i,
    /^ä¸|3/i,
    /^å|4/i,
    /^äº|5/i,
    /^å­|6/i,
    /^ä¸|7/i,
    /^å«|8/i,
    /^ä¹|9/i,
    /^å(?!(ä¸|äº))|10/i,
    /^åä¸|11/i,
    /^åäº|12/i,
  ],
};

const matchDayPatterns = {
  narrow: /^[ä¸äºä¸åäºå­æ¥]/i,
  short: /^[ä¸äºä¸åäºå­æ¥]/i,
  abbreviated: /^é±[ä¸äºä¸åäºå­æ¥]/i,
  wide: /^ææ[ä¸äºä¸åäºå­æ¥]/i,
};
const parseDayPatterns = {
  any: [/æ¥/i, /ä¸/i, /äº/i, /ä¸/i, /å/i, /äº/i, /å­/i],
};

const matchDayPeriodPatterns = {
  any: /^(ä¸å?|ä¸å?|åå¤|[ä¸­æ­£]å|æ©ä¸?|ä¸å|æä¸?|åæ¨)/i,
};
const parseDayPeriodPatterns = {
  any: {
    am: /^ä¸å?/i,
    pm: /^ä¸å?/i,
    midnight: /^åå¤/i,
    noon: /^[ä¸­æ­£]å/i,
    morning: /^æ©ä¸/i,
    afternoon: /^ä¸å/i,
    evening: /^æä¸?/i,
    night: /^åæ¨/i,
  },
};

(match.match = {
  ordinalNumber: (0, _index2$1z.buildMatchPatternFn)({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: (0, _index$3U.buildMatchFn)({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any",
  }),

  quarter: (0, _index$3U.buildMatchFn)({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: (0, _index$3U.buildMatchFn)({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any",
  }),

  day: (0, _index$3U.buildMatchFn)({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any",
  }),

  dayPeriod: (0, _index$3U.buildMatchFn)({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any",
  }),
});

zhTW.zhTW = void 0;
var _index$3T = formatDistance$3;
var _index2$1y = formatLong;
var _index3$O = formatRelative$3;
var _index4$i = localize;
var _index5$9 = match;

/**
 * @category Locales
 * @summary Chinese Traditional locale.
 * @language Chinese Traditional
 * @iso-639-2 zho
 * @author tonypai [@tpai](https://github.com/tpai)
 * @author Jack Hsu [@jackhsu978](https://github.com/jackhsu978)
 * @author Terrence Lam [@skyuplam](https://github.com/skyuplam)
 */
(zhTW.zhTW = {
  code: "zh-TW",
  formatDistance: _index$3T.formatDistance,
  formatLong: _index2$1y.formatLong,
  formatRelative: _index3$O.formatRelative,
  localize: _index4$i.localize,
  match: _index5$9.match,
  options: {
    weekStartsOn: 1 /* Monday */,
    firstWeekContainsDate: 4,
  },
});

(function (exports) {

var _index = af;
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    },
  });
});
var _index2 = ar;
Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    },
  });
});
var _index3 = arDZ;
Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index3[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index3[key];
    },
  });
});
var _index4 = arEG;
Object.keys(_index4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index4[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index4[key];
    },
  });
});
var _index5 = arMA;
Object.keys(_index5).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index5[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index5[key];
    },
  });
});
var _index6 = arSA;
Object.keys(_index6).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index6[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index6[key];
    },
  });
});
var _index7 = arTN;
Object.keys(_index7).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index7[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index7[key];
    },
  });
});
var _index8 = az;
Object.keys(_index8).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index8[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index8[key];
    },
  });
});
var _index9 = be;
Object.keys(_index9).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index9[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index9[key];
    },
  });
});
var _index10 = beTarask;
Object.keys(_index10).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index10[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index10[key];
    },
  });
});
var _index11 = bg;
Object.keys(_index11).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index11[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index11[key];
    },
  });
});
var _index12 = bn;
Object.keys(_index12).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index12[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index12[key];
    },
  });
});
var _index13 = bs;
Object.keys(_index13).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index13[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index13[key];
    },
  });
});
var _index14 = ca;
Object.keys(_index14).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index14[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index14[key];
    },
  });
});
var _index15 = ckb;
Object.keys(_index15).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index15[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index15[key];
    },
  });
});
var _index16 = cs;
Object.keys(_index16).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index16[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index16[key];
    },
  });
});
var _index17 = cy;
Object.keys(_index17).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index17[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index17[key];
    },
  });
});
var _index18 = da;
Object.keys(_index18).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index18[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index18[key];
    },
  });
});
var _index19 = de;
Object.keys(_index19).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index19[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index19[key];
    },
  });
});
var _index20 = deAT;
Object.keys(_index20).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index20[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index20[key];
    },
  });
});
var _index21 = el;
Object.keys(_index21).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index21[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index21[key];
    },
  });
});
var _index22 = enAU;
Object.keys(_index22).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index22[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index22[key];
    },
  });
});
var _index23 = enCA;
Object.keys(_index23).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index23[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index23[key];
    },
  });
});
var _index24 = enGB;
Object.keys(_index24).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index24[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index24[key];
    },
  });
});
var _index25 = enIE;
Object.keys(_index25).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index25[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index25[key];
    },
  });
});
var _index26 = enIN;
Object.keys(_index26).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index26[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index26[key];
    },
  });
});
var _index27 = enNZ;
Object.keys(_index27).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index27[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index27[key];
    },
  });
});
var _index28 = enUS;
Object.keys(_index28).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index28[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index28[key];
    },
  });
});
var _index29 = enZA;
Object.keys(_index29).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index29[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index29[key];
    },
  });
});
var _index30 = eo;
Object.keys(_index30).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index30[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index30[key];
    },
  });
});
var _index31 = es;
Object.keys(_index31).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index31[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index31[key];
    },
  });
});
var _index32 = et;
Object.keys(_index32).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index32[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index32[key];
    },
  });
});
var _index33 = eu;
Object.keys(_index33).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index33[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index33[key];
    },
  });
});
var _index34 = faIR;
Object.keys(_index34).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index34[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index34[key];
    },
  });
});
var _index35 = fi;
Object.keys(_index35).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index35[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index35[key];
    },
  });
});
var _index36 = fr;
Object.keys(_index36).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index36[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index36[key];
    },
  });
});
var _index37 = frCA;
Object.keys(_index37).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index37[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index37[key];
    },
  });
});
var _index38 = frCH;
Object.keys(_index38).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index38[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index38[key];
    },
  });
});
var _index39 = fy;
Object.keys(_index39).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index39[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index39[key];
    },
  });
});
var _index40 = gd;
Object.keys(_index40).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index40[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index40[key];
    },
  });
});
var _index41 = gl;
Object.keys(_index41).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index41[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index41[key];
    },
  });
});
var _index42 = gu;
Object.keys(_index42).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index42[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index42[key];
    },
  });
});
var _index43 = he;
Object.keys(_index43).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index43[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index43[key];
    },
  });
});
var _index44 = hi;
Object.keys(_index44).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index44[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index44[key];
    },
  });
});
var _index45 = hr;
Object.keys(_index45).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index45[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index45[key];
    },
  });
});
var _index46 = ht;
Object.keys(_index46).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index46[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index46[key];
    },
  });
});
var _index47 = hu;
Object.keys(_index47).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index47[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index47[key];
    },
  });
});
var _index48 = hy;
Object.keys(_index48).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index48[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index48[key];
    },
  });
});
var _index49 = id;
Object.keys(_index49).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index49[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index49[key];
    },
  });
});
var _index50 = is;
Object.keys(_index50).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index50[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index50[key];
    },
  });
});
var _index51 = it;
Object.keys(_index51).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index51[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index51[key];
    },
  });
});
var _index52 = itCH;
Object.keys(_index52).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index52[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index52[key];
    },
  });
});
var _index53 = ja;
Object.keys(_index53).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index53[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index53[key];
    },
  });
});
var _index54 = jaHira;
Object.keys(_index54).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index54[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index54[key];
    },
  });
});
var _index55 = ka;
Object.keys(_index55).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index55[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index55[key];
    },
  });
});
var _index56 = kk;
Object.keys(_index56).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index56[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index56[key];
    },
  });
});
var _index57 = km;
Object.keys(_index57).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index57[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index57[key];
    },
  });
});
var _index58 = kn;
Object.keys(_index58).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index58[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index58[key];
    },
  });
});
var _index59 = ko;
Object.keys(_index59).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index59[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index59[key];
    },
  });
});
var _index60 = lb;
Object.keys(_index60).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index60[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index60[key];
    },
  });
});
var _index61 = lt;
Object.keys(_index61).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index61[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index61[key];
    },
  });
});
var _index62 = lv;
Object.keys(_index62).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index62[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index62[key];
    },
  });
});
var _index63 = mk;
Object.keys(_index63).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index63[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index63[key];
    },
  });
});
var _index64 = mn;
Object.keys(_index64).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index64[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index64[key];
    },
  });
});
var _index65 = ms;
Object.keys(_index65).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index65[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index65[key];
    },
  });
});
var _index66 = mt;
Object.keys(_index66).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index66[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index66[key];
    },
  });
});
var _index67 = nb;
Object.keys(_index67).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index67[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index67[key];
    },
  });
});
var _index68 = nl;
Object.keys(_index68).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index68[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index68[key];
    },
  });
});
var _index69 = nlBE;
Object.keys(_index69).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index69[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index69[key];
    },
  });
});
var _index70 = nn;
Object.keys(_index70).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index70[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index70[key];
    },
  });
});
var _index71 = oc;
Object.keys(_index71).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index71[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index71[key];
    },
  });
});
var _index72 = pl;
Object.keys(_index72).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index72[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index72[key];
    },
  });
});
var _index73 = pt;
Object.keys(_index73).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index73[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index73[key];
    },
  });
});
var _index74 = ptBR;
Object.keys(_index74).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index74[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index74[key];
    },
  });
});
var _index75 = ro;
Object.keys(_index75).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index75[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index75[key];
    },
  });
});
var _index76 = ru;
Object.keys(_index76).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index76[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index76[key];
    },
  });
});
var _index77 = se;
Object.keys(_index77).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index77[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index77[key];
    },
  });
});
var _index78 = sk;
Object.keys(_index78).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index78[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index78[key];
    },
  });
});
var _index79 = sl;
Object.keys(_index79).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index79[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index79[key];
    },
  });
});
var _index80 = sq;
Object.keys(_index80).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index80[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index80[key];
    },
  });
});
var _index81 = sr;
Object.keys(_index81).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index81[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index81[key];
    },
  });
});
var _index82 = srLatn;
Object.keys(_index82).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index82[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index82[key];
    },
  });
});
var _index83 = sv;
Object.keys(_index83).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index83[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index83[key];
    },
  });
});
var _index84 = ta;
Object.keys(_index84).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index84[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index84[key];
    },
  });
});
var _index85 = te;
Object.keys(_index85).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index85[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index85[key];
    },
  });
});
var _index86 = th;
Object.keys(_index86).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index86[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index86[key];
    },
  });
});
var _index87 = tr;
Object.keys(_index87).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index87[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index87[key];
    },
  });
});
var _index88 = ug;
Object.keys(_index88).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index88[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index88[key];
    },
  });
});
var _index89 = uk;
Object.keys(_index89).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index89[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index89[key];
    },
  });
});
var _index90 = uz;
Object.keys(_index90).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index90[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index90[key];
    },
  });
});
var _index91 = uzCyrl;
Object.keys(_index91).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index91[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index91[key];
    },
  });
});
var _index92 = vi;
Object.keys(_index92).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index92[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index92[key];
    },
  });
});
var _index93 = zhCN;
Object.keys(_index93).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index93[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index93[key];
    },
  });
});
var _index94 = zhHK;
Object.keys(_index94).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index94[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index94[key];
    },
  });
});
var _index95 = zhTW;
Object.keys(_index95).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index95[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index95[key];
    },
  });
});
}(locale));

const initialState$3 = {
    currentPage: 'booking',
    dir: 'LTR',
    selectedLocale: locale.enUS,
    localizedWords: [],
    userPreferences: {
        currency_id: 'usd',
        language_id: 'en',
    },
    app_data: {
        token: '',
        property_id: null,
        injected: false,
        roomtype_id: null,
    },
    property: undefined,
    setup_entries: undefined,
    currencies: [],
    userDefaultCountry: undefined,
    fetchedBooking: false,
    languages: [],
};
const { state: app_store, onChange: onAppDataChange } = index.createStore(initialState$3);
function changeLocale(dir, locale) {
    document.body.dir = dir;
    app_store.dir = dir;
    app_store.selectedLocale = locale;
}
function updateUserPreference(params) {
    app_store.userPreferences = Object.assign(Object.assign({}, app_store.userPreferences), params);
}

var dateFns = {};

var add$1 = {};

var addDays$1 = {};

var constructFrom$1 = {};

constructFrom$1.constructFrom = constructFrom;

/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from 'date-fns'
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use contrustor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   )
 * }
 */
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

addDays$1.addDays = addDays;
var _index$3S = toDate$1;
var _index2$1x = constructFrom$1;

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be added.
 *
 * @returns The new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(date, amount) {
  const _date = (0, _index$3S.toDate)(date);
  if (isNaN(amount)) return (0, _index2$1x.constructFrom)(date, NaN);
  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

var addMonths$1 = {};

addMonths$1.addMonths = addMonths;
var _index$3R = toDate$1;
var _index2$1w = constructFrom$1;

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be added.
 *
 * @returns The new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 *
 * // Add one month to 30 January 2023:
 * const result = addMonths(new Date(2023, 0, 30), 1)
 * //=> Tue Feb 28 2023 00:00:00
 */
function addMonths(date, amount) {
  const _date = (0, _index$3R.toDate)(date);
  if (isNaN(amount)) return (0, _index2$1w.constructFrom)(date, NaN);
  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return _date;
  }
  const dayOfMonth = _date.getDate();

  // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.
  const endOfDesiredMonth = (0, _index2$1w.constructFrom)(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth,
    );
    return _date;
  }
}

add$1.add = add;
var _index$3Q = addDays$1;
var _index2$1v = addMonths$1;
var _index3$N = constructFrom$1;
var _index4$h = toDate$1;

/**
 * @name add
 * @category Common Helpers
 * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @description
 * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * | Key            | Description                        |
 * |----------------|------------------------------------|
 * | years          | Amount of years to be added        |
 * | months         | Amount of months to be added       |
 * | weeks          | Amount of weeks to be added        |
 * | days           | Amount of days to be added         |
 * | hours          | Amount of hours to be added        |
 * | minutes        | Amount of minutes to be added      |
 * | seconds        | Amount of seconds to be added      |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add the following duration to 1 September 2014, 10:19:50
 * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,\\-7
 *   minutes: 9,
 *   seconds: 30,
 * })
 * //=> Thu Jun 15 2017 15:29:20
 */
function add(date, duration) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  // Add years and months
  const _date = (0, _index4$h.toDate)(date);
  const dateWithMonths =
    months || years
      ? (0, _index2$1v.addMonths)(_date, months + years * 12)
      : _date;

  // Add weeks and days
  const dateWithDays =
    days || weeks
      ? (0, _index$3Q.addDays)(dateWithMonths, days + weeks * 7)
      : dateWithMonths;

  // Add days, hours, minutes and seconds
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1000;
  const finalDate = (0, _index3$N.constructFrom)(
    date,
    dateWithDays.getTime() + msToAdd,
  );

  return finalDate;
}

var addBusinessDays$1 = {};

var isSaturday$1 = {};

isSaturday$1.isSaturday = isSaturday;
var _index$3P = toDate$1;

/**
 * @name isSaturday
 * @category Weekday Helpers
 * @summary Is the given date Saturday?
 *
 * @description
 * Is the given date Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Saturday
 *
 * @example
 * // Is 27 September 2014 Saturday?
 * const result = isSaturday(new Date(2014, 8, 27))
 * //=> true
 */
function isSaturday(date) {
  return (0, _index$3P.toDate)(date).getDay() === 6;
}

var isSunday$1 = {};

isSunday$1.isSunday = isSunday;
var _index$3O = toDate$1;

/**
 * @name isSunday
 * @category Weekday Helpers
 * @summary Is the given date Sunday?
 *
 * @description
 * Is the given date Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Sunday
 *
 * @example
 * // Is 21 September 2014 Sunday?
 * const result = isSunday(new Date(2014, 8, 21))
 * //=> true
 */
function isSunday(date) {
  return (0, _index$3O.toDate)(date).getDay() === 0;
}

var isWeekend$1 = {};

isWeekend$1.isWeekend = isWeekend;
var _index$3N = toDate$1;

/**
 * @name isWeekend
 * @category Weekday Helpers
 * @summary Does the given date fall on a weekend?
 *
 * @description
 * Does the given date fall on a weekend?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date falls on a weekend
 *
 * @example
 * // Does 5 October 2014 fall on a weekend?
 * const result = isWeekend(new Date(2014, 9, 5))
 * //=> true
 */
function isWeekend(date) {
  const day = (0, _index$3N.toDate)(date).getDay();
  return day === 0 || day === 6;
}

addBusinessDays$1.addBusinessDays = addBusinessDays;
var _index$3M = constructFrom$1;
var _index2$1u = isSaturday$1;
var _index3$M = isSunday$1;
var _index4$g = isWeekend$1;
var _index5$8 = toDate$1;

/**
 * @name addBusinessDays
 * @category Date Extension Helpers
 * @summary Add the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be added.
 *
 * @returns The new date with the business days added
 *
 * @example
 * // Add 10 business days to 1 September 2014:
 * const result = addBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)
 */
function addBusinessDays(date, amount) {
  const _date = (0, _index5$8.toDate)(date);
  const startedOnWeekend = (0, _index4$g.isWeekend)(_date);

  if (isNaN(amount)) return (0, _index$3M.constructFrom)(date, NaN);

  const hours = _date.getHours();
  const sign = amount < 0 ? -1 : 1;
  const fullWeeks = Math.trunc(amount / 5);

  _date.setDate(_date.getDate() + fullWeeks * 7);

  // Get remaining days not part of a full week
  let restDays = Math.abs(amount % 5);

  // Loops over remaining days
  while (restDays > 0) {
    _date.setDate(_date.getDate() + sign);
    if (!(0, _index4$g.isWeekend)(_date)) restDays -= 1;
  }

  // If the date is a weekend day and we reduce a dividable of
  // 5 from it, we land on a weekend date.
  // To counter this, we add days accordingly to land on the next business day
  if (startedOnWeekend && (0, _index4$g.isWeekend)(_date) && amount !== 0) {
    // If we're reducing days, we want to add days until we land on a weekday
    // If we're adding days we want to reduce days until we land on a weekday
    if ((0, _index2$1u.isSaturday)(_date))
      _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));
    if ((0, _index3$M.isSunday)(_date))
      _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));
  }

  // Restore hours to avoid DST lag
  _date.setHours(hours);

  return _date;
}

var addHours$1 = {};

var addMilliseconds$1 = {};

addMilliseconds$1.addMilliseconds = addMilliseconds;
var _index$3L = toDate$1;
var _index2$1t = constructFrom$1;

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be added.
 *
 * @returns The new date with the milliseconds added
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(date, amount) {
  const timestamp = +(0, _index$3L.toDate)(date);
  return (0, _index2$1t.constructFrom)(date, timestamp + amount);
}

var constants$1 = {};

constants$1.secondsInYear =
  constants$1.secondsInWeek =
  constants$1.secondsInQuarter =
  constants$1.secondsInMonth =
  constants$1.secondsInMinute =
  constants$1.secondsInHour =
  constants$1.secondsInDay =
  constants$1.quartersInYear =
  constants$1.monthsInYear =
  constants$1.monthsInQuarter =
  constants$1.minutesInYear =
  constants$1.minutesInMonth =
  constants$1.minutesInHour =
  constants$1.minutesInDay =
  constants$1.minTime =
  constants$1.millisecondsInWeek =
  constants$1.millisecondsInSecond =
  constants$1.millisecondsInMinute =
  constants$1.millisecondsInHour =
  constants$1.millisecondsInDay =
  constants$1.maxTime =
  constants$1.daysInYear =
  constants$1.daysInWeek =
    void 0; /**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */

/**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */
(constants$1.daysInWeek = 7);

/**
 * @constant
 * @name daysInYear
 * @summary Days in 1 year.
 *
 * @description
 * How many days in a year.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 */
const daysInYear = (constants$1.daysInYear = 365.2425);

/**
 * @constant
 * @name maxTime
 * @summary Maximum allowed time.
 *
 * @example
 * import { maxTime } from "date-fns/constants";
 *
 * const isValid = 8640000000000001 <= maxTime;
 * //=> false
 *
 * new Date(8640000000000001);
 * //=> Invalid Date
 */
const maxTime = (constants$1.maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000);

/**
 * @constant
 * @name minTime
 * @summary Minimum allowed time.
 *
 * @example
 * import { minTime } from "date-fns/constants";
 *
 * const isValid = -8640000000000001 >= minTime;
 * //=> false
 *
 * new Date(-8640000000000001)
 * //=> Invalid Date
 */
(constants$1.minTime = -maxTime);

/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */
(constants$1.millisecondsInWeek = 604800000);

/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */
(constants$1.millisecondsInDay = 86400000);

/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */
(constants$1.millisecondsInMinute = 60000);

/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */
(constants$1.millisecondsInHour = 3600000);

/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */
(constants$1.millisecondsInSecond = 1000);

/**
 * @constant
 * @name minutesInYear
 * @summary Minutes in 1 year.
 */
(constants$1.minutesInYear = 525600);

/**
 * @constant
 * @name minutesInMonth
 * @summary Minutes in 1 month.
 */
(constants$1.minutesInMonth = 43200);

/**
 * @constant
 * @name minutesInDay
 * @summary Minutes in 1 day.
 */
(constants$1.minutesInDay = 1440);

/**
 * @constant
 * @name minutesInHour
 * @summary Minutes in 1 hour.
 */
(constants$1.minutesInHour = 60);

/**
 * @constant
 * @name monthsInQuarter
 * @summary Months in 1 quarter.
 */
(constants$1.monthsInQuarter = 3);

/**
 * @constant
 * @name monthsInYear
 * @summary Months in 1 year.
 */
(constants$1.monthsInYear = 12);

/**
 * @constant
 * @name quartersInYear
 * @summary Quarters in 1 year
 */
(constants$1.quartersInYear = 4);

/**
 * @constant
 * @name secondsInHour
 * @summary Seconds in 1 hour.
 */
const secondsInHour = (constants$1.secondsInHour = 3600);

/**
 * @constant
 * @name secondsInMinute
 * @summary Seconds in 1 minute.
 */
(constants$1.secondsInMinute = 60);

/**
 * @constant
 * @name secondsInDay
 * @summary Seconds in 1 day.
 */
const secondsInDay = (constants$1.secondsInDay = secondsInHour * 24);

/**
 * @constant
 * @name secondsInWeek
 * @summary Seconds in 1 week.
 */
(constants$1.secondsInWeek = secondsInDay * 7);

/**
 * @constant
 * @name secondsInYear
 * @summary Seconds in 1 year.
 */
const secondsInYear = (constants$1.secondsInYear = secondsInDay * daysInYear);

/**
 * @constant
 * @name secondsInMonth
 * @summary Seconds in 1 month
 */
const secondsInMonth = (constants$1.secondsInMonth = secondsInYear / 12);

/**
 * @constant
 * @name secondsInQuarter
 * @summary Seconds in 1 quarter.
 */
(constants$1.secondsInQuarter = secondsInMonth * 3);

addHours$1.addHours = addHours;
var _index$3K = addMilliseconds$1;
var _index2$1s = constants$1;

/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be added.
 *
 * @returns The new date with the hours added
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */
function addHours(date, amount) {
  return (0, _index$3K.addMilliseconds)(date, amount * _index2$1s.millisecondsInHour);
}

var addISOWeekYears$1 = {};

var getISOWeekYear$1 = {};

var startOfISOWeek$1 = {};

startOfISOWeek$1.startOfISOWeek = startOfISOWeek;
var _index$3J = startOfWeek$1;

/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(date) {
  return (0, _index$3J.startOfWeek)(date, { weekStartsOn: 1 });
}

getISOWeekYear$1.getISOWeekYear = getISOWeekYear;
var _index$3I = constructFrom$1;
var _index2$1r = startOfISOWeek$1;
var _index3$L = toDate$1;

/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOWeekYear(date) {
  const _date = (0, _index3$L.toDate)(date);
  const year = _date.getFullYear();

  const fourthOfJanuaryOfNextYear = (0, _index$3I.constructFrom)(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0, _index2$1r.startOfISOWeek)(
    fourthOfJanuaryOfNextYear,
  );

  const fourthOfJanuaryOfThisYear = (0, _index$3I.constructFrom)(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0, _index2$1r.startOfISOWeek)(
    fourthOfJanuaryOfThisYear,
  );

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

var setISOWeekYear$1 = {};

var differenceInCalendarDays$1 = {};

var startOfDay$1 = {};

startOfDay$1.startOfDay = startOfDay;
var _index$3H = toDate$1;

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(date) {
  const _date = (0, _index$3H.toDate)(date);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

var getTimezoneOffsetInMilliseconds$1 = {};

getTimezoneOffsetInMilliseconds$1.getTimezoneOffsetInMilliseconds = getTimezoneOffsetInMilliseconds;
var _index$3G = toDate$1;

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  const _date = (0, _index$3G.toDate)(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds(),
    ),
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

differenceInCalendarDays$1.differenceInCalendarDays = differenceInCalendarDays;
var _index$3F = constants$1;
var _index2$1q = startOfDay$1;
var _index3$K = getTimezoneOffsetInMilliseconds$1;

/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = (0, _index2$1q.startOfDay)(dateLeft);
  const startOfDayRight = (0, _index2$1q.startOfDay)(dateRight);

  const timestampLeft =
    +startOfDayLeft -
    (0, _index3$K.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
  const timestampRight =
    +startOfDayRight -
    (0, _index3$K.getTimezoneOffsetInMilliseconds)(startOfDayRight);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a day is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index$3F.millisecondsInDay,
  );
}

var startOfISOWeekYear$1 = {};

startOfISOWeekYear$1.startOfISOWeekYear = startOfISOWeekYear;
var _index$3E = getISOWeekYear$1;
var _index2$1p = startOfISOWeek$1;
var _index3$J = constructFrom$1;

/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(date) {
  const year = (0, _index$3E.getISOWeekYear)(date);
  const fourthOfJanuary = (0, _index3$J.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return (0, _index2$1p.startOfISOWeek)(fourthOfJanuary);
}

setISOWeekYear$1.setISOWeekYear = setISOWeekYear;
var _index$3D = constructFrom$1;
var _index2$1o = differenceInCalendarDays$1;
var _index3$I = startOfISOWeekYear$1;
var _index4$f = toDate$1;

/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
function setISOWeekYear(date, weekYear) {
  let _date = (0, _index4$f.toDate)(date);
  const diff = (0, _index2$1o.differenceInCalendarDays)(
    _date,
    (0, _index3$I.startOfISOWeekYear)(_date),
  );
  const fourthOfJanuary = (0, _index$3D.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(weekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  _date = (0, _index3$I.startOfISOWeekYear)(fourthOfJanuary);
  _date.setDate(_date.getDate() + diff);
  return _date;
}

addISOWeekYears$1.addISOWeekYears = addISOWeekYears;
var _index$3C = getISOWeekYear$1;
var _index2$1n = setISOWeekYear$1;

/**
 * @name addISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Add the specified number of ISO week-numbering years to the given date.
 *
 * @description
 * Add the specified number of ISO week-numbering years to the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be added.
 *
 * @returns The new date with the ISO week-numbering years added
 *
 * @example
 * // Add 5 ISO week-numbering years to 2 July 2010:
 * const result = addISOWeekYears(new Date(2010, 6, 2), 5)
 * //=> Fri Jn 26 2015 00:00:00
 */
function addISOWeekYears(date, amount) {
  return (0, _index2$1n.setISOWeekYear)(
    date,
    (0, _index$3C.getISOWeekYear)(date) + amount,
  );
}

var addMinutes$1 = {};

addMinutes$1.addMinutes = addMinutes;
var _index$3B = addMilliseconds$1;
var _index2$1m = constants$1;

/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be added.
 *
 * @returns The new date with the minutes added
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */
function addMinutes(date, amount) {
  return (0, _index$3B.addMilliseconds)(
    date,
    amount * _index2$1m.millisecondsInMinute,
  );
}

var addQuarters$1 = {};

addQuarters$1.addQuarters = addQuarters;
var _index$3A = addMonths$1;

/**
 * @name addQuarters
 * @category Quarter Helpers
 * @summary Add the specified number of year quarters to the given date.
 *
 * @description
 * Add the specified number of year quarters to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be added.
 *
 * @returns The new date with the quarters added
 *
 * @example
 * // Add 1 quarter to 1 September 2014:
 * const result = addQuarters(new Date(2014, 8, 1), 1)
 * //=> Mon Dec 01 2014 00:00:00
 */
function addQuarters(date, amount) {
  const months = amount * 3;
  return (0, _index$3A.addMonths)(date, months);
}

var addSeconds$1 = {};

addSeconds$1.addSeconds = addSeconds;
var _index$3z = addMilliseconds$1;

/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be added.
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */
function addSeconds(date, amount) {
  return (0, _index$3z.addMilliseconds)(date, amount * 1000);
}

var addWeeks$1 = {};

addWeeks$1.addWeeks = addWeeks;
var _index$3y = addDays$1;

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be added.
 *
 * @returns The new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(date, amount) {
  const days = amount * 7;
  return (0, _index$3y.addDays)(date, days);
}

var addYears$1 = {};

addYears$1.addYears = addYears;
var _index$3x = addMonths$1;

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be added.
 *
 * @returns The new date with the years added
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */
function addYears(date, amount) {
  return (0, _index$3x.addMonths)(date, amount * 12);
}

var areIntervalsOverlapping$1 = {};

areIntervalsOverlapping$1.areIntervalsOverlapping = areIntervalsOverlapping;
var _index$3w = toDate$1;

/**
 * The {@link areIntervalsOverlapping} function options.
 */

/**
 * @name areIntervalsOverlapping
 * @category Interval Helpers
 * @summary Is the given time interval overlapping with another time interval?
 *
 * @description
 * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 * @param options - The object with options
 *
 * @returns Whether the time intervals are overlapping
 *
 * @example
 * // For overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> true
 *
 * @example
 * // For non-overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> false
 *
 * @example
 * // For adjacent time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }
 * )
 * //=> false
 *
 * @example
 * // Using the inclusive option:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }
 * )
 * //=> false
 *
 * @example
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },
 *   { inclusive: true }
 * )
 * //=> true
 */
function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
  const [leftStartTime, leftEndTime] = [
    +(0, _index$3w.toDate)(intervalLeft.start),
    +(0, _index$3w.toDate)(intervalLeft.end),
  ].sort((a, b) => a - b);
  const [rightStartTime, rightEndTime] = [
    +(0, _index$3w.toDate)(intervalRight.start),
    +(0, _index$3w.toDate)(intervalRight.end),
  ].sort((a, b) => a - b);

  if (options?.inclusive)
    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;

  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}

var clamp$1 = {};

var max$1 = {};

max$1.max = max;
var _index$3v = toDate$1;

/**
 * @name max
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The latest of the dates
 *
 * @example
 * // Which of these dates is the latest?
 * const result = max([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Sun Jul 02 1995 00:00:00
 */
function max(dates) {
  let result;
  dates.forEach(function (dirtyDate) {
    const currentDate = (0, _index$3v.toDate)(dirtyDate);

    if (
      result === undefined ||
      result < currentDate ||
      isNaN(Number(currentDate))
    ) {
      result = currentDate;
    }
  });

  return result || new Date(NaN);
}

var min$1 = {};

min$1.min = min;
var _index$3u = toDate$1;

/**
 * @name min
 * @category Common Helpers
 * @summary Returns the earliest of the given dates.
 *
 * @description
 * Returns the earliest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The earliest of the dates
 *
 * @example
 * // Which of these dates is the earliest?
 * const result = min([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Wed Feb 11 1987 00:00:00
 */
function min(dates) {
  let result;

  dates.forEach((dirtyDate) => {
    const date = (0, _index$3u.toDate)(dirtyDate);
    if (!result || result > date || isNaN(+date)) {
      result = date;
    }
  });

  return result || new Date(NaN);
}

clamp$1.clamp = clamp;
var _index$3t = max$1;
var _index2$1l = min$1;

/**
 * @name clamp
 * @category Interval Helpers
 * @summary Return a date bounded by the start and the end of the given interval
 *
 * @description
 * Clamps a date to the lower bound with the start of the interval and the upper
 * bound with the end of the interval.
 *
 * - When the date is less than the start of the interval, the start is returned.
 * - When the date is greater than the end of the interval, the end is returned.
 * - Otherwise the date is returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be bounded
 * @param interval - The interval to bound to
 *
 * @returns The date bounded by the start and the end of the interval
 *
 * @example
 * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021
 * const result = clamp(new Date(2021, 2, 21), {
 *   start: new Date(2021, 2, 22),
 *   end: new Date(2021, 3, 1),
 * })
 * //=> Mon Mar 22 2021 00:00:00
 */
function clamp(date, interval) {
  return (0, _index2$1l.min)([
    (0, _index$3t.max)([date, interval.start]),
    interval.end,
  ]);
}

var closestIndexTo$1 = {};

closestIndexTo$1.closestIndexTo = closestIndexTo;
var _index$3s = toDate$1;

/**
 * @name closestIndexTo
 * @category Common Helpers
 * @summary Return an index of the closest date from the array comparing to the given date.
 *
 * @description
 * Return an index of the closest date from the array comparing to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns An index of the date closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015?
 * const dateToCompare = new Date(2015, 8, 6)
 * const datesArray = [
 *   new Date(2015, 0, 1),
 *   new Date(2016, 0, 1),
 *   new Date(2017, 0, 1)
 * ]
 * const result = closestIndexTo(dateToCompare, datesArray)
 * //=> 1
 */
function closestIndexTo(dateToCompare, dates) {
  const date = (0, _index$3s.toDate)(dateToCompare);

  if (isNaN(Number(date))) return NaN;

  const timeToCompare = date.getTime();

  let result;
  let minDistance;
  dates.forEach(function (dirtyDate, index) {
    const currentDate = (0, _index$3s.toDate)(dirtyDate);

    if (isNaN(Number(currentDate))) {
      result = NaN;
      minDistance = NaN;
      return;
    }

    const distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < minDistance) {
      result = index;
      minDistance = distance;
    }
  });

  return result;
}

var closestTo$1 = {};

closestTo$1.closestTo = closestTo;
var _index$3r = constructFrom$1;
var _index2$1k = toDate$1;

/**
 * @name closestTo
 * @category Common Helpers
 * @summary Return a date from the array closest to the given date.
 *
 * @description
 * Return a date from the array closest to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns The date from the array closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015: 1 January 2000 or 1 January 2030?
 * const dateToCompare = new Date(2015, 8, 6)
 * const result = closestTo(dateToCompare, [
 *   new Date(2000, 0, 1),
 *   new Date(2030, 0, 1)
 * ])
 * //=> Tue Jan 01 2030 00:00:00
 */
function closestTo(dateToCompare, dates) {
  const date = (0, _index2$1k.toDate)(dateToCompare);

  if (isNaN(Number(date))) return (0, _index$3r.constructFrom)(dateToCompare, NaN);

  const timeToCompare = date.getTime();

  let result;
  let minDistance;
  dates.forEach((dirtyDate) => {
    const currentDate = (0, _index2$1k.toDate)(dirtyDate);

    if (isNaN(Number(currentDate))) {
      result = (0, _index$3r.constructFrom)(dateToCompare, NaN);
      minDistance = NaN;
      return;
    }

    const distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < minDistance) {
      result = currentDate;
      minDistance = distance;
    }
  });

  return result;
}

var compareAsc$1 = {};

compareAsc$1.compareAsc = compareAsc;
var _index$3q = toDate$1;

/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */
function compareAsc(dateLeft, dateRight) {
  const _dateLeft = (0, _index$3q.toDate)(dateLeft);
  const _dateRight = (0, _index$3q.toDate)(dateRight);

  const diff = _dateLeft.getTime() - _dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

var compareDesc$1 = {};

compareDesc$1.compareDesc = compareDesc;
var _index$3p = toDate$1;

/**
 * @name compareDesc
 * @category Common Helpers
 * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return -1 if the first date is after the second,
 * 1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
 * const result = compareDesc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> 1
 *
 * @example
 * // Sort the array of dates in reverse chronological order:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareDesc)
 * //=> [
 * //   Sun Jul 02 1995 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Wed Feb 11 1987 00:00:00
 * // ]
 */
function compareDesc(dateLeft, dateRight) {
  const _dateLeft = (0, _index$3p.toDate)(dateLeft);
  const _dateRight = (0, _index$3p.toDate)(dateRight);

  const diff = _dateLeft.getTime() - _dateRight.getTime();

  if (diff > 0) {
    return -1;
  } else if (diff < 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

var constructNow$1 = {};

constructNow$1.constructNow = constructNow;
var _index$3o = constructFrom$1;

/**
 * @name constructNow
 * @category Generic Helpers
 * @summary Constructs a new current date using the passed value constructor.
 * @pure false
 *
 * @description
 * The function constructs a new current date using the constructor from
 * the reference date. It helps to build generic functions that accept date
 * extensions and use the current date.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 *
 * @returns Current date initialized using the given date constructor
 *
 * @example
 * import { constructNow, isSameDay } from 'date-fns'
 *
 * function isToday<DateType extends Date>(
 *   date: DateType | number | string,
 * ): boolean {
 *   // If we were to use `new Date()` directly, the function would  behave
 *   // differently in different timezones and return false for the same date.
 *   return isSameDay(date, constructNow(date));
 * }
 */
function constructNow(date) {
  return (0, _index$3o.constructFrom)(date, Date.now());
}

var daysToWeeks$1 = {};

daysToWeeks$1.daysToWeeks = daysToWeeks;
var _index$3n = constants$1;

/**
 * @name daysToWeeks
 * @category Conversion Helpers
 * @summary Convert days to weeks.
 *
 * @description
 * Convert a number of days to a full number of weeks.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param days - The number of days to be converted
 *
 * @returns The number of days converted in weeks
 *
 * @example
 * // Convert 14 days to weeks:
 * const result = daysToWeeks(14)
 * //=> 2
 *
 * @example
 * // It uses trunc rounding:
 * const result = daysToWeeks(13)
 * //=> 1
 */
function daysToWeeks(days) {
  const weeks = days / _index$3n.daysInWeek;
  const result = Math.trunc(weeks);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}

var differenceInBusinessDays$1 = {};

var isSameDay$1 = {};

isSameDay$1.isSameDay = isSameDay;
var _index$3m = startOfDay$1;

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same day (and year and month)
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */
function isSameDay(dateLeft, dateRight) {
  const dateLeftStartOfDay = (0, _index$3m.startOfDay)(dateLeft);
  const dateRightStartOfDay = (0, _index$3m.startOfDay)(dateRight);

  return +dateLeftStartOfDay === +dateRightStartOfDay;
}

var isValid$1 = {};

var isDate$1 = {};

isDate$1.isDate = isDate; /**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param value - The value to check
 *
 * @returns True if the given value is a date
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  return (
    value instanceof Date ||
    (typeof value === "object" &&
      Object.prototype.toString.call(value) === "[object Date]")
  );
}

isValid$1.isValid = isValid;
var _index$3l = isDate$1;
var _index2$1j = toDate$1;

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is valid
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(date) {
  if (!(0, _index$3l.isDate)(date) && typeof date !== "number") {
    return false;
  }
  const _date = (0, _index2$1j.toDate)(date);
  return !isNaN(Number(_date));
}

differenceInBusinessDays$1.differenceInBusinessDays = differenceInBusinessDays;
var _index$3k = addDays$1;
var _index2$1i = differenceInCalendarDays$1;
var _index3$H = isSameDay$1;
var _index4$e = isValid$1;
var _index5$7 = isWeekend$1;
var _index6$5 = toDate$1;

/**
 * @name differenceInBusinessDays
 * @category Day Helpers
 * @summary Get the number of business days between the given dates.
 *
 * @description
 * Get the number of business day periods between the given dates.
 * Business days being days that arent in the weekend.
 * Like `differenceInCalendarDays`, the function removes the times from
 * the dates before calculating the difference.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of business days
 *
 * @example
 * // How many business days are between
 * // 10 January 2014 and 20 July 2014?
 * const result = differenceInBusinessDays(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 0, 10)
 * )
 * //=> 136
 *
 * // How many business days are between
 * // 30 November 2021 and 1 November 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 30),
 *   new Date(2021, 10, 1)
 * )
 * //=> 21
 *
 * // How many business days are between
 * // 1 November 2021 and 1 December 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 11, 1)
 * )
 * //=> -22
 *
 * // How many business days are between
 * // 1 November 2021 and 1 November 2021 ?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 10, 1)
 * )
 * //=> 0
 */
function differenceInBusinessDays(dateLeft, dateRight) {
  const _dateLeft = (0, _index6$5.toDate)(dateLeft);
  let _dateRight = (0, _index6$5.toDate)(dateRight);

  if (!(0, _index4$e.isValid)(_dateLeft) || !(0, _index4$e.isValid)(_dateRight))
    return NaN;

  const calendarDifference = (0, _index2$1i.differenceInCalendarDays)(
    _dateLeft,
    _dateRight,
  );
  const sign = calendarDifference < 0 ? -1 : 1;

  const weeks = Math.trunc(calendarDifference / 7);

  let result = weeks * 5;
  _dateRight = (0, _index$3k.addDays)(_dateRight, weeks * 7);

  // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week
  while (!(0, _index3$H.isSameDay)(_dateLeft, _dateRight)) {
    // sign is used to account for both negative and positive differences
    result += (0, _index5$7.isWeekend)(_dateRight) ? 0 : sign;
    _dateRight = (0, _index$3k.addDays)(_dateRight, sign);
  }

  // Prevent negative zero
  return result === 0 ? 0 : result;
}

var differenceInCalendarISOWeekYears$1 = {};

differenceInCalendarISOWeekYears$1.differenceInCalendarISOWeekYears = differenceInCalendarISOWeekYears;
var _index$3j = getISOWeekYear$1;

/**
 * @name differenceInCalendarISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of calendar ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of calendar ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO week-numbering years
 *
 * @example
 * // How many calendar ISO week-numbering years are 1 January 2010 and 1 January 2012?
 * const result = differenceInCalendarISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 2
 */
function differenceInCalendarISOWeekYears(dateLeft, dateRight) {
  return (
    (0, _index$3j.getISOWeekYear)(dateLeft) - (0, _index$3j.getISOWeekYear)(dateRight)
  );
}

var differenceInCalendarISOWeeks$1 = {};

differenceInCalendarISOWeeks$1.differenceInCalendarISOWeeks = differenceInCalendarISOWeeks;
var _index$3i = constants$1;
var _index2$1h = startOfISOWeek$1;
var _index3$G = getTimezoneOffsetInMilliseconds$1;

/**
 * @name differenceInCalendarISOWeeks
 * @category ISO Week Helpers
 * @summary Get the number of calendar ISO weeks between the given dates.
 *
 * @description
 * Get the number of calendar ISO weeks between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO weeks
 *
 * @example
 * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?
 * const result = differenceInCalendarISOWeeks(
 *   new Date(2014, 6, 21),
 *   new Date(2014, 6, 6)
 * )
 * //=> 3
 */
function differenceInCalendarISOWeeks(dateLeft, dateRight) {
  const startOfISOWeekLeft = (0, _index2$1h.startOfISOWeek)(dateLeft);
  const startOfISOWeekRight = (0, _index2$1h.startOfISOWeek)(dateRight);

  const timestampLeft =
    +startOfISOWeekLeft -
    (0, _index3$G.getTimezoneOffsetInMilliseconds)(startOfISOWeekLeft);
  const timestampRight =
    +startOfISOWeekRight -
    (0, _index3$G.getTimezoneOffsetInMilliseconds)(startOfISOWeekRight);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index$3i.millisecondsInWeek,
  );
}

var differenceInCalendarMonths$1 = {};

differenceInCalendarMonths$1.differenceInCalendarMonths = differenceInCalendarMonths;
var _index$3h = toDate$1;

/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar months
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = (0, _index$3h.toDate)(dateLeft);
  const _dateRight = (0, _index$3h.toDate)(dateRight);

  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();

  return yearDiff * 12 + monthDiff;
}

var differenceInCalendarQuarters$1 = {};

var getQuarter$1 = {};

getQuarter$1.getQuarter = getQuarter;
var _index$3g = toDate$1;

/**
 * @name getQuarter
 * @category Quarter Helpers
 * @summary Get the year quarter of the given date.
 *
 * @description
 * Get the year quarter of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The quarter
 *
 * @example
 * // Which quarter is 2 July 2014?
 * const result = getQuarter(new Date(2014, 6, 2))
 * //=> 3
 */
function getQuarter(date) {
  const _date = (0, _index$3g.toDate)(date);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}

differenceInCalendarQuarters$1.differenceInCalendarQuarters = differenceInCalendarQuarters;
var _index$3f = getQuarter$1;
var _index2$1g = toDate$1;

/**
 * @name differenceInCalendarQuarters
 * @category Quarter Helpers
 * @summary Get the number of calendar quarters between the given dates.
 *
 * @description
 * Get the number of calendar quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar quarters
 *
 * @example
 * // How many calendar quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInCalendarQuarters(
 *   new Date(2014, 6, 2),
 *   new Date(2013, 11, 31)
 * )
 * //=> 3
 */
function differenceInCalendarQuarters(dateLeft, dateRight) {
  const _dateLeft = (0, _index2$1g.toDate)(dateLeft);
  const _dateRight = (0, _index2$1g.toDate)(dateRight);

  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const quarterDiff =
    (0, _index$3f.getQuarter)(_dateLeft) - (0, _index$3f.getQuarter)(_dateRight);

  return yearDiff * 4 + quarterDiff;
}

var differenceInCalendarWeeks$1 = {};

differenceInCalendarWeeks$1.differenceInCalendarWeeks = differenceInCalendarWeeks;
var _index$3e = constants$1;
var _index2$1f = startOfWeek$1;

var _index3$F = getTimezoneOffsetInMilliseconds$1;

/**
 * The {@link differenceInCalendarWeeks} function options.
 */

/**
 * @name differenceInCalendarWeeks
 * @category Week Helpers
 * @summary Get the number of calendar weeks between the given dates.
 *
 * @description
 * Get the number of calendar weeks between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5)
 * )
 * //=> 3
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5),
 *   { weekStartsOn: 1 }
 * )
 * //=> 2
 */
function differenceInCalendarWeeks(dateLeft, dateRight, options) {
  const startOfWeekLeft = (0, _index2$1f.startOfWeek)(dateLeft, options);
  const startOfWeekRight = (0, _index2$1f.startOfWeek)(dateRight, options);

  const timestampLeft =
    +startOfWeekLeft -
    (0, _index3$F.getTimezoneOffsetInMilliseconds)(startOfWeekLeft);
  const timestampRight =
    +startOfWeekRight -
    (0, _index3$F.getTimezoneOffsetInMilliseconds)(startOfWeekRight);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a days is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(
    (timestampLeft - timestampRight) / _index$3e.millisecondsInWeek,
  );
}

var differenceInCalendarYears$1 = {};

differenceInCalendarYears$1.differenceInCalendarYears = differenceInCalendarYears;
var _index$3d = toDate$1;

/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar years
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */
function differenceInCalendarYears(dateLeft, dateRight) {
  const _dateLeft = (0, _index$3d.toDate)(dateLeft);
  const _dateRight = (0, _index$3d.toDate)(dateRight);

  return _dateLeft.getFullYear() - _dateRight.getFullYear();
}

var differenceInDays$1 = {};

differenceInDays$1.differenceInDays = differenceInDays;
var _index$3c = differenceInCalendarDays$1;
var _index2$1e = toDate$1;

/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.trunc(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full days according to the local timezone
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 *
 * @example
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
 * //=> 92
 */
function differenceInDays(dateLeft, dateRight) {
  const _dateLeft = (0, _index2$1e.toDate)(dateLeft);
  const _dateRight = (0, _index2$1e.toDate)(dateRight);

  const sign = compareLocalAsc(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index$3c.differenceInCalendarDays)(_dateLeft, _dateRight),
  );

  _dateLeft.setDate(_dateLeft.getDate() - sign * difference);

  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastDayNotFull = Number(
    compareLocalAsc(_dateLeft, _dateRight) === -sign,
  );
  const result = sign * (difference - isLastDayNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}

// Like `compareAsc` but uses local time not UTC, which is needed
// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.
function compareLocalAsc(dateLeft, dateRight) {
  const diff =
    dateLeft.getFullYear() - dateRight.getFullYear() ||
    dateLeft.getMonth() - dateRight.getMonth() ||
    dateLeft.getDate() - dateRight.getDate() ||
    dateLeft.getHours() - dateRight.getHours() ||
    dateLeft.getMinutes() - dateRight.getMinutes() ||
    dateLeft.getSeconds() - dateRight.getSeconds() ||
    dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

var differenceInHours$1 = {};

var getRoundingMethod$1 = {};

getRoundingMethod$1.getRoundingMethod = getRoundingMethod;

function getRoundingMethod(method) {
  return (number) => {
    const round = method ? Math[method] : Math.trunc;
    const result = round(number);
    // Prevent negative zero
    return result === 0 ? 0 : result;
  };
}

var differenceInMilliseconds$1 = {};

differenceInMilliseconds$1.differenceInMilliseconds = differenceInMilliseconds;
var _index$3b = toDate$1;

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of milliseconds
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */
function differenceInMilliseconds(dateLeft, dateRight) {
  return +(0, _index$3b.toDate)(dateLeft) - +(0, _index$3b.toDate)(dateRight);
}

differenceInHours$1.differenceInHours = differenceInHours;
var _index$3a = getRoundingMethod$1;
var _index2$1d = constants$1;
var _index3$E = differenceInMilliseconds$1;

/**
 * The {@link differenceInHours} function options.
 */

/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of hours
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */
function differenceInHours(dateLeft, dateRight, options) {
  const diff =
    (0, _index3$E.differenceInMilliseconds)(dateLeft, dateRight) /
    _index2$1d.millisecondsInHour;
  return (0, _index$3a.getRoundingMethod)(options?.roundingMethod)(diff);
}

var differenceInISOWeekYears$1 = {};

var subISOWeekYears$1 = {};

subISOWeekYears$1.subISOWeekYears = subISOWeekYears;
var _index$39 = addISOWeekYears$1;

/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
function subISOWeekYears(date, amount) {
  return (0, _index$39.addISOWeekYears)(date, -amount);
}

differenceInISOWeekYears$1.differenceInISOWeekYears = differenceInISOWeekYears;
var _index$38 = compareAsc$1;
var _index2$1c = differenceInCalendarISOWeekYears$1;
var _index3$D = subISOWeekYears$1;
var _index4$d = toDate$1;

/**
 * @name differenceInISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of full ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of full ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full ISO week-numbering years
 *
 * @example
 * // How many full ISO week-numbering years are between 1 January 2010 and 1 January 2012?
 * const result = differenceInISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 1
 */
function differenceInISOWeekYears(dateLeft, dateRight) {
  let _dateLeft = (0, _index4$d.toDate)(dateLeft);
  const _dateRight = (0, _index4$d.toDate)(dateRight);

  const sign = (0, _index$38.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2$1c.differenceInCalendarISOWeekYears)(_dateLeft, _dateRight),
  );
  _dateLeft = (0, _index3$D.subISOWeekYears)(_dateLeft, sign * difference);

  // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1
  // if last calendar ISO year is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastISOWeekYearNotFull = Number(
    (0, _index$38.compareAsc)(_dateLeft, _dateRight) === -sign,
  );
  const result = sign * (difference - isLastISOWeekYearNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}

var differenceInMinutes$1 = {};

differenceInMinutes$1.differenceInMinutes = differenceInMinutes;
var _index$37 = getRoundingMethod$1;
var _index2$1b = constants$1;
var _index3$C = differenceInMilliseconds$1;

/**
 * The {@link differenceInMinutes} function options.
 */

/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of minutes
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * const result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are between 10:01:59 and 10:00:00
 * const result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff =
    (0, _index3$C.differenceInMilliseconds)(dateLeft, dateRight) /
    _index2$1b.millisecondsInMinute;
  return (0, _index$37.getRoundingMethod)(options?.roundingMethod)(diff);
}

var differenceInMonths$1 = {};

var isLastDayOfMonth$1 = {};

var endOfDay$1 = {};

endOfDay$1.endOfDay = endOfDay;
var _index$36 = toDate$1;

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a day
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */
function endOfDay(date) {
  const _date = (0, _index$36.toDate)(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

var endOfMonth$1 = {};

endOfMonth$1.endOfMonth = endOfMonth;
var _index$35 = toDate$1;

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a month
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfMonth(date) {
  const _date = (0, _index$35.toDate)(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

isLastDayOfMonth$1.isLastDayOfMonth = isLastDayOfMonth;
var _index$34 = endOfDay$1;
var _index2$1a = endOfMonth$1;
var _index3$B = toDate$1;

/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the last day of a month
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */
function isLastDayOfMonth(date) {
  const _date = (0, _index3$B.toDate)(date);
  return +(0, _index$34.endOfDay)(_date) === +(0, _index2$1a.endOfMonth)(_date);
}

differenceInMonths$1.differenceInMonths = differenceInMonths;
var _index$33 = compareAsc$1;
var _index2$19 = differenceInCalendarMonths$1;
var _index3$A = isLastDayOfMonth$1;
var _index4$c = toDate$1;

/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full months
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */
function differenceInMonths(dateLeft, dateRight) {
  const _dateLeft = (0, _index4$c.toDate)(dateLeft);
  const _dateRight = (0, _index4$c.toDate)(dateRight);

  const sign = (0, _index$33.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2$19.differenceInCalendarMonths)(_dateLeft, _dateRight),
  );
  let result;

  // Check for the difference of less than month
  if (difference < 1) {
    result = 0;
  } else {
    if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
      // This will check if the date is end of Feb and assign a higher end of month date
      // to compare it with Jan
      _dateLeft.setDate(30);
    }

    _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);

    // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value
    let isLastMonthNotFull =
      (0, _index$33.compareAsc)(_dateLeft, _dateRight) === -sign;

    // Check for cases of one full calendar month
    if (
      (0, _index3$A.isLastDayOfMonth)((0, _index4$c.toDate)(dateLeft)) &&
      difference === 1 &&
      (0, _index$33.compareAsc)(dateLeft, _dateRight) === 1
    ) {
      isLastMonthNotFull = false;
    }

    result = sign * (difference - Number(isLastMonthNotFull));
  }

  // Prevent negative zero
  return result === 0 ? 0 : result;
}

var differenceInQuarters$1 = {};

differenceInQuarters$1.differenceInQuarters = differenceInQuarters;
var _index$32 = getRoundingMethod$1;
var _index2$18 = differenceInMonths$1;

/**
 * The {@link differenceInQuarters} function options.
 */

/**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of quarters between the given dates.
 *
 * @description
 * Get the number of quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of full quarters
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */
function differenceInQuarters(dateLeft, dateRight, options) {
  const diff = (0, _index2$18.differenceInMonths)(dateLeft, dateRight) / 3;
  return (0, _index$32.getRoundingMethod)(options?.roundingMethod)(diff);
}

var differenceInSeconds$1 = {};

differenceInSeconds$1.differenceInSeconds = differenceInSeconds;
var _index$31 = getRoundingMethod$1;
var _index2$17 = differenceInMilliseconds$1;

/**
 * The {@link differenceInSeconds} function options.
 */

/**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of seconds
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * const result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */
function differenceInSeconds(dateLeft, dateRight, options) {
  const diff =
    (0, _index2$17.differenceInMilliseconds)(dateLeft, dateRight) / 1000;
  return (0, _index$31.getRoundingMethod)(options?.roundingMethod)(diff);
}

var differenceInWeeks$1 = {};

differenceInWeeks$1.differenceInWeeks = differenceInWeeks;
var _index$30 = getRoundingMethod$1;
var _index2$16 = differenceInDays$1;

/**
 * The {@link differenceInWeeks} function options.
 */

/**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero by default.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.trunc(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options
 *
 * @returns The number of full weeks
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * @example
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * const result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */
function differenceInWeeks(dateLeft, dateRight, options) {
  const diff = (0, _index2$16.differenceInDays)(dateLeft, dateRight) / 7;
  return (0, _index$30.getRoundingMethod)(options?.roundingMethod)(diff);
}

var differenceInYears$1 = {};

differenceInYears$1.differenceInYears = differenceInYears;
var _index$2$ = compareAsc$1;
var _index2$15 = differenceInCalendarYears$1;
var _index3$z = toDate$1;

/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full years
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */
function differenceInYears(dateLeft, dateRight) {
  const _dateLeft = (0, _index3$z.toDate)(dateLeft);
  const _dateRight = (0, _index3$z.toDate)(dateRight);

  const sign = (0, _index$2$.compareAsc)(_dateLeft, _dateRight);
  const difference = Math.abs(
    (0, _index2$15.differenceInCalendarYears)(_dateLeft, _dateRight),
  );

  // Set both dates to a valid leap year for accurate comparison when dealing
  // with leap days
  _dateLeft.setFullYear(1584);
  _dateRight.setFullYear(1584);

  // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
  // If so, result must be decreased by 1 in absolute value
  const isLastYearNotFull =
    (0, _index$2$.compareAsc)(_dateLeft, _dateRight) === -sign;
  const result = sign * (difference - +isLastYearNotFull);

  // Prevent negative zero
  return result === 0 ? 0 : result;
}

var eachDayOfInterval$1 = {};

eachDayOfInterval$1.eachDayOfInterval = eachDayOfInterval;
var _index$2_ = toDate$1;

/**
 * The {@link eachDayOfInterval} function options.
 */

/**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of days from the day of the interval start to the day of the interval end
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * const result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */
function eachDayOfInterval(interval, options) {
  const startDate = (0, _index$2_.toDate)(interval.start);
  const endDate = (0, _index$2_.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index$2_.toDate)(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }

  return reversed ? dates.reverse() : dates;
}

var eachHourOfInterval$1 = {};

eachHourOfInterval$1.eachHourOfInterval = eachHourOfInterval;
var _index$2Z = addHours$1;
var _index2$14 = toDate$1;

/**
 * The {@link eachHourOfInterval} function options.
 */

/**
 * @name eachHourOfInterval
 * @category Interval Helpers
 * @summary Return the array of hours within the specified time interval.
 *
 * @description
 * Return the array of hours within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of hours from the hour of the interval start to the hour of the interval end
 *
 * @example
 * // Each hour between 6 October 2014, 12:00 and 6 October 2014, 15:00
 * const result = eachHourOfInterval({
 *   start: new Date(2014, 9, 6, 12),
 *   end: new Date(2014, 9, 6, 15)
 * })
 * //=> [
 * //   Mon Oct 06 2014 12:00:00,
 * //   Mon Oct 06 2014 13:00:00,
 * //   Mon Oct 06 2014 14:00:00,
 * //   Mon Oct 06 2014 15:00:00
 * // ]
 */
function eachHourOfInterval(interval, options) {
  const startDate = (0, _index2$14.toDate)(interval.start);
  const endDate = (0, _index2$14.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  let currentDate = reversed ? endDate : startDate;
  currentDate.setMinutes(0, 0, 0);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index2$14.toDate)(currentDate));
    currentDate = (0, _index$2Z.addHours)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}

var eachMinuteOfInterval$1 = {};

var startOfMinute$1 = {};

startOfMinute$1.startOfMinute = startOfMinute;
var _index$2Y = toDate$1;

/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
function startOfMinute(date) {
  const _date = (0, _index$2Y.toDate)(date);
  _date.setSeconds(0, 0);
  return _date;
}

eachMinuteOfInterval$1.eachMinuteOfInterval = eachMinuteOfInterval;
var _index$2X = addMinutes$1;
var _index2$13 = startOfMinute$1;
var _index3$y = toDate$1;

/**
 * The {@link eachMinuteOfInterval} function options.
 */

/**
 * @name eachMinuteOfInterval
 * @category Interval Helpers
 * @summary Return the array of minutes within the specified time interval.
 *
 * @description
 * Returns the array of minutes within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of minutes from the minute of the interval start to the minute of the interval end
 *
 * @example
 * // Each minute between 14 October 2020, 13:00 and 14 October 2020, 13:03
 * const result = eachMinuteOfInterval({
 *   start: new Date(2014, 9, 14, 13),
 *   end: new Date(2014, 9, 14, 13, 3)
 * })
 * //=> [
 * //   Wed Oct 14 2014 13:00:00,
 * //   Wed Oct 14 2014 13:01:00,
 * //   Wed Oct 14 2014 13:02:00,
 * //   Wed Oct 14 2014 13:03:00
 * // ]
 */
function eachMinuteOfInterval(interval, options) {
  const startDate = (0, _index2$13.startOfMinute)(
    (0, _index3$y.toDate)(interval.start),
  );
  const endDate = (0, _index3$y.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  let currentDate = reversed ? endDate : startDate;

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index3$y.toDate)(currentDate));
    currentDate = (0, _index$2X.addMinutes)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}

var eachMonthOfInterval$1 = {};

eachMonthOfInterval$1.eachMonthOfInterval = eachMonthOfInterval;
var _index$2W = toDate$1;

/**
 * The {@link eachMonthOfInterval} function options.
 */

/**
 * @name eachMonthOfInterval
 * @category Interval Helpers
 * @summary Return the array of months within the specified time interval.
 *
 * @description
 * Return the array of months within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of months from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each month between 6 February 2014 and 10 August 2014:
 * const result = eachMonthOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Sat Feb 01 2014 00:00:00,
 * //   Sat Mar 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Thu May 01 2014 00:00:00,
 * //   Sun Jun 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * //   Fri Aug 01 2014 00:00:00
 * // ]
 */
function eachMonthOfInterval(interval, options) {
  const startDate = (0, _index$2W.toDate)(interval.start);
  const endDate = (0, _index$2W.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setDate(1);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index$2W.toDate)(currentDate));
    currentDate.setMonth(currentDate.getMonth() + step);
  }

  return reversed ? dates.reverse() : dates;
}

var eachQuarterOfInterval$1 = {};

var startOfQuarter$1 = {};

startOfQuarter$1.startOfQuarter = startOfQuarter;
var _index$2V = toDate$1;

/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
function startOfQuarter(date) {
  const _date = (0, _index$2V.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3);
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

eachQuarterOfInterval$1.eachQuarterOfInterval = eachQuarterOfInterval;
var _index$2U = addQuarters$1;
var _index2$12 = startOfQuarter$1;
var _index3$x = toDate$1;

/**
 * The {@link eachQuarterOfInterval} function options.
 */

/**
 * @name eachQuarterOfInterval
 * @category Interval Helpers
 * @summary Return the array of quarters within the specified time interval.
 *
 * @description
 * Return the array of quarters within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of quarters from the quarter of the interval start to the quarter of the interval end
 *
 * @example
 * // Each quarter within interval 6 February 2014 - 10 August 2014:
 * const result = eachQuarterOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * // ]
 */
function eachQuarterOfInterval(interval, options) {
  const startDate = (0, _index3$x.toDate)(interval.start);
  const endDate = (0, _index3$x.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed
    ? +(0, _index2$12.startOfQuarter)(startDate)
    : +(0, _index2$12.startOfQuarter)(endDate);
  let currentDate = reversed
    ? (0, _index2$12.startOfQuarter)(endDate)
    : (0, _index2$12.startOfQuarter)(startDate);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index3$x.toDate)(currentDate));
    currentDate = (0, _index$2U.addQuarters)(currentDate, step);
  }

  return reversed ? dates.reverse() : dates;
}

var eachWeekOfInterval$1 = {};

eachWeekOfInterval$1.eachWeekOfInterval = eachWeekOfInterval;
var _index$2T = addWeeks$1;
var _index2$11 = startOfWeek$1;
var _index3$w = toDate$1;

/**
 * The {@link eachWeekOfInterval} function options.
 */

/**
 * @name eachWeekOfInterval
 * @category Interval Helpers
 * @summary Return the array of weeks within the specified time interval.
 *
 * @description
 * Return the array of weeks within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of weeks from the week of the interval start to the week of the interval end
 *
 * @example
 * // Each week within interval 6 October 2014 - 23 November 2014:
 * const result = eachWeekOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 10, 23)
 * })
 * //=> [
 * //   Sun Oct 05 2014 00:00:00,
 * //   Sun Oct 12 2014 00:00:00,
 * //   Sun Oct 19 2014 00:00:00,
 * //   Sun Oct 26 2014 00:00:00,
 * //   Sun Nov 02 2014 00:00:00,
 * //   Sun Nov 09 2014 00:00:00,
 * //   Sun Nov 16 2014 00:00:00,
 * //   Sun Nov 23 2014 00:00:00
 * // ]
 */
function eachWeekOfInterval(interval, options) {
  const startDate = (0, _index3$w.toDate)(interval.start);
  const endDate = (0, _index3$w.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const startDateWeek = reversed
    ? (0, _index2$11.startOfWeek)(endDate, options)
    : (0, _index2$11.startOfWeek)(startDate, options);
  const endDateWeek = reversed
    ? (0, _index2$11.startOfWeek)(startDate, options)
    : (0, _index2$11.startOfWeek)(endDate, options);

  // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet
  startDateWeek.setHours(15);
  endDateWeek.setHours(15);

  const endTime = +endDateWeek.getTime();
  let currentDate = startDateWeek;

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    currentDate.setHours(0);
    dates.push((0, _index3$w.toDate)(currentDate));
    currentDate = (0, _index$2T.addWeeks)(currentDate, step);
    currentDate.setHours(15);
  }

  return reversed ? dates.reverse() : dates;
}

var eachWeekendOfInterval$1 = {};

eachWeekendOfInterval$1.eachWeekendOfInterval = eachWeekendOfInterval;
var _index$2S = eachDayOfInterval$1;
var _index2$10 = isWeekend$1;

/**
 * @name eachWeekendOfInterval
 * @category Interval Helpers
 * @summary List all the Saturdays and Sundays in the given date interval.
 *
 * @description
 * Get all the Saturdays and Sundays in the given date interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The given interval
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given date interval
 * const result = eachWeekendOfInterval({
 *   start: new Date(2018, 8, 17),
 *   end: new Date(2018, 8, 30)
 * })
 * //=> [
 * //   Sat Sep 22 2018 00:00:00,
 * //   Sun Sep 23 2018 00:00:00,
 * //   Sat Sep 29 2018 00:00:00,
 * //   Sun Sep 30 2018 00:00:00
 * // ]
 */
function eachWeekendOfInterval(interval) {
  const dateInterval = (0, _index$2S.eachDayOfInterval)(interval);
  const weekends = [];
  let index = 0;
  while (index < dateInterval.length) {
    const date = dateInterval[index++];
    if ((0, _index2$10.isWeekend)(date)) weekends.push(date);
  }
  return weekends;
}

var eachWeekendOfMonth$1 = {};

var startOfMonth$1 = {};

startOfMonth$1.startOfMonth = startOfMonth;
var _index$2R = toDate$1;

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth(date) {
  const _date = (0, _index$2R.toDate)(date);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

eachWeekendOfMonth$1.eachWeekendOfMonth = eachWeekendOfMonth;
var _index$2Q = eachWeekendOfInterval$1;
var _index2$$ = endOfMonth$1;
var _index3$v = startOfMonth$1;

/**
 * @name eachWeekendOfMonth
 * @category Month Helpers
 * @summary List all the Saturdays and Sundays in the given month.
 *
 * @description
 * Get all the Saturdays and Sundays in the given month.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given month
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given month
 * const result = eachWeekendOfMonth(new Date(2022, 1, 1))
 * //=> [
 * //   Sat Feb 05 2022 00:00:00,
 * //   Sun Feb 06 2022 00:00:00,
 * //   Sat Feb 12 2022 00:00:00,
 * //   Sun Feb 13 2022 00:00:00,
 * //   Sat Feb 19 2022 00:00:00,
 * //   Sun Feb 20 2022 00:00:00,
 * //   Sat Feb 26 2022 00:00:00,
 * //   Sun Feb 27 2022 00:00:00
 * // ]
 */
function eachWeekendOfMonth(date) {
  const start = (0, _index3$v.startOfMonth)(date);
  const end = (0, _index2$$.endOfMonth)(date);
  return (0, _index$2Q.eachWeekendOfInterval)({ start, end });
}

var eachWeekendOfYear$1 = {};

var endOfYear$1 = {};

endOfYear$1.endOfYear = endOfYear;
var _index$2P = toDate$1;

/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a year
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */
function endOfYear(date) {
  const _date = (0, _index$2P.toDate)(date);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

var startOfYear$1 = {};

startOfYear$1.startOfYear = startOfYear;
var _index$2O = toDate$1;
var _index2$_ = constructFrom$1;

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(date) {
  const cleanDate = (0, _index$2O.toDate)(date);
  const _date = (0, _index2$_.constructFrom)(date, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

eachWeekendOfYear$1.eachWeekendOfYear = eachWeekendOfYear;
var _index$2N = eachWeekendOfInterval$1;
var _index2$Z = endOfYear$1;
var _index3$u = startOfYear$1;

/**
 * @name eachWeekendOfYear
 * @category Year Helpers
 * @summary List all the Saturdays and Sundays in the year.
 *
 * @description
 * Get all the Saturdays and Sundays in the year.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given year
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the year
 * const result = eachWeekendOfYear(new Date(2020, 1, 1))
 * //=> [
 * //   Sat Jan 03 2020 00:00:00,
 * //   Sun Jan 04 2020 00:00:00,
 * //   ...
 * //   Sun Dec 27 2020 00:00:00
 * // ]
 * ]
 */
function eachWeekendOfYear(date) {
  const start = (0, _index3$u.startOfYear)(date);
  const end = (0, _index2$Z.endOfYear)(date);
  return (0, _index$2N.eachWeekendOfInterval)({ start, end });
}

var eachYearOfInterval$1 = {};

eachYearOfInterval$1.eachYearOfInterval = eachYearOfInterval;
var _index$2M = toDate$1;

/**
 * The {@link eachYearOfInterval} function options.
 */

/**
 * @name eachYearOfInterval
 * @category Interval Helpers
 * @summary Return the array of yearly timestamps within the specified time interval.
 *
 * @description
 * Return the array of yearly timestamps within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 *
 * @returns The array with starts of yearly timestamps from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each year between 6 February 2014 and 10 August 2017:
 * const result = eachYearOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2017, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Thu Jan 01 2015 00:00:00,
 * //   Fri Jan 01 2016 00:00:00,
 * //   Sun Jan 01 2017 00:00:00
 * // ]
 */
function eachYearOfInterval(interval, options) {
  const startDate = (0, _index$2M.toDate)(interval.start);
  const endDate = (0, _index$2M.toDate)(interval.end);

  let reversed = +startDate > +endDate;
  const endTime = reversed ? +startDate : +endDate;
  const currentDate = reversed ? endDate : startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setMonth(0, 1);

  let step = options?.step ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }

  const dates = [];

  while (+currentDate <= endTime) {
    dates.push((0, _index$2M.toDate)(currentDate));
    currentDate.setFullYear(currentDate.getFullYear() + step);
  }

  return reversed ? dates.reverse() : dates;
}

var endOfDecade$1 = {};

endOfDecade$1.endOfDecade = endOfDecade;
var _index$2L = toDate$1;

/**
 * @name endOfDecade
 * @category Decade Helpers
 * @summary Return the end of a decade for the given date.
 *
 * @description
 * Return the end of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a decade
 *
 * @example
 * // The end of a decade for 12 May 1984 00:00:00:
 * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))
 * //=> Dec 31 1989 23:59:59.999
 */
function endOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index$2L.toDate)(date);
  const year = _date.getFullYear();
  const decade = 9 + Math.floor(year / 10) * 10;
  _date.setFullYear(decade, 11, 31);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

var endOfHour$1 = {};

endOfHour$1.endOfHour = endOfHour;
var _index$2K = toDate$1;

/**
 * @name endOfHour
 * @category Hour Helpers
 * @summary Return the end of an hour for the given date.
 *
 * @description
 * Return the end of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an hour
 *
 * @example
 * // The end of an hour for 2 September 2014 11:55:00:
 * const result = endOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:59:59.999
 */
function endOfHour(date) {
  const _date = (0, _index$2K.toDate)(date);
  _date.setMinutes(59, 59, 999);
  return _date;
}

var endOfISOWeek$1 = {};

var endOfWeek$1 = {};

endOfWeek$1.endOfWeek = endOfWeek;
var _index$2J = toDate$1;

var _index2$Y = defaultOptions$1;

/**
 * The {@link endOfWeek} function options.
 */

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The end of a week
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(date, options) {
  const defaultOptions = (0, _index2$Y.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index$2J.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

endOfISOWeek$1.endOfISOWeek = endOfISOWeek;
var _index$2I = endOfWeek$1;

/**
 * @name endOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the end of an ISO week for the given date.
 *
 * @description
 * Return the end of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week
 *
 * @example
 * // The end of an ISO week for 2 September 2014 11:55:00:
 * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfISOWeek(date) {
  return (0, _index$2I.endOfWeek)(date, { weekStartsOn: 1 });
}

var endOfISOWeekYear$1 = {};

endOfISOWeekYear$1.endOfISOWeekYear = endOfISOWeekYear;
var _index$2H = getISOWeekYear$1;
var _index2$X = startOfISOWeek$1;
var _index3$t = constructFrom$1;

/**
 * @name endOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the end of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the end of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The end of an ISO week-numbering year for 2 July 2005:
 * const result = endOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 23:59:59.999
 */
function endOfISOWeekYear(date) {
  const year = (0, _index$2H.getISOWeekYear)(date);
  const fourthOfJanuaryOfNextYear = (0, _index3$t.constructFrom)(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const _date = (0, _index2$X.startOfISOWeek)(fourthOfJanuaryOfNextYear);
  _date.setMilliseconds(_date.getMilliseconds() - 1);
  return _date;
}

var endOfMinute$1 = {};

endOfMinute$1.endOfMinute = endOfMinute;
var _index$2G = toDate$1;

/**
 * @name endOfMinute
 * @category Minute Helpers
 * @summary Return the end of a minute for the given date.
 *
 * @description
 * Return the end of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a minute
 *
 * @example
 * // The end of a minute for 1 December 2014 22:15:45.400:
 * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:59.999
 */
function endOfMinute(date) {
  const _date = (0, _index$2G.toDate)(date);
  _date.setSeconds(59, 999);
  return _date;
}

var endOfQuarter$1 = {};

endOfQuarter$1.endOfQuarter = endOfQuarter;
var _index$2F = toDate$1;

/**
 * @name endOfQuarter
 * @category Quarter Helpers
 * @summary Return the end of a year quarter for the given date.
 *
 * @description
 * Return the end of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a quarter
 *
 * @example
 * // The end of a quarter for 2 September 2014 11:55:00:
 * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfQuarter(date) {
  const _date = (0, _index$2F.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3) + 3;
  _date.setMonth(month, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

var endOfSecond$1 = {};

endOfSecond$1.endOfSecond = endOfSecond;
var _index$2E = toDate$1;

/**
 * @name endOfSecond
 * @category Second Helpers
 * @summary Return the end of a second for the given date.
 *
 * @description
 * Return the end of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a second
 *
 * @example
 * // The end of a second for 1 December 2014 22:15:45.400:
 * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.999
 */
function endOfSecond(date) {
  const _date = (0, _index$2E.toDate)(date);
  _date.setMilliseconds(999);
  return _date;
}

var endOfToday$1 = {};

endOfToday$1.endOfToday = endOfToday;
var _index$2D = endOfDay$1;

/**
 * @name endOfToday
 * @category Day Helpers
 * @summary Return the end of today.
 * @pure false
 *
 * @description
 * Return the end of today.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfToday()
 * //=> Mon Oct 6 2014 23:59:59.999
 */
function endOfToday() {
  return (0, _index$2D.endOfDay)(Date.now());
}

var endOfTomorrow$1 = {};

endOfTomorrow$1.endOfTomorrow = endOfTomorrow; /**
 * @name endOfTomorrow
 * @category Day Helpers
 * @summary Return the end of tomorrow.
 * @pure false
 *
 * @description
 * Return the end of tomorrow.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfTomorrow()
 * //=> Tue Oct 7 2014 23:59:59.999
 */
function endOfTomorrow() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(23, 59, 59, 999);
  return date;
}

var endOfYesterday$1 = {};

endOfYesterday$1.endOfYesterday = endOfYesterday; /**
 * @name endOfYesterday
 * @category Day Helpers
 * @summary Return the end of yesterday.
 * @pure false
 *
 * @description
 * Return the end of yesterday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfYesterday()
 * //=> Sun Oct 5 2014 23:59:59.999
 */
function endOfYesterday() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(23, 59, 59, 999);
  return date;
}

var format = {};

var defaultLocale = {};

(function (exports) {
Object.defineProperty(exports, "defaultLocale", {
  enumerable: true,
  get: function () {
    return _index.enUS;
  },
});
var _index = enUS;
}(defaultLocale));

var formatters = {};

var getDayOfYear$1 = {};

getDayOfYear$1.getDayOfYear = getDayOfYear;
var _index$2C = differenceInCalendarDays$1;
var _index2$W = startOfYear$1;
var _index3$s = toDate$1;

/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(date) {
  const _date = (0, _index3$s.toDate)(date);
  const diff = (0, _index$2C.differenceInCalendarDays)(
    _date,
    (0, _index2$W.startOfYear)(_date),
  );
  const dayOfYear = diff + 1;
  return dayOfYear;
}

var getISOWeek$1 = {};

getISOWeek$1.getISOWeek = getISOWeek;
var _index$2B = constants$1;
var _index2$V = startOfISOWeek$1;
var _index3$r = startOfISOWeekYear$1;
var _index4$b = toDate$1;

/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(date) {
  const _date = (0, _index4$b.toDate)(date);
  const diff =
    +(0, _index2$V.startOfISOWeek)(_date) -
    +(0, _index3$r.startOfISOWeekYear)(_date);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index$2B.millisecondsInWeek) + 1;
}

var getWeek$1 = {};

var startOfWeekYear$1 = {};

var getWeekYear$1 = {};

getWeekYear$1.getWeekYear = getWeekYear;
var _index$2A = constructFrom$1;
var _index2$U = startOfWeek$1;
var _index3$q = toDate$1;

var _index4$a = defaultOptions$1;

/**
 * The {@link getWeekYear} function options.
 */

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The local week-numbering year
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(date, options) {
  const _date = (0, _index3$q.toDate)(date);
  const year = _date.getFullYear();

  const defaultOptions = (0, _index4$a.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const firstWeekOfNextYear = (0, _index$2A.constructFrom)(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = (0, _index2$U.startOfWeek)(
    firstWeekOfNextYear,
    options,
  );

  const firstWeekOfThisYear = (0, _index$2A.constructFrom)(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = (0, _index2$U.startOfWeek)(
    firstWeekOfThisYear,
    options,
  );

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

startOfWeekYear$1.startOfWeekYear = startOfWeekYear;
var _index$2z = constructFrom$1;
var _index2$T = getWeekYear$1;
var _index3$p = startOfWeek$1;

var _index4$9 = defaultOptions$1;

/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(date, options) {
  const defaultOptions = (0, _index4$9.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = (0, _index2$T.getWeekYear)(date, options);
  const firstWeek = (0, _index$2z.constructFrom)(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = (0, _index3$p.startOfWeek)(firstWeek, options);
  return _date;
}

getWeek$1.getWeek = getWeek;
var _index$2y = constants$1;
var _index2$S = startOfWeek$1;
var _index3$o = startOfWeekYear$1;
var _index4$8 = toDate$1;

/**
 * The {@link getWeek} function options.
 */

/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The week
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(date, options) {
  const _date = (0, _index4$8.toDate)(date);
  const diff =
    +(0, _index2$S.startOfWeek)(_date, options) -
    +(0, _index3$o.startOfWeekYear)(_date, options);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index$2y.millisecondsInWeek) + 1;
}

var addLeadingZeros$1 = {};

addLeadingZeros$1.addLeadingZeros = addLeadingZeros;
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

var lightFormatters = {};

lightFormatters.lightFormatters = void 0;
var _index$2x = addLeadingZeros$1;

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

(lightFormatters.lightFormatters = {
  // Year
  y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    const signedYear = date.getFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0, _index$2x.addLeadingZeros)(
      token === "yy" ? year % 100 : year,
      token.length,
    );
  },

  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M"
      ? String(month + 1)
      : (0, _index$2x.addLeadingZeros)(month + 1, 2);
  },

  // Day of the month
  d(date, token) {
    return (0, _index$2x.addLeadingZeros)(date.getDate(), token.length);
  },

  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },

  // Hour [1-12]
  h(date, token) {
    return (0, _index$2x.addLeadingZeros)(
      date.getHours() % 12 || 12,
      token.length,
    );
  },

  // Hour [0-23]
  H(date, token) {
    return (0, _index$2x.addLeadingZeros)(date.getHours(), token.length);
  },

  // Minute
  m(date, token) {
    return (0, _index$2x.addLeadingZeros)(date.getMinutes(), token.length);
  },

  // Second
  s(date, token) {
    return (0, _index$2x.addLeadingZeros)(date.getSeconds(), token.length);
  },

  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3),
    );
    return (0, _index$2x.addLeadingZeros)(fractionalSeconds, token.length);
  },
});

formatters.formatters = void 0;
var _index$2w = getDayOfYear$1;
var _index2$R = getISOWeek$1;
var _index3$n = getISOWeekYear$1;
var _index4$7 = getWeek$1;
var _index5$6 = getWeekYear$1;

var _index6$4 = addLeadingZeros$1;
var _index7$4 = lightFormatters;

const dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night",
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

(formatters.formatters = {
  // Era
  G: function (date, token, localize) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize.era(era, { width: "wide" });
    }
  },

  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === "yo") {
      const signedYear = date.getFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, { unit: "year" });
    }

    return _index7$4.lightFormatters.y(date, token);
  },

  // Local week-numbering year
  Y: function (date, token, localize, options) {
    const signedWeekYear = (0, _index5$6.getWeekYear)(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return (0, _index6$4.addLeadingZeros)(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, { unit: "year" });
    }

    // Padding
    return (0, _index6$4.addLeadingZeros)(weekYear, token.length);
  },

  // ISO week-numbering year
  R: function (date, token) {
    const isoWeekYear = (0, _index3$n.getISOWeekYear)(date);

    // Padding
    return (0, _index6$4.addLeadingZeros)(isoWeekYear, token.length);
  },

  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    const year = date.getFullYear();
    return (0, _index6$4.addLeadingZeros)(year, token.length);
  },

  // Quarter
  Q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return (0, _index6$4.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone quarter
  q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return (0, _index6$4.addLeadingZeros)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // Month
  M: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return _index7$4.lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting",
        });
      // J, F, ..., D
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize.month(month, { width: "wide", context: "formatting" });
    }
  },

  // Stand-alone month
  L: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return (0, _index6$4.addLeadingZeros)(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone",
        });
      // J, F, ..., D
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize.month(month, { width: "wide", context: "standalone" });
    }
  },

  // Local week of year
  w: function (date, token, localize, options) {
    const week = (0, _index4$7.getWeek)(date, options);

    if (token === "wo") {
      return localize.ordinalNumber(week, { unit: "week" });
    }

    return (0, _index6$4.addLeadingZeros)(week, token.length);
  },

  // ISO week of year
  I: function (date, token, localize) {
    const isoWeek = (0, _index2$R.getISOWeek)(date);

    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, { unit: "week" });
    }

    return (0, _index6$4.addLeadingZeros)(isoWeek, token.length);
  },

  // Day of the month
  d: function (date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getDate(), { unit: "date" });
    }

    return _index7$4.lightFormatters.d(date, token);
  },

  // Day of year
  D: function (date, token, localize) {
    const dayOfYear = (0, _index$2w.getDayOfYear)(date);

    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }

    return (0, _index6$4.addLeadingZeros)(dayOfYear, token.length);
  },

  // Day of week
  E: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Local day of week
  e: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return (0, _index6$4.addLeadingZeros)(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return (0, _index6$4.addLeadingZeros)(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone",
        });
      // T
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone",
        });
      // Tuesday
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // ISO day of week
  i: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return (0, _index6$4.addLeadingZeros)(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM or PM
  a: function (date, token, localize) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "aaa":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }

    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "bbb":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return _index7$4.lightFormatters.h(date, token);
  },

  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
    }

    return _index7$4.lightFormatters.H(date, token);
  },

  // Hour [0-11]
  K: function (date, token, localize) {
    const hours = date.getHours() % 12;

    if (token === "Ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0, _index6$4.addLeadingZeros)(hours, token.length);
  },

  // Hour [1-24]
  k: function (date, token, localize) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;

    if (token === "ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return (0, _index6$4.addLeadingZeros)(hours, token.length);
  },

  // Minute
  m: function (date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }

    return _index7$4.lightFormatters.m(date, token);
  },

  // Second
  s: function (date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
    }

    return _index7$4.lightFormatters.s(date, token);
  },

  // Fraction of second
  S: function (date, token) {
    return _index7$4.lightFormatters.S(date, token);
  },

  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return "Z";
    }

    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (GMT)
  O: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (specific non-location)
  z: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Seconds timestamp
  t: function (date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1000);
    return (0, _index6$4.addLeadingZeros)(timestamp, token.length);
  },

  // Milliseconds timestamp
  T: function (date, token, _localize) {
    const timestamp = date.getTime();
    return (0, _index6$4.addLeadingZeros)(timestamp, token.length);
  },
});

function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return (
    sign + String(hours) + delimiter + (0, _index6$4.addLeadingZeros)(minutes, 2)
  );
}

function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + (0, _index6$4.addLeadingZeros)(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}

function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = (0, _index6$4.addLeadingZeros)(Math.trunc(absOffset / 60), 2);
  const minutes = (0, _index6$4.addLeadingZeros)(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var longFormatters = {};

longFormatters.longFormatters = void 0;

const dateLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong.date({ width: "full" });
  }
};

const timeLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    case "pppp":
    default:
      return formatLong.time({ width: "full" });
  }
};

const dateTimeLongFormatter = (pattern, formatLong) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  let dateTimeFormat;

  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
      break;
  }

  return dateTimeFormat
    .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
    .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};

(longFormatters.longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter,
});

var protectedTokens = {};

protectedTokens.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
protectedTokens.isProtectedWeekYearToken = isProtectedWeekYearToken;
protectedTokens.warnOrThrowProtectedError = warnOrThrowProtectedError;
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;

const throwTokens = ["D", "DD", "YY", "YYYY"];

function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}

function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}

function warnOrThrowProtectedError(token, format, input) {
  const _message = message(token, format, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}

function message(token, format, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

(function (exports) {
exports.format = exports.formatDate = format;
Object.defineProperty(exports, "formatters", {
  enumerable: true,
  get: function () {
    return _index3.formatters;
  },
});
Object.defineProperty(exports, "longFormatters", {
  enumerable: true,
  get: function () {
    return _index4.longFormatters;
  },
});
var _index = defaultLocale;
var _index2 = defaultOptions$1;
var _index3 = formatters;
var _index4 = longFormatters;
var _index5 = protectedTokens;

var _index6 = isValid$1;
var _index7 = toDate$1;

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * The {@link format} function options.
 */

/**
 * @name format
 * @alias formatDate
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 * @param options - An object with options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */
function format(date, formatStr, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;

  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const originalDate = (0, _index7.toDate)(date);

  if (!(0, _index6.isValid)(originalDate)) {
    throw new RangeError("Invalid time value");
  }

  let parts = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = _index4.longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp)
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }

      if (_index3.formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return { isToken: false, value: substring };
    });

  // invoke localize preprocessor (only for french locales at the moment)
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }

  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  return parts
    .map((part) => {
      if (!part.isToken) return part.value;

      const token = part.value;

      if (
        (!options?.useAdditionalWeekYearTokens &&
          (0, _index5.isProtectedWeekYearToken)(token)) ||
        (!options?.useAdditionalDayOfYearTokens &&
          (0, _index5.isProtectedDayOfYearToken)(token))
      ) {
        (0, _index5.warnOrThrowProtectedError)(token, formatStr, String(date));
      }

      const formatter = _index3.formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    })
    .join("");
}

function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}
}(format));

var formatDistance$1 = {};

formatDistance$1.formatDistance = formatDistance;
var _index$2v = compareAsc$1;
var _index2$Q = constants$1;
var _index3$m = differenceInMonths$1;
var _index4$6 = differenceInSeconds$1;
var _index5$5 = toDate$1;

var _index6$3 = defaultLocale;
var _index7$3 = defaultOptions$1;
var _index8$2 = getTimezoneOffsetInMilliseconds$1;

/**
 * The {@link formatDistance} function options.
 */

/**
 * @name formatDistance
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words.
 *
 * | Distance between dates                                            | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance between dates | Result               |
 * |------------------------|----------------------|
 * | 0 secs ... 5 secs      | less than 5 seconds  |
 * | 5 secs ... 10 secs     | less than 10 seconds |
 * | 10 secs ... 20 secs    | less than 20 seconds |
 * | 20 secs ... 40 secs    | half a minute        |
 * | 40 secs ... 60 secs    | less than a minute   |
 * | 60 secs ... 90 secs    | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00, including seconds?
 * const result = formatDistance(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0),
 *   { includeSeconds: true }
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> 'about 1 year ago'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> 'pli ol 1 jaro'
 */

function formatDistance(date, baseDate, options) {
  const defaultOptions = (0, _index7$3.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index6$3.defaultLocale;
  const minutesInAlmostTwoDays = 2520;

  const comparison = (0, _index$2v.compareAsc)(date, baseDate);

  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }

  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison: comparison,
  });

  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index5$5.toDate)(baseDate);
    dateRight = (0, _index5$5.toDate)(date);
  } else {
    dateLeft = (0, _index5$5.toDate)(date);
    dateRight = (0, _index5$5.toDate)(baseDate);
  }

  const seconds = (0, _index4$6.differenceInSeconds)(dateRight, dateLeft);
  const offsetInSeconds =
    ((0, _index8$2.getTimezoneOffsetInMilliseconds)(dateRight) -
      (0, _index8$2.getTimezoneOffsetInMilliseconds)(dateLeft)) /
    1000;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;

  // 0 up to 2 mins
  if (minutes < 2) {
    if (options?.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }

    // 2 mins up to 0.75 hrs
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);

    // 0.75 hrs up to 1.5 hrs
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);

    // 1.5 hrs up to 24 hrs
  } else if (minutes < _index2$Q.minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);

    // 1 day up to 1.75 days
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);

    // 1.75 days up to 30 days
  } else if (minutes < _index2$Q.minutesInMonth) {
    const days = Math.round(minutes / _index2$Q.minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);

    // 1 month up to 2 months
  } else if (minutes < _index2$Q.minutesInMonth * 2) {
    months = Math.round(minutes / _index2$Q.minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }

  months = (0, _index3$m.differenceInMonths)(dateRight, dateLeft);

  // 2 months up to 12 months
  if (months < 12) {
    const nearestMonth = Math.round(minutes / _index2$Q.minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);

    // 1 year up to max Date
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);

    // N years up to 1 years 3 months
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);

      // N years 3 months up to N years 9 months
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);

      // N years 9 months up to N year 12 months
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}

var formatDistanceStrict$1 = {};

formatDistanceStrict$1.formatDistanceStrict = formatDistanceStrict;
var _index$2u = defaultLocale;
var _index2$P = defaultOptions$1;
var _index3$l = getRoundingMethod$1;
var _index4$5 = getTimezoneOffsetInMilliseconds$1;
var _index5$4 = compareAsc$1;
var _index6$2 = constants$1;

var _index7$2 = toDate$1;

/**
 * The {@link formatDistanceStrict} function options.
 */

/**
 * The unit used to format the distance in {@link formatDistanceStrict}.
 */

/**
 * @name formatDistanceStrict
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00?
 * const result = formatDistanceStrict(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> '1 year ago'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, in minutes?
 * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
 *   unit: 'minute'
 * })
 * //=> '525600 minutes'
 *
 * @example
 * // What is the distance from 1 January 2015
 * // to 28 January 2015, in months, rounded up?
 * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> '1 jaro'
 */

function formatDistanceStrict(date, baseDate, options) {
  const defaultOptions = (0, _index2$P.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index$2u.defaultLocale;

  const comparison = (0, _index5$4.compareAsc)(date, baseDate);

  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }

  const localizeOptions = Object.assign({}, options, {
    addSuffix: options?.addSuffix,
    comparison: comparison,
  });

  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index7$2.toDate)(baseDate);
    dateRight = (0, _index7$2.toDate)(date);
  } else {
    dateLeft = (0, _index7$2.toDate)(date);
    dateRight = (0, _index7$2.toDate)(baseDate);
  }

  const roundingMethod = (0, _index3$l.getRoundingMethod)(
    options?.roundingMethod ?? "round",
  );

  const milliseconds = dateRight.getTime() - dateLeft.getTime();
  const minutes = milliseconds / _index6$2.millisecondsInMinute;

  const timezoneOffset =
    (0, _index4$5.getTimezoneOffsetInMilliseconds)(dateRight) -
    (0, _index4$5.getTimezoneOffsetInMilliseconds)(dateLeft);

  // Use DST-normalized difference in minutes for years, months and days;
  // use regular difference in minutes for hours, minutes and seconds.
  const dstNormalizedMinutes =
    (milliseconds - timezoneOffset) / _index6$2.millisecondsInMinute;

  const defaultUnit = options?.unit;
  let unit;
  if (!defaultUnit) {
    if (minutes < 1) {
      unit = "second";
    } else if (minutes < 60) {
      unit = "minute";
    } else if (minutes < _index6$2.minutesInDay) {
      unit = "hour";
    } else if (dstNormalizedMinutes < _index6$2.minutesInMonth) {
      unit = "day";
    } else if (dstNormalizedMinutes < _index6$2.minutesInYear) {
      unit = "month";
    } else {
      unit = "year";
    }
  } else {
    unit = defaultUnit;
  }

  // 0 up to 60 seconds
  if (unit === "second") {
    const seconds = roundingMethod(milliseconds / 1000);
    return locale.formatDistance("xSeconds", seconds, localizeOptions);

    // 1 up to 60 mins
  } else if (unit === "minute") {
    const roundedMinutes = roundingMethod(minutes);
    return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);

    // 1 up to 24 hours
  } else if (unit === "hour") {
    const hours = roundingMethod(minutes / 60);
    return locale.formatDistance("xHours", hours, localizeOptions);

    // 1 up to 30 days
  } else if (unit === "day") {
    const days = roundingMethod(dstNormalizedMinutes / _index6$2.minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);

    // 1 up to 12 months
  } else if (unit === "month") {
    const months = roundingMethod(
      dstNormalizedMinutes / _index6$2.minutesInMonth,
    );
    return months === 12 && defaultUnit !== "month"
      ? locale.formatDistance("xYears", 1, localizeOptions)
      : locale.formatDistance("xMonths", months, localizeOptions);

    // 1 year up to max Date
  } else {
    const years = roundingMethod(dstNormalizedMinutes / _index6$2.minutesInYear);
    return locale.formatDistance("xYears", years, localizeOptions);
  }
}

var formatDistanceToNow$1 = {};

formatDistanceToNow$1.formatDistanceToNow = formatDistanceToNow;
var _index$2t = constructNow$1;

var _index2$O = formatDistance$1;

/**
 * The {@link formatDistanceToNow} function options.
 */

/**
 * @name formatDistanceToNow
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given date and now in words.
 *
 * | Distance to now                                                   | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance to now     | Result               |
 * |---------------------|----------------------|
 * | 0 secs ... 5 secs   | less than 5 seconds  |
 * | 5 secs ... 10 secs  | less than 10 seconds |
 * | 10 secs ... 20 secs | less than 20 seconds |
 * | 20 secs ... 40 secs | half a minute        |
 * | 40 secs ... 60 secs | less than a minute   |
 * | 60 secs ... 90 secs | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - The object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNow(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNow(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNow(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in about 1 year'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 August 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNow(
 *   new Date(2016, 7, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */
function formatDistanceToNow(date, options) {
  return (0, _index2$O.formatDistance)(
    date,
    (0, _index$2t.constructNow)(date),
    options,
  );
}

var formatDistanceToNowStrict$1 = {};

formatDistanceToNowStrict$1.formatDistanceToNowStrict = formatDistanceToNowStrict;
var _index$2s = formatDistanceStrict$1;
var _index2$N = constructNow$1;

/**
 * The {@link formatDistanceToNowStrict} function options.
 */

/**
 * @name formatDistanceToNowStrict
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNowStrict(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNowStrict(
 *   new Date(2015, 0, 1, 0, 0, 15)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in 1 year'
 *
 * @example
 * // If today is 28 January 2015,
 * // what is the distance to 1 January 2015, in months, rounded up??
 * const result = formatDistanceToNowStrict(new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {locale: eoLocale}
 * )
 * //=> '1 jaro'
 */
function formatDistanceToNowStrict(date, options) {
  return (0, _index$2s.formatDistanceStrict)(
    date,
    (0, _index2$N.constructNow)(date),
    options,
  );
}

var formatDuration$1 = {};

formatDuration$1.formatDuration = formatDuration;

var _index$2r = defaultLocale;
var _index2$M = defaultOptions$1;

/**
 * The {@link formatDuration} function options.
 */

const defaultFormat = [
  "years",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
];

/**
 * @name formatDuration
 * @category Common Helpers
 * @summary Formats a duration in human-readable format
 *
 * @description
 * Return human-readable duration string i.e. "9 months 2 days"
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param duration - The duration to format
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @example
 * // Format full duration
 * formatDuration({
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> '2 years 9 months 1 week 7 days 5 hours 9 minutes 30 seconds'
 *
 * @example
 * // Format partial duration
 * formatDuration({ months: 9, days: 2 })
 * //=> '9 months 2 days'
 *
 * @example
 * // Customize the format
 * formatDuration(
 *   {
 *     years: 2,
 *     months: 9,
 *     weeks: 1,
 *     days: 7,
 *     hours: 5,
 *     minutes: 9,
 *     seconds: 30
 *   },
 *   { format: ['months', 'weeks'] }
 * ) === '9 months 1 week'
 *
 * @example
 * // Customize the zeros presence
 * formatDuration({ years: 0, months: 9 })
 * //=> '9 months'
 * formatDuration({ years: 0, months: 9 }, { zero: true })
 * //=> '0 years 9 months'
 *
 * @example
 * // Customize the delimiter
 * formatDuration({ years: 2, months: 9, weeks: 3 }, { delimiter: ', ' })
 * //=> '2 years, 9 months, 3 weeks'
 */
function formatDuration(duration, options) {
  const defaultOptions = (0, _index2$M.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index$2r.defaultLocale;
  const format = options?.format ?? defaultFormat;
  const zero = options?.zero ?? false;
  const delimiter = options?.delimiter ?? " ";

  if (!locale.formatDistance) {
    return "";
  }

  const result = format
    .reduce((acc, unit) => {
      const token = `x${unit.replace(/(^.)/, (m) => m.toUpperCase())}`;
      const value = duration[unit];
      if (value !== undefined && (zero || duration[unit])) {
        return acc.concat(locale.formatDistance(token, value));
      }
      return acc;
    }, [])
    .join(delimiter);

  return result;
}

var formatISO$1 = {};

formatISO$1.formatISO = formatISO;
var _index$2q = toDate$1;

var _index2$L = addLeadingZeros$1;

/**
 * The {@link formatISO} function options.
 */

/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string (in loca.l time zone)
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */
function formatISO(date, options) {
  const _date = (0, _index$2q.toDate)(date);

  if (isNaN(_date.getTime())) {
    throw new RangeError("Invalid time value");
  }

  const format = options?.format ?? "extended";
  const representation = options?.representation ?? "complete";

  let result = "";
  let tzOffset = "";

  const dateDelimiter = format === "extended" ? "-" : "";
  const timeDelimiter = format === "extended" ? ":" : "";

  // Representation is either 'date' or 'complete'
  if (representation !== "time") {
    const day = (0, _index2$L.addLeadingZeros)(_date.getDate(), 2);
    const month = (0, _index2$L.addLeadingZeros)(_date.getMonth() + 1, 2);
    const year = (0, _index2$L.addLeadingZeros)(_date.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
  }

  // Representation is either 'time' or 'complete'
  if (representation !== "date") {
    // Add the timezone.
    const offset = _date.getTimezoneOffset();

    if (offset !== 0) {
      const absoluteOffset = Math.abs(offset);
      const hourOffset = (0, _index2$L.addLeadingZeros)(
        Math.trunc(absoluteOffset / 60),
        2,
      );
      const minuteOffset = (0, _index2$L.addLeadingZeros)(absoluteOffset % 60, 2);
      // If less than 0, the sign is +, because it is ahead of time.
      const sign = offset < 0 ? "+" : "-";

      tzOffset = `${sign}${hourOffset}:${minuteOffset}`;
    } else {
      tzOffset = "Z";
    }

    const hour = (0, _index2$L.addLeadingZeros)(_date.getHours(), 2);
    const minute = (0, _index2$L.addLeadingZeros)(_date.getMinutes(), 2);
    const second = (0, _index2$L.addLeadingZeros)(_date.getSeconds(), 2);

    // If there's also date, separate it with time with 'T'
    const separator = result === "" ? "" : "T";

    // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
    const time = [hour, minute, second].join(timeDelimiter);

    // HHmmss or HH:mm:ss.
    result = `${result}${separator}${time}${tzOffset}`;
  }

  return result;
}

var formatISO9075$1 = {};

formatISO9075$1.formatISO9075 = formatISO9075;
var _index$2p = isValid$1;
var _index2$K = toDate$1;

var _index3$k = addLeadingZeros$1;

/**
 * The {@link formatISO9075} function options.
 */

/**
 * @name formatISO9075
 * @category Common Helpers
 * @summary Format the date according to the ISO 9075 standard (https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_get-format).
 *
 * @description
 * Return the formatted date string in ISO 9075 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18 19:00:52'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075, short format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918 190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, date only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, time only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52'
 */
function formatISO9075(date, options) {
  const _date = (0, _index2$K.toDate)(date);

  if (!(0, _index$2p.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const format = options?.format ?? "extended";
  const representation = options?.representation ?? "complete";

  let result = "";

  const dateDelimiter = format === "extended" ? "-" : "";
  const timeDelimiter = format === "extended" ? ":" : "";

  // Representation is either 'date' or 'complete'
  if (representation !== "time") {
    const day = (0, _index3$k.addLeadingZeros)(_date.getDate(), 2);
    const month = (0, _index3$k.addLeadingZeros)(_date.getMonth() + 1, 2);
    const year = (0, _index3$k.addLeadingZeros)(_date.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
  }

  // Representation is either 'time' or 'complete'
  if (representation !== "date") {
    const hour = (0, _index3$k.addLeadingZeros)(_date.getHours(), 2);
    const minute = (0, _index3$k.addLeadingZeros)(_date.getMinutes(), 2);
    const second = (0, _index3$k.addLeadingZeros)(_date.getSeconds(), 2);

    // If there's also date, separate it with time with a space
    const separator = result === "" ? "" : " ";

    // HHmmss or HH:mm:ss.
    result = `${result}${separator}${hour}${timeDelimiter}${minute}${timeDelimiter}${second}`;
  }

  return result;
}

var formatISODuration$1 = {};

formatISODuration$1.formatISODuration = formatISODuration;

/**
 * @name formatISODuration
 * @category Common Helpers
 * @summary Format a duration object according as ISO 8601 duration string
 *
 * @description
 * Format a duration object according to the ISO 8601 duration standard (https://www.digi.com/resources/documentation/digidocs//90001488-13/reference/r_iso_8601_duration_format.htm)
 *
 * @param duration - The duration to format
 *
 * @returns The ISO 8601 duration string
 *
 * @example
 * // Format the given duration as ISO 8601 string
 * const result = formatISODuration({
 *   years: 39,
 *   months: 2,
 *   days: 20,
 *   hours: 7,
 *   minutes: 5,
 *   seconds: 0
 * })
 * //=> 'P39Y2M20DT0H0M0S'
 */
function formatISODuration(duration) {
  const {
    years = 0,
    months = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  return `P${years}Y${months}M${days}DT${hours}H${minutes}M${seconds}S`;
}

var formatRFC3339$1 = {};

formatRFC3339$1.formatRFC3339 = formatRFC3339;
var _index$2o = isValid$1;
var _index2$J = toDate$1;
var _index3$j = addLeadingZeros$1;

/**
 * The {@link formatRFC3339} function options.
 */

/**
 * @name formatRFC3339
 * @category Common Helpers
 * @summary Format the date according to the RFC 3339 standard (https://tools.ietf.org/html/rfc3339#section-5.6).
 *
 * @description
 * Return the formatted date string in RFC 3339 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format:
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format, 3 digits of second fraction
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), {
 *   fractionDigits: 3
 * })
 * //=> '2019-09-18T19:00:52.234Z'
 */
function formatRFC3339(date, options) {
  const _date = (0, _index2$J.toDate)(date);

  if (!(0, _index$2o.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const fractionDigits = options?.fractionDigits ?? 0;

  const day = (0, _index3$j.addLeadingZeros)(_date.getDate(), 2);
  const month = (0, _index3$j.addLeadingZeros)(_date.getMonth() + 1, 2);
  const year = _date.getFullYear();

  const hour = (0, _index3$j.addLeadingZeros)(_date.getHours(), 2);
  const minute = (0, _index3$j.addLeadingZeros)(_date.getMinutes(), 2);
  const second = (0, _index3$j.addLeadingZeros)(_date.getSeconds(), 2);

  let fractionalSecond = "";
  if (fractionDigits > 0) {
    const milliseconds = _date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, fractionDigits - 3),
    );
    fractionalSecond =
      "." + (0, _index3$j.addLeadingZeros)(fractionalSeconds, fractionDigits);
  }

  let offset = "";
  const tzOffset = _date.getTimezoneOffset();

  if (tzOffset !== 0) {
    const absoluteOffset = Math.abs(tzOffset);
    const hourOffset = (0, _index3$j.addLeadingZeros)(
      Math.trunc(absoluteOffset / 60),
      2,
    );
    const minuteOffset = (0, _index3$j.addLeadingZeros)(absoluteOffset % 60, 2);
    // If less than 0, the sign is +, because it is ahead of time.
    const sign = tzOffset < 0 ? "+" : "-";

    offset = `${sign}${hourOffset}:${minuteOffset}`;
  } else {
    offset = "Z";
  }

  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}${offset}`;
}

var formatRFC7231$1 = {};

formatRFC7231$1.formatRFC7231 = formatRFC7231;
var _index$2n = isValid$1;
var _index2$I = toDate$1;
var _index3$i = addLeadingZeros$1;

const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

/**
 * @name formatRFC7231
 * @category Common Helpers
 * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).
 *
 * @description
 * Return the formatted date string in RFC 7231 format.
 * The result will always be in UTC timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 7231 format:
 * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))
 * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'
 */
function formatRFC7231(date) {
  const _date = (0, _index2$I.toDate)(date);

  if (!(0, _index$2n.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const dayName = days[_date.getUTCDay()];
  const dayOfMonth = (0, _index3$i.addLeadingZeros)(_date.getUTCDate(), 2);
  const monthName = months[_date.getUTCMonth()];
  const year = _date.getUTCFullYear();

  const hour = (0, _index3$i.addLeadingZeros)(_date.getUTCHours(), 2);
  const minute = (0, _index3$i.addLeadingZeros)(_date.getUTCMinutes(), 2);
  const second = (0, _index3$i.addLeadingZeros)(_date.getUTCSeconds(), 2);

  // Result variables.
  return `${dayName}, ${dayOfMonth} ${monthName} ${year} ${hour}:${minute}:${second} GMT`;
}

var formatRelative$1 = {};

formatRelative$1.formatRelative = formatRelative;
var _index$2m = differenceInCalendarDays$1;
var _index2$H = format;

var _index3$h = toDate$1;

var _index4$4 = defaultLocale;
var _index5$3 = defaultOptions$1;

/**
 * The {@link formatRelative} function options.
 */

/**
 * @name formatRelative
 * @category Common Helpers
 * @summary Represent the date in words relative to the given base date.
 *
 * @description
 * Represent the date in words relative to the given base date.
 *
 * | Distance to the base date | Result                    |
 * |---------------------------|---------------------------|
 * | Previous 6 days           | last Sunday at 04:30 AM   |
 * | Last day                  | yesterday at 04:30 AM     |
 * | Same day                  | today at 04:30 AM         |
 * | Next day                  | tomorrow at 04:30 AM      |
 * | Next 6 days               | Sunday at 04:30 AM        |
 * | Other                     | 12/31/2017                |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The date in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws `options.locale` must contain `formatRelative` property
 *
 * @example
 * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
 * const result = formatRelative(subDays(new Date(), 6), new Date())
 * //=> "last Thursday at 12:45 AM"
 */
function formatRelative(date, baseDate, options) {
  const _date = (0, _index3$h.toDate)(date);
  const _baseDate = (0, _index3$h.toDate)(baseDate);

  const defaultOptions = (0, _index5$3.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index4$4.defaultLocale;
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const diff = (0, _index$2m.differenceInCalendarDays)(_date, _baseDate);

  if (isNaN(diff)) {
    throw new RangeError("Invalid time value");
  }

  let token;
  if (diff < -6) {
    token = "other";
  } else if (diff < -1) {
    token = "lastWeek";
  } else if (diff < 0) {
    token = "yesterday";
  } else if (diff < 1) {
    token = "today";
  } else if (diff < 2) {
    token = "tomorrow";
  } else if (diff < 7) {
    token = "nextWeek";
  } else {
    token = "other";
  }

  const formatStr = locale.formatRelative(token, _date, _baseDate, {
    locale,
    weekStartsOn,
  });
  return (0, _index2$H.format)(_date, formatStr, { locale, weekStartsOn });
}

var fromUnixTime$1 = {};

fromUnixTime$1.fromUnixTime = fromUnixTime;
var _index$2l = toDate$1;

/**
 * @name fromUnixTime
 * @category Timestamp Helpers
 * @summary Create a date from a Unix timestamp.
 *
 * @description
 * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
 *
 * @param unixTime - The given Unix timestamp (in seconds)
 *
 * @returns The date
 *
 * @example
 * // Create the date 29 February 2012 11:45:05:
 * const result = fromUnixTime(1330515905)
 * //=> Wed Feb 29 2012 11:45:05
 */
function fromUnixTime(unixTime) {
  return (0, _index$2l.toDate)(unixTime * 1000);
}

var getDate$1 = {};

getDate$1.getDate = getDate;
var _index$2k = toDate$1;

/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of month
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */
function getDate(date) {
  const _date = (0, _index$2k.toDate)(date);
  const dayOfMonth = _date.getDate();
  return dayOfMonth;
}

var getDay$1 = {};

getDay$1.getDay = getDay;
var _index$2j = toDate$1;

/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of week, 0 represents Sunday
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */
function getDay(date) {
  const _date = (0, _index$2j.toDate)(date);
  const day = _date.getDay();
  return day;
}

var getDaysInMonth$1 = {};

getDaysInMonth$1.getDaysInMonth = getDaysInMonth;
var _index$2i = toDate$1;
var _index2$G = constructFrom$1;

/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */
function getDaysInMonth(date) {
  const _date = (0, _index$2i.toDate)(date);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = (0, _index2$G.constructFrom)(date, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

var getDaysInYear$1 = {};

var isLeapYear$1 = {};

isLeapYear$1.isLeapYear = isLeapYear;
var _index$2h = toDate$1;

/**
 * @name isLeapYear
 * @category Year Helpers
 * @summary Is the given date in the leap year?
 *
 * @description
 * Is the given date in the leap year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the leap year
 *
 * @example
 * // Is 1 September 2012 in the leap year?
 * const result = isLeapYear(new Date(2012, 8, 1))
 * //=> true
 */
function isLeapYear(date) {
  const _date = (0, _index$2h.toDate)(date);
  const year = _date.getFullYear();
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

getDaysInYear$1.getDaysInYear = getDaysInYear;
var _index$2g = isLeapYear$1;
var _index2$F = toDate$1;

/**
 * @name getDaysInYear
 * @category Year Helpers
 * @summary Get the number of days in a year of the given date.
 *
 * @description
 * Get the number of days in a year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a year
 *
 * @example
 * // How many days are in 2012?
 * const result = getDaysInYear(new Date(2012, 0, 1))
 * //=> 366
 */
function getDaysInYear(date) {
  const _date = (0, _index2$F.toDate)(date);

  if (String(new Date(_date)) === "Invalid Date") {
    return NaN;
  }

  return (0, _index$2g.isLeapYear)(_date) ? 366 : 365;
}

var getDecade$1 = {};

getDecade$1.getDecade = getDecade;
var _index$2f = toDate$1;

/**
 * @name getDecade
 * @category Decade Helpers
 * @summary Get the decade of the given date.
 *
 * @description
 * Get the decade of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year of decade
 *
 * @example
 * // Which decade belongs 27 November 1942?
 * const result = getDecade(new Date(1942, 10, 27))
 * //=> 1940
 */
function getDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index$2f.toDate)(date);
  const year = _date.getFullYear();
  const decade = Math.floor(year / 10) * 10;
  return decade;
}

var getDefaultOptions$1 = {};

getDefaultOptions$1.getDefaultOptions = getDefaultOptions;

var _index$2e = defaultOptions$1;

/**
 * @name getDefaultOptions
 * @category Common Helpers
 * @summary Get default options.
 * @pure false
 *
 * @description
 * Returns an object that contains defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
 *
 * @returns The default options
 *
 * @example
 * const result = getDefaultOptions()
 * //=> {}
 *
 * @example
 * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
 * const result = getDefaultOptions()
 * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
 */
function getDefaultOptions() {
  return Object.assign({}, (0, _index$2e.getDefaultOptions)());
}

var getHours$1 = {};

getHours$1.getHours = getHours;
var _index$2d = toDate$1;

/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The hours
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */
function getHours(date) {
  const _date = (0, _index$2d.toDate)(date);
  const hours = _date.getHours();
  return hours;
}

var getISODay$1 = {};

getISODay$1.getISODay = getISODay;
var _index$2c = toDate$1;

/**
 * @name getISODay
 * @category Weekday Helpers
 * @summary Get the day of the ISO week of the given date.
 *
 * @description
 * Get the day of the ISO week of the given date,
 * which is 7 for Sunday, 1 for Monday etc.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of ISO week
 *
 * @example
 * // Which day of the ISO week is 26 February 2012?
 * const result = getISODay(new Date(2012, 1, 26))
 * //=> 7
 */
function getISODay(date) {
  const _date = (0, _index$2c.toDate)(date);
  let day = _date.getDay();

  if (day === 0) {
    day = 7;
  }

  return day;
}

var getISOWeeksInYear$1 = {};

getISOWeeksInYear$1.getISOWeeksInYear = getISOWeeksInYear;
var _index$2b = addWeeks$1;
var _index2$E = constants$1;
var _index3$g = startOfISOWeekYear$1;

/**
 * @name getISOWeeksInYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * @description
 * Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of ISO weeks in a year
 *
 * @example
 * // How many weeks are in ISO week-numbering year 2015?
 * const result = getISOWeeksInYear(new Date(2015, 1, 11))
 * //=> 53
 */
function getISOWeeksInYear(date) {
  const thisYear = (0, _index3$g.startOfISOWeekYear)(date);
  const nextYear = (0, _index3$g.startOfISOWeekYear)(
    (0, _index$2b.addWeeks)(thisYear, 60),
  );
  const diff = +nextYear - +thisYear;

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / _index2$E.millisecondsInWeek);
}

var getMilliseconds$1 = {};

getMilliseconds$1.getMilliseconds = getMilliseconds;
var _index$2a = toDate$1;

/**
 * @name getMilliseconds
 * @category Millisecond Helpers
 * @summary Get the milliseconds of the given date.
 *
 * @description
 * Get the milliseconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The milliseconds
 *
 * @example
 * // Get the milliseconds of 29 February 2012 11:45:05.123:
 * const result = getMilliseconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 123
 */
function getMilliseconds(date) {
  const _date = (0, _index$2a.toDate)(date);
  const milliseconds = _date.getMilliseconds();
  return milliseconds;
}

var getMinutes$1 = {};

getMinutes$1.getMinutes = getMinutes;
var _index$29 = toDate$1;

/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The minutes
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */
function getMinutes(date) {
  const _date = (0, _index$29.toDate)(date);
  const minutes = _date.getMinutes();
  return minutes;
}

var getMonth$1 = {};

getMonth$1.getMonth = getMonth;
var _index$28 = toDate$1;

/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The month index (0-11)
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */
function getMonth(date) {
  const _date = (0, _index$28.toDate)(date);
  const month = _date.getMonth();
  return month;
}

var getOverlappingDaysInIntervals$1 = {};

getOverlappingDaysInIntervals$1.getOverlappingDaysInIntervals = getOverlappingDaysInIntervals;
var _index$27 = getTimezoneOffsetInMilliseconds$1;
var _index2$D = constants$1;
var _index3$f = toDate$1;

/**
 * @name getOverlappingDaysInIntervals
 * @category Interval Helpers
 * @summary Get the number of days that overlap in two time intervals
 *
 * @description
 * Get the number of days that overlap in two time intervals. It uses the time
 * between dates to calculate the number of days, rounding it up to include
 * partial days.
 *
 * Two equal 0-length intervals will result in 0. Two equal 1ms intervals will
 * result in 1.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 *
 * @returns The number of days that overlap in two time intervals
 *
 * @example
 * // For overlapping time intervals adds 1 for each started overlapping day:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> 3
 *
 * @example
 * // For non-overlapping time intervals returns 0:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> 0
 */

function getOverlappingDaysInIntervals(intervalLeft, intervalRight) {
  const [leftStart, leftEnd] = [
    +(0, _index3$f.toDate)(intervalLeft.start),
    +(0, _index3$f.toDate)(intervalLeft.end),
  ].sort((a, b) => a - b);
  const [rightStart, rightEnd] = [
    +(0, _index3$f.toDate)(intervalRight.start),
    +(0, _index3$f.toDate)(intervalRight.end),
  ].sort((a, b) => a - b);

  // Prevent NaN result if intervals don't overlap at all.
  const isOverlapping = leftStart < rightEnd && rightStart < leftEnd;
  if (!isOverlapping) return 0;

  // Remove the timezone offset to negate the DST effect on calculations.
  const overlapLeft = rightStart < leftStart ? leftStart : rightStart;
  const left =
    overlapLeft - (0, _index$27.getTimezoneOffsetInMilliseconds)(overlapLeft);
  const overlapRight = rightEnd > leftEnd ? leftEnd : rightEnd;
  const right =
    overlapRight - (0, _index$27.getTimezoneOffsetInMilliseconds)(overlapRight);

  // Ceil the number to include partial days too.
  return Math.ceil((right - left) / _index2$D.millisecondsInDay);
}

var getSeconds$1 = {};

getSeconds$1.getSeconds = getSeconds;
var _index$26 = toDate$1;

/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The seconds
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */
function getSeconds(date) {
  const _date = (0, _index$26.toDate)(date);
  const seconds = _date.getSeconds();
  return seconds;
}

var getTime$1 = {};

getTime$1.getTime = getTime;
var _index$25 = toDate$1;

/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */
function getTime(date) {
  const _date = (0, _index$25.toDate)(date);
  const timestamp = _date.getTime();
  return timestamp;
}

var getUnixTime$1 = {};

getUnixTime$1.getUnixTime = getUnixTime;
var _index$24 = toDate$1;

/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */
function getUnixTime(date) {
  return Math.trunc(+(0, _index$24.toDate)(date) / 1000);
}

var getWeekOfMonth$1 = {};

getWeekOfMonth$1.getWeekOfMonth = getWeekOfMonth;
var _index$23 = getDate$1;
var _index2$C = getDay$1;
var _index3$e = startOfMonth$1;

var _index4$3 = defaultOptions$1;

/**
 * The {@link getWeekOfMonth} function options.
 */

/**
 * @name getWeekOfMonth
 * @category Week Helpers
 * @summary Get the week of the month of the given date.
 *
 * @description
 * Get the week of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The week of month
 *
 * @example
 * // Which week of the month is 9 November 2017?
 * const result = getWeekOfMonth(new Date(2017, 10, 9))
 * //=> 2
 */
function getWeekOfMonth(date, options) {
  const defaultOptions = (0, _index4$3.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const currentDayOfMonth = (0, _index$23.getDate)(date);
  if (isNaN(currentDayOfMonth)) return NaN;

  const startWeekDay = (0, _index2$C.getDay)((0, _index3$e.startOfMonth)(date));

  let lastDayOfFirstWeek = weekStartsOn - startWeekDay;
  if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;

  const remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
  return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}

var getWeeksInMonth$1 = {};

var lastDayOfMonth$1 = {};

lastDayOfMonth$1.lastDayOfMonth = lastDayOfMonth;
var _index$22 = toDate$1;

/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a month
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfMonth(date) {
  const _date = (0, _index$22.toDate)(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

getWeeksInMonth$1.getWeeksInMonth = getWeeksInMonth;
var _index$21 = differenceInCalendarWeeks$1;
var _index2$B = lastDayOfMonth$1;
var _index3$d = startOfMonth$1;

/**
 * The {@link getWeeksInMonth} function options.
 */

/**
 * @name getWeeksInMonth
 * @category Week Helpers
 * @summary Get the number of calendar weeks a month spans.
 *
 * @description
 * Get the number of calendar weeks the month in the given date spans.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks does February 2015 span?
 * const result = getWeeksInMonth(new Date(2015, 1, 8))
 * //=> 4
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks does July 2017 span?
 * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
 * //=> 6
 */
function getWeeksInMonth(date, options) {
  return (
    (0, _index$21.differenceInCalendarWeeks)(
      (0, _index2$B.lastDayOfMonth)(date),
      (0, _index3$d.startOfMonth)(date),
      options,
    ) + 1
  );
}

var getYear$1 = {};

getYear$1.getYear = getYear;
var _index$20 = toDate$1;

/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */
function getYear(date) {
  return (0, _index$20.toDate)(date).getFullYear();
}

var hoursToMilliseconds$1 = {};

hoursToMilliseconds$1.hoursToMilliseconds = hoursToMilliseconds;
var _index$1$ = constants$1;

/**
 * @name hoursToMilliseconds
 * @category  Conversion Helpers
 * @summary Convert hours to milliseconds.
 *
 * @description
 * Convert a number of hours to a full number of milliseconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted to milliseconds
 *
 * @example
 * // Convert 2 hours to milliseconds:
 * const result = hoursToMilliseconds(2)
 * //=> 7200000
 */
function hoursToMilliseconds(hours) {
  return Math.trunc(hours * _index$1$.millisecondsInHour);
}

var hoursToMinutes$1 = {};

hoursToMinutes$1.hoursToMinutes = hoursToMinutes;
var _index$1_ = constants$1;

/**
 * @name hoursToMinutes
 * @category Conversion Helpers
 * @summary Convert hours to minutes.
 *
 * @description
 * Convert a number of hours to a full number of minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted in minutes
 *
 * @example
 * // Convert 2 hours to minutes:
 * const result = hoursToMinutes(2)
 * //=> 120
 */
function hoursToMinutes(hours) {
  return Math.trunc(hours * _index$1_.minutesInHour);
}

var hoursToSeconds$1 = {};

hoursToSeconds$1.hoursToSeconds = hoursToSeconds;
var _index$1Z = constants$1;

/**
 * @name hoursToSeconds
 * @category Conversion Helpers
 * @summary Convert hours to seconds.
 *
 * @description
 * Convert a number of hours to a full number of seconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - The number of hours to be converted
 *
 * @returns The number of hours converted in seconds
 *
 * @example
 * // Convert 2 hours to seconds:
 * const result = hoursToSeconds(2)
 * //=> 7200
 */
function hoursToSeconds(hours) {
  return Math.trunc(hours * _index$1Z.secondsInHour);
}

var interval$1 = {};

interval$1.interval = interval;
var _index$1Y = toDate$1;

/**
 * The {@link interval} function options.
 */

/**
 * @name interval
 * @category Interval Helpers
 * @summary Creates an interval object and validates its values.
 *
 * @description
 * Creates a normalized interval object and validates its values. If the interval is invalid, an exception is thrown.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param start - The start of the interval.
 * @param end - The end of the interval.
 * @param options - The options object.
 *
 * @throws `Start date is invalid` when `start` is invalid.
 * @throws `End date is invalid` when `end` is invalid.
 * @throws `End date must be after start date` when end is before `start` and `options.assertPositive` is true.
 *
 * @returns The normalized and validated interval object.
 */
function interval(start, end, options) {
  const _start = (0, _index$1Y.toDate)(start);
  if (isNaN(+_start)) throw new TypeError("Start date is invalid");

  const _end = (0, _index$1Y.toDate)(end);
  if (isNaN(+_end)) throw new TypeError("End date is invalid");

  if (options?.assertPositive && +_start > +_end)
    throw new TypeError("End date must be after start date");

  return { start: _start, end: _end };
}

var intervalToDuration$1 = {};

intervalToDuration$1.intervalToDuration = intervalToDuration;
var _index$1X = add$1;
var _index2$A = differenceInDays$1;
var _index3$c = differenceInHours$1;
var _index4$2 = differenceInMinutes$1;
var _index5$2 = differenceInMonths$1;
var _index6$1 = differenceInSeconds$1;
var _index7$1 = differenceInYears$1;
var _index8$1 = toDate$1;

/**
 * @name intervalToDuration
 * @category Common Helpers
 * @summary Convert interval to duration
 *
 * @description
 * Convert a interval object to a duration object.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval to convert to duration
 *
 * @returns The duration object
 *
 * @example
 * // Get the duration between January 15, 1929 and April 4, 1968.
 * intervalToDuration({
 *   start: new Date(1929, 0, 15, 12, 0, 0),
 *   end: new Date(1968, 3, 4, 19, 5, 0)
 * })
 * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }
 */
function intervalToDuration(interval) {
  const start = (0, _index8$1.toDate)(interval.start);
  const end = (0, _index8$1.toDate)(interval.end);

  const duration = {};

  const years = (0, _index7$1.differenceInYears)(end, start);
  if (years) duration.years = years;

  const remainingMonths = (0, _index$1X.add)(start, { years: duration.years });

  const months = (0, _index5$2.differenceInMonths)(end, remainingMonths);
  if (months) duration.months = months;

  const remainingDays = (0, _index$1X.add)(remainingMonths, {
    months: duration.months,
  });

  const days = (0, _index2$A.differenceInDays)(end, remainingDays);
  if (days) duration.days = days;

  const remainingHours = (0, _index$1X.add)(remainingDays, {
    days: duration.days,
  });

  const hours = (0, _index3$c.differenceInHours)(end, remainingHours);
  if (hours) duration.hours = hours;

  const remainingMinutes = (0, _index$1X.add)(remainingHours, {
    hours: duration.hours,
  });

  const minutes = (0, _index4$2.differenceInMinutes)(end, remainingMinutes);
  if (minutes) duration.minutes = minutes;

  const remainingSeconds = (0, _index$1X.add)(remainingMinutes, {
    minutes: duration.minutes,
  });

  const seconds = (0, _index6$1.differenceInSeconds)(end, remainingSeconds);
  if (seconds) duration.seconds = seconds;

  return duration;
}

var intlFormat$1 = {};

intlFormat$1.intlFormat = intlFormat;
var _index$1W = toDate$1;

/**
 * The locale string (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).
 */

/**
 * The format options (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#options)
 */

/**
 * The locale options.
 */

/**
 * @name intlFormat
 * @category Common Helpers
 * @summary Format the date with Intl.DateTimeFormat (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
 *
 * @description
 * Return the formatted date string in the given format.
 * The method uses [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) inside.
 * formatOptions are the same as [`Intl.DateTimeFormat` options](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options)
 *
 * > â ï¸ Please note that before Node version 13.0.0, only the locale data for en-US is available by default.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in middle-endian format:
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456))
 * //=> 10/4/2019
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in Korean.
 * // Convert the date with locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   locale: 'ko-KR',
 * })
 * //=> 2019. 10. 4.
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019.
 * // Convert the date with format's options.
 * const result = intlFormat.default(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   year: 'numeric',
 *   month: 'numeric',
 *   day: 'numeric',
 *   hour: 'numeric',
 * })
 * //=> 10/4/2019, 12 PM
 */

/**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 4 October 2019 in German.
 * // Convert the date with format's options and locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   weekday: 'long',
 *   year: 'numeric',
 *   month: 'long',
 *   day: 'numeric',
 * }, {
 *   locale: 'de-DE',
 * })
 * //=> Freitag, 4. Oktober 2019
 */

function intlFormat(date, formatOrLocale, localeOptions) {
  let formatOptions;

  if (isFormatOptions(formatOrLocale)) {
    formatOptions = formatOrLocale;
  } else {
    localeOptions = formatOrLocale;
  }

  return new Intl.DateTimeFormat(localeOptions?.locale, formatOptions).format(
    (0, _index$1W.toDate)(date),
  );
}

function isFormatOptions(opts) {
  return opts !== undefined && !("locale" in opts);
}

var intlFormatDistance$1 = {};

intlFormatDistance$1.intlFormatDistance = intlFormatDistance;
var _index$1V = constants$1;

var _index2$z = differenceInCalendarDays$1;
var _index3$b = differenceInCalendarMonths$1;
var _index4$1 = differenceInCalendarQuarters$1;
var _index5$1 = differenceInCalendarWeeks$1;
var _index6 = differenceInCalendarYears$1;
var _index7 = differenceInHours$1;
var _index8 = differenceInMinutes$1;
var _index9 = differenceInSeconds$1;
var _index10 = toDate$1;

/**
 * The {@link intlFormatDistance} function options.
 */

/**
 * The unit used to format the distance in {@link intlFormatDistance}.
 */

/**
 * @name intlFormatDistance
 * @category Common Helpers
 * @summary Formats distance between two dates in a human-readable format
 * @description
 * The function calculates the difference between two dates and formats it as a human-readable string.
 *
 * The function will pick the most appropriate unit depending on the distance between dates. For example, if the distance is a few hours, it might return `x hours`. If the distance is a few months, it might return `x months`.
 *
 * You can also specify a unit to force using it regardless of the distance to get a result like `123456 hours`.
 *
 * See the table below for the unit picking logic:
 *
 * | Distance between dates | Result (past)  | Result (future) |
 * | ---------------------- | -------------- | --------------- |
 * | 0 seconds              | now            | now             |
 * | 1-59 seconds           | X seconds ago  | in X seconds    |
 * | 1-59 minutes           | X minutes ago  | in X minutes    |
 * | 1-23 hours             | X hours ago    | in X hours      |
 * | 1 day                  | yesterday      | tomorrow        |
 * | 2-6 days               | X days ago     | in X days       |
 * | 7 days                 | last week      | next week       |
 * | 8 days-1 month         | X weeks ago    | in X weeks      |
 * | 1 month                | last month     | next month      |
 * | 2-3 months             | X months ago   | in X months     |
 * | 1 quarter              | last quarter   | next quarter    |
 * | 2-3 quarters           | X quarters ago | in X quarters   |
 * | 1 year                 | last year      | next year       |
 * | 2+ years               | X years ago    | in X years      |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with.
 * @param options - An object with options.
 * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)
 * The narrow one could be similar to the short one for some locales.
 *
 * @returns The distance in words according to language-sensitive relative time formatting.
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must not be invalid Unit
 * @throws `options.locale` must not be invalid locale
 * @throws `options.localeMatcher` must not be invalid localeMatcher
 * @throws `options.numeric` must not be invalid numeric
 * @throws `options.style` must not be invalid style
 *
 * @example
 * // What is the distance between the dates when the fist date is after the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0)
 * )
 * //=> 'in 1 hour'
 *
 * // What is the distance between the dates when the fist date is before the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0)
 * )
 * //=> '1 hour ago'
 *
 * @example
 * // Use the unit option to force the function to output the result in quarters. Without setting it, the example would return "next year"
 * intlFormatDistance(
 *   new Date(1987, 6, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { unit: 'quarter' }
 * )
 * //=> 'in 5 quarters'
 *
 * @example
 * // Use the locale option to get the result in Spanish. Without setting it, the example would return "in 1 hour".
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { locale: 'es' }
 * )
 * //=> 'dentro de 1 hora'
 *
 * @example
 * // Use the numeric option to force the function to use numeric values. Without setting it, the example would return "tomorrow".
 * intlFormatDistance(
 *   new Date(1986, 3, 5, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { numeric: 'always' }
 * )
 * //=> 'in 1 day'
 *
 * @example
 * // Use the style option to force the function to use short values. Without setting it, the example would return "in 2 years".
 * intlFormatDistance(
 *   new Date(1988, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { style: 'short' }
 * )
 * //=> 'in 2 yr'
 */
function intlFormatDistance(date, baseDate, options) {
  let value = 0;
  let unit;
  const dateLeft = (0, _index10.toDate)(date);
  const dateRight = (0, _index10.toDate)(baseDate);

  if (!options?.unit) {
    // Get the unit based on diffInSeconds calculations if no unit is specified
    const diffInSeconds = (0, _index9.differenceInSeconds)(dateLeft, dateRight); // The smallest unit

    if (Math.abs(diffInSeconds) < _index$1V.secondsInMinute) {
      value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
      unit = "second";
    } else if (Math.abs(diffInSeconds) < _index$1V.secondsInHour) {
      value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
      unit = "minute";
    } else if (
      Math.abs(diffInSeconds) < _index$1V.secondsInDay &&
      Math.abs((0, _index2$z.differenceInCalendarDays)(dateLeft, dateRight)) < 1
    ) {
      value = (0, _index7.differenceInHours)(dateLeft, dateRight);
      unit = "hour";
    } else if (
      Math.abs(diffInSeconds) < _index$1V.secondsInWeek &&
      (value = (0, _index2$z.differenceInCalendarDays)(dateLeft, dateRight)) &&
      Math.abs(value) < 7
    ) {
      unit = "day";
    } else if (Math.abs(diffInSeconds) < _index$1V.secondsInMonth) {
      value = (0, _index5$1.differenceInCalendarWeeks)(dateLeft, dateRight);
      unit = "week";
    } else if (Math.abs(diffInSeconds) < _index$1V.secondsInQuarter) {
      value = (0, _index3$b.differenceInCalendarMonths)(dateLeft, dateRight);
      unit = "month";
    } else if (Math.abs(diffInSeconds) < _index$1V.secondsInYear) {
      if ((0, _index4$1.differenceInCalendarQuarters)(dateLeft, dateRight) < 4) {
        // To filter out cases that are less than a year but match 4 quarters
        value = (0, _index4$1.differenceInCalendarQuarters)(dateLeft, dateRight);
        unit = "quarter";
      } else {
        value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
      unit = "year";
    }
  } else {
    // Get the value if unit is specified
    unit = options?.unit;
    if (unit === "second") {
      value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
    } else if (unit === "minute") {
      value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
    } else if (unit === "hour") {
      value = (0, _index7.differenceInHours)(dateLeft, dateRight);
    } else if (unit === "day") {
      value = (0, _index2$z.differenceInCalendarDays)(dateLeft, dateRight);
    } else if (unit === "week") {
      value = (0, _index5$1.differenceInCalendarWeeks)(dateLeft, dateRight);
    } else if (unit === "month") {
      value = (0, _index3$b.differenceInCalendarMonths)(dateLeft, dateRight);
    } else if (unit === "quarter") {
      value = (0, _index4$1.differenceInCalendarQuarters)(dateLeft, dateRight);
    } else if (unit === "year") {
      value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
    }
  }

  const rtf = new Intl.RelativeTimeFormat(options?.locale, {
    localeMatcher: options?.localeMatcher,
    numeric: options?.numeric || "auto",
    style: options?.style,
  });

  return rtf.format(value, unit);
}

var isAfter$1 = {};

isAfter$1.isAfter = isAfter;
var _index$1U = toDate$1;

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be after the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is after the second date
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */
function isAfter(date, dateToCompare) {
  const _date = (0, _index$1U.toDate)(date);
  const _dateToCompare = (0, _index$1U.toDate)(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}

var isBefore$1 = {};

isBefore$1.isBefore = isBefore;
var _index$1T = toDate$1;

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be before the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is before the second date
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore(date, dateToCompare) {
  const _date = (0, _index$1T.toDate)(date);
  const _dateToCompare = (0, _index$1T.toDate)(dateToCompare);
  return +_date < +_dateToCompare;
}

var isEqual$1 = {};

isEqual$1.isEqual = isEqual;
var _index$1S = toDate$1;

/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The dates are equal
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */
function isEqual(leftDate, rightDate) {
  const _dateLeft = (0, _index$1S.toDate)(leftDate);
  const _dateRight = (0, _index$1S.toDate)(rightDate);
  return +_dateLeft === +_dateRight;
}

var isExists$1 = {};

isExists$1.isExists = isExists; /**
 * @name isExists
 * @category Common Helpers
 * @summary Is the given date exists?
 *
 * @description
 * Checks if the given arguments convert to an existing date.
 *
 * @param year - The year of the date to check
 * @param month - The month of the date to check
 * @param day - The day of the date to check
 *
 * @returns `true` if the date exists
 *
 * @example
 * // For the valid date:
 * const result = isExists(2018, 0, 31)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isExists(2018, 1, 31)
 * //=> false
 */
function isExists(year, month, day) {
  const date = new Date(year, month, day);
  return (
    date.getFullYear() === year &&
    date.getMonth() === month &&
    date.getDate() === day
  );
}

var isFirstDayOfMonth$1 = {};

isFirstDayOfMonth$1.isFirstDayOfMonth = isFirstDayOfMonth;
var _index$1R = toDate$1;

/**
 * @name isFirstDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the first day of a month?
 *
 * @description
 * Is the given date the first day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the first day of a month
 *
 * @example
 * // Is 1 September 2014 the first day of a month?
 * const result = isFirstDayOfMonth(new Date(2014, 8, 1))
 * //=> true
 */
function isFirstDayOfMonth(date) {
  return (0, _index$1R.toDate)(date).getDate() === 1;
}

var isFriday$1 = {};

isFriday$1.isFriday = isFriday;
var _index$1Q = toDate$1;

/**
 * @name isFriday
 * @category Weekday Helpers
 * @summary Is the given date Friday?
 *
 * @description
 * Is the given date Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Friday
 *
 * @example
 * // Is 26 September 2014 Friday?
 * const result = isFriday(new Date(2014, 8, 26))
 * //=> true
 */
function isFriday(date) {
  return (0, _index$1Q.toDate)(date).getDay() === 5;
}

var isFuture$1 = {};

isFuture$1.isFuture = isFuture;
var _index$1P = toDate$1;

/**
 * @name isFuture
 * @category Common Helpers
 * @summary Is the given date in the future?
 * @pure false
 *
 * @description
 * Is the given date in the future?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the future
 *
 * @example
 * // If today is 6 October 2014, is 31 December 2014 in the future?
 * const result = isFuture(new Date(2014, 11, 31))
 * //=> true
 */
function isFuture(date) {
  return +(0, _index$1P.toDate)(date) > Date.now();
}

var isMatch$1 = {};

var parse = {};

var parsers = {};

var EraParser$1 = {};

var Parser$1 = {};

var Setter$1 = {};

var transpose$1 = {};

transpose$1.transpose = transpose;
var _index$1O = constructFrom$1;

/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam DateInputType - The input `Date` type derived from the passed argument.
 * @typeParam DateOutputType - The output `Date` type derived from the passed constructor.
 *
 * @param fromDate - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
function transpose(fromDate, constructor) {
  const date =
    constructor instanceof Date
      ? (0, _index$1O.constructFrom)(constructor, 0)
      : new constructor(0);
  date.setFullYear(
    fromDate.getFullYear(),
    fromDate.getMonth(),
    fromDate.getDate(),
  );
  date.setHours(
    fromDate.getHours(),
    fromDate.getMinutes(),
    fromDate.getSeconds(),
    fromDate.getMilliseconds(),
  );
  return date;
}

Setter$1.ValueSetter =
  Setter$1.Setter =
  Setter$1.DateToSystemTimezoneSetter =
    void 0;
var _index$1N = transpose$1;
var _index2$y = constructFrom$1;

const TIMEZONE_UNIT_PRIORITY = 10;

class Setter {
  subPriority = 0;

  validate(_utcDate, _options) {
    return true;
  }
}
Setter$1.Setter = Setter;

class ValueSetter extends Setter {
  constructor(
    value,

    validateValue,

    setValue,

    priority,
    subPriority,
  ) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }

  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }

  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}
Setter$1.ValueSetter = ValueSetter;

class DateToSystemTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;
  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return (0, _index2$y.constructFrom)(date, (0, _index$1N.transpose)(date, Date));
  }
}
Setter$1.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;

Parser$1.Parser = void 0;
var _Setter = Setter$1;

class Parser {
  run(dateString, token, match, options) {
    const result = this.parse(dateString, token, match, options);
    if (!result) {
      return null;
    }

    return {
      setter: new _Setter.ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority,
      ),
      rest: result.rest,
    };
  }

  validate(_utcDate, _value, _options) {
    return true;
  }
}
Parser$1.Parser = Parser;

EraParser$1.EraParser = void 0;

var _Parser$u = Parser$1;

class EraParser extends _Parser$u.Parser {
  priority = 140;

  parse(dateString, token, match) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return (
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );

      // A, B
      case "GGGGG":
        return match.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return (
          match.era(dateString, { width: "wide" }) ||
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );
    }
  }

  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["R", "u", "t", "T"];
}
EraParser$1.EraParser = EraParser;

var YearParser$1 = {};

var utils = {};

var constants = {};

constants.timezonePatterns = constants.numericPatterns = void 0;
(constants.numericPatterns = {
  month: /^(1[0-2]|0?\d)/, // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/, // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/, // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/, // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/, // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/, // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/, // 0 to 12
  minute: /^[0-5]?\d/, // 0 to 59
  second: /^[0-5]?\d/, // 0 to 59

  singleDigit: /^\d/, // 0 to 9
  twoDigits: /^\d{1,2}/, // 0 to 99
  threeDigits: /^\d{1,3}/, // 0 to 999
  fourDigits: /^\d{1,4}/, // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/, // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/, // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/, // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/, // 0 to 9999, -0 to -9999
});

(constants.timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/,
});

utils.dayPeriodEnumToHours = dayPeriodEnumToHours;
utils.isLeapYearIndex = isLeapYearIndex$1;
utils.mapValue = mapValue;
utils.normalizeTwoDigitYear = normalizeTwoDigitYear;
utils.parseAnyDigitsSigned = parseAnyDigitsSigned;
utils.parseNDigits = parseNDigits;
utils.parseNDigitsSigned = parseNDigitsSigned;
utils.parseNumericPattern = parseNumericPattern;
utils.parseTimezonePattern = parseTimezonePattern;
var _index$1M = constants$1;

var _constants$e = constants;

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest,
  };
}

function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1),
    };
  }

  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

  return {
    value:
      sign *
      (hours * _index$1M.millisecondsInHour +
        minutes * _index$1M.millisecondsInMinute +
        seconds * _index$1M.millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(
    _constants$e.numericPatterns.anyDigitsSigned,
    dateString,
  );
}

function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants$e.numericPatterns.singleDigit,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants$e.numericPatterns.twoDigits,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants$e.numericPatterns.threeDigits,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants$e.numericPatterns.fourDigits,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}

function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants$e.numericPatterns.singleDigitSigned,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants$e.numericPatterns.twoDigitsSigned,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants$e.numericPatterns.threeDigitsSigned,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants$e.numericPatterns.fourDigitsSigned,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}

function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

function isLeapYearIndex$1(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

YearParser$1.YearParser = void 0;
var _Parser$t = Parser$1;

var _utils$s = utils;

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
class YearParser extends _Parser$t.Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy",
    });

    switch (token) {
      case "y":
        return (0, _utils$s.mapValue)(
          (0, _utils$s.parseNDigits)(4, dateString),
          valueCallback,
        );
      case "yo":
        return (0, _utils$s.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return (0, _utils$s.mapValue)(
          (0, _utils$s.parseNDigits)(token.length, dateString),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value) {
    const currentYear = date.getFullYear();

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = (0, _utils$s.normalizeTwoDigitYear)(
        value.year,
        currentYear,
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
YearParser$1.YearParser = YearParser;

var LocalWeekYearParser$1 = {};

LocalWeekYearParser$1.LocalWeekYearParser = void 0;
var _index$1L = getWeekYear$1;

var _index2$x = startOfWeek$1;
var _Parser$s = Parser$1;

var _utils$r = utils;

// Local week-numbering year
class LocalWeekYearParser extends _Parser$s.Parser {
  priority = 130;

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY",
    });

    switch (token) {
      case "Y":
        return (0, _utils$r.mapValue)(
          (0, _utils$r.parseNDigits)(4, dateString),
          valueCallback,
        );
      case "Yo":
        return (0, _utils$r.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return (0, _utils$r.mapValue)(
          (0, _utils$r.parseNDigits)(token.length, dateString),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value, options) {
    const currentYear = (0, _index$1L.getWeekYear)(date, options);

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = (0, _utils$r.normalizeTwoDigitYear)(
        value.year,
        currentYear,
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate,
      );
      date.setHours(0, 0, 0, 0);
      return (0, _index2$x.startOfWeek)(date, options);
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return (0, _index2$x.startOfWeek)(date, options);
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}
LocalWeekYearParser$1.LocalWeekYearParser = LocalWeekYearParser;

var ISOWeekYearParser$1 = {};

ISOWeekYearParser$1.ISOWeekYearParser = void 0;
var _index$1K = startOfISOWeek$1;
var _index2$w = constructFrom$1;
var _Parser$r = Parser$1;

var _utils$q = utils;

// ISO week-numbering year
class ISOWeekYearParser extends _Parser$r.Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "R") {
      return (0, _utils$q.parseNDigitsSigned)(4, dateString);
    }

    return (0, _utils$q.parseNDigitsSigned)(token.length, dateString);
  }

  set(date, _flags, value) {
    const firstWeekOfYear = (0, _index2$w.constructFrom)(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return (0, _index$1K.startOfISOWeek)(firstWeekOfYear);
  }

  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}
ISOWeekYearParser$1.ISOWeekYearParser = ISOWeekYearParser;

var ExtendedYearParser$1 = {};

ExtendedYearParser$1.ExtendedYearParser = void 0;
var _Parser$q = Parser$1;

var _utils$p = utils;

class ExtendedYearParser extends _Parser$q.Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "u") {
      return (0, _utils$p.parseNDigitsSigned)(4, dateString);
    }

    return (0, _utils$p.parseNDigitsSigned)(token.length, dateString);
  }

  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}
ExtendedYearParser$1.ExtendedYearParser = ExtendedYearParser;

var QuarterParser$1 = {};

QuarterParser$1.QuarterParser = void 0;
var _Parser$p = Parser$1;

var _utils$o = utils;

class QuarterParser extends _Parser$p.Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ": // 01, 02, 03, 04
        return (0, _utils$o.parseNDigits)(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match.quarter(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
QuarterParser$1.QuarterParser = QuarterParser;

var StandAloneQuarterParser$1 = {};

StandAloneQuarterParser$1.StandAloneQuarterParser = void 0;
var _Parser$o = Parser$1;

var _utils$n = utils;

class StandAloneQuarterParser extends _Parser$o.Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq": // 01, 02, 03, 04
        return (0, _utils$n.parseNDigits)(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
StandAloneQuarterParser$1.StandAloneQuarterParser = StandAloneQuarterParser;

var MonthParser$1 = {};

MonthParser$1.MonthParser = void 0;
var _constants$d = constants;
var _Parser$n = Parser$1;

var _utils$m = utils;

class MonthParser extends _Parser$n.Parser {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];

  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return (0, _utils$m.mapValue)(
          (0, _utils$m.parseNumericPattern)(
            _constants$d.numericPatterns.month,
            dateString,
          ),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "MM":
        return (0, _utils$m.mapValue)(
          (0, _utils$m.parseNDigits)(2, dateString),
          valueCallback,
        );
      // 1st, 2nd, ..., 12th
      case "Mo":
        return (0, _utils$m.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );

      // J, F, ..., D
      case "MMMMM":
        return match.month(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return (
          match.month(dateString, { width: "wide", context: "formatting" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
MonthParser$1.MonthParser = MonthParser;

var StandAloneMonthParser$1 = {};

StandAloneMonthParser$1.StandAloneMonthParser = void 0;
var _constants$c = constants;
var _Parser$m = Parser$1;

var _utils$l = utils;

class StandAloneMonthParser extends _Parser$m.Parser {
  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return (0, _utils$l.mapValue)(
          (0, _utils$l.parseNumericPattern)(
            _constants$c.numericPatterns.month,
            dateString,
          ),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "LL":
        return (0, _utils$l.mapValue)(
          (0, _utils$l.parseNDigits)(2, dateString),
          valueCallback,
        );
      // 1st, 2nd, ..., 12th
      case "Lo":
        return (0, _utils$l.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );

      // J, F, ..., D
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return (
          match.month(dateString, { width: "wide", context: "standalone" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
StandAloneMonthParser$1.StandAloneMonthParser = StandAloneMonthParser;

var LocalWeekParser$1 = {};

var setWeek$1 = {};

setWeek$1.setWeek = setWeek;
var _index$1J = getWeek$1;
var _index2$v = toDate$1;

/**
 * The {@link setWeek} function options.
 */

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(date, week, options) {
  const _date = (0, _index2$v.toDate)(date);
  const diff = (0, _index$1J.getWeek)(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

LocalWeekParser$1.LocalWeekParser = void 0;
var _index$1I = setWeek$1;
var _index2$u = startOfWeek$1;
var _constants$b = constants;
var _Parser$l = Parser$1;

var _utils$k = utils;

// Local week of year
class LocalWeekParser extends _Parser$l.Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "w":
        return (0, _utils$k.parseNumericPattern)(
          _constants$b.numericPatterns.week,
          dateString,
        );
      case "wo":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return (0, _utils$k.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value, options) {
    return (0, _index2$u.startOfWeek)(
      (0, _index$1I.setWeek)(date, value, options),
      options,
    );
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}
LocalWeekParser$1.LocalWeekParser = LocalWeekParser;

var ISOWeekParser$1 = {};

var setISOWeek$1 = {};

setISOWeek$1.setISOWeek = setISOWeek;
var _index$1H = getISOWeek$1;
var _index2$t = toDate$1;

/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
function setISOWeek(date, week) {
  const _date = (0, _index2$t.toDate)(date);
  const diff = (0, _index$1H.getISOWeek)(_date) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

ISOWeekParser$1.ISOWeekParser = void 0;
var _index$1G = setISOWeek$1;
var _index2$s = startOfISOWeek$1;
var _constants$a = constants;
var _Parser$k = Parser$1;

var _utils$j = utils;

// ISO week of year
class ISOWeekParser extends _Parser$k.Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "I":
        return (0, _utils$j.parseNumericPattern)(
          _constants$a.numericPatterns.week,
          dateString,
        );
      case "Io":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return (0, _utils$j.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value) {
    return (0, _index2$s.startOfISOWeek)((0, _index$1G.setISOWeek)(date, value));
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}
ISOWeekParser$1.ISOWeekParser = ISOWeekParser;

var DateParser$1 = {};

DateParser$1.DateParser = void 0;
var _constants$9 = constants;
var _Parser$j = Parser$1;

var _utils$i = utils;

const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
  31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
];

// Day of the month
class DateParser extends _Parser$j.Parser {
  priority = 90;
  subPriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "d":
        return (0, _utils$i.parseNumericPattern)(
          _constants$9.numericPatterns.date,
          dateString,
        );
      case "do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return (0, _utils$i.parseNDigits)(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = (0, _utils$i.isLeapYearIndex)(year);
    const month = date.getMonth();
    if (isLeapYear) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }

  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
DateParser$1.DateParser = DateParser;

var DayOfYearParser$1 = {};

DayOfYearParser$1.DayOfYearParser = void 0;
var _constants$8 = constants;
var _Parser$i = Parser$1;

var _utils$h = utils;

class DayOfYearParser extends _Parser$i.Parser {
  priority = 90;

  subpriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "D":
      case "DD":
        return (0, _utils$h.parseNumericPattern)(
          _constants$8.numericPatterns.dayOfYear,
          dateString,
        );
      case "Do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return (0, _utils$h.parseNDigits)(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = (0, _utils$h.isLeapYearIndex)(year);
    if (isLeapYear) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }

  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
DayOfYearParser$1.DayOfYearParser = DayOfYearParser;

var DayParser$1 = {};

var setDay$1 = {};

setDay$1.setDay = setDay;
var _index$1F = addDays$1;
var _index2$r = toDate$1;

var _index3$a = defaultOptions$1;

/**
 * The {@link setDay} function options.
 */

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(date, day, options) {
  const defaultOptions = (0, _index3$a.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index2$r.toDate)(date);
  const currentDay = _date.getDay();

  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;

  const delta = 7 - weekStartsOn;
  const diff =
    day < 0 || day > 6
      ? day - ((currentDay + delta) % 7)
      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
  return (0, _index$1F.addDays)(_date, diff);
}

DayParser$1.DayParser = void 0;
var _index$1E = setDay$1;
var _Parser$h = Parser$1;

// Day of week
class DayParser extends _Parser$h.Parser {
  priority = 90;

  parse(dateString, token, match) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "EEEEE":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "EEEE":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index$1E.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}
DayParser$1.DayParser = DayParser;

var LocalDayParser$1 = {};

LocalDayParser$1.LocalDayParser = void 0;
var _index$1D = setDay$1;
var _Parser$g = Parser$1;

var _utils$g = utils;

// Local day of week
class LocalDayParser extends _Parser$g.Parser {
  priority = 90;
  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "e":
      case "ee": // 03
        return (0, _utils$g.mapValue)(
          (0, _utils$g.parseNDigits)(token.length, dateString),
          valueCallback,
        );
      // 3rd
      case "eo":
        return (0, _utils$g.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "eee":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "eeeee":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "eeee":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index$1D.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T",
  ];
}
LocalDayParser$1.LocalDayParser = LocalDayParser;

var StandAloneLocalDayParser$1 = {};

StandAloneLocalDayParser$1.StandAloneLocalDayParser = void 0;
var _index$1C = setDay$1;
var _Parser$f = Parser$1;

var _utils$f = utils;

// Stand-alone local day of week
class StandAloneLocalDayParser extends _Parser$f.Parser {
  priority = 90;

  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "c":
      case "cc": // 03
        return (0, _utils$f.mapValue)(
          (0, _utils$f.parseNDigits)(token.length, dateString),
          valueCallback,
        );
      // 3rd
      case "co":
        return (0, _utils$f.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "ccc":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // T
      case "ccccc":
        return match.day(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return (
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // Tuesday
      case "cccc":
      default:
        return (
          match.day(dateString, { width: "wide", context: "standalone" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = (0, _index$1C.setDay)(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T",
  ];
}
StandAloneLocalDayParser$1.StandAloneLocalDayParser = StandAloneLocalDayParser;

var ISODayParser$1 = {};

var setISODay$1 = {};

setISODay$1.setISODay = setISODay;
var _index$1B = addDays$1;
var _index2$q = getISODay$1;
var _index3$9 = toDate$1;

/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
function setISODay(date, day) {
  const _date = (0, _index3$9.toDate)(date);
  const currentDay = (0, _index2$q.getISODay)(_date);
  const diff = day - currentDay;
  return (0, _index$1B.addDays)(_date, diff);
}

ISODayParser$1.ISODayParser = void 0;
var _index$1A = setISODay$1;
var _Parser$e = Parser$1;

var _utils$e = utils;

// ISO day of week
class ISODayParser extends _Parser$e.Parser {
  priority = 90;

  parse(dateString, token, match) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };

    switch (token) {
      // 2
      case "i":
      case "ii": // 02
        return (0, _utils$e.parseNDigits)(token.length, dateString);
      // 2nd
      case "io":
        return match.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return (0, _utils$e.mapValue)(
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // T
      case "iiiii":
        return (0, _utils$e.mapValue)(
          match.day(dateString, {
            width: "narrow",
            context: "formatting",
          }),
          valueCallback,
        );
      // Tu
      case "iiiiii":
        return (0, _utils$e.mapValue)(
          match.day(dateString, {
            width: "short",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // Tuesday
      case "iiii":
      default:
        return (0, _utils$e.mapValue)(
          match.day(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 7;
  }

  set(date, _flags, value) {
    date = (0, _index$1A.setISODay)(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T",
  ];
}
ISODayParser$1.ISODayParser = ISODayParser;

var AMPMParser$1 = {};

AMPMParser$1.AMPMParser = void 0;
var _Parser$d = Parser$1;

var _utils$d = utils;

class AMPMParser extends _Parser$d.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "aaaaa":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils$d.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}
AMPMParser$1.AMPMParser = AMPMParser;

var AMPMMidnightParser$1 = {};

AMPMMidnightParser$1.AMPMMidnightParser = void 0;
var _Parser$c = Parser$1;

var _utils$c = utils;

class AMPMMidnightParser extends _Parser$c.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "bbbbb":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils$c.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}
AMPMMidnightParser$1.AMPMMidnightParser = AMPMMidnightParser;

var DayPeriodParser$1 = {};

DayPeriodParser$1.DayPeriodParser = void 0;
var _Parser$b = Parser$1;

var _utils$b = utils;

// in the morning, in the afternoon, in the evening, at night
class DayPeriodParser extends _Parser$b.Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "BBBBB":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours((0, _utils$b.dayPeriodEnumToHours)(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "t", "T"];
}
DayPeriodParser$1.DayPeriodParser = DayPeriodParser;

var Hour1to12Parser$1 = {};

Hour1to12Parser$1.Hour1to12Parser = void 0;
var _constants$7 = constants;
var _Parser$a = Parser$1;

var _utils$a = utils;

class Hour1to12Parser extends _Parser$a.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "h":
        return (0, _utils$a.parseNumericPattern)(
          _constants$7.numericPatterns.hour12h,
          dateString,
        );
      case "ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils$a.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 12;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["H", "K", "k", "t", "T"];
}
Hour1to12Parser$1.Hour1to12Parser = Hour1to12Parser;

var Hour0to23Parser$1 = {};

Hour0to23Parser$1.Hour0to23Parser = void 0;
var _constants$6 = constants;
var _Parser$9 = Parser$1;

var _utils$9 = utils;

class Hour0to23Parser extends _Parser$9.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "H":
        return (0, _utils$9.parseNumericPattern)(
          _constants$6.numericPatterns.hour23h,
          dateString,
        );
      case "Ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils$9.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 23;
  }

  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}
Hour0to23Parser$1.Hour0to23Parser = Hour0to23Parser;

var Hour0To11Parser$1 = {};

Hour0To11Parser$1.Hour0To11Parser = void 0;
var _constants$5 = constants;
var _Parser$8 = Parser$1;

var _utils$8 = utils;

class Hour0To11Parser extends _Parser$8.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "K":
        return (0, _utils$8.parseNumericPattern)(
          _constants$5.numericPatterns.hour11h,
          dateString,
        );
      case "Ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils$8.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["h", "H", "k", "t", "T"];
}
Hour0To11Parser$1.Hour0To11Parser = Hour0To11Parser;

var Hour1To24Parser$1 = {};

Hour1To24Parser$1.Hour1To24Parser = void 0;
var _constants$4 = constants;
var _Parser$7 = Parser$1;

var _utils$7 = utils;

class Hour1To24Parser extends _Parser$7.Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "k":
        return (0, _utils$7.parseNumericPattern)(
          _constants$4.numericPatterns.hour24h,
          dateString,
        );
      case "ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return (0, _utils$7.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 24;
  }

  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}
Hour1To24Parser$1.Hour1To24Parser = Hour1To24Parser;

var MinuteParser$1 = {};

MinuteParser$1.MinuteParser = void 0;
var _constants$3 = constants;
var _Parser$6 = Parser$1;

var _utils$6 = utils;

class MinuteParser extends _Parser$6.Parser {
  priority = 60;

  parse(dateString, token, match) {
    switch (token) {
      case "m":
        return (0, _utils$6.parseNumericPattern)(
          _constants$3.numericPatterns.minute,
          dateString,
        );
      case "mo":
        return match.ordinalNumber(dateString, { unit: "minute" });
      default:
        return (0, _utils$6.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
MinuteParser$1.MinuteParser = MinuteParser;

var SecondParser$1 = {};

SecondParser$1.SecondParser = void 0;
var _constants$2 = constants;
var _Parser$5 = Parser$1;

var _utils$5 = utils;

class SecondParser extends _Parser$5.Parser {
  priority = 50;

  parse(dateString, token, match) {
    switch (token) {
      case "s":
        return (0, _utils$5.parseNumericPattern)(
          _constants$2.numericPatterns.second,
          dateString,
        );
      case "so":
        return match.ordinalNumber(dateString, { unit: "second" });
      default:
        return (0, _utils$5.parseNDigits)(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
SecondParser$1.SecondParser = SecondParser;

var FractionOfSecondParser$1 = {};

FractionOfSecondParser$1.FractionOfSecondParser = void 0;
var _Parser$4 = Parser$1;

var _utils$4 = utils;

class FractionOfSecondParser extends _Parser$4.Parser {
  priority = 30;

  parse(dateString, token) {
    const valueCallback = (value) =>
      Math.trunc(value * Math.pow(10, -token.length + 3));
    return (0, _utils$4.mapValue)(
      (0, _utils$4.parseNDigits)(token.length, dateString),
      valueCallback,
    );
  }

  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}
FractionOfSecondParser$1.FractionOfSecondParser = FractionOfSecondParser;

var ISOTimezoneWithZParser$1 = {};

ISOTimezoneWithZParser$1.ISOTimezoneWithZParser = void 0;
var _index$1z = constructFrom$1;
var _index2$p = getTimezoneOffsetInMilliseconds$1;
var _constants$1 = constants;
var _Parser$3 = Parser$1;

var _utils$3 = utils;

// Timezone (ISO-8601. +00:00 is `'Z'`)
class ISOTimezoneWithZParser extends _Parser$3.Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "X":
        return (0, _utils$3.parseTimezonePattern)(
          _constants$1.timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "XX":
        return (0, _utils$3.parseTimezonePattern)(
          _constants$1.timezonePatterns.basic,
          dateString,
        );
      case "XXXX":
        return (0, _utils$3.parseTimezonePattern)(
          _constants$1.timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "XXXXX":
        return (0, _utils$3.parseTimezonePattern)(
          _constants$1.timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "XXX":
      default:
        return (0, _utils$3.parseTimezonePattern)(
          _constants$1.timezonePatterns.extended,
          dateString,
        );
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return (0, _index$1z.constructFrom)(
      date,
      date.getTime() -
        (0, _index2$p.getTimezoneOffsetInMilliseconds)(date) -
        value,
    );
  }

  incompatibleTokens = ["t", "T", "x"];
}
ISOTimezoneWithZParser$1.ISOTimezoneWithZParser = ISOTimezoneWithZParser;

var ISOTimezoneParser$1 = {};

ISOTimezoneParser$1.ISOTimezoneParser = void 0;
var _index$1y = constructFrom$1;
var _index2$o = getTimezoneOffsetInMilliseconds$1;
var _constants = constants;
var _Parser$2 = Parser$1;

var _utils$2 = utils;

// Timezone (ISO-8601)
class ISOTimezoneParser extends _Parser$2.Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "x":
        return (0, _utils$2.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "xx":
        return (0, _utils$2.parseTimezonePattern)(
          _constants.timezonePatterns.basic,
          dateString,
        );
      case "xxxx":
        return (0, _utils$2.parseTimezonePattern)(
          _constants.timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "xxxxx":
        return (0, _utils$2.parseTimezonePattern)(
          _constants.timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "xxx":
      default:
        return (0, _utils$2.parseTimezonePattern)(
          _constants.timezonePatterns.extended,
          dateString,
        );
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return (0, _index$1y.constructFrom)(
      date,
      date.getTime() -
        (0, _index2$o.getTimezoneOffsetInMilliseconds)(date) -
        value,
    );
  }

  incompatibleTokens = ["t", "T", "X"];
}
ISOTimezoneParser$1.ISOTimezoneParser = ISOTimezoneParser;

var TimestampSecondsParser$1 = {};

TimestampSecondsParser$1.TimestampSecondsParser = void 0;
var _index$1x = constructFrom$1;
var _Parser$1 = Parser$1;

var _utils$1 = utils;

class TimestampSecondsParser extends _Parser$1.Parser {
  priority = 40;

  parse(dateString) {
    return (0, _utils$1.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [
      (0, _index$1x.constructFrom)(date, value * 1000),
      { timestampIsSet: true },
    ];
  }

  incompatibleTokens = "*";
}
TimestampSecondsParser$1.TimestampSecondsParser = TimestampSecondsParser;

var TimestampMillisecondsParser$1 = {};

TimestampMillisecondsParser$1.TimestampMillisecondsParser = void 0;
var _index$1w = constructFrom$1;
var _Parser = Parser$1;

var _utils = utils;

class TimestampMillisecondsParser extends _Parser.Parser {
  priority = 20;

  parse(dateString) {
    return (0, _utils.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [(0, _index$1w.constructFrom)(date, value), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}
TimestampMillisecondsParser$1.TimestampMillisecondsParser = TimestampMillisecondsParser;

parsers.parsers = void 0;
var _EraParser = EraParser$1;
var _YearParser = YearParser$1;
var _LocalWeekYearParser = LocalWeekYearParser$1;
var _ISOWeekYearParser = ISOWeekYearParser$1;
var _ExtendedYearParser = ExtendedYearParser$1;
var _QuarterParser = QuarterParser$1;
var _StandAloneQuarterParser = StandAloneQuarterParser$1;
var _MonthParser = MonthParser$1;
var _StandAloneMonthParser = StandAloneMonthParser$1;
var _LocalWeekParser = LocalWeekParser$1;
var _ISOWeekParser = ISOWeekParser$1;
var _DateParser = DateParser$1;
var _DayOfYearParser = DayOfYearParser$1;
var _DayParser = DayParser$1;
var _LocalDayParser = LocalDayParser$1;
var _StandAloneLocalDayParser = StandAloneLocalDayParser$1;
var _ISODayParser = ISODayParser$1;
var _AMPMParser = AMPMParser$1;
var _AMPMMidnightParser = AMPMMidnightParser$1;
var _DayPeriodParser = DayPeriodParser$1;
var _Hour1to12Parser = Hour1to12Parser$1;
var _Hour0to23Parser = Hour0to23Parser$1;
var _Hour0To11Parser = Hour0To11Parser$1;
var _Hour1To24Parser = Hour1To24Parser$1;
var _MinuteParser = MinuteParser$1;
var _SecondParser = SecondParser$1;
var _FractionOfSecondParser = FractionOfSecondParser$1;
var _ISOTimezoneWithZParser = ISOTimezoneWithZParser$1;
var _ISOTimezoneParser = ISOTimezoneParser$1;
var _TimestampSecondsParser = TimestampSecondsParser$1;
var _TimestampMillisecondsParser = TimestampMillisecondsParser$1;

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any -- It's ok, we want any here
(parsers.parsers = {
  G: new _EraParser.EraParser(),
  y: new _YearParser.YearParser(),
  Y: new _LocalWeekYearParser.LocalWeekYearParser(),
  R: new _ISOWeekYearParser.ISOWeekYearParser(),
  u: new _ExtendedYearParser.ExtendedYearParser(),
  Q: new _QuarterParser.QuarterParser(),
  q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
  M: new _MonthParser.MonthParser(),
  L: new _StandAloneMonthParser.StandAloneMonthParser(),
  w: new _LocalWeekParser.LocalWeekParser(),
  I: new _ISOWeekParser.ISOWeekParser(),
  d: new _DateParser.DateParser(),
  D: new _DayOfYearParser.DayOfYearParser(),
  E: new _DayParser.DayParser(),
  e: new _LocalDayParser.LocalDayParser(),
  c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
  i: new _ISODayParser.ISODayParser(),
  a: new _AMPMParser.AMPMParser(),
  b: new _AMPMMidnightParser.AMPMMidnightParser(),
  B: new _DayPeriodParser.DayPeriodParser(),
  h: new _Hour1to12Parser.Hour1to12Parser(),
  H: new _Hour0to23Parser.Hour0to23Parser(),
  K: new _Hour0To11Parser.Hour0To11Parser(),
  k: new _Hour1To24Parser.Hour1To24Parser(),
  m: new _MinuteParser.MinuteParser(),
  s: new _SecondParser.SecondParser(),
  S: new _FractionOfSecondParser.FractionOfSecondParser(),
  X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
  x: new _ISOTimezoneParser.ISOTimezoneParser(),
  t: new _TimestampSecondsParser.TimestampSecondsParser(),
  T: new _TimestampMillisecondsParser.TimestampMillisecondsParser(),
});

(function (exports) {
Object.defineProperty(exports, "longFormatters", {
  enumerable: true,
  get: function () {
    return _index5.longFormatters;
  },
});
exports.parse = parse;
Object.defineProperty(exports, "parsers", {
  enumerable: true,
  get: function () {
    return _index7.parsers;
  },
});
var _index = constructFrom$1;
var _index2 = getDefaultOptions$1;
var _index3 = defaultLocale;
var _index4 = toDate$1;

var _index5 = longFormatters;
var _index6 = protectedTokens;

var _index7 = parsers;

var _Setter = Setter$1;

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

/**
 * The {@link parse} function options.
 */

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;

const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The string to parse
 * @param formatStr - The string of tokens
 * @param referenceDate - defines values missing from the parsed dateString
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns The parsed date
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dateStr, formatStr, referenceDate, options) {
  const defaultOptions = (0, _index2.getDefaultOptions)();
  const locale =
    options?.locale ?? defaultOptions.locale ?? _index3.defaultLocale;

  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  if (formatStr === "") {
    if (dateStr === "") {
      return (0, _index4.toDate)(referenceDate);
    } else {
      return (0, _index.constructFrom)(referenceDate, NaN);
    }
  }

  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  // If timezone isn't specified, it will be set to the system timezone
  const setters = [new _Setter.DateToSystemTimezoneSetter()];

  const tokens = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter in _index5.longFormatters) {
        const longFormatter = _index5.longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp);

  const usedTokens = [];

  for (let token of tokens) {
    if (
      !options?.useAdditionalWeekYearTokens &&
      (0, _index6.isProtectedWeekYearToken)(token)
    ) {
      (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
    }
    if (
      !options?.useAdditionalDayOfYearTokens &&
      (0, _index6.isProtectedDayOfYearToken)(token)
    ) {
      (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
    }

    const firstCharacter = token[0];
    const parser = _index7.parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) =>
            incompatibleTokens.includes(usedToken.token) ||
            usedToken.token === firstCharacter,
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`,
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`,
        );
      }

      usedTokens.push({ token: firstCharacter, fullToken: token });

      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions,
      );

      if (!parseResult) {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }

      setters.push(parseResult.setter);

      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      // Replace two single quote characters with one single quote character
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }

      // Cut token from string, or, if string doesn't match the token, return Invalid Date
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return (0, _index.constructFrom)(referenceDate, NaN);
      }
    }
  }

  // Check if the remaining input contains something other than whitespace
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return (0, _index.constructFrom)(referenceDate, NaN);
  }

  const uniquePrioritySetters = setters
    .map((setter) => setter.priority)
    .sort((a, b) => b - a)
    .filter((priority, index, array) => array.indexOf(priority) === index)
    .map((priority) =>
      setters
        .filter((setter) => setter.priority === priority)
        .sort((a, b) => b.subPriority - a.subPriority),
    )
    .map((setterArray) => setterArray[0]);

  let date = (0, _index4.toDate)(referenceDate);

  if (isNaN(date.getTime())) {
    return (0, _index.constructFrom)(referenceDate, NaN);
  }

  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return (0, _index.constructFrom)(referenceDate, NaN);
    }

    const result = setter.set(date, flags, subFnOptions);
    // Result is tuple (date, flags)
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
      // Result is date
    } else {
      date = result;
    }
  }

  return (0, _index.constructFrom)(referenceDate, date);
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
}(parse));

isMatch$1.isMatch = isMatch;
var _index$1v = isValid$1;
var _index2$n = parse;

/**
 * The {@link isMatch} function options.
 */

/**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The date string to verify
 * @param format - The string of tokens
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns Is format string a match for date string?
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */
function isMatch(dateStr, formatStr, options) {
  return (0, _index$1v.isValid)(
    (0, _index2$n.parse)(dateStr, formatStr, new Date(), options),
  );
}

var isMonday$1 = {};

isMonday$1.isMonday = isMonday;
var _index$1u = toDate$1;

/**
 * @name isMonday
 * @category Weekday Helpers
 * @summary Is the given date Monday?
 *
 * @description
 * Is the given date Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Monday
 *
 * @example
 * // Is 22 September 2014 Monday?
 * const result = isMonday(new Date(2014, 8, 22))
 * //=> true
 */
function isMonday(date) {
  return (0, _index$1u.toDate)(date).getDay() === 1;
}

var isPast$1 = {};

isPast$1.isPast = isPast;
var _index$1t = toDate$1;

/**
 * @name isPast
 * @category Common Helpers
 * @summary Is the given date in the past?
 * @pure false
 *
 * @description
 * Is the given date in the past?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the past
 *
 * @example
 * // If today is 6 October 2014, is 2 July 2014 in the past?
 * const result = isPast(new Date(2014, 6, 2))
 * //=> true
 */
function isPast(date) {
  return +(0, _index$1t.toDate)(date) < Date.now();
}

var isSameHour$1 = {};

var startOfHour$1 = {};

startOfHour$1.startOfHour = startOfHour;
var _index$1s = toDate$1;

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
function startOfHour(date) {
  const _date = (0, _index$1s.toDate)(date);
  _date.setMinutes(0, 0, 0);
  return _date;
}

isSameHour$1.isSameHour = isSameHour;
var _index$1r = startOfHour$1;

/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same hour (and same day)
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */
function isSameHour(dateLeft, dateRight) {
  const dateLeftStartOfHour = (0, _index$1r.startOfHour)(dateLeft);
  const dateRightStartOfHour = (0, _index$1r.startOfHour)(dateRight);

  return +dateLeftStartOfHour === +dateRightStartOfHour;
}

var isSameISOWeek$1 = {};

isSameISOWeek$1.isSameISOWeek = isSameISOWeek;
var _index$1q = isSameWeek$1;

/**
 * @name isSameISOWeek
 * @category ISO Week Helpers
 * @summary Are the given dates in the same ISO week (and year)?
 *
 * @description
 * Are the given dates in the same ISO week (and year)?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week (and year)
 *
 * @example
 * // Are 1 September 2014 and 7 September 2014 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2014, 8, 7))
 * //=> true
 *
 * @example
 * // Are 1 September 2014 and 1 September 2015 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))
 * //=> false
 */
function isSameISOWeek(dateLeft, dateRight) {
  return (0, _index$1q.isSameWeek)(dateLeft, dateRight, { weekStartsOn: 1 });
}

var isSameISOWeekYear$1 = {};

isSameISOWeekYear$1.isSameISOWeekYear = isSameISOWeekYear;
var _index$1p = startOfISOWeekYear$1;

/**
 * @name isSameISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Are the given dates in the same ISO week-numbering year?
 *
 * @description
 * Are the given dates in the same ISO week-numbering year?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week-numbering year
 *
 * @example
 * // Are 29 December 2003 and 2 January 2005 in the same ISO week-numbering year?
 * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))
 * //=> true
 */
function isSameISOWeekYear(dateLeft, dateRight) {
  const dateLeftStartOfYear = (0, _index$1p.startOfISOWeekYear)(dateLeft);
  const dateRightStartOfYear = (0, _index$1p.startOfISOWeekYear)(dateRight);

  return +dateLeftStartOfYear === +dateRightStartOfYear;
}

var isSameMinute$1 = {};

isSameMinute$1.isSameMinute = isSameMinute;
var _index$1o = startOfMinute$1;

/**
 * @name isSameMinute
 * @category Minute Helpers
 * @summary Are the given dates in the same minute (and hour and day)?
 *
 * @description
 * Are the given dates in the same minute (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same minute (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 4, 6, 30, 15)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 5, 6, 30)
 * )
 * //=> false
 */
function isSameMinute(dateLeft, dateRight) {
  const dateLeftStartOfMinute = (0, _index$1o.startOfMinute)(dateLeft);
  const dateRightStartOfMinute = (0, _index$1o.startOfMinute)(dateRight);

  return +dateLeftStartOfMinute === +dateRightStartOfMinute;
}

var isSameMonth$1 = {};

isSameMonth$1.isSameMonth = isSameMonth;
var _index$1n = toDate$1;

/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same month (and year)
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */
function isSameMonth(dateLeft, dateRight) {
  const _dateLeft = (0, _index$1n.toDate)(dateLeft);
  const _dateRight = (0, _index$1n.toDate)(dateRight);
  return (
    _dateLeft.getFullYear() === _dateRight.getFullYear() &&
    _dateLeft.getMonth() === _dateRight.getMonth()
  );
}

var isSameQuarter$1 = {};

isSameQuarter$1.isSameQuarter = isSameQuarter;
var _index$1m = startOfQuarter$1;

/**
 * @name isSameQuarter
 * @category Quarter Helpers
 * @summary Are the given dates in the same quarter (and year)?
 *
 * @description
 * Are the given dates in the same quarter (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same quarter (and year)
 *
 * @example
 * // Are 1 January 2014 and 8 March 2014 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
 * //=> true
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameQuarter(dateLeft, dateRight) {
  const dateLeftStartOfQuarter = (0, _index$1m.startOfQuarter)(dateLeft);
  const dateRightStartOfQuarter = (0, _index$1m.startOfQuarter)(dateRight);

  return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
}

var isSameSecond$1 = {};

var startOfSecond$1 = {};

startOfSecond$1.startOfSecond = startOfSecond;
var _index$1l = toDate$1;

/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
function startOfSecond(date) {
  const _date = (0, _index$1l.toDate)(date);
  _date.setMilliseconds(0);
  return _date;
}

isSameSecond$1.isSameSecond = isSameSecond;
var _index$1k = startOfSecond$1;

/**
 * @name isSameSecond
 * @category Second Helpers
 * @summary Are the given dates in the same second (and hour and day)?
 *
 * @description
 * Are the given dates in the same second (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same second (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 30, 15),
 *   new Date(2014, 8, 4, 6, 30, 15, 500)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 4, 6, 1, 15)
 * )
 * //=> false
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 5, 6, 0, 15)
 * )
 * //=> false
 */
function isSameSecond(dateLeft, dateRight) {
  const dateLeftStartOfSecond = (0, _index$1k.startOfSecond)(dateLeft);
  const dateRightStartOfSecond = (0, _index$1k.startOfSecond)(dateRight);

  return +dateLeftStartOfSecond === +dateRightStartOfSecond;
}

var isSameYear$1 = {};

isSameYear$1.isSameYear = isSameYear;
var _index$1j = toDate$1;

/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same year
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */
function isSameYear(dateLeft, dateRight) {
  const _dateLeft = (0, _index$1j.toDate)(dateLeft);
  const _dateRight = (0, _index$1j.toDate)(dateRight);
  return _dateLeft.getFullYear() === _dateRight.getFullYear();
}

var isThisHour$1 = {};

isThisHour$1.isThisHour = isThisHour;
var _index$1i = constructNow$1;
var _index2$m = isSameHour$1;

/**
 * @name isThisHour
 * @category Hour Helpers
 * @summary Is the given date in the same hour as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same hour as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this hour
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:00:00 in this hour?
 * const result = isThisHour(new Date(2014, 8, 25, 18))
 * //=> true
 */
function isThisHour(date) {
  return (0, _index2$m.isSameHour)(date, (0, _index$1i.constructNow)(date));
}

var isThisISOWeek$1 = {};

isThisISOWeek$1.isThisISOWeek = isThisISOWeek;
var _index$1h = constructNow$1;
var _index2$l = isSameISOWeek$1;

/**
 * @name isThisISOWeek
 * @category ISO Week Helpers
 * @summary Is the given date in the same ISO week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same ISO week as the current date?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this ISO week
 *
 * @example
 * // If today is 25 September 2014, is 22 September 2014 in this ISO week?
 * const result = isThisISOWeek(new Date(2014, 8, 22))
 * //=> true
 */

function isThisISOWeek(date) {
  return (0, _index2$l.isSameISOWeek)(date, (0, _index$1h.constructNow)(date));
}

var isThisMinute$1 = {};

isThisMinute$1.isThisMinute = isThisMinute;
var _index$1g = constructNow$1;
var _index2$k = isSameMinute$1;

/**
 * @name isThisMinute
 * @category Minute Helpers
 * @summary Is the given date in the same minute as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same minute as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this minute
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:00 in this minute?
 * const result = isThisMinute(new Date(2014, 8, 25, 18, 30))
 * //=> true
 */

function isThisMinute(date) {
  return (0, _index2$k.isSameMinute)(date, (0, _index$1g.constructNow)(date));
}

var isThisMonth$1 = {};

isThisMonth$1.isThisMonth = isThisMonth;
var _index$1f = constructNow$1;
var _index2$j = isSameMonth$1;

/**
 * @name isThisMonth
 * @category Month Helpers
 * @summary Is the given date in the same month as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same month as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this month
 *
 * @example
 * // If today is 25 September 2014, is 15 September 2014 in this month?
 * const result = isThisMonth(new Date(2014, 8, 15))
 * //=> true
 */

function isThisMonth(date) {
  return (0, _index2$j.isSameMonth)(date, (0, _index$1f.constructNow)(date));
}

var isThisQuarter$1 = {};

isThisQuarter$1.isThisQuarter = isThisQuarter;
var _index$1e = constructNow$1;
var _index2$i = isSameQuarter$1;

/**
 * @name isThisQuarter
 * @category Quarter Helpers
 * @summary Is the given date in the same quarter as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same quarter as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this quarter
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this quarter?
 * const result = isThisQuarter(new Date(2014, 6, 2))
 * //=> true
 */
function isThisQuarter(date) {
  return (0, _index2$i.isSameQuarter)(date, (0, _index$1e.constructNow)(date));
}

var isThisSecond$1 = {};

isThisSecond$1.isThisSecond = isThisSecond;
var _index$1d = constructNow$1;
var _index2$h = isSameSecond$1;

/**
 * @name isThisSecond
 * @category Second Helpers
 * @summary Is the given date in the same second as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same second as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this second
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:15.000 in this second?
 * const result = isThisSecond(new Date(2014, 8, 25, 18, 30, 15))
 * //=> true
 */
function isThisSecond(date) {
  return (0, _index2$h.isSameSecond)(date, (0, _index$1d.constructNow)(date));
}

var isThisWeek$1 = {};

isThisWeek$1.isThisWeek = isThisWeek;
var _index$1c = constructNow$1;
var _index2$g = isSameWeek$1;

/**
 * The {@link isThisWeek} function options.
 */

/**
 * @name isThisWeek
 * @category Week Helpers
 * @summary Is the given date in the same week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same week as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param options - The object with options
 *
 * @returns The date is in this week
 *
 * @example
 * // If today is 25 September 2014, is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21))
 * //=> true
 *
 * @example
 * // If today is 25 September 2014 and week starts with Monday
 * // is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
 * //=> false
 */
function isThisWeek(date, options) {
  return (0, _index2$g.isSameWeek)(date, (0, _index$1c.constructNow)(date), options);
}

var isThisYear$1 = {};

isThisYear$1.isThisYear = isThisYear;
var _index$1b = constructNow$1;
var _index2$f = isSameYear$1;

/**
 * @name isThisYear
 * @category Year Helpers
 * @summary Is the given date in the same year as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same year as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this year
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this year?
 * const result = isThisYear(new Date(2014, 6, 2))
 * //=> true
 */
function isThisYear(date) {
  return (0, _index2$f.isSameYear)(date, (0, _index$1b.constructNow)(date));
}

var isThursday$1 = {};

isThursday$1.isThursday = isThursday;
var _index$1a = toDate$1;

/**
 * @name isThursday
 * @category Weekday Helpers
 * @summary Is the given date Thursday?
 *
 * @description
 * Is the given date Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Thursday
 *
 * @example
 * // Is 25 September 2014 Thursday?
 * const result = isThursday(new Date(2014, 8, 25))
 * //=> true
 */
function isThursday(date) {
  return (0, _index$1a.toDate)(date).getDay() === 4;
}

var isToday$1 = {};

isToday$1.isToday = isToday;
var _index$19 = constructNow$1;
var _index2$e = isSameDay$1;

/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is today
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */
function isToday(date) {
  return (0, _index2$e.isSameDay)(date, (0, _index$19.constructNow)(date));
}

var isTomorrow$1 = {};

isTomorrow$1.isTomorrow = isTomorrow;
var _index$18 = addDays$1;
var _index2$d = constructNow$1;
var _index3$8 = isSameDay$1;

/**
 * @name isTomorrow
 * @category Day Helpers
 * @summary Is the given date tomorrow?
 * @pure false
 *
 * @description
 * Is the given date tomorrow?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is tomorrow
 *
 * @example
 * // If today is 6 October 2014, is 7 October 14:00:00 tomorrow?
 * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))
 * //=> true
 */
function isTomorrow(date) {
  return (0, _index3$8.isSameDay)(
    date,
    (0, _index$18.addDays)((0, _index2$d.constructNow)(date), 1),
  );
}

var isTuesday$1 = {};

isTuesday$1.isTuesday = isTuesday;
var _index$17 = toDate$1;

/**
 * @name isTuesday
 * @category Weekday Helpers
 * @summary Is the given date Tuesday?
 *
 * @description
 * Is the given date Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Tuesday
 *
 * @example
 * // Is 23 September 2014 Tuesday?
 * const result = isTuesday(new Date(2014, 8, 23))
 * //=> true
 */
function isTuesday(date) {
  return (0, _index$17.toDate)(date).getDay() === 2;
}

var isWednesday$1 = {};

isWednesday$1.isWednesday = isWednesday;
var _index$16 = toDate$1;

/**
 * @name isWednesday
 * @category Weekday Helpers
 * @summary Is the given date Wednesday?
 *
 * @description
 * Is the given date Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Wednesday
 *
 * @example
 * // Is 24 September 2014 Wednesday?
 * const result = isWednesday(new Date(2014, 8, 24))
 * //=> true
 */
function isWednesday(date) {
  return (0, _index$16.toDate)(date).getDay() === 3;
}

var isWithinInterval$1 = {};

isWithinInterval$1.isWithinInterval = isWithinInterval;
var _index$15 = toDate$1;

/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param interval - The interval to check
 *
 * @returns The date is within the interval
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date })
 * // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end })
 * // => true
 */
function isWithinInterval(date, interval) {
  const time = +(0, _index$15.toDate)(date);
  const [startTime, endTime] = [
    +(0, _index$15.toDate)(interval.start),
    +(0, _index$15.toDate)(interval.end),
  ].sort((a, b) => a - b);

  return time >= startTime && time <= endTime;
}

var isYesterday$1 = {};

var subDays$1 = {};

subDays$1.subDays = subDays;
var _index$14 = addDays$1;

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
function subDays(date, amount) {
  return (0, _index$14.addDays)(date, -amount);
}

isYesterday$1.isYesterday = isYesterday;
var _index$13 = constructNow$1;
var _index2$c = isSameDay$1;
var _index3$7 = subDays$1;

/**
 * @name isYesterday
 * @category Day Helpers
 * @summary Is the given date yesterday?
 * @pure false
 *
 * @description
 * Is the given date yesterday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is yesterday
 *
 * @example
 * // If today is 6 October 2014, is 5 October 14:00:00 yesterday?
 * const result = isYesterday(new Date(2014, 9, 5, 14, 0))
 * //=> true
 */
function isYesterday(date) {
  return (0, _index2$c.isSameDay)(
    date,
    (0, _index3$7.subDays)((0, _index$13.constructNow)(date), 1),
  );
}

var lastDayOfDecade$1 = {};

lastDayOfDecade$1.lastDayOfDecade = lastDayOfDecade;
var _index$12 = toDate$1;

/**
 * @name lastDayOfDecade
 * @category Decade Helpers
 * @summary Return the last day of a decade for the given date.
 *
 * @description
 * Return the last day of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a decade
 *
 * @example
 * // The last day of a decade for 21 December 2012 21:12:00:
 * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))
 * //=> Wed Dec 31 2019 00:00:00
 */
function lastDayOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index$12.toDate)(date);
  const year = _date.getFullYear();
  const decade = 9 + Math.floor(year / 10) * 10;
  _date.setFullYear(decade + 1, 0, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

var lastDayOfISOWeek$1 = {};

var lastDayOfWeek$1 = {};

lastDayOfWeek$1.lastDayOfWeek = lastDayOfWeek;
var _index$11 = toDate$1;

var _index2$b = defaultOptions$1;

/**
 * The {@link lastDayOfWeek} function options.
 */

/**
 * @name lastDayOfWeek
 * @category Week Helpers
 * @summary Return the last day of a week for the given date.
 *
 * @description
 * Return the last day of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The last day of a week
 *
 * @example
 * // The last day of a week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfWeek(date, options) {
  const defaultOptions = (0, _index2$b.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = (0, _index$11.toDate)(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

  _date.setHours(0, 0, 0, 0);
  _date.setDate(_date.getDate() + diff);
  return _date;
}

lastDayOfISOWeek$1.lastDayOfISOWeek = lastDayOfISOWeek;
var _index$10 = lastDayOfWeek$1;

/**
 * @name lastDayOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the last day of an ISO week for the given date.
 *
 * @description
 * Return the last day of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of an ISO week
 *
 * @example
 * // The last day of an ISO week for 2 September 2014 11:55:00:
 * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfISOWeek(date) {
  return (0, _index$10.lastDayOfWeek)(date, { weekStartsOn: 1 });
}

var lastDayOfISOWeekYear$1 = {};

lastDayOfISOWeekYear$1.lastDayOfISOWeekYear = lastDayOfISOWeekYear;
var _index$$ = getISOWeekYear$1;
var _index2$a = startOfISOWeek$1;
var _index3$6 = constructFrom$1;

/**
 * @name lastDayOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the last day of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the last day of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The last day of an ISO week-numbering year for 2 July 2005:
 * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 00:00:00
 */
function lastDayOfISOWeekYear(date) {
  const year = (0, _index$$.getISOWeekYear)(date);
  const fourthOfJanuary = (0, _index3$6.constructFrom)(date, 0);
  fourthOfJanuary.setFullYear(year + 1, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  const _date = (0, _index2$a.startOfISOWeek)(fourthOfJanuary);
  _date.setDate(_date.getDate() - 1);
  return _date;
}

var lastDayOfQuarter$1 = {};

lastDayOfQuarter$1.lastDayOfQuarter = lastDayOfQuarter;
var _index$_ = toDate$1;

/**
 * @name lastDayOfQuarter
 * @category Quarter Helpers
 * @summary Return the last day of a year quarter for the given date.
 *
 * @description
 * Return the last day of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a quarter
 *
 * @example
 * // The last day of a quarter for 2 September 2014 11:55:00:
 * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfQuarter(date) {
  const _date = (0, _index$_.toDate)(date);
  const currentMonth = _date.getMonth();
  const month = currentMonth - (currentMonth % 3) + 3;
  _date.setMonth(month, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

var lastDayOfYear$1 = {};

lastDayOfYear$1.lastDayOfYear = lastDayOfYear;
var _index$Z = toDate$1;

/**
 * @name lastDayOfYear
 * @category Year Helpers
 * @summary Return the last day of a year for the given date.
 *
 * @description
 * Return the last day of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a year
 *
 * @example
 * // The last day of a year for 2 September 2014 11:55:00:
 * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 00:00:00
 */
function lastDayOfYear(date) {
  const _date = (0, _index$Z.toDate)(date);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

var lightFormat = {};

(function (exports) {
exports.lightFormat = lightFormat;
Object.defineProperty(exports, "lightFormatters", {
  enumerable: true,
  get: function () {
    return _index3.lightFormatters;
  },
});
var _index = isValid$1;
var _index2 = toDate$1;
var _index3 = lightFormatters;

// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874

// This RegExp consists of three parts separated by `|`:
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @private
 */

/**
 * @name lightFormat
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. Unlike `format`,
 * `lightFormat` doesn't use locales and outputs date using the most popular tokens.
 *
 * > â ï¸ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   |
 * |---------------------------------|---------|-----------------------------------|
 * | AM, PM                          | a..aaa  | AM, PM                            |
 * |                                 | aaaa    | a.m., p.m.                        |
 * |                                 | aaaaa   | a, p                              |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 |
 * |                                 | yy      | 44, 01, 00, 17                    |
 * |                                 | yyy     | 044, 001, 000, 017                |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |
 * |                                 | MM      | 01, 02, ..., 12                   |
 * | Day of month                    | d       | 1, 2, ..., 31                     |
 * |                                 | dd      | 01, 02, ..., 31                   |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |
 * |                                 | hh      | 01, 02, ..., 11, 12               |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |
 * |                                 | HH      | 00, 01, 02, ..., 23               |
 * | Minute                          | m       | 0, 1, ..., 59                     |
 * |                                 | mm      | 00, 01, ..., 59                   |
 * | Second                          | s       | 0, 1, ..., 59                     |
 * |                                 | ss      | 00, 01, ..., 59                   |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |
 * |                                 | SS      | 00, 01, ..., 99                   |
 * |                                 | SSS     | 000, 001, ..., 999                |
 * |                                 | SSSS    | ...                               |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 *
 * @returns The formatted date string
 *
 * @throws `Invalid time value` if the date is invalid
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')
 * //=> '2014-02-11'
 */
function lightFormat(date, formatStr) {
  const _date = (0, _index2.toDate)(date);

  if (!(0, _index.isValid)(_date)) {
    throw new RangeError("Invalid time value");
  }

  const tokens = formatStr.match(formattingTokensRegExp);

  // The only case when formattingTokensRegExp doesn't match the string is when it's empty
  if (!tokens) return "";

  const result = tokens
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }

      const formatter = _index3.lightFormatters[firstCharacter];
      if (formatter) {
        return formatter(_date, substring);
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return substring;
    })
    .join("");

  return result;
}

function cleanEscapedString(input) {
  const matches = input.match(escapedStringRegExp);

  if (!matches) {
    return input;
  }

  return matches[1].replace(doubleQuoteRegExp, "'");
}
}(lightFormat));

var milliseconds$1 = {};

milliseconds$1.milliseconds = milliseconds;
var _index$Y = constants$1;

/**
 * @name milliseconds
 * @category Millisecond Helpers
 * @summary
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * @description
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * One month is a year divided by 12.
 *
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * @returns The milliseconds
 *
 * @example
 * // 1 year in milliseconds
 * milliseconds({ years: 1 })
 * //=> 31556952000
 *
 * // 3 months in milliseconds
 * milliseconds({ months: 3 })
 * //=> 7889238000
 */
function milliseconds({ years, months, weeks, days, hours, minutes, seconds }) {
  let totalDays = 0;

  if (years) totalDays += years * _index$Y.daysInYear;
  if (months) totalDays += months * (_index$Y.daysInYear / 12);
  if (weeks) totalDays += weeks * 7;
  if (days) totalDays += days;

  let totalSeconds = totalDays * 24 * 60 * 60;

  if (hours) totalSeconds += hours * 60 * 60;
  if (minutes) totalSeconds += minutes * 60;
  if (seconds) totalSeconds += seconds;

  return Math.trunc(totalSeconds * 1000);
}

var millisecondsToHours$1 = {};

millisecondsToHours$1.millisecondsToHours = millisecondsToHours;
var _index$X = constants$1;

/**
 * @name millisecondsToHours
 * @category Conversion Helpers
 * @summary Convert milliseconds to hours.
 *
 * @description
 * Convert a number of milliseconds to a full number of hours.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in hours
 *
 * @example
 * // Convert 7200000 milliseconds to hours:
 * const result = millisecondsToHours(7200000)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToHours(7199999)
 * //=> 1
 */
function millisecondsToHours(milliseconds) {
  const hours = milliseconds / _index$X.millisecondsInHour;
  return Math.trunc(hours);
}

var millisecondsToMinutes$1 = {};

millisecondsToMinutes$1.millisecondsToMinutes = millisecondsToMinutes;
var _index$W = constants$1;

/**
 * @name millisecondsToMinutes
 * @category Conversion Helpers
 * @summary Convert milliseconds to minutes.
 *
 * @description
 * Convert a number of milliseconds to a full number of minutes.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in minutes
 *
 * @example
 * // Convert 60000 milliseconds to minutes:
 * const result = millisecondsToMinutes(60000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToMinutes(119999)
 * //=> 1
 */
function millisecondsToMinutes(milliseconds) {
  const minutes = milliseconds / _index$W.millisecondsInMinute;
  return Math.trunc(minutes);
}

var millisecondsToSeconds$1 = {};

millisecondsToSeconds$1.millisecondsToSeconds = millisecondsToSeconds;
var _index$V = constants$1;

/**
 * @name millisecondsToSeconds
 * @category Conversion Helpers
 * @summary Convert milliseconds to seconds.
 *
 * @description
 * Convert a number of milliseconds to a full number of seconds.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in seconds
 *
 * @example
 * // Convert 1000 miliseconds to seconds:
 * const result = millisecondsToSeconds(1000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToSeconds(1999)
 * //=> 1
 */
function millisecondsToSeconds(milliseconds) {
  const seconds = milliseconds / _index$V.millisecondsInSecond;
  return Math.trunc(seconds);
}

var minutesToHours$1 = {};

minutesToHours$1.minutesToHours = minutesToHours;
var _index$U = constants$1;

/**
 * @name minutesToHours
 * @category Conversion Helpers
 * @summary Convert minutes to hours.
 *
 * @description
 * Convert a number of minutes to a full number of hours.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in hours
 *
 * @example
 * // Convert 140 minutes to hours:
 * const result = minutesToHours(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = minutesToHours(179)
 * //=> 2
 */
function minutesToHours(minutes) {
  const hours = minutes / _index$U.minutesInHour;
  return Math.trunc(hours);
}

var minutesToMilliseconds$1 = {};

minutesToMilliseconds$1.minutesToMilliseconds = minutesToMilliseconds;
var _index$T = constants$1;

/**
 * @name minutesToMilliseconds
 * @category Conversion Helpers
 * @summary Convert minutes to milliseconds.
 *
 * @description
 * Convert a number of minutes to a full number of milliseconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in milliseconds
 *
 * @example
 * // Convert 2 minutes to milliseconds
 * const result = minutesToMilliseconds(2)
 * //=> 120000
 */
function minutesToMilliseconds(minutes) {
  return Math.trunc(minutes * _index$T.millisecondsInMinute);
}

var minutesToSeconds$1 = {};

minutesToSeconds$1.minutesToSeconds = minutesToSeconds;
var _index$S = constants$1;

/**
 * @name minutesToSeconds
 * @category Conversion Helpers
 * @summary Convert minutes to seconds.
 *
 * @description
 * Convert a number of minutes to a full number of seconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in seconds
 *
 * @example
 * // Convert 2 minutes to seconds
 * const result = minutesToSeconds(2)
 * //=> 120
 */
function minutesToSeconds(minutes) {
  return Math.trunc(minutes * _index$S.secondsInMinute);
}

var monthsToQuarters$1 = {};

monthsToQuarters$1.monthsToQuarters = monthsToQuarters;
var _index$R = constants$1;

/**
 * @name monthsToQuarters
 * @category Conversion Helpers
 * @summary Convert number of months to quarters.
 *
 * @description
 * Convert a number of months to a full number of quarters.
 *
 * @param months - The number of months to be converted.
 *
 * @returns The number of months converted in quarters
 *
 * @example
 * // Convert 6 months to quarters:
 * const result = monthsToQuarters(6)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = monthsToQuarters(7)
 * //=> 2
 */
function monthsToQuarters(months) {
  const quarters = months / _index$R.monthsInQuarter;
  return Math.trunc(quarters);
}

var monthsToYears$1 = {};

monthsToYears$1.monthsToYears = monthsToYears;
var _index$Q = constants$1;

/**
 * @name monthsToYears
 * @category Conversion Helpers
 * @summary Convert number of months to years.
 *
 * @description
 * Convert a number of months to a full number of years.
 *
 * @param months - The number of months to be converted
 *
 * @returns The number of months converted in years
 *
 * @example
 * // Convert 36 months to years:
 * const result = monthsToYears(36)
 * //=> 3
 *
 * // It uses floor rounding:
 * const result = monthsToYears(40)
 * //=> 3
 */
function monthsToYears(months) {
  const years = months / _index$Q.monthsInYear;
  return Math.trunc(years);
}

var nextDay$1 = {};

nextDay$1.nextDay = nextDay;
var _index$P = addDays$1;
var _index2$9 = getDay$1;

/**
 * @name nextDay
 * @category Weekday Helpers
 * @summary When is the next day of the week?
 *
 * @description
 * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - day of the week
 *
 * @returns The date is the next day of week
 *
 * @example
 * // When is the next Monday after Mar, 20, 2020?
 * const result = nextDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 23 2020 00:00:00
 *
 * @example
 * // When is the next Tuesday after Mar, 21, 2020?
 * const result = nextDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextDay(date, day) {
  let delta = day - (0, _index2$9.getDay)(date);
  if (delta <= 0) delta += 7;

  return (0, _index$P.addDays)(date, delta);
}

var nextFriday$1 = {};

nextFriday$1.nextFriday = nextFriday;
var _index$O = nextDay$1;

/**
 * @name nextFriday
 * @category Weekday Helpers
 * @summary When is the next Friday?
 *
 * @description
 * When is the next Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Friday
 *
 * @example
 * // When is the next Friday after Mar, 22, 2020?
 * const result = nextFriday(new Date(2020, 2, 22))
 * //=> Fri Mar 27 2020 00:00:00
 */
function nextFriday(date) {
  return (0, _index$O.nextDay)(date, 5);
}

var nextMonday$1 = {};

nextMonday$1.nextMonday = nextMonday;
var _index$N = nextDay$1;

/**
 * @name nextMonday
 * @category Weekday Helpers
 * @summary When is the next Monday?
 *
 * @description
 * When is the next Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Monday
 *
 * @example
 * // When is the next Monday after Mar, 22, 2020?
 * const result = nextMonday(new Date(2020, 2, 22))
 * //=> Mon Mar 23 2020 00:00:00
 */
function nextMonday(date) {
  return (0, _index$N.nextDay)(date, 1);
}

var nextSaturday$1 = {};

nextSaturday$1.nextSaturday = nextSaturday;
var _index$M = nextDay$1;

/**
 * @name nextSaturday
 * @category Weekday Helpers
 * @summary When is the next Saturday?
 *
 * @description
 * When is the next Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Saturday
 *
 * @example
 * // When is the next Saturday after Mar, 22, 2020?
 * const result = nextSaturday(new Date(2020, 2, 22))
 * //=> Sat Mar 28 2020 00:00:00
 */
function nextSaturday(date) {
  return (0, _index$M.nextDay)(date, 6);
}

var nextSunday$1 = {};

nextSunday$1.nextSunday = nextSunday;
var _index$L = nextDay$1;

/**
 * @name nextSunday
 * @category Weekday Helpers
 * @summary When is the next Sunday?
 *
 * @description
 * When is the next Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Sunday
 *
 * @example
 * // When is the next Sunday after Mar, 22, 2020?
 * const result = nextSunday(new Date(2020, 2, 22))
 * //=> Sun Mar 29 2020 00:00:00
 */
function nextSunday(date) {
  return (0, _index$L.nextDay)(date, 0);
}

var nextThursday$1 = {};

nextThursday$1.nextThursday = nextThursday;
var _index$K = nextDay$1;

/**
 * @name nextThursday
 * @category Weekday Helpers
 * @summary When is the next Thursday?
 *
 * @description
 * When is the next Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Thursday
 *
 * @example
 * // When is the next Thursday after Mar, 22, 2020?
 * const result = nextThursday(new Date(2020, 2, 22))
 * //=> Thur Mar 26 2020 00:00:00
 */
function nextThursday(date) {
  return (0, _index$K.nextDay)(date, 4);
}

var nextTuesday$1 = {};

nextTuesday$1.nextTuesday = nextTuesday;
var _index$J = nextDay$1;

/**
 * @name nextTuesday
 * @category Weekday Helpers
 * @summary When is the next Tuesday?
 *
 * @description
 * When is the next Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Tuesday
 *
 * @example
 * // When is the next Tuesday after Mar, 22, 2020?
 * const result = nextTuesday(new Date(2020, 2, 22))
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextTuesday(date) {
  return (0, _index$J.nextDay)(date, 2);
}

var nextWednesday$1 = {};

nextWednesday$1.nextWednesday = nextWednesday;
var _index$I = nextDay$1;

/**
 * @name nextWednesday
 * @category Weekday Helpers
 * @summary When is the next Wednesday?
 *
 * @description
 * When is the next Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Wednesday
 *
 * @example
 * // When is the next Wednesday after Mar, 22, 2020?
 * const result = nextWednesday(new Date(2020, 2, 22))
 * //=> Wed Mar 25 2020 00:00:00
 */
function nextWednesday(date) {
  return (0, _index$I.nextDay)(date, 3);
}

var parseISO$1 = {};

parseISO$1.parseISO = parseISO;
var _index$H = constants$1;

/**
 * The {@link parseISO} function options.
 */

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  const additionalDigits = options?.additionalDigits ?? 2;
  const dateStrings = splitDateString(argument);

  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }

  const timestamp = date.getTime();
  let time = 0;
  let offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time);
    // JS parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.
    const result = new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate(),
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds(),
    );
    return result;
  }

  return new Date(timestamp + time + offset);
}

const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/,
};

const dateRegex =
  /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex =
  /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length,
      );
    }
  }

  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" +
      (4 + additionalDigits) +
      "})|(\\d{2}|[+-]\\d{" +
      (2 + additionalDigits) +
      "})$)",
  );

  const captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return { year: NaN, restDateString: "" };

  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length),
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);

  const captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);

  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (
      !validateDate(year, month, day) ||
      !validateDayOfYearDate(year, dayOfYear)
    ) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return (
    hours * _index$H.millisecondsInHour +
    minutes * _index$H.millisecondsInMinute +
    seconds * 1000
  );
}

function parseTimeUnit(value) {
  return (value && parseFloat(value.replace(",", "."))) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;

  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;

  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = (captures[3] && parseInt(captures[3])) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return (
    sign *
    (hours * _index$H.millisecondsInHour + minutes * _index$H.millisecondsInMinute)
  );
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

function validateDate(year, month, date) {
  return (
    month >= 0 &&
    month <= 11 &&
    date >= 1 &&
    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
  );
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return (
    seconds >= 0 &&
    seconds < 60 &&
    minutes >= 0 &&
    minutes < 60 &&
    hours >= 0 &&
    hours < 25
  );
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

var parseJSON$1 = {};

parseJSON$1.parseJSON = parseJSON; /**
 * @name parseJSON
 * @category Common Helpers
 * @summary Parse a JSON date string
 *
 * @description
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 *
 * @returns The parsed date in the local time zone
 */
function parseJSON(dateStr) {
  const parts = dateStr.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
  );
  if (parts) {
    // Group 8 matches the sign
    return new Date(
      Date.UTC(
        +parts[1],
        +parts[2] - 1,
        +parts[3],
        +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
        +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
        +parts[6],
        +((parts[7] || "0") + "00").substring(0, 3),
      ),
    );
  }
  return new Date(NaN);
}

var previousDay$1 = {};

previousDay$1.previousDay = previousDay;
var _index$G = getDay$1;
var _index2$8 = subDays$1;

/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - The day of the week
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
function previousDay(date, day) {
  let delta = (0, _index$G.getDay)(date) - day;
  if (delta <= 0) delta += 7;

  return (0, _index2$8.subDays)(date, delta);
}

var previousFriday$1 = {};

previousFriday$1.previousFriday = previousFriday;
var _index$F = previousDay$1;

/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
function previousFriday(date) {
  return (0, _index$F.previousDay)(date, 5);
}

var previousMonday$1 = {};

previousMonday$1.previousMonday = previousMonday;
var _index$E = previousDay$1;

/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
function previousMonday(date) {
  return (0, _index$E.previousDay)(date, 1);
}

var previousSaturday$1 = {};

previousSaturday$1.previousSaturday = previousSaturday;
var _index$D = previousDay$1;

/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
function previousSaturday(date) {
  return (0, _index$D.previousDay)(date, 6);
}

var previousSunday$1 = {};

previousSunday$1.previousSunday = previousSunday;
var _index$C = previousDay$1;

/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
function previousSunday(date) {
  return (0, _index$C.previousDay)(date, 0);
}

var previousThursday$1 = {};

previousThursday$1.previousThursday = previousThursday;
var _index$B = previousDay$1;

/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
function previousThursday(date) {
  return (0, _index$B.previousDay)(date, 4);
}

var previousTuesday$1 = {};

previousTuesday$1.previousTuesday = previousTuesday;
var _index$A = previousDay$1;

/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
function previousTuesday(date) {
  return (0, _index$A.previousDay)(date, 2);
}

var previousWednesday$1 = {};

previousWednesday$1.previousWednesday = previousWednesday;
var _index$z = previousDay$1;

/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
function previousWednesday(date) {
  return (0, _index$z.previousDay)(date, 3);
}

var quartersToMonths$1 = {};

quartersToMonths$1.quartersToMonths = quartersToMonths;
var _index$y = constants$1;

/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
function quartersToMonths(quarters) {
  return Math.trunc(quarters * _index$y.monthsInQuarter);
}

var quartersToYears$1 = {};

quartersToYears$1.quartersToYears = quartersToYears;
var _index$x = constants$1;

/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
function quartersToYears(quarters) {
  const years = quarters / _index$x.quartersInYear;
  return Math.trunc(years);
}

var roundToNearestHours$1 = {};

roundToNearestHours$1.roundToNearestHours = roundToNearestHours;
var _index$w = getRoundingMethod$1;
var _index2$7 = constructFrom$1;
var _index3$5 = toDate$1;

/**
 * The {@link roundToNearestHours} function options.
 */

/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00

 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00

* @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
function roundToNearestHours(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 12)
    return (0, _index2$7.constructFrom)(date, NaN);

  const _date = (0, _index3$5.toDate)(date);
  const fractionalMinutes = _date.getMinutes() / 60;
  const fractionalSeconds = _date.getSeconds() / 60 / 60;
  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60 / 60;
  const hours =
    _date.getHours() +
    fractionalMinutes +
    fractionalSeconds +
    fractionalMilliseconds;

  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index$w.getRoundingMethod)(method);

  // nearestTo option does not care daylight savings time
  const roundedHours = roundingMethod(hours / nearestTo) * nearestTo;

  const result = (0, _index2$7.constructFrom)(date, _date);
  result.setHours(roundedHours, 0, 0, 0);
  return result;
}

var roundToNearestMinutes$1 = {};

roundToNearestMinutes$1.roundToNearestMinutes = roundToNearestMinutes;
var _index$v = getRoundingMethod$1;
var _index2$6 = constructFrom$1;
var _index3$4 = toDate$1;

/**
 * The {@link roundToNearestMinutes} function options.
 */

/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
function roundToNearestMinutes(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 30)
    return (0, _index2$6.constructFrom)(date, NaN);

  const _date = (0, _index3$4.toDate)(date);
  const fractionalSeconds = _date.getSeconds() / 60;
  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60;
  const minutes =
    _date.getMinutes() + fractionalSeconds + fractionalMilliseconds;

  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index$v.getRoundingMethod)(method);

  const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;

  const result = (0, _index2$6.constructFrom)(date, _date);
  result.setMinutes(roundedMinutes, 0, 0);
  return result;
}

var secondsToHours$1 = {};

secondsToHours$1.secondsToHours = secondsToHours;
var _index$u = constants$1;

/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
function secondsToHours(seconds) {
  const hours = seconds / _index$u.secondsInHour;
  return Math.trunc(hours);
}

var secondsToMilliseconds$1 = {};

secondsToMilliseconds$1.secondsToMilliseconds = secondsToMilliseconds;
var _index$t = constants$1;

/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
function secondsToMilliseconds(seconds) {
  return seconds * _index$t.millisecondsInSecond;
}

var secondsToMinutes$1 = {};

secondsToMinutes$1.secondsToMinutes = secondsToMinutes;
var _index$s = constants$1;

/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
function secondsToMinutes(seconds) {
  const minutes = seconds / _index$s.secondsInMinute;
  return Math.trunc(minutes);
}

var set$1 = {};

var setMonth$1 = {};

setMonth$1.setMonth = setMonth;
var _index$r = constructFrom$1;
var _index2$5 = getDaysInMonth$1;
var _index3$3 = toDate$1;

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
function setMonth(date, month) {
  const _date = (0, _index3$3.toDate)(date);
  const year = _date.getFullYear();
  const day = _date.getDate();

  const dateWithDesiredMonth = (0, _index$r.constructFrom)(date, 0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  const daysInMonth = (0, _index2$5.getDaysInMonth)(dateWithDesiredMonth);
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

set$1.set = set;
var _index$q = constructFrom$1;
var _index2$4 = setMonth$1;
var _index3$2 = toDate$1;

/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */

function set(date, values) {
  let _date = (0, _index3$2.toDate)(date);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) {
    return (0, _index$q.constructFrom)(date, NaN);
  }

  if (values.year != null) {
    _date.setFullYear(values.year);
  }

  if (values.month != null) {
    _date = (0, _index2$4.setMonth)(_date, values.month);
  }

  if (values.date != null) {
    _date.setDate(values.date);
  }

  if (values.hours != null) {
    _date.setHours(values.hours);
  }

  if (values.minutes != null) {
    _date.setMinutes(values.minutes);
  }

  if (values.seconds != null) {
    _date.setSeconds(values.seconds);
  }

  if (values.milliseconds != null) {
    _date.setMilliseconds(values.milliseconds);
  }

  return _date;
}

var setDate$1 = {};

setDate$1.setDate = setDate;
var _index$p = toDate$1;

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
function setDate(date, dayOfMonth) {
  const _date = (0, _index$p.toDate)(date);
  _date.setDate(dayOfMonth);
  return _date;
}

var setDayOfYear$1 = {};

setDayOfYear$1.setDayOfYear = setDayOfYear;
var _index$o = toDate$1;

/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
function setDayOfYear(date, dayOfYear) {
  const _date = (0, _index$o.toDate)(date);
  _date.setMonth(0);
  _date.setDate(dayOfYear);
  return _date;
}

var setDefaultOptions$1 = {};

setDefaultOptions$1.setDefaultOptions = setDefaultOptions;

var _index$n = defaultOptions$1;

/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
function setDefaultOptions(options) {
  const result = {};
  const defaultOptions = (0, _index$n.getDefaultOptions)();

  for (const property in defaultOptions) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      result[property] = defaultOptions[property];
    }
  }

  for (const property in options) {
    if (Object.prototype.hasOwnProperty.call(options, property)) {
      if (options[property] === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        delete result[property];
      } else {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        result[property] = options[property];
      }
    }
  }

  (0, _index$n.setDefaultOptions)(result);
}

var setHours$1 = {};

setHours$1.setHours = setHours;
var _index$m = toDate$1;

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
function setHours(date, hours) {
  const _date = (0, _index$m.toDate)(date);
  _date.setHours(hours);
  return _date;
}

var setMilliseconds$1 = {};

setMilliseconds$1.setMilliseconds = setMilliseconds;
var _index$l = toDate$1;

/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
function setMilliseconds(date, milliseconds) {
  const _date = (0, _index$l.toDate)(date);
  _date.setMilliseconds(milliseconds);
  return _date;
}

var setMinutes$1 = {};

setMinutes$1.setMinutes = setMinutes;
var _index$k = toDate$1;

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
function setMinutes(date, minutes) {
  const _date = (0, _index$k.toDate)(date);
  _date.setMinutes(minutes);
  return _date;
}

var setQuarter$1 = {};

setQuarter$1.setQuarter = setQuarter;
var _index$j = setMonth$1;
var _index2$3 = toDate$1;

/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
function setQuarter(date, quarter) {
  const _date = (0, _index2$3.toDate)(date);
  const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
  const diff = quarter - oldQuarter;
  return (0, _index$j.setMonth)(_date, _date.getMonth() + diff * 3);
}

var setSeconds$1 = {};

setSeconds$1.setSeconds = setSeconds;
var _index$i = toDate$1;

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
function setSeconds(date, seconds) {
  const _date = (0, _index$i.toDate)(date);
  _date.setSeconds(seconds);
  return _date;
}

var setWeekYear$1 = {};

setWeekYear$1.setWeekYear = setWeekYear;
var _index$h = constructFrom$1;
var _index2$2 = differenceInCalendarDays$1;
var _index3$1 = startOfWeekYear$1;
var _index4 = toDate$1;

var _index5 = defaultOptions$1;

/**
 * The {@link setWeekYear} function options.
 */

/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
function setWeekYear(date, weekYear, options) {
  const defaultOptions = (0, _index5.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  let _date = (0, _index4.toDate)(date);
  const diff = (0, _index2$2.differenceInCalendarDays)(
    _date,
    (0, _index3$1.startOfWeekYear)(_date, options),
  );
  const firstWeek = (0, _index$h.constructFrom)(date, 0);
  firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  _date = (0, _index3$1.startOfWeekYear)(firstWeek, options);
  _date.setDate(_date.getDate() + diff);
  return _date;
}

var setYear$1 = {};

setYear$1.setYear = setYear;
var _index$g = constructFrom$1;
var _index2$1 = toDate$1;

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
function setYear(date, year) {
  const _date = (0, _index2$1.toDate)(date);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) {
    return (0, _index$g.constructFrom)(date, NaN);
  }

  _date.setFullYear(year);
  return _date;
}

var startOfDecade$1 = {};

startOfDecade$1.startOfDecade = startOfDecade;
var _index$f = toDate$1;

/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
function startOfDecade(date) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index$f.toDate)(date);
  const year = _date.getFullYear();
  const decade = Math.floor(year / 10) * 10;
  _date.setFullYear(decade, 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

var startOfToday$1 = {};

startOfToday$1.startOfToday = startOfToday;
var _index$e = startOfDay$1;

/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
function startOfToday() {
  return (0, _index$e.startOfDay)(Date.now());
}

var startOfTomorrow$1 = {};

startOfTomorrow$1.startOfTomorrow = startOfTomorrow; /**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @description
 * Return the start of tomorrow.
 *
 * @returns The start of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
function startOfTomorrow() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

var startOfYesterday$1 = {};

startOfYesterday$1.startOfYesterday = startOfYesterday; /**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
function startOfYesterday() {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();
  const day = now.getDate();

  const date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

var sub$1 = {};

var subMonths$1 = {};

subMonths$1.subMonths = subMonths;
var _index$d = addMonths$1;

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths(date, amount) {
  return (0, _index$d.addMonths)(date, -amount);
}

sub$1.sub = sub;
var _index$c = subDays$1;
var _index2 = subMonths$1;

var _index3 = constructFrom$1;

/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
function sub(date, duration) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  // Subtract years and months
  const dateWithoutMonths = (0, _index2.subMonths)(date, months + years * 12);

  // Subtract weeks and days
  const dateWithoutDays = (0, _index$c.subDays)(
    dateWithoutMonths,
    days + weeks * 7,
  );

  // Subtract hours, minutes and seconds
  const minutestoSub = minutes + hours * 60;
  const secondstoSub = seconds + minutestoSub * 60;
  const mstoSub = secondstoSub * 1000;
  const finalDate = (0, _index3.constructFrom)(
    date,
    dateWithoutDays.getTime() - mstoSub,
  );

  return finalDate;
}

var subBusinessDays$1 = {};

subBusinessDays$1.subBusinessDays = subBusinessDays;
var _index$b = addBusinessDays$1;

/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Substract the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Substract the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Substract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
function subBusinessDays(date, amount) {
  return (0, _index$b.addBusinessDays)(date, -amount);
}

var subHours$1 = {};

subHours$1.subHours = subHours;
var _index$a = addHours$1;

/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
function subHours(date, amount) {
  return (0, _index$a.addHours)(date, -amount);
}

var subMilliseconds$1 = {};

subMilliseconds$1.subMilliseconds = subMilliseconds;
var _index$9 = addMilliseconds$1;

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 *
 * @returns The new date with the milliseconds subtracted
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */
function subMilliseconds(date, amount) {
  return (0, _index$9.addMilliseconds)(date, -amount);
}

var subMinutes$1 = {};

subMinutes$1.subMinutes = subMinutes;
var _index$8 = addMinutes$1;

/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
function subMinutes(date, amount) {
  return (0, _index$8.addMinutes)(date, -amount);
}

var subQuarters$1 = {};

subQuarters$1.subQuarters = subQuarters;
var _index$7 = addQuarters$1;

/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
function subQuarters(date, amount) {
  return (0, _index$7.addQuarters)(date, -amount);
}

var subSeconds$1 = {};

subSeconds$1.subSeconds = subSeconds;
var _index$6 = addSeconds$1;

/**
 * @name subSeconds
 * @category Second Helpers
 * @summary Subtract the specified number of seconds from the given date.
 *
 * @description
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
function subSeconds(date, amount) {
  return (0, _index$6.addSeconds)(date, -amount);
}

var subWeeks$1 = {};

subWeeks$1.subWeeks = subWeeks;
var _index$5 = addWeeks$1;

/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
function subWeeks(date, amount) {
  return (0, _index$5.addWeeks)(date, -amount);
}

var subYears$1 = {};

subYears$1.subYears = subYears;
var _index$4 = addYears$1;

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
function subYears(date, amount) {
  return (0, _index$4.addYears)(date, -amount);
}

var weeksToDays$1 = {};

weeksToDays$1.weeksToDays = weeksToDays;
var _index$3 = constants$1;

/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
function weeksToDays(weeks) {
  return Math.trunc(weeks * _index$3.daysInWeek);
}

var yearsToDays$1 = {};

yearsToDays$1.yearsToDays = yearsToDays;
var _index$2 = constants$1;

/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
function yearsToDays(years) {
  return Math.trunc(years * _index$2.daysInYear);
}

var yearsToMonths$1 = {};

yearsToMonths$1.yearsToMonths = yearsToMonths;
var _index$1 = constants$1;

/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
function yearsToMonths(years) {
  return Math.trunc(years * _index$1.monthsInYear);
}

var yearsToQuarters$1 = {};

yearsToQuarters$1.yearsToQuarters = yearsToQuarters;
var _index = constants$1;

/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
function yearsToQuarters(years) {
  return Math.trunc(years * _index.quartersInYear);
}

(function (exports) {

var _index = add$1;
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    },
  });
});
var _index2 = addBusinessDays$1;
Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    },
  });
});
var _index3 = addDays$1;
Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index3[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index3[key];
    },
  });
});
var _index4 = addHours$1;
Object.keys(_index4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index4[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index4[key];
    },
  });
});
var _index5 = addISOWeekYears$1;
Object.keys(_index5).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index5[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index5[key];
    },
  });
});
var _index6 = addMilliseconds$1;
Object.keys(_index6).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index6[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index6[key];
    },
  });
});
var _index7 = addMinutes$1;
Object.keys(_index7).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index7[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index7[key];
    },
  });
});
var _index8 = addMonths$1;
Object.keys(_index8).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index8[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index8[key];
    },
  });
});
var _index9 = addQuarters$1;
Object.keys(_index9).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index9[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index9[key];
    },
  });
});
var _index10 = addSeconds$1;
Object.keys(_index10).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index10[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index10[key];
    },
  });
});
var _index11 = addWeeks$1;
Object.keys(_index11).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index11[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index11[key];
    },
  });
});
var _index12 = addYears$1;
Object.keys(_index12).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index12[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index12[key];
    },
  });
});
var _index13 = areIntervalsOverlapping$1;
Object.keys(_index13).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index13[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index13[key];
    },
  });
});
var _index14 = clamp$1;
Object.keys(_index14).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index14[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index14[key];
    },
  });
});
var _index15 = closestIndexTo$1;
Object.keys(_index15).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index15[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index15[key];
    },
  });
});
var _index16 = closestTo$1;
Object.keys(_index16).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index16[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index16[key];
    },
  });
});
var _index17 = compareAsc$1;
Object.keys(_index17).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index17[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index17[key];
    },
  });
});
var _index18 = compareDesc$1;
Object.keys(_index18).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index18[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index18[key];
    },
  });
});
var _index19 = constructFrom$1;
Object.keys(_index19).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index19[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index19[key];
    },
  });
});
var _index20 = constructNow$1;
Object.keys(_index20).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index20[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index20[key];
    },
  });
});
var _index21 = daysToWeeks$1;
Object.keys(_index21).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index21[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index21[key];
    },
  });
});
var _index22 = differenceInBusinessDays$1;
Object.keys(_index22).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index22[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index22[key];
    },
  });
});
var _index23 = differenceInCalendarDays$1;
Object.keys(_index23).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index23[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index23[key];
    },
  });
});
var _index24 = differenceInCalendarISOWeekYears$1;
Object.keys(_index24).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index24[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index24[key];
    },
  });
});
var _index25 = differenceInCalendarISOWeeks$1;
Object.keys(_index25).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index25[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index25[key];
    },
  });
});
var _index26 = differenceInCalendarMonths$1;
Object.keys(_index26).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index26[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index26[key];
    },
  });
});
var _index27 = differenceInCalendarQuarters$1;
Object.keys(_index27).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index27[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index27[key];
    },
  });
});
var _index28 = differenceInCalendarWeeks$1;
Object.keys(_index28).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index28[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index28[key];
    },
  });
});
var _index29 = differenceInCalendarYears$1;
Object.keys(_index29).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index29[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index29[key];
    },
  });
});
var _index30 = differenceInDays$1;
Object.keys(_index30).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index30[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index30[key];
    },
  });
});
var _index31 = differenceInHours$1;
Object.keys(_index31).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index31[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index31[key];
    },
  });
});
var _index32 = differenceInISOWeekYears$1;
Object.keys(_index32).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index32[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index32[key];
    },
  });
});
var _index33 = differenceInMilliseconds$1;
Object.keys(_index33).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index33[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index33[key];
    },
  });
});
var _index34 = differenceInMinutes$1;
Object.keys(_index34).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index34[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index34[key];
    },
  });
});
var _index35 = differenceInMonths$1;
Object.keys(_index35).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index35[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index35[key];
    },
  });
});
var _index36 = differenceInQuarters$1;
Object.keys(_index36).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index36[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index36[key];
    },
  });
});
var _index37 = differenceInSeconds$1;
Object.keys(_index37).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index37[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index37[key];
    },
  });
});
var _index38 = differenceInWeeks$1;
Object.keys(_index38).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index38[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index38[key];
    },
  });
});
var _index39 = differenceInYears$1;
Object.keys(_index39).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index39[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index39[key];
    },
  });
});
var _index40 = eachDayOfInterval$1;
Object.keys(_index40).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index40[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index40[key];
    },
  });
});
var _index41 = eachHourOfInterval$1;
Object.keys(_index41).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index41[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index41[key];
    },
  });
});
var _index42 = eachMinuteOfInterval$1;
Object.keys(_index42).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index42[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index42[key];
    },
  });
});
var _index43 = eachMonthOfInterval$1;
Object.keys(_index43).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index43[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index43[key];
    },
  });
});
var _index44 = eachQuarterOfInterval$1;
Object.keys(_index44).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index44[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index44[key];
    },
  });
});
var _index45 = eachWeekOfInterval$1;
Object.keys(_index45).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index45[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index45[key];
    },
  });
});
var _index46 = eachWeekendOfInterval$1;
Object.keys(_index46).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index46[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index46[key];
    },
  });
});
var _index47 = eachWeekendOfMonth$1;
Object.keys(_index47).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index47[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index47[key];
    },
  });
});
var _index48 = eachWeekendOfYear$1;
Object.keys(_index48).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index48[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index48[key];
    },
  });
});
var _index49 = eachYearOfInterval$1;
Object.keys(_index49).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index49[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index49[key];
    },
  });
});
var _index50 = endOfDay$1;
Object.keys(_index50).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index50[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index50[key];
    },
  });
});
var _index51 = endOfDecade$1;
Object.keys(_index51).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index51[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index51[key];
    },
  });
});
var _index52 = endOfHour$1;
Object.keys(_index52).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index52[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index52[key];
    },
  });
});
var _index53 = endOfISOWeek$1;
Object.keys(_index53).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index53[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index53[key];
    },
  });
});
var _index54 = endOfISOWeekYear$1;
Object.keys(_index54).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index54[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index54[key];
    },
  });
});
var _index55 = endOfMinute$1;
Object.keys(_index55).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index55[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index55[key];
    },
  });
});
var _index56 = endOfMonth$1;
Object.keys(_index56).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index56[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index56[key];
    },
  });
});
var _index57 = endOfQuarter$1;
Object.keys(_index57).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index57[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index57[key];
    },
  });
});
var _index58 = endOfSecond$1;
Object.keys(_index58).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index58[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index58[key];
    },
  });
});
var _index59 = endOfToday$1;
Object.keys(_index59).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index59[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index59[key];
    },
  });
});
var _index60 = endOfTomorrow$1;
Object.keys(_index60).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index60[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index60[key];
    },
  });
});
var _index61 = endOfWeek$1;
Object.keys(_index61).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index61[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index61[key];
    },
  });
});
var _index62 = endOfYear$1;
Object.keys(_index62).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index62[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index62[key];
    },
  });
});
var _index63 = endOfYesterday$1;
Object.keys(_index63).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index63[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index63[key];
    },
  });
});
var _index64 = format;
Object.keys(_index64).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index64[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index64[key];
    },
  });
});
var _index65 = formatDistance$1;
Object.keys(_index65).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index65[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index65[key];
    },
  });
});
var _index66 = formatDistanceStrict$1;
Object.keys(_index66).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index66[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index66[key];
    },
  });
});
var _index67 = formatDistanceToNow$1;
Object.keys(_index67).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index67[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index67[key];
    },
  });
});
var _index68 = formatDistanceToNowStrict$1;
Object.keys(_index68).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index68[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index68[key];
    },
  });
});
var _index69 = formatDuration$1;
Object.keys(_index69).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index69[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index69[key];
    },
  });
});
var _index70 = formatISO$1;
Object.keys(_index70).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index70[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index70[key];
    },
  });
});
var _index71 = formatISO9075$1;
Object.keys(_index71).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index71[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index71[key];
    },
  });
});
var _index72 = formatISODuration$1;
Object.keys(_index72).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index72[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index72[key];
    },
  });
});
var _index73 = formatRFC3339$1;
Object.keys(_index73).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index73[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index73[key];
    },
  });
});
var _index74 = formatRFC7231$1;
Object.keys(_index74).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index74[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index74[key];
    },
  });
});
var _index75 = formatRelative$1;
Object.keys(_index75).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index75[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index75[key];
    },
  });
});
var _index76 = fromUnixTime$1;
Object.keys(_index76).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index76[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index76[key];
    },
  });
});
var _index77 = getDate$1;
Object.keys(_index77).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index77[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index77[key];
    },
  });
});
var _index78 = getDay$1;
Object.keys(_index78).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index78[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index78[key];
    },
  });
});
var _index79 = getDayOfYear$1;
Object.keys(_index79).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index79[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index79[key];
    },
  });
});
var _index80 = getDaysInMonth$1;
Object.keys(_index80).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index80[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index80[key];
    },
  });
});
var _index81 = getDaysInYear$1;
Object.keys(_index81).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index81[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index81[key];
    },
  });
});
var _index82 = getDecade$1;
Object.keys(_index82).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index82[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index82[key];
    },
  });
});
var _index83 = getDefaultOptions$1;
Object.keys(_index83).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index83[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index83[key];
    },
  });
});
var _index84 = getHours$1;
Object.keys(_index84).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index84[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index84[key];
    },
  });
});
var _index85 = getISODay$1;
Object.keys(_index85).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index85[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index85[key];
    },
  });
});
var _index86 = getISOWeek$1;
Object.keys(_index86).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index86[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index86[key];
    },
  });
});
var _index87 = getISOWeekYear$1;
Object.keys(_index87).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index87[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index87[key];
    },
  });
});
var _index88 = getISOWeeksInYear$1;
Object.keys(_index88).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index88[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index88[key];
    },
  });
});
var _index89 = getMilliseconds$1;
Object.keys(_index89).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index89[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index89[key];
    },
  });
});
var _index90 = getMinutes$1;
Object.keys(_index90).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index90[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index90[key];
    },
  });
});
var _index91 = getMonth$1;
Object.keys(_index91).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index91[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index91[key];
    },
  });
});
var _index92 = getOverlappingDaysInIntervals$1;
Object.keys(_index92).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index92[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index92[key];
    },
  });
});
var _index93 = getQuarter$1;
Object.keys(_index93).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index93[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index93[key];
    },
  });
});
var _index94 = getSeconds$1;
Object.keys(_index94).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index94[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index94[key];
    },
  });
});
var _index95 = getTime$1;
Object.keys(_index95).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index95[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index95[key];
    },
  });
});
var _index96 = getUnixTime$1;
Object.keys(_index96).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index96[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index96[key];
    },
  });
});
var _index97 = getWeek$1;
Object.keys(_index97).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index97[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index97[key];
    },
  });
});
var _index98 = getWeekOfMonth$1;
Object.keys(_index98).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index98[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index98[key];
    },
  });
});
var _index99 = getWeekYear$1;
Object.keys(_index99).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index99[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index99[key];
    },
  });
});
var _index100 = getWeeksInMonth$1;
Object.keys(_index100).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index100[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index100[key];
    },
  });
});
var _index101 = getYear$1;
Object.keys(_index101).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index101[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index101[key];
    },
  });
});
var _index102 = hoursToMilliseconds$1;
Object.keys(_index102).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index102[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index102[key];
    },
  });
});
var _index103 = hoursToMinutes$1;
Object.keys(_index103).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index103[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index103[key];
    },
  });
});
var _index104 = hoursToSeconds$1;
Object.keys(_index104).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index104[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index104[key];
    },
  });
});
var _index105 = interval$1;
Object.keys(_index105).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index105[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index105[key];
    },
  });
});
var _index106 = intervalToDuration$1;
Object.keys(_index106).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index106[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index106[key];
    },
  });
});
var _index107 = intlFormat$1;
Object.keys(_index107).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index107[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index107[key];
    },
  });
});
var _index108 = intlFormatDistance$1;
Object.keys(_index108).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index108[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index108[key];
    },
  });
});
var _index109 = isAfter$1;
Object.keys(_index109).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index109[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index109[key];
    },
  });
});
var _index110 = isBefore$1;
Object.keys(_index110).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index110[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index110[key];
    },
  });
});
var _index111 = isDate$1;
Object.keys(_index111).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index111[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index111[key];
    },
  });
});
var _index112 = isEqual$1;
Object.keys(_index112).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index112[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index112[key];
    },
  });
});
var _index113 = isExists$1;
Object.keys(_index113).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index113[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index113[key];
    },
  });
});
var _index114 = isFirstDayOfMonth$1;
Object.keys(_index114).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index114[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index114[key];
    },
  });
});
var _index115 = isFriday$1;
Object.keys(_index115).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index115[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index115[key];
    },
  });
});
var _index116 = isFuture$1;
Object.keys(_index116).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index116[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index116[key];
    },
  });
});
var _index117 = isLastDayOfMonth$1;
Object.keys(_index117).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index117[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index117[key];
    },
  });
});
var _index118 = isLeapYear$1;
Object.keys(_index118).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index118[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index118[key];
    },
  });
});
var _index119 = isMatch$1;
Object.keys(_index119).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index119[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index119[key];
    },
  });
});
var _index120 = isMonday$1;
Object.keys(_index120).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index120[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index120[key];
    },
  });
});
var _index121 = isPast$1;
Object.keys(_index121).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index121[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index121[key];
    },
  });
});
var _index122 = isSameDay$1;
Object.keys(_index122).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index122[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index122[key];
    },
  });
});
var _index123 = isSameHour$1;
Object.keys(_index123).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index123[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index123[key];
    },
  });
});
var _index124 = isSameISOWeek$1;
Object.keys(_index124).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index124[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index124[key];
    },
  });
});
var _index125 = isSameISOWeekYear$1;
Object.keys(_index125).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index125[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index125[key];
    },
  });
});
var _index126 = isSameMinute$1;
Object.keys(_index126).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index126[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index126[key];
    },
  });
});
var _index127 = isSameMonth$1;
Object.keys(_index127).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index127[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index127[key];
    },
  });
});
var _index128 = isSameQuarter$1;
Object.keys(_index128).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index128[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index128[key];
    },
  });
});
var _index129 = isSameSecond$1;
Object.keys(_index129).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index129[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index129[key];
    },
  });
});
var _index130 = isSameWeek$1;
Object.keys(_index130).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index130[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index130[key];
    },
  });
});
var _index131 = isSameYear$1;
Object.keys(_index131).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index131[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index131[key];
    },
  });
});
var _index132 = isSaturday$1;
Object.keys(_index132).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index132[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index132[key];
    },
  });
});
var _index133 = isSunday$1;
Object.keys(_index133).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index133[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index133[key];
    },
  });
});
var _index134 = isThisHour$1;
Object.keys(_index134).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index134[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index134[key];
    },
  });
});
var _index135 = isThisISOWeek$1;
Object.keys(_index135).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index135[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index135[key];
    },
  });
});
var _index136 = isThisMinute$1;
Object.keys(_index136).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index136[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index136[key];
    },
  });
});
var _index137 = isThisMonth$1;
Object.keys(_index137).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index137[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index137[key];
    },
  });
});
var _index138 = isThisQuarter$1;
Object.keys(_index138).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index138[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index138[key];
    },
  });
});
var _index139 = isThisSecond$1;
Object.keys(_index139).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index139[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index139[key];
    },
  });
});
var _index140 = isThisWeek$1;
Object.keys(_index140).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index140[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index140[key];
    },
  });
});
var _index141 = isThisYear$1;
Object.keys(_index141).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index141[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index141[key];
    },
  });
});
var _index142 = isThursday$1;
Object.keys(_index142).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index142[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index142[key];
    },
  });
});
var _index143 = isToday$1;
Object.keys(_index143).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index143[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index143[key];
    },
  });
});
var _index144 = isTomorrow$1;
Object.keys(_index144).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index144[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index144[key];
    },
  });
});
var _index145 = isTuesday$1;
Object.keys(_index145).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index145[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index145[key];
    },
  });
});
var _index146 = isValid$1;
Object.keys(_index146).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index146[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index146[key];
    },
  });
});
var _index147 = isWednesday$1;
Object.keys(_index147).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index147[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index147[key];
    },
  });
});
var _index148 = isWeekend$1;
Object.keys(_index148).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index148[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index148[key];
    },
  });
});
var _index149 = isWithinInterval$1;
Object.keys(_index149).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index149[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index149[key];
    },
  });
});
var _index150 = isYesterday$1;
Object.keys(_index150).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index150[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index150[key];
    },
  });
});
var _index151 = lastDayOfDecade$1;
Object.keys(_index151).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index151[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index151[key];
    },
  });
});
var _index152 = lastDayOfISOWeek$1;
Object.keys(_index152).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index152[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index152[key];
    },
  });
});
var _index153 = lastDayOfISOWeekYear$1;
Object.keys(_index153).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index153[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index153[key];
    },
  });
});
var _index154 = lastDayOfMonth$1;
Object.keys(_index154).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index154[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index154[key];
    },
  });
});
var _index155 = lastDayOfQuarter$1;
Object.keys(_index155).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index155[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index155[key];
    },
  });
});
var _index156 = lastDayOfWeek$1;
Object.keys(_index156).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index156[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index156[key];
    },
  });
});
var _index157 = lastDayOfYear$1;
Object.keys(_index157).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index157[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index157[key];
    },
  });
});
var _index158 = lightFormat;
Object.keys(_index158).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index158[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index158[key];
    },
  });
});
var _index159 = max$1;
Object.keys(_index159).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index159[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index159[key];
    },
  });
});
var _index160 = milliseconds$1;
Object.keys(_index160).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index160[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index160[key];
    },
  });
});
var _index161 = millisecondsToHours$1;
Object.keys(_index161).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index161[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index161[key];
    },
  });
});
var _index162 = millisecondsToMinutes$1;
Object.keys(_index162).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index162[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index162[key];
    },
  });
});
var _index163 = millisecondsToSeconds$1;
Object.keys(_index163).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index163[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index163[key];
    },
  });
});
var _index164 = min$1;
Object.keys(_index164).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index164[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index164[key];
    },
  });
});
var _index165 = minutesToHours$1;
Object.keys(_index165).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index165[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index165[key];
    },
  });
});
var _index166 = minutesToMilliseconds$1;
Object.keys(_index166).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index166[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index166[key];
    },
  });
});
var _index167 = minutesToSeconds$1;
Object.keys(_index167).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index167[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index167[key];
    },
  });
});
var _index168 = monthsToQuarters$1;
Object.keys(_index168).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index168[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index168[key];
    },
  });
});
var _index169 = monthsToYears$1;
Object.keys(_index169).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index169[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index169[key];
    },
  });
});
var _index170 = nextDay$1;
Object.keys(_index170).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index170[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index170[key];
    },
  });
});
var _index171 = nextFriday$1;
Object.keys(_index171).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index171[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index171[key];
    },
  });
});
var _index172 = nextMonday$1;
Object.keys(_index172).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index172[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index172[key];
    },
  });
});
var _index173 = nextSaturday$1;
Object.keys(_index173).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index173[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index173[key];
    },
  });
});
var _index174 = nextSunday$1;
Object.keys(_index174).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index174[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index174[key];
    },
  });
});
var _index175 = nextThursday$1;
Object.keys(_index175).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index175[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index175[key];
    },
  });
});
var _index176 = nextTuesday$1;
Object.keys(_index176).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index176[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index176[key];
    },
  });
});
var _index177 = nextWednesday$1;
Object.keys(_index177).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index177[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index177[key];
    },
  });
});
var _index178 = parse;
Object.keys(_index178).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index178[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index178[key];
    },
  });
});
var _index179 = parseISO$1;
Object.keys(_index179).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index179[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index179[key];
    },
  });
});
var _index180 = parseJSON$1;
Object.keys(_index180).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index180[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index180[key];
    },
  });
});
var _index181 = previousDay$1;
Object.keys(_index181).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index181[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index181[key];
    },
  });
});
var _index182 = previousFriday$1;
Object.keys(_index182).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index182[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index182[key];
    },
  });
});
var _index183 = previousMonday$1;
Object.keys(_index183).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index183[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index183[key];
    },
  });
});
var _index184 = previousSaturday$1;
Object.keys(_index184).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index184[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index184[key];
    },
  });
});
var _index185 = previousSunday$1;
Object.keys(_index185).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index185[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index185[key];
    },
  });
});
var _index186 = previousThursday$1;
Object.keys(_index186).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index186[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index186[key];
    },
  });
});
var _index187 = previousTuesday$1;
Object.keys(_index187).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index187[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index187[key];
    },
  });
});
var _index188 = previousWednesday$1;
Object.keys(_index188).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index188[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index188[key];
    },
  });
});
var _index189 = quartersToMonths$1;
Object.keys(_index189).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index189[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index189[key];
    },
  });
});
var _index190 = quartersToYears$1;
Object.keys(_index190).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index190[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index190[key];
    },
  });
});
var _index191 = roundToNearestHours$1;
Object.keys(_index191).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index191[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index191[key];
    },
  });
});
var _index192 = roundToNearestMinutes$1;
Object.keys(_index192).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index192[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index192[key];
    },
  });
});
var _index193 = secondsToHours$1;
Object.keys(_index193).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index193[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index193[key];
    },
  });
});
var _index194 = secondsToMilliseconds$1;
Object.keys(_index194).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index194[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index194[key];
    },
  });
});
var _index195 = secondsToMinutes$1;
Object.keys(_index195).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index195[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index195[key];
    },
  });
});
var _index196 = set$1;
Object.keys(_index196).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index196[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index196[key];
    },
  });
});
var _index197 = setDate$1;
Object.keys(_index197).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index197[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index197[key];
    },
  });
});
var _index198 = setDay$1;
Object.keys(_index198).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index198[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index198[key];
    },
  });
});
var _index199 = setDayOfYear$1;
Object.keys(_index199).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index199[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index199[key];
    },
  });
});
var _index200 = setDefaultOptions$1;
Object.keys(_index200).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index200[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index200[key];
    },
  });
});
var _index201 = setHours$1;
Object.keys(_index201).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index201[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index201[key];
    },
  });
});
var _index202 = setISODay$1;
Object.keys(_index202).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index202[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index202[key];
    },
  });
});
var _index203 = setISOWeek$1;
Object.keys(_index203).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index203[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index203[key];
    },
  });
});
var _index204 = setISOWeekYear$1;
Object.keys(_index204).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index204[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index204[key];
    },
  });
});
var _index205 = setMilliseconds$1;
Object.keys(_index205).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index205[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index205[key];
    },
  });
});
var _index206 = setMinutes$1;
Object.keys(_index206).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index206[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index206[key];
    },
  });
});
var _index207 = setMonth$1;
Object.keys(_index207).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index207[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index207[key];
    },
  });
});
var _index208 = setQuarter$1;
Object.keys(_index208).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index208[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index208[key];
    },
  });
});
var _index209 = setSeconds$1;
Object.keys(_index209).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index209[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index209[key];
    },
  });
});
var _index210 = setWeek$1;
Object.keys(_index210).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index210[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index210[key];
    },
  });
});
var _index211 = setWeekYear$1;
Object.keys(_index211).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index211[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index211[key];
    },
  });
});
var _index212 = setYear$1;
Object.keys(_index212).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index212[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index212[key];
    },
  });
});
var _index213 = startOfDay$1;
Object.keys(_index213).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index213[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index213[key];
    },
  });
});
var _index214 = startOfDecade$1;
Object.keys(_index214).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index214[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index214[key];
    },
  });
});
var _index215 = startOfHour$1;
Object.keys(_index215).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index215[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index215[key];
    },
  });
});
var _index216 = startOfISOWeek$1;
Object.keys(_index216).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index216[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index216[key];
    },
  });
});
var _index217 = startOfISOWeekYear$1;
Object.keys(_index217).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index217[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index217[key];
    },
  });
});
var _index218 = startOfMinute$1;
Object.keys(_index218).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index218[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index218[key];
    },
  });
});
var _index219 = startOfMonth$1;
Object.keys(_index219).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index219[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index219[key];
    },
  });
});
var _index220 = startOfQuarter$1;
Object.keys(_index220).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index220[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index220[key];
    },
  });
});
var _index221 = startOfSecond$1;
Object.keys(_index221).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index221[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index221[key];
    },
  });
});
var _index222 = startOfToday$1;
Object.keys(_index222).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index222[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index222[key];
    },
  });
});
var _index223 = startOfTomorrow$1;
Object.keys(_index223).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index223[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index223[key];
    },
  });
});
var _index224 = startOfWeek$1;
Object.keys(_index224).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index224[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index224[key];
    },
  });
});
var _index225 = startOfWeekYear$1;
Object.keys(_index225).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index225[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index225[key];
    },
  });
});
var _index226 = startOfYear$1;
Object.keys(_index226).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index226[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index226[key];
    },
  });
});
var _index227 = startOfYesterday$1;
Object.keys(_index227).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index227[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index227[key];
    },
  });
});
var _index228 = sub$1;
Object.keys(_index228).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index228[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index228[key];
    },
  });
});
var _index229 = subBusinessDays$1;
Object.keys(_index229).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index229[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index229[key];
    },
  });
});
var _index230 = subDays$1;
Object.keys(_index230).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index230[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index230[key];
    },
  });
});
var _index231 = subHours$1;
Object.keys(_index231).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index231[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index231[key];
    },
  });
});
var _index232 = subISOWeekYears$1;
Object.keys(_index232).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index232[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index232[key];
    },
  });
});
var _index233 = subMilliseconds$1;
Object.keys(_index233).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index233[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index233[key];
    },
  });
});
var _index234 = subMinutes$1;
Object.keys(_index234).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index234[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index234[key];
    },
  });
});
var _index235 = subMonths$1;
Object.keys(_index235).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index235[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index235[key];
    },
  });
});
var _index236 = subQuarters$1;
Object.keys(_index236).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index236[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index236[key];
    },
  });
});
var _index237 = subSeconds$1;
Object.keys(_index237).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index237[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index237[key];
    },
  });
});
var _index238 = subWeeks$1;
Object.keys(_index238).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index238[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index238[key];
    },
  });
});
var _index239 = subYears$1;
Object.keys(_index239).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index239[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index239[key];
    },
  });
});
var _index240 = toDate$1;
Object.keys(_index240).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index240[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index240[key];
    },
  });
});
var _index241 = transpose$1;
Object.keys(_index241).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index241[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index241[key];
    },
  });
});
var _index242 = weeksToDays$1;
Object.keys(_index242).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index242[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index242[key];
    },
  });
});
var _index243 = yearsToDays$1;
Object.keys(_index243).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index243[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index243[key];
    },
  });
});
var _index244 = yearsToMonths$1;
Object.keys(_index244).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index244[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index244[key];
    },
  });
});
var _index245 = yearsToQuarters$1;
Object.keys(_index245).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index245[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index245[key];
    },
  });
});
}(dateFns));

const initialState$2 = {
    tax_statement: null,
    roomTypes: undefined,
    enableBooking: false,
    ratePlanSelections: {},
    bookingAvailabilityParams: {
        from_date: null,
        to_date: null,
        adult_nbr: 0,
        child_nbr: 0,
    },
};
const { state: booking_store, onChange: onRoomTypeChange } = index.createStore(initialState$2);
onRoomTypeChange('roomTypes', (newValue) => {
    const currentSelections = booking_store.ratePlanSelections;
    const ratePlanSelections = {};
    console.log(newValue);
    newValue.forEach(roomType => {
        if (roomType.is_active) {
            ratePlanSelections[roomType.id] = ratePlanSelections[roomType.id] || {};
            roomType.rateplans.forEach(ratePlan => {
                if (ratePlan.is_active && ratePlan.variations && ratePlan.variations.length > 0) {
                    const currentRatePlanSelection = currentSelections[roomType.id] && currentSelections[roomType.id][ratePlan.id];
                    ratePlanSelections[roomType.id][ratePlan.id] = currentRatePlanSelection
                        ? Object.assign(Object.assign({}, currentRatePlanSelection), { ratePlan, visibleInventory: currentRatePlanSelection.visibleInventory, selected_variation: ratePlan.variations[ratePlan.variations.length - 1], guestName: currentRatePlanSelection.guestName, roomtype: {
                                id: roomType.id,
                                name: roomType.name,
                                physicalrooms: null,
                                rateplans: null,
                                availabilities: null,
                                inventory: roomType.inventory,
                                rate: roomType.rate,
                                smoking_option: roomType.smoking_option,
                                bedding_setup: roomType.bedding_setup,
                                pre_payment_amount: roomType.pre_payment_amount,
                            } }) : {
                        reserved: 0,
                        visibleInventory: roomType.inventory === 1 ? 2 : roomType.inventory,
                        selected_variation: ratePlan.variations[ratePlan.variations.length - 1],
                        ratePlan,
                        guestName: [],
                        is_bed_configuration_enabled: roomType.is_bed_configuration_enabled,
                        roomtype: {
                            id: roomType.id,
                            name: roomType.name,
                            physicalrooms: null,
                            rateplans: null,
                            availabilities: null,
                            inventory: roomType.inventory,
                            rate: roomType.rate,
                            smoking_option: roomType.smoking_option,
                            bedding_setup: roomType.bedding_setup,
                            pre_payment_amount: roomType.pre_payment_amount,
                        },
                        checkoutVariations: [],
                        checkoutBedSelection: [],
                        checkoutSmokingSelection: [],
                    };
                }
            });
        }
    });
    console.log(ratePlanSelections);
    booking_store.ratePlanSelections = ratePlanSelections;
});
function updateInventory(roomTypeId) {
    const roomTypeSelection = booking_store.ratePlanSelections[roomTypeId];
    const calculateTotalSelectedRoomsExcludingIndex = (excludedRatePlanId) => {
        return Object.entries(roomTypeSelection).reduce((acc, [ratePlanId, ratePlan]) => {
            return Number(ratePlanId) !== excludedRatePlanId ? acc + ratePlan.reserved : acc;
        }, 0);
    };
    const newRatePlans = Object.fromEntries(Object.entries(roomTypeSelection).map(([ratePlanId, ratePlan]) => {
        const totalSelectedRoomsExcludingCurrent = calculateTotalSelectedRoomsExcludingIndex(Number(ratePlanId));
        const roomTypeData = booking_store.roomTypes.find(rt => rt.id === roomTypeId);
        const availableRooms = roomTypeData ? (roomTypeData.inventory === 1 ? 2 : roomTypeData.inventory) - totalSelectedRoomsExcludingCurrent : 0;
        return [
            ratePlanId,
            Object.assign(Object.assign({}, ratePlan), { visibleInventory: availableRooms > 0 ? availableRooms : 0 }),
        ];
    }));
    if (JSON.stringify(roomTypeSelection) !== JSON.stringify(newRatePlans)) {
        booking_store.ratePlanSelections = Object.assign(Object.assign({}, booking_store.ratePlanSelections), { [roomTypeId]: newRatePlans });
    }
}
function updateRoomParams({ ratePlanId, roomTypeId, params }) {
    booking_store.ratePlanSelections = Object.assign(Object.assign({}, booking_store.ratePlanSelections), { [Number(roomTypeId)]: Object.assign(Object.assign({}, booking_store.ratePlanSelections[Number(roomTypeId)]), { [ratePlanId]: Object.assign(Object.assign({}, booking_store.ratePlanSelections[roomTypeId][ratePlanId]), params) }) });
}
function reserveRooms(roomTypeId, ratePlanId, rooms) {
    if (!booking_store.ratePlanSelections[roomTypeId]) {
        booking_store.ratePlanSelections[roomTypeId] = {};
    }
    const roomType = booking_store.roomTypes.find(r => r.id === roomTypeId);
    if (!roomType) {
        throw new Error('Invalid room type id');
    }
    const ratePlan = roomType.rateplans.find(r => r.id === ratePlanId);
    if (!ratePlan) {
        throw new Error('Invalid rate plan');
    }
    if (!booking_store.ratePlanSelections[roomTypeId][ratePlanId]) {
        booking_store.ratePlanSelections[roomTypeId][ratePlanId] = {
            guestName: null,
            reserved: 0,
            is_bed_configuration_enabled: roomType.is_bed_configuration_enabled,
            visibleInventory: 0,
            selected_variation: null,
            ratePlan,
            checkoutVariations: [],
            checkoutBedSelection: [],
            checkoutSmokingSelection: [],
            roomtype: {
                id: roomType.id,
                name: roomType.name,
                physicalrooms: null,
                rateplans: null,
                availabilities: null,
                inventory: roomType.inventory,
                rate: roomType.rate,
                bedding_setup: roomType.bedding_setup,
                smoking_option: roomType.smoking_option,
                pre_payment_amount: roomType.pre_payment_amount,
            },
        };
    }
    booking_store.ratePlanSelections = Object.assign(Object.assign({}, booking_store.ratePlanSelections), { [Number(roomTypeId)]: Object.assign(Object.assign({}, booking_store.ratePlanSelections[Number(roomTypeId)]), { [ratePlanId]: Object.assign(Object.assign({}, booking_store.ratePlanSelections[roomTypeId][ratePlanId]), { reserved: rooms }) }) });
    updateInventory(roomTypeId);
}
function getVisibleInventory(roomTypeId, ratePlanId) {
    if (!booking_store.ratePlanSelections || !booking_store.ratePlanSelections[roomTypeId]) {
        return { reserved: 0, visibleInventory: 0, selected_variation: null };
    }
    return booking_store.ratePlanSelections[roomTypeId][ratePlanId];
}
function modifyBookingStore(key, value) {
    booking_store[key] = value;
}
function calculateTotalCost() {
    let prePaymentAmount = 0;
    let totalAmount = 0;
    totalAmount = Object.values(booking_store.ratePlanSelections).reduce((total, value) => {
        return (total +
            Object.values(value).reduce((innerTotal, ratePlan) => {
                var _a;
                let cost = 0;
                if (ratePlan.checkoutVariations.length > 0) {
                    cost = ratePlan.checkoutVariations.reduce((old, v) => old + v.amount, 0);
                }
                else {
                    cost = ratePlan.reserved > 0 ? ratePlan.reserved * ((_a = ratePlan.selected_variation.amount) !== null && _a !== void 0 ? _a : 0) : 0;
                }
                return innerTotal + cost;
            }, 0));
    }, 0);
    prePaymentAmount = Object.values(booking_store.ratePlanSelections).reduce((total, value) => {
        return (total +
            Object.values(value).reduce((innerTotal, ratePlan) => {
                var _a;
                let cost = 0;
                if (ratePlan.checkoutVariations.length > 0) {
                    cost = ratePlan.checkoutVariations.reduce((old, v) => old + v.amount, 0);
                }
                else {
                    cost = ratePlan.reserved > 0 ? ratePlan.reserved * ((_a = ratePlan.roomtype.pre_payment_amount) !== null && _a !== void 0 ? _a : 0) : 0;
                }
                return innerTotal + cost;
            }, 0));
    }, 0);
    return { totalAmount, prePaymentAmount };
}

const initialState$1 = {
    userFormData: {},
    modifiedGuestName: false,
    pickup: {
        arrival_date: dateFns.format(new Date(), 'yyyy-MM-dd'),
    },
};
const { state: checkout_store, onChange: onCheckoutDataChange } = index.createStore(initialState$1);
function updateUserFormData(key, value) {
    checkout_store.userFormData = Object.assign(Object.assign({}, checkout_store.userFormData), { [key]: value });
}
function updatePickupFormData(key, value) {
    if (key === 'location' && value === null) {
        checkout_store.pickup = {
            arrival_date: dateFns.format(new Date(), 'yyyy-MM-dd'),
            location: null,
        };
    }
    else {
        checkout_store.pickup = Object.assign(Object.assign({}, checkout_store.pickup), { [key]: value });
    }
}
function updatePartialPickupFormData(params) {
    checkout_store.pickup = Object.assign(Object.assign({}, checkout_store.pickup), params);
}

function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

var bundleCjs = {};

(function (exports) {

Object.defineProperty(exports, Symbol.toStringTag, {
  value: 'Module'
});
const CLASS_PART_SEPARATOR = '-';
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
    if (classParts[0] === '' && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return undefined;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
}
const arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
    if (property) {
      // I use two dots here because one dot is used as prefix for class groups in plugins
      return 'arbitrary..' + property;
    }
  }
}
/**
 * Exported for testing only
 */
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach(classDefinition => {
    if (typeof classDefinition === 'string') {
      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === 'function') {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup]) => {
      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map(classDefinition => {
      if (typeof classDefinition === 'string') {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === 'object') {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}

// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => undefined,
      set: () => {}
    };
  }
  let cacheSize = 0;
  let cache = new Map();
  let previousCache = new Map();
  function update(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = new Map();
    }
  }
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== undefined) {
        return value;
      }
      if ((value = previousCache.get(key)) !== undefined) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}
const IMPORTANT_MODIFIER = '!';
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === '/') {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === '[') {
        bracketDepth++;
      } else if (currentCharacter === ']') {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach(modifier => {
    const isArbitraryVariant = modifier[0] === '[';
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
const SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  /**
   * Set of classGroupIds in following format:
   * `{importantModifier}{variantModifiers}{classGroupId}`
   * @example 'float'
   * @example 'hover:focus:bg-color'
   * @example 'md:!pr'
   */
  const classGroupsInConflict = new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(originalClassName => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(':');
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse()
  // Last class in conflict wins, so we need to filter conflicting classes in reverse order.
  .filter(parsed => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(group => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map(parsed => parsed.originalClassName).join(' ');
}

/**
 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
 *
 * Specifically:
 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
 *
 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
 */
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = '';
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += ' ');
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === 'string') {
    return mix;
  }
  let resolvedValue;
  let string = '';
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += ' ');
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  const themeGetter = theme => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
// Shadow always begins with x and y offset separated by underscore optionally prepended by inset
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, 'length', isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, 'number', isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith('%') && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
const sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, 'position', isNever);
}
const imageLabels = /*#__PURE__*/new Set(['image', 'url']);
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, '', isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === 'string' ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
const validators = /*#__PURE__*/Object.defineProperty({
  __proto__: null,
  isAny,
  isArbitraryImage,
  isArbitraryLength,
  isArbitraryNumber,
  isArbitraryPosition,
  isArbitraryShadow,
  isArbitrarySize,
  isArbitraryValue,
  isInteger,
  isLength,
  isNumber,
  isPercent,
  isTshirtSize
}, Symbol.toStringTag, {
  value: 'Module'
});
function getDefaultConfig() {
  const colors = fromTheme('colors');
  const spacing = fromTheme('spacing');
  const blur = fromTheme('blur');
  const brightness = fromTheme('brightness');
  const borderColor = fromTheme('borderColor');
  const borderRadius = fromTheme('borderRadius');
  const borderSpacing = fromTheme('borderSpacing');
  const borderWidth = fromTheme('borderWidth');
  const contrast = fromTheme('contrast');
  const grayscale = fromTheme('grayscale');
  const hueRotate = fromTheme('hueRotate');
  const invert = fromTheme('invert');
  const gap = fromTheme('gap');
  const gradientColorStops = fromTheme('gradientColorStops');
  const gradientColorStopPositions = fromTheme('gradientColorStopPositions');
  const inset = fromTheme('inset');
  const margin = fromTheme('margin');
  const opacity = fromTheme('opacity');
  const padding = fromTheme('padding');
  const saturate = fromTheme('saturate');
  const scale = fromTheme('scale');
  const sepia = fromTheme('sepia');
  const skew = fromTheme('skew');
  const space = fromTheme('space');
  const translate = fromTheme('translate');
  const getOverscroll = () => ['auto', 'contain', 'none'];
  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];
  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ['', isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber, isArbitraryValue];
  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];
  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];
  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'plus-lighter'];
  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];
  const getZeroAndEmpty = () => ['', '0', isArbitraryValue];
  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ':',
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ['none', '', isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ['auto', 'square', 'video', isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ['container'],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      'break-after': [{
        'break-after': getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      'break-before': [{
        'break-before': getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      'break-inside': [{
        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      'box-decoration': [{
        'box-decoration': ['slice', 'clone']
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ['border', 'content']
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ['right', 'left', 'none', 'start', 'end']
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ['left', 'right', 'both', 'none', 'start', 'end']
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ['isolate', 'isolation-auto'],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      'object-fit': [{
        object: ['contain', 'cover', 'fill', 'none', 'scale-down']
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      'object-position': [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      'overflow-x': [{
        'overflow-x': getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      'overflow-y': [{
        'overflow-y': getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      'overscroll-x': [{
        'overscroll-x': getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      'overscroll-y': [{
        'overscroll-y': getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      'inset-x': [{
        'inset-x': [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      'inset-y': [{
        'inset-y': [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ['visible', 'invisible', 'collapse'],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ['auto', isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      'flex-direction': [{
        flex: ['row', 'row-reverse', 'col', 'col-reverse']
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      'flex-wrap': [{
        flex: ['wrap', 'wrap-reverse', 'nowrap']
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ['first', 'last', 'none', isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      'grid-cols': [{
        'grid-cols': [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      'col-start-end': [{
        col: ['auto', {
          span: ['full', isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      'col-start': [{
        'col-start': getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      'col-end': [{
        'col-end': getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      'grid-rows': [{
        'grid-rows': [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      'row-start-end': [{
        row: ['auto', {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      'row-start': [{
        'row-start': getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      'row-end': [{
        'row-end': getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      'grid-flow': [{
        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      'auto-cols': [{
        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      'auto-rows': [{
        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      'gap-x': [{
        'gap-x': [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      'gap-y': [{
        'gap-y': [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      'justify-content': [{
        justify: ['normal', ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      'justify-items': [{
        'justify-items': ['start', 'end', 'center', 'stretch']
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      'justify-self': [{
        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      'align-content': [{
        content: ['normal', ...getAlign(), 'baseline']
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      'align-items': [{
        items: ['start', 'end', 'center', 'baseline', 'stretch']
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      'align-self': [{
        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      'place-content': [{
        'place-content': [...getAlign(), 'baseline']
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      'place-items': [{
        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      'place-self': [{
        'place-self': ['auto', 'start', 'end', 'center', 'stretch']
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      'space-x': [{
        'space-x': [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      'space-x-reverse': ['space-x-reverse'],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      'space-y': [{
        'space-y': [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      'space-y-reverse': ['space-y-reverse'],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      'min-w': [{
        'min-w': [isArbitraryValue, spacing, 'min', 'max', 'fit']
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      'max-w': [{
        'max-w': [isArbitraryValue, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      'min-h': [{
        'min-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      'max-h': [{
        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      'font-size': [{
        text: ['base', isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      'font-smoothing': ['antialiased', 'subpixel-antialiased'],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      'font-style': ['italic', 'not-italic'],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      'font-weight': [{
        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      'font-family': [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-normal': ['normal-nums'],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-ordinal': ['ordinal'],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-slashed-zero': ['slashed-zero'],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-figure': ['lining-nums', 'oldstyle-nums'],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-spacing': ['proportional-nums', 'tabular-nums'],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      'line-clamp': [{
        'line-clamp': ['none', isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      'list-image': [{
        'list-image': ['none', isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      'list-style-type': [{
        list: ['none', 'disc', 'decimal', isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      'list-style-position': [{
        list: ['inside', 'outside']
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      'placeholder-color': [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      'placeholder-opacity': [{
        'placeholder-opacity': [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      'text-alignment': [{
        text: ['left', 'center', 'right', 'justify', 'start', 'end']
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      'text-color': [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      'text-opacity': [{
        'text-opacity': [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      'text-decoration-style': [{
        decoration: [...getLineStyles(), 'wavy']
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      'text-decoration-thickness': [{
        decoration: ['auto', 'from-font', isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      'underline-offset': [{
        'underline-offset': ['auto', isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      'text-decoration-color': [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      'text-wrap': [{
        text: ['wrap', 'nowrap', 'balance', 'pretty']
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      'vertical-align': [{
        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ['normal', 'words', 'all', 'keep']
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ['none', 'manual', 'auto']
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ['none', isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      'bg-attachment': [{
        bg: ['fixed', 'local', 'scroll']
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      'bg-clip': [{
        'bg-clip': ['border', 'padding', 'content', 'text']
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      'bg-opacity': [{
        'bg-opacity': [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      'bg-origin': [{
        'bg-origin': ['border', 'padding', 'content']
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      'bg-position': [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      'bg-repeat': [{
        bg: ['no-repeat', {
          repeat: ['', 'x', 'y', 'round', 'space']
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      'bg-size': [{
        bg: ['auto', 'cover', 'contain', isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      'bg-image': [{
        bg: ['none', {
          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      'bg-color': [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-from-pos': [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-via-pos': [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-to-pos': [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-from': [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-via': [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      'gradient-to': [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-s': [{
        'rounded-s': [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-e': [{
        'rounded-e': [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-t': [{
        'rounded-t': [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-r': [{
        'rounded-r': [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-b': [{
        'rounded-b': [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-l': [{
        'rounded-l': [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-ss': [{
        'rounded-ss': [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-se': [{
        'rounded-se': [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-ee': [{
        'rounded-ee': [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-es': [{
        'rounded-es': [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-tl': [{
        'rounded-tl': [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-tr': [{
        'rounded-tr': [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-br': [{
        'rounded-br': [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      'rounded-bl': [{
        'rounded-bl': [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w': [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-x': [{
        'border-x': [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-y': [{
        'border-y': [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-s': [{
        'border-s': [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-e': [{
        'border-e': [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-t': [{
        'border-t': [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-r': [{
        'border-r': [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-b': [{
        'border-b': [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      'border-w-l': [{
        'border-l': [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      'border-opacity': [{
        'border-opacity': [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      'border-style': [{
        border: [...getLineStyles(), 'hidden']
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      'divide-x': [{
        'divide-x': [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      'divide-x-reverse': ['divide-x-reverse'],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      'divide-y': [{
        'divide-y': [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      'divide-y-reverse': ['divide-y-reverse'],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      'divide-opacity': [{
        'divide-opacity': [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      'divide-style': [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color': [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-x': [{
        'border-x': [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-y': [{
        'border-y': [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-t': [{
        'border-t': [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-r': [{
        'border-r': [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-b': [{
        'border-b': [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      'border-color-l': [{
        'border-l': [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      'divide-color': [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      'outline-style': [{
        outline: ['', ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      'outline-offset': [{
        'outline-offset': [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      'outline-w': [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      'outline-color': [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      'ring-w': [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      'ring-w-inset': ['ring-inset'],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      'ring-color': [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      'ring-opacity': [{
        'ring-opacity': [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      'ring-offset-w': [{
        'ring-offset': [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      'ring-offset-color': [{
        'ring-offset': [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      'shadow-color': [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      'mix-blend': [{
        'mix-blend': getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      'bg-blend': [{
        'bg-blend': getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ['', 'none']
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      'drop-shadow': [{
        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      'hue-rotate': [{
        'hue-rotate': [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      'backdrop-filter': [{
        'backdrop-filter': ['', 'none']
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      'backdrop-blur': [{
        'backdrop-blur': [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      'backdrop-brightness': [{
        'backdrop-brightness': [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      'backdrop-contrast': [{
        'backdrop-contrast': [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      'backdrop-grayscale': [{
        'backdrop-grayscale': [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      'backdrop-hue-rotate': [{
        'backdrop-hue-rotate': [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      'backdrop-invert': [{
        'backdrop-invert': [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      'backdrop-opacity': [{
        'backdrop-opacity': [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      'backdrop-saturate': [{
        'backdrop-saturate': [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      'backdrop-sepia': [{
        'backdrop-sepia': [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      'border-collapse': [{
        border: ['collapse', 'separate']
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      'border-spacing': [{
        'border-spacing': [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      'border-spacing-x': [{
        'border-spacing-x': [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      'border-spacing-y': [{
        'border-spacing-y': [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      'table-layout': [{
        table: ['auto', 'fixed']
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ['top', 'bottom']
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ['', 'gpu', 'none']
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      'scale-x': [{
        'scale-x': [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      'scale-y': [{
        'scale-y': [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      'translate-x': [{
        'translate-x': [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      'translate-y': [{
        'translate-y': [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      'skew-x': [{
        'skew-x': [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      'skew-y': [{
        'skew-y': [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      'transform-origin': [{
        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ['auto', colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ['none', 'auto']
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      'caret-color': [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      'pointer-events': [{
        'pointer-events': ['none', 'auto']
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ['none', 'y', 'x', '']
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      'scroll-behavior': [{
        scroll: ['auto', 'smooth']
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-m': [{
        'scroll-m': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-mx': [{
        'scroll-mx': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-my': [{
        'scroll-my': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-ms': [{
        'scroll-ms': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-me': [{
        'scroll-me': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-mt': [{
        'scroll-mt': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-mr': [{
        'scroll-mr': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-mb': [{
        'scroll-mb': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      'scroll-ml': [{
        'scroll-ml': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-p': [{
        'scroll-p': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-px': [{
        'scroll-px': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-py': [{
        'scroll-py': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-ps': [{
        'scroll-ps': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-pe': [{
        'scroll-pe': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-pt': [{
        'scroll-pt': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-pr': [{
        'scroll-pr': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-pb': [{
        'scroll-pb': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      'scroll-pl': [{
        'scroll-pl': getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      'snap-align': [{
        snap: ['start', 'end', 'center', 'align-none']
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      'snap-stop': [{
        snap: ['normal', 'always']
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      'snap-type': [{
        snap: ['none', 'x', 'y', 'both']
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      'snap-strictness': [{
        snap: ['mandatory', 'proximity']
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ['auto', 'none', 'manipulation']
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      'touch-x': [{
        'touch-pan': ['x', 'left', 'right']
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      'touch-y': [{
        'touch-pan': ['y', 'up', 'down']
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      'touch-pz': ['touch-pinch-zoom'],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ['none', 'text', 'all', 'auto']
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      'will-change': [{
        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, 'none']
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      'stroke-w': [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, 'none']
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ['sr-only', 'not-sr-only'],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      'forced-color-adjust': [{
        'forced-color-adjust': ['auto', 'none']
      }]
    },
    conflictingClassGroups: {
      overflow: ['overflow-x', 'overflow-y'],
      overscroll: ['overscroll-x', 'overscroll-y'],
      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
      'inset-x': ['right', 'left'],
      'inset-y': ['top', 'bottom'],
      flex: ['basis', 'grow', 'shrink'],
      gap: ['gap-x', 'gap-y'],
      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
      px: ['pr', 'pl'],
      py: ['pt', 'pb'],
      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
      mx: ['mr', 'ml'],
      my: ['mt', 'mb'],
      size: ['w', 'h'],
      'font-size': ['leading'],
      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],
      'fvn-ordinal': ['fvn-normal'],
      'fvn-slashed-zero': ['fvn-normal'],
      'fvn-figure': ['fvn-normal'],
      'fvn-spacing': ['fvn-normal'],
      'fvn-fraction': ['fvn-normal'],
      'line-clamp': ['display', 'overflow'],
      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],
      'rounded-s': ['rounded-ss', 'rounded-es'],
      'rounded-e': ['rounded-se', 'rounded-ee'],
      'rounded-t': ['rounded-tl', 'rounded-tr'],
      'rounded-r': ['rounded-tr', 'rounded-br'],
      'rounded-b': ['rounded-br', 'rounded-bl'],
      'rounded-l': ['rounded-tl', 'rounded-bl'],
      'border-spacing': ['border-spacing-x', 'border-spacing-y'],
      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],
      'border-w-x': ['border-w-r', 'border-w-l'],
      'border-w-y': ['border-w-t', 'border-w-b'],
      'border-color': ['border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],
      'border-color-x': ['border-color-r', 'border-color-l'],
      'border-color-y': ['border-color-t', 'border-color-b'],
      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],
      'scroll-mx': ['scroll-mr', 'scroll-ml'],
      'scroll-my': ['scroll-mt', 'scroll-mb'],
      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],
      'scroll-px': ['scroll-pr', 'scroll-pl'],
      'scroll-py': ['scroll-pt', 'scroll-pb'],
      touch: ['touch-x', 'touch-y', 'touch-pz'],
      'touch-x': ['touch'],
      'touch-y': ['touch'],
      'touch-pz': ['touch']
    },
    conflictingClassGroupModifiers: {
      'font-size': ['leading']
    }
  };
}

/**
 * @param baseConfig Config where other config will be merged into. This object will be mutated.
 * @param configExtension Partial config to merge into the `baseConfig`.
 */
function mergeConfigs(baseConfig, {
  cacheSize,
  prefix,
  separator,
  extend = {},
  override = {}
}) {
  overrideProperty(baseConfig, 'cacheSize', cacheSize);
  overrideProperty(baseConfig, 'prefix', prefix);
  overrideProperty(baseConfig, 'separator', separator);
  for (const configKey in override) {
    overrideConfigProperties(baseConfig[configKey], override[configKey]);
  }
  for (const key in extend) {
    mergeConfigProperties(baseConfig[key], extend[key]);
  }
  return baseConfig;
}
function overrideProperty(baseObject, overrideKey, overrideValue) {
  if (overrideValue !== undefined) {
    baseObject[overrideKey] = overrideValue;
  }
}
function overrideConfigProperties(baseObject, overrideObject) {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
}
function mergeConfigProperties(baseObject, mergeObject) {
  if (mergeObject) {
    for (const key in mergeObject) {
      const mergeValue = mergeObject[key];
      if (mergeValue !== undefined) {
        baseObject[key] = (baseObject[key] || []).concat(mergeValue);
      }
    }
  }
}
function extendTailwindMerge(configExtension, ...createConfig) {
  return typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
}
const twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);
exports.createTailwindMerge = createTailwindMerge;
exports.extendTailwindMerge = extendTailwindMerge;
exports.fromTheme = fromTheme;
exports.getDefaultConfig = getDefaultConfig;
exports.mergeConfigs = mergeConfigs;
exports.twJoin = twJoin;
exports.twMerge = twMerge;
exports.validators = validators;

}(bundleCjs));

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const localeMap = {
    en: locale.enUS,
    ar: locale.ar,
    fr: locale.fr,
    es: locale.es,
    de: locale.de,
    pl: locale.pl,
    ua: locale.uk,
    ru: locale.ru,
    el: locale.el,
};
function matchLocale(locale$1) {
    return localeMap[locale$1.toLowerCase()] || locale.enUS;
}
function getAbbreviatedWeekdays(locale) {
    const baseDate = new Date(2020, 5, 7);
    let weekdays = [];
    for (let i = 0; i < 7; i++) {
        const weekday = dateFns.format(dateFns.addDays(baseDate, i), 'eee', { locale });
        weekdays.push(weekday);
    }
    return weekdays.slice(1, 7).concat(weekdays.slice(0, 1));
}
function cn(...inputs) {
    return bundleCjs.twMerge(clsx(inputs));
}
const formatAmount = (amount, currency = 'USD') => {
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: currency }).format(amount);
};
function hexToHSL(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    let r = parseInt(result[1], 16);
    let g = parseInt(result[2], 16);
    let b = parseInt(result[3], 16);
    (r /= 255), (g /= 255), (b /= 255);
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max == min) {
        h = s = 0; // achromatic
    }
    else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    s = s * 100;
    s = Math.round(s);
    l = l * 100;
    l = Math.round(l);
    h = Math.round(360 * h);
    return { h, s, l };
}
function generateColorShades(baseHex) {
    const { h, s, l: baseL } = hexToHSL(baseHex);
    let shades = [];
    for (let i = -3; i <= 6; i++) {
        let l = baseL + i * 4;
        shades.push({ h, s, l: Math.min(Math.max(l, 0), 100) });
    }
    return shades;
}
function getDateDifference(date1, date2) {
    return dateFns.differenceInCalendarDays(date2, date1);
}
function renderTime(time) {
    return time < 10 ? time.toString().padStart(2, '0') : time.toString();
}
function getUserPrefernce() {
    const p = JSON.parse(localStorage.getItem('user_prefernce'));
    if (p) {
        const { direction } = p, others = __rest(p, ["direction"]);
        app_store.userPreferences = Object.assign({}, others);
        changeLocale(direction, matchLocale(p.language_id));
    }
}
function setDefaultLocale({ currency }) {
    app_store.userPreferences = Object.assign(Object.assign({}, app_store.userPreferences), { currency_id: currency.code.toString() });
    // matchLocale(language_id)
}

class PropertyService extends Token {
    async getExposedProperty(params) {
        const token = this.getToken();
        if (!token) {
            throw new MissingTokenError();
        }
        const { data } = await axios.axios.post(`/Get_Exposed_Property?Ticket=${token}`, params);
        const result = data;
        if (result.ExceptionMsg !== '') {
            throw new Error(result.ExceptionMsg);
        }
        if (!app_store.fetchedBooking) {
            booking_store.roomTypes = [...result.My_Result.roomtypes];
        }
        app_store.property = Object.assign({}, result.My_Result);
        return result.My_Result;
    }
    async getExposedBookingAvailability(params) {
        const token = this.getToken();
        if (!token) {
            throw new MissingTokenError();
        }
        let roomtypeIds = [];
        const { injected, roomtype_id } = app_store.app_data;
        if (injected) {
            roomtypeIds.push(roomtype_id);
        }
        const { data } = await axios.axios.post(`/Get_Exposed_Booking_Availability?Ticket=${token}`, Object.assign(Object.assign({}, params), { room_type_ids: roomtypeIds, skip_getting_assignable_units: true }));
        const result = data;
        if (result.ExceptionMsg !== '') {
            throw new Error(result.ExceptionMsg);
        }
        booking_store.roomTypes = [...result.My_Result.roomtypes];
        booking_store.tax_statement = { message: result.My_Result.tax_statement };
        booking_store.enableBooking = true;
        return result;
    }
    async fetchSetupEntries() {
        try {
            const token = this.getToken();
            if (token) {
                if (app_store.setup_entries) {
                    return app_store.setup_entries;
                }
                const { data } = await axios.axios.post(`/Get_Setup_Entries_By_TBL_NAME_MULTI?Ticket=${token}`, {
                    TBL_NAMES: ['_ARRIVAL_TIME', '_RATE_PRICING_MODE', '_BED_PREFERENCE_TYPE'],
                });
                if (data.ExceptionMsg !== '') {
                    throw new Error(data.ExceptionMsg);
                }
                const res = data.My_Result;
                const setupEntries = {
                    arrivalTime: res.filter(e => e.TBL_NAME === '_ARRIVAL_TIME'),
                    ratePricingMode: res.filter(e => e.TBL_NAME === '_RATE_PRICING_MODE'),
                    bedPreferenceType: res.filter(e => e.TBL_NAME === '_BED_PREFERENCE_TYPE'),
                };
                app_store.setup_entries = setupEntries;
                updateUserFormData('arrival_time', setupEntries.arrivalTime[0].CODE_NAME);
                return setupEntries;
            }
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
    generateDays(from_date, to_date, amount) {
        const endDate = to_date;
        let currentDate = from_date;
        const days = [];
        while (currentDate < endDate) {
            days.push({
                date: dateFns.format(currentDate, 'yyyy-MM-dd'),
                amount: amount,
                cost: null,
            });
            currentDate = dateFns.addDays(currentDate, 1);
        }
        return days;
    }
    filterRooms() {
        let rooms = [];
        Object.values(booking_store.ratePlanSelections).map(rt => {
            Object.values(rt).map((rp) => {
                if (rp.reserved > 0) {
                    [...new Array(rp.reserved)].map((_, index) => {
                        var _a, _b, _c;
                        rooms.push({
                            identifier: null,
                            roomtype: rp.roomtype,
                            rateplan: rp.ratePlan,
                            unit: null,
                            smoking_option: rp.checkoutSmokingSelection[index],
                            occupancy: {
                                adult_nbr: rp.checkoutVariations[index].adult_nbr,
                                children_nbr: rp.checkoutVariations[index].child_nbr,
                                infant_nbr: null,
                            },
                            bed_preference: rp.is_bed_configuration_enabled ? rp.checkoutBedSelection[index] : null,
                            from_date: dateFns.format(booking_store.bookingAvailabilityParams.from_date, 'yyyy-MM-dd'),
                            to_date: dateFns.format(booking_store.bookingAvailabilityParams.to_date, 'yyyy-MM-dd'),
                            notes: null,
                            days: this.generateDays(booking_store.bookingAvailabilityParams.from_date, booking_store.bookingAvailabilityParams.to_date, +rp.checkoutVariations[index].amount / getDateDifference(booking_store.bookingAvailabilityParams.from_date, booking_store.bookingAvailabilityParams.to_date)),
                            guest: {
                                email: null,
                                first_name: ((_a = checkout_store.userFormData) === null || _a === void 0 ? void 0 : _a.bookingForSomeoneElse)
                                    ? rp.guestName[index]
                                    : (((_b = checkout_store.userFormData) === null || _b === void 0 ? void 0 : _b.firstName) || '') + ' ' + (((_c = checkout_store.userFormData) === null || _c === void 0 ? void 0 : _c.lastName) || ''),
                                last_name: null,
                                country_id: null,
                                city: null,
                                mobile: null,
                                address: null,
                                dob: null,
                                subscribe_to_news_letter: null,
                            },
                        });
                    });
                }
            });
        });
        return rooms;
    }
    convertPickup(pickup) {
        let res = {};
        const [hour, minute] = pickup.arrival_time.split(':');
        res = {
            booking_nbr: null,
            is_remove: false,
            currency: pickup.currency,
            date: pickup.arrival_date,
            details: pickup.flight_details || null,
            hour: Number(hour),
            minute: Number(minute),
            nbr_of_units: pickup.number_of_vehicles,
            selected_option: pickup.selected_option,
            total: Number(pickup.due_upon_booking),
        };
        return res;
    }
    async bookUser() {
        var _a;
        try {
            const token = this.getToken();
            if (!token) {
                throw new MissingTokenError();
            }
            let guest = {
                email: checkout_store.userFormData.email,
                first_name: checkout_store.userFormData.firstName,
                last_name: checkout_store.userFormData.lastName,
                country_id: checkout_store.userFormData.country_id,
                city: null,
                mobile: checkout_store.userFormData.country_code + checkout_store.userFormData.mobile_number,
                address: '',
                dob: null,
                subscribe_to_news_letter: true,
                cci: null,
            };
            const body = {
                assign_units: false,
                check_in: false,
                is_pms: false,
                is_direct: true,
                agent: booking_store.bookingAvailabilityParams.agent ? { id: booking_store.bookingAvailabilityParams.agent } : null,
                is_in_loyalty_mode: booking_store.bookingAvailabilityParams.loyalty,
                promo_key: (_a = booking_store.bookingAvailabilityParams.coupon) !== null && _a !== void 0 ? _a : null,
                booking: {
                    booking_nbr: '',
                    from_date: dateFns.format(booking_store.bookingAvailabilityParams.from_date, 'yyyy-MM-dd'),
                    to_date: dateFns.format(booking_store.bookingAvailabilityParams.to_date, 'yyyy-MM-dd'),
                    remark: checkout_store.userFormData.message || null,
                    property: {
                        id: app_store.app_data.property_id,
                    },
                    source: null,
                    referrer_site: 'www.igloorooms.com',
                    currency: app_store.property.currency,
                    arrival: { code: checkout_store.userFormData.arrival_time },
                    guest,
                    rooms: this.filterRooms(),
                },
                pickup_info: checkout_store.pickup.location ? this.convertPickup(checkout_store.pickup) : null,
            };
            const { data } = await axios.axios.post(`/DoReservation?Ticket=${token}`, body);
            if (data.ExceptionMsg !== '') {
                throw new Error(data.ExceptionMsg);
            }
            return data['My_Result'];
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
}

const initialState = {
    entries: null,
    direction: 'ltr',
};
const { state: localizedWords, onChange: onCalendarDatesChange } = index.createStore(initialState);

class CommonService extends Token {
    async getCurrencies() {
        const token = this.getToken();
        if (!token) {
            throw new MissingTokenError();
        }
        const { data } = await axios.axios.post(`/Get_Exposed_Currencies?Ticket=${token}`);
        app_store.currencies = [...data['My_Result']];
        return data['My_Result'];
    }
    async getExposedLanguages() {
        const token = this.getToken();
        if (!token) {
            throw new MissingTokenError();
        }
        const { data } = await axios.axios.post(`/Get_Exposed_Languages?Ticket=${token}`);
        app_store.languages = [...data.My_Result];
        return data['My_Result'];
    }
    async getCountries(language) {
        try {
            const token = this.getToken();
            if (token) {
                const { data } = await axios.axios.post(`/Get_Exposed_Countries?Ticket=${token}`, {
                    language,
                });
                if (data.ExceptionMsg !== '') {
                    throw new Error(data.ExceptionMsg);
                }
                return data.My_Result;
            }
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
    async getUserDefaultCountry() {
        try {
            const token = this.getToken();
            if (token) {
                const { data } = await axios.axios.post(`/Get_Country_By_IP?Ticket=${token}`, {
                    IP: '',
                });
                if (data.ExceptionMsg !== '') {
                    throw new Error(data.ExceptionMsg);
                }
                return data['My_Result'];
            }
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
    async getExposedCountryByIp() {
        try {
            const token = this.getToken();
            if (token) {
                const { data } = await axios.axios.post(`/Get_Exposed_Country_By_IP?Ticket=${token}`, {
                    IP: '',
                    lang: 'en',
                });
                if (data.ExceptionMsg !== '') {
                    throw new Error(data.ExceptionMsg);
                }
                app_store.userDefaultCountry = data['My_Result'];
                return data['My_Result'];
            }
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
    async getBEToken() {
        try {
            const { data } = await axios.axios.post(`/Get_BE_Token`, {});
            if (data.ExceptionMsg !== '') {
                throw new Error(data.ExceptionMsg);
            }
            return data['My_Result'];
        }
        catch (error) {
            console.error(error);
            throw new Error(error);
        }
    }
    async getExposedLanguage() {
        try {
            const token = this.getToken();
            if (token !== null) {
                const { data } = await axios.axios.post(`/Get_Exposed_Language?Ticket=${token}`, { code: app_store.userPreferences.language_id, sections: ['_BE_FRONT'] });
                if (data.ExceptionMsg !== '') {
                    throw new Error(data.ExceptionMsg);
                }
                let entries = this.transformArrayToObject(data.My_Result.entries);
                localizedWords.entries = Object.assign(Object.assign({}, localizedWords.entries), entries);
                localizedWords.direction = data.My_Result.direction;
                return { entries, direction: data.My_Result.direction };
            }
        }
        catch (error) {
            console.log(error);
            throw new Error(error);
        }
    }
    transformArrayToObject(data) {
        let object = {};
        for (const d of data) {
            object[d.code] = d.description;
        }
        return object;
    }
}

exports.CommonService = CommonService;
exports.MissingTokenError = MissingTokenError;
exports.PropertyService = PropertyService;
exports.Token = Token;
exports.app_store = app_store;
exports.booking_store = booking_store;
exports.calculateTotalCost = calculateTotalCost;
exports.changeLocale = changeLocale;
exports.checkout_store = checkout_store;
exports.cn = cn;
exports.dateFns = dateFns;
exports.formatAmount = formatAmount;
exports.generateColorShades = generateColorShades;
exports.getAbbreviatedWeekdays = getAbbreviatedWeekdays;
exports.getDateDifference = getDateDifference;
exports.getUserPrefernce = getUserPrefernce;
exports.getVisibleInventory = getVisibleInventory;
exports.locale = locale;
exports.localizedWords = localizedWords;
exports.matchLocale = matchLocale;
exports.modifyBookingStore = modifyBookingStore;
exports.onAppDataChange = onAppDataChange;
exports.onCheckoutDataChange = onCheckoutDataChange;
exports.renderTime = renderTime;
exports.reserveRooms = reserveRooms;
exports.setDefaultLocale = setDefaultLocale;
exports.updatePartialPickupFormData = updatePartialPickupFormData;
exports.updatePickupFormData = updatePickupFormData;
exports.updateRoomParams = updateRoomParams;
exports.updateUserFormData = updateUserFormData;
exports.updateUserPreference = updateUserPreference;

//# sourceMappingURL=common.service-a47d30b2.js.map
{"version":3,"file":"slot.js","sourceRoot":"","sources":["../../src/utils/slot.ts"],"names":[],"mappings":"AAAA,EAAE;AACF,kHAAkH;AAClH,kFAAkF;AAClF,EAAE;AACF,MAAM,UAAU,cAAc,CAAC,IAAsB;IACnD,MAAM,KAAK,GAAG,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACxE,IAAI,IAAI,GAAG,EAAE,CAAC;IAEd,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACpB,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;YACrC,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC;QAC3B,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC;AACd,CAAC;AAED,EAAE;AACF,mHAAmH;AACnH,uHAAuH;AACvH,EAAE;AACF,MAAM,UAAU,OAAO,CAAC,EAAe,EAAE,IAAa;IACpD,wBAAwB;IACxB,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,EAAE,EAAE,CAAC;QAChC,OAAO,EAAE,CAAC,aAAa,CAAC,UAAU,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC;IACvD,CAAC;IAED,0BAA0B;IAC1B,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;;QAC3C,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,SAAS,IAAI,CAAA,MAAA,IAAI,CAAC,WAAW,0CAAE,IAAI,EAAE,MAAK,EAAE,EAAE,CAAC;YACxE,OAAO,IAAI,CAAC;QACd,CAAC;QAED,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,EAAE,CAAC;YACxC,MAAM,EAAE,GAAG,IAAmB,CAAC;YAC/B,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC;gBAC7B,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAU,OAAO,CAAC,OAAsC,EAAE,QAAgB;IAC9E,IAAI,OAAO,IAAI,IAAI;QAAE,OAAO,IAAI,CAAC;IACjC,OAAO,OAAO,CAAC,aAAa,CAAC,UAAU,QAAQ,IAAI,CAAC,CAAC;AACvD,CAAC","sourcesContent":["//\r\n// Given a slot, this function iterates over all of its assigned text nodes and returns the concatenated text as a\r\n// string. This is useful because we can't use slot.textContent as an alternative.\r\n//\r\nexport function getTextContent(slot?: HTMLSlotElement): string {\r\n  const nodes = slot != null ? slot.assignedNodes({ flatten: true }) : [];\r\n  let text = '';\r\n\r\n  [...nodes].map(node => {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n      text += node.textContent;\r\n    }\r\n  });\r\n\r\n  return text;\r\n}\r\n\r\n//\r\n// Determines whether an element has a slot. If name is specified, the function will look for a corresponding named\r\n// slot, otherwise it will look for a \"default\" slot (e.g. a non-empty text node or an element with no slot attribute).\r\n//\r\nexport function hasSlot(el: HTMLElement, name?: string): boolean {\r\n  // Look for a named slot\r\n  if (name != null && name !== '') {\r\n    return el.querySelector(`[slot=\"${name}\"]`) !== null;\r\n  }\r\n\r\n  // Look for a default slot\r\n  return Array.from(el.childNodes).some(node => {\r\n    if (node.nodeType === node.TEXT_NODE && node.textContent?.trim() !== '') {\r\n      return true;\r\n    }\r\n\r\n    if (node.nodeType === node.ELEMENT_NODE) {\r\n      const el = node as HTMLElement;\r\n      if (!el.hasAttribute('slot')) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\nexport function getSlot(element: ParentNode | null | undefined, slotName: string): HTMLElement | null {\r\n  if (element == null) return null;\r\n  return element.querySelector(`[slot=\"${slotName}\"]`);\r\n}\r\n"]}